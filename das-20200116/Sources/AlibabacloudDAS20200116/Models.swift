import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class DataResultValue : Tea.TeaModel {
    public var sqlId: String?

    public var instanceId: String?

    public var count: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sqlId != nil {
            map["sqlId"] = self.sqlId!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.count != nil {
            map["count"] = self.count!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["sqlId"] as? String {
            self.sqlId = value
        }
        if let value = dict["instanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["count"] as? Int32 {
            self.count = value
        }
    }
}

public class DataSessionStatClientStatsValue : Tea.TeaModel {
    public var activeCount: Int64?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activeCount != nil {
            map["ActiveCount"] = self.activeCount!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActiveCount"] as? Int64 {
            self.activeCount = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DataSessionStatDbStatsValue : Tea.TeaModel {
    public var activeCount: Int64?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activeCount != nil {
            map["ActiveCount"] = self.activeCount!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActiveCount"] as? Int64 {
            self.activeCount = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DataValue : Tea.TeaModel {
    public var timestamp: String?

    public var value: Any?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.timestamp != nil {
            map["Timestamp"] = self.timestamp!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Timestamp"] as? String {
            self.timestamp = value
        }
        if let value = dict["Value"] as? Any {
            self.value = value
        }
    }
}

public class AddHDMInstanceRequest : Tea.TeaModel {
    public var engine: String?

    public var flushAccount: String?

    public var instanceAlias: String?

    public var instanceArea: String?

    public var instanceId: String?

    public var ip: String?

    public var networkType: String?

    public var password: String?

    public var port: String?

    public var region: String?

    public var username: String?

    public var vpcId: String?

    public var context: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.flushAccount != nil {
            map["FlushAccount"] = self.flushAccount!
        }
        if self.instanceAlias != nil {
            map["InstanceAlias"] = self.instanceAlias!
        }
        if self.instanceArea != nil {
            map["InstanceArea"] = self.instanceArea!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.context != nil {
            map["__context"] = self.context!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["FlushAccount"] as? String {
            self.flushAccount = value
        }
        if let value = dict["InstanceAlias"] as? String {
            self.instanceAlias = value
        }
        if let value = dict["InstanceArea"] as? String {
            self.instanceArea = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Ip"] as? String {
            self.ip = value
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["Username"] as? String {
            self.username = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["__context"] as? String {
            self.context = value
        }
    }
}

public class AddHDMInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var callerUid: String?

        public var code: Int32?

        public var error: String?

        public var instanceId: String?

        public var ip: String?

        public var ownerId: String?

        public var port: Int32?

        public var role: String?

        public var tenantId: String?

        public var token: String?

        public var uuid: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callerUid != nil {
                map["CallerUid"] = self.callerUid!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.token != nil {
                map["Token"] = self.token!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CallerUid"] as? String {
                self.callerUid = value
            }
            if let value = dict["Code"] as? Int32 {
                self.code = value
            }
            if let value = dict["Error"] as? String {
                self.error = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["Ip"] as? String {
                self.ip = value
            }
            if let value = dict["OwnerId"] as? String {
                self.ownerId = value
            }
            if let value = dict["Port"] as? Int32 {
                self.port = value
            }
            if let value = dict["Role"] as? String {
                self.role = value
            }
            if let value = dict["TenantId"] as? String {
                self.tenantId = value
            }
            if let value = dict["Token"] as? String {
                self.token = value
            }
            if let value = dict["Uuid"] as? String {
                self.uuid = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var code: String?

    public var data: AddHDMInstanceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = AddHDMInstanceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
        if let value = dict["Synchro"] as? String {
            self.synchro = value
        }
    }
}

public class AddHDMInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddHDMInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddHDMInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCacheAnalysisJobRequest : Tea.TeaModel {
    public var backupSetId: String?

    public var instanceId: String?

    public var nodeId: String?

    public var separators: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupSetId != nil {
            map["BackupSetId"] = self.backupSetId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.separators != nil {
            map["Separators"] = self.separators!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupSetId"] as? String {
            self.backupSetId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["Separators"] as? String {
            self.separators = value
        }
    }
}

public class CreateCacheAnalysisJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BigKeys : Tea.TeaModel {
            public class KeyInfo : Tea.TeaModel {
                public var bytes: Int64?

                public var count: Int64?

                public var db: Int32?

                public var encoding: String?

                public var expirationTimeMillis: Int64?

                public var key: String?

                public var nodeId: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bytes != nil {
                        map["Bytes"] = self.bytes!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.db != nil {
                        map["Db"] = self.db!
                    }
                    if self.encoding != nil {
                        map["Encoding"] = self.encoding!
                    }
                    if self.expirationTimeMillis != nil {
                        map["ExpirationTimeMillis"] = self.expirationTimeMillis!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Bytes"] as? Int64 {
                        self.bytes = value
                    }
                    if let value = dict["Count"] as? Int64 {
                        self.count = value
                    }
                    if let value = dict["Db"] as? Int32 {
                        self.db = value
                    }
                    if let value = dict["Encoding"] as? String {
                        self.encoding = value
                    }
                    if let value = dict["ExpirationTimeMillis"] as? Int64 {
                        self.expirationTimeMillis = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["NodeId"] as? String {
                        self.nodeId = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var keyInfo: [CreateCacheAnalysisJobResponseBody.Data.BigKeys.KeyInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.keyInfo != nil {
                    var tmp : [Any] = []
                    for k in self.keyInfo! {
                        tmp.append(k.toMap())
                    }
                    map["KeyInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["KeyInfo"] as? [Any?] {
                    var tmp : [CreateCacheAnalysisJobResponseBody.Data.BigKeys.KeyInfo] = []
                    for v in value {
                        if v != nil {
                            var model = CreateCacheAnalysisJobResponseBody.Data.BigKeys.KeyInfo()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.keyInfo = tmp
                }
            }
        }
        public var bigKeys: CreateCacheAnalysisJobResponseBody.Data.BigKeys?

        public var instanceId: String?

        public var jobId: String?

        public var message: String?

        public var nodeId: String?

        public var taskState: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.bigKeys?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bigKeys != nil {
                map["BigKeys"] = self.bigKeys?.toMap()
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.taskState != nil {
                map["TaskState"] = self.taskState!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BigKeys"] as? [String: Any?] {
                var model = CreateCacheAnalysisJobResponseBody.Data.BigKeys()
                model.fromMap(value)
                self.bigKeys = model
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["JobId"] as? String {
                self.jobId = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["NodeId"] as? String {
                self.nodeId = value
            }
            if let value = dict["TaskState"] as? String {
                self.taskState = value
            }
        }
    }
    public var code: String?

    public var data: CreateCacheAnalysisJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateCacheAnalysisJobResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class CreateCacheAnalysisJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCacheAnalysisJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCacheAnalysisJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCloudBenchTasksRequest : Tea.TeaModel {
    public var amount: String?

    public var backupId: String?

    public var backupTime: String?

    public var clientType: String?

    public var description_: String?

    public var dstConnectionString: String?

    public var dstInstanceId: String?

    public var dstPort: String?

    public var dstSuperAccount: String?

    public var dstSuperPassword: String?

    public var dstType: String?

    public var dtsJobClass: String?

    public var dtsJobId: String?

    public var endState: String?

    public var gatewayVpcId: String?

    public var gatewayVpcIp: String?

    public var rate: String?

    public var requestDuration: String?

    public var requestEndTime: String?

    public var requestStartTime: String?

    public var smartPressureTime: String?

    public var srcInstanceId: String?

    public var srcPublicIp: String?

    public var srcSuperAccount: String?

    public var srcSuperPassword: String?

    public var taskType: String?

    public var workDir: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.backupTime != nil {
            map["BackupTime"] = self.backupTime!
        }
        if self.clientType != nil {
            map["ClientType"] = self.clientType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dstConnectionString != nil {
            map["DstConnectionString"] = self.dstConnectionString!
        }
        if self.dstInstanceId != nil {
            map["DstInstanceId"] = self.dstInstanceId!
        }
        if self.dstPort != nil {
            map["DstPort"] = self.dstPort!
        }
        if self.dstSuperAccount != nil {
            map["DstSuperAccount"] = self.dstSuperAccount!
        }
        if self.dstSuperPassword != nil {
            map["DstSuperPassword"] = self.dstSuperPassword!
        }
        if self.dstType != nil {
            map["DstType"] = self.dstType!
        }
        if self.dtsJobClass != nil {
            map["DtsJobClass"] = self.dtsJobClass!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.endState != nil {
            map["EndState"] = self.endState!
        }
        if self.gatewayVpcId != nil {
            map["GatewayVpcId"] = self.gatewayVpcId!
        }
        if self.gatewayVpcIp != nil {
            map["GatewayVpcIp"] = self.gatewayVpcIp!
        }
        if self.rate != nil {
            map["Rate"] = self.rate!
        }
        if self.requestDuration != nil {
            map["RequestDuration"] = self.requestDuration!
        }
        if self.requestEndTime != nil {
            map["RequestEndTime"] = self.requestEndTime!
        }
        if self.requestStartTime != nil {
            map["RequestStartTime"] = self.requestStartTime!
        }
        if self.smartPressureTime != nil {
            map["SmartPressureTime"] = self.smartPressureTime!
        }
        if self.srcInstanceId != nil {
            map["SrcInstanceId"] = self.srcInstanceId!
        }
        if self.srcPublicIp != nil {
            map["SrcPublicIp"] = self.srcPublicIp!
        }
        if self.srcSuperAccount != nil {
            map["SrcSuperAccount"] = self.srcSuperAccount!
        }
        if self.srcSuperPassword != nil {
            map["SrcSuperPassword"] = self.srcSuperPassword!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.workDir != nil {
            map["WorkDir"] = self.workDir!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Amount"] as? String {
            self.amount = value
        }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["BackupTime"] as? String {
            self.backupTime = value
        }
        if let value = dict["ClientType"] as? String {
            self.clientType = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DstConnectionString"] as? String {
            self.dstConnectionString = value
        }
        if let value = dict["DstInstanceId"] as? String {
            self.dstInstanceId = value
        }
        if let value = dict["DstPort"] as? String {
            self.dstPort = value
        }
        if let value = dict["DstSuperAccount"] as? String {
            self.dstSuperAccount = value
        }
        if let value = dict["DstSuperPassword"] as? String {
            self.dstSuperPassword = value
        }
        if let value = dict["DstType"] as? String {
            self.dstType = value
        }
        if let value = dict["DtsJobClass"] as? String {
            self.dtsJobClass = value
        }
        if let value = dict["DtsJobId"] as? String {
            self.dtsJobId = value
        }
        if let value = dict["EndState"] as? String {
            self.endState = value
        }
        if let value = dict["GatewayVpcId"] as? String {
            self.gatewayVpcId = value
        }
        if let value = dict["GatewayVpcIp"] as? String {
            self.gatewayVpcIp = value
        }
        if let value = dict["Rate"] as? String {
            self.rate = value
        }
        if let value = dict["RequestDuration"] as? String {
            self.requestDuration = value
        }
        if let value = dict["RequestEndTime"] as? String {
            self.requestEndTime = value
        }
        if let value = dict["RequestStartTime"] as? String {
            self.requestStartTime = value
        }
        if let value = dict["SmartPressureTime"] as? String {
            self.smartPressureTime = value
        }
        if let value = dict["SrcInstanceId"] as? String {
            self.srcInstanceId = value
        }
        if let value = dict["SrcPublicIp"] as? String {
            self.srcPublicIp = value
        }
        if let value = dict["SrcSuperAccount"] as? String {
            self.srcSuperAccount = value
        }
        if let value = dict["SrcSuperPassword"] as? String {
            self.srcSuperPassword = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
        if let value = dict["WorkDir"] as? String {
            self.workDir = value
        }
    }
}

public class CreateCloudBenchTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var taskIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskIds != nil {
                map["taskIds"] = self.taskIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["taskIds"] as? [String] {
                self.taskIds = value
            }
        }
    }
    public var code: String?

    public var data: CreateCloudBenchTasksResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateCloudBenchTasksResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class CreateCloudBenchTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudBenchTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCloudBenchTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDiagnosticReportRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class CreateDiagnosticReportResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class CreateDiagnosticReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDiagnosticReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDiagnosticReportResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateKillInstanceSessionTaskRequest : Tea.TeaModel {
    public var dbUser: String?

    public var dbUserPassword: String?

    public var ignoredUsers: String?

    public var instanceId: String?

    public var killAllSessions: Bool?

    public var nodeId: String?

    public var sessionIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbUser != nil {
            map["DbUser"] = self.dbUser!
        }
        if self.dbUserPassword != nil {
            map["DbUserPassword"] = self.dbUserPassword!
        }
        if self.ignoredUsers != nil {
            map["IgnoredUsers"] = self.ignoredUsers!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.killAllSessions != nil {
            map["KillAllSessions"] = self.killAllSessions!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.sessionIds != nil {
            map["SessionIds"] = self.sessionIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DbUser"] as? String {
            self.dbUser = value
        }
        if let value = dict["DbUserPassword"] as? String {
            self.dbUserPassword = value
        }
        if let value = dict["IgnoredUsers"] as? String {
            self.ignoredUsers = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["KillAllSessions"] as? Bool {
            self.killAllSessions = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["SessionIds"] as? String {
            self.sessionIds = value
        }
    }
}

public class CreateKillInstanceSessionTaskResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateKillInstanceSessionTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateKillInstanceSessionTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateKillInstanceSessionTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateKillInstanceSessionTaskWithMaintainUserRequest : Tea.TeaModel {
    public var ignoredUsers: String?

    public var instanceId: String?

    public var killAllSessions: Bool?

    public var nodeId: String?

    public var sessionIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ignoredUsers != nil {
            map["IgnoredUsers"] = self.ignoredUsers!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.killAllSessions != nil {
            map["KillAllSessions"] = self.killAllSessions!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.sessionIds != nil {
            map["SessionIds"] = self.sessionIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IgnoredUsers"] as? String {
            self.ignoredUsers = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["KillAllSessions"] as? Bool {
            self.killAllSessions = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["SessionIds"] as? String {
            self.sessionIds = value
        }
    }
}

public class CreateKillInstanceSessionTaskWithMaintainUserResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateKillInstanceSessionTaskWithMaintainUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateKillInstanceSessionTaskWithMaintainUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateKillInstanceSessionTaskWithMaintainUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateLatestDeadLockAnalysisRequest : Tea.TeaModel {
    public var instanceId: String?

    public var nodeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
    }
}

public class CreateLatestDeadLockAnalysisResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateLatestDeadLockAnalysisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLatestDeadLockAnalysisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateLatestDeadLockAnalysisResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateQueryOptimizeTagRequest : Tea.TeaModel {
    public var comments: String?

    public var engine: String?

    public var instanceId: String?

    public var sqlIds: String?

    public var status: Int32?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comments != nil {
            map["Comments"] = self.comments!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sqlIds != nil {
            map["SqlIds"] = self.sqlIds!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comments"] as? String {
            self.comments = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["SqlIds"] as? String {
            self.sqlIds = value
        }
        if let value = dict["Status"] as? Int32 {
            self.status = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
    }
}

public class CreateQueryOptimizeTagResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class CreateQueryOptimizeTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateQueryOptimizeTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateQueryOptimizeTagResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRequestDiagnosisRequest : Tea.TeaModel {
    public var database: String?

    public var instanceId: String?

    public var nodeId: String?

    public var sql: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.database != nil {
            map["Database"] = self.database!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.sql != nil {
            map["Sql"] = self.sql!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Database"] as? String {
            self.database = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["Sql"] as? String {
            self.sql = value
        }
    }
}

public class CreateRequestDiagnosisResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class CreateRequestDiagnosisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRequestDiagnosisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRequestDiagnosisResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateSqlLogTaskRequest : Tea.TeaModel {
    public class Filters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var endTime: Int64?

    public var filters: [CreateSqlLogTaskRequest.Filters]?

    public var instanceId: String?

    public var name: String?

    public var nodeId: String?

    public var role: String?

    public var startTime: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filters != nil {
            var tmp : [Any] = []
            for k in self.filters! {
                tmp.append(k.toMap())
            }
            map["Filters"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["Filters"] as? [Any?] {
            var tmp : [CreateSqlLogTaskRequest.Filters] = []
            for v in value {
                if v != nil {
                    var model = CreateSqlLogTaskRequest.Filters()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filters = tmp
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["Role"] as? String {
            self.role = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class CreateSqlLogTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createTime: Int64?

        public var end: Int64?

        public var instanceId: String?

        public var name: String?

        public var start: Int64?

        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.start != nil {
                map["Start"] = self.start!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["End"] as? Int64 {
                self.end = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Start"] as? Int64 {
                self.start = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
        }
    }
    public var code: String?

    public var data: CreateSqlLogTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateSqlLogTaskResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class CreateSqlLogTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSqlLogTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateSqlLogTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateStorageAnalysisTaskRequest : Tea.TeaModel {
    public var dbName: String?

    public var instanceId: String?

    public var nodeId: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DbName"] as? String {
            self.dbName = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class CreateStorageAnalysisTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createTaskSuccess: Bool?

        public var errorMessage: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTaskSuccess != nil {
                map["CreateTaskSuccess"] = self.createTaskSuccess!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTaskSuccess"] as? Bool {
                self.createTaskSuccess = value
            }
            if let value = dict["ErrorMessage"] as? String {
                self.errorMessage = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
        }
    }
    public var code: Int64?

    public var data: CreateStorageAnalysisTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateStorageAnalysisTaskResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateStorageAnalysisTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateStorageAnalysisTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateStorageAnalysisTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCloudBenchTaskRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class DeleteCloudBenchTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DeleteCloudBenchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCloudBenchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCloudBenchTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteStopGatewayRequest : Tea.TeaModel {
    public var gatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GatewayId"] as? String {
            self.gatewayId = value
        }
    }
}

public class DeleteStopGatewayResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DeleteStopGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteStopGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteStopGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAutoScalingConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DescribeAutoScalingConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Bandwidth : Tea.TeaModel {
            public var bandwidthUsageLowerThreshold: Int32?

            public var bandwidthUsageUpperThreshold: Int32?

            public var downgrade: Bool?

            public var observationWindowSize: String?

            public var upgrade: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandwidthUsageLowerThreshold != nil {
                    map["BandwidthUsageLowerThreshold"] = self.bandwidthUsageLowerThreshold!
                }
                if self.bandwidthUsageUpperThreshold != nil {
                    map["BandwidthUsageUpperThreshold"] = self.bandwidthUsageUpperThreshold!
                }
                if self.downgrade != nil {
                    map["Downgrade"] = self.downgrade!
                }
                if self.observationWindowSize != nil {
                    map["ObservationWindowSize"] = self.observationWindowSize!
                }
                if self.upgrade != nil {
                    map["Upgrade"] = self.upgrade!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BandwidthUsageLowerThreshold"] as? Int32 {
                    self.bandwidthUsageLowerThreshold = value
                }
                if let value = dict["BandwidthUsageUpperThreshold"] as? Int32 {
                    self.bandwidthUsageUpperThreshold = value
                }
                if let value = dict["Downgrade"] as? Bool {
                    self.downgrade = value
                }
                if let value = dict["ObservationWindowSize"] as? String {
                    self.observationWindowSize = value
                }
                if let value = dict["Upgrade"] as? Bool {
                    self.upgrade = value
                }
            }
        }
        public class Resource : Tea.TeaModel {
            public var cpuStep: Int32?

            public var cpuUsageUpperThreshold: Int32?

            public var downgradeObservationWindowSize: String?

            public var enable: Bool?

            public var upgradeObservationWindowSize: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpuStep != nil {
                    map["CpuStep"] = self.cpuStep!
                }
                if self.cpuUsageUpperThreshold != nil {
                    map["CpuUsageUpperThreshold"] = self.cpuUsageUpperThreshold!
                }
                if self.downgradeObservationWindowSize != nil {
                    map["DowngradeObservationWindowSize"] = self.downgradeObservationWindowSize!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.upgradeObservationWindowSize != nil {
                    map["UpgradeObservationWindowSize"] = self.upgradeObservationWindowSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CpuStep"] as? Int32 {
                    self.cpuStep = value
                }
                if let value = dict["CpuUsageUpperThreshold"] as? Int32 {
                    self.cpuUsageUpperThreshold = value
                }
                if let value = dict["DowngradeObservationWindowSize"] as? String {
                    self.downgradeObservationWindowSize = value
                }
                if let value = dict["Enable"] as? Bool {
                    self.enable = value
                }
                if let value = dict["UpgradeObservationWindowSize"] as? String {
                    self.upgradeObservationWindowSize = value
                }
            }
        }
        public class Shard : Tea.TeaModel {
            public var downgrade: Bool?

            public var downgradeObservationWindowSize: String?

            public var maxShards: Int32?

            public var memUsageLowerThreshold: Int32?

            public var memUsageUpperThreshold: Int32?

            public var minShards: Int32?

            public var upgrade: Bool?

            public var upgradeObservationWindowSize: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.downgrade != nil {
                    map["Downgrade"] = self.downgrade!
                }
                if self.downgradeObservationWindowSize != nil {
                    map["DowngradeObservationWindowSize"] = self.downgradeObservationWindowSize!
                }
                if self.maxShards != nil {
                    map["MaxShards"] = self.maxShards!
                }
                if self.memUsageLowerThreshold != nil {
                    map["MemUsageLowerThreshold"] = self.memUsageLowerThreshold!
                }
                if self.memUsageUpperThreshold != nil {
                    map["MemUsageUpperThreshold"] = self.memUsageUpperThreshold!
                }
                if self.minShards != nil {
                    map["MinShards"] = self.minShards!
                }
                if self.upgrade != nil {
                    map["Upgrade"] = self.upgrade!
                }
                if self.upgradeObservationWindowSize != nil {
                    map["UpgradeObservationWindowSize"] = self.upgradeObservationWindowSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Downgrade"] as? Bool {
                    self.downgrade = value
                }
                if let value = dict["DowngradeObservationWindowSize"] as? String {
                    self.downgradeObservationWindowSize = value
                }
                if let value = dict["MaxShards"] as? Int32 {
                    self.maxShards = value
                }
                if let value = dict["MemUsageLowerThreshold"] as? Int32 {
                    self.memUsageLowerThreshold = value
                }
                if let value = dict["MemUsageUpperThreshold"] as? Int32 {
                    self.memUsageUpperThreshold = value
                }
                if let value = dict["MinShards"] as? Int32 {
                    self.minShards = value
                }
                if let value = dict["Upgrade"] as? Bool {
                    self.upgrade = value
                }
                if let value = dict["UpgradeObservationWindowSize"] as? String {
                    self.upgradeObservationWindowSize = value
                }
            }
        }
        public class Spec : Tea.TeaModel {
            public var coolDownTime: String?

            public var cpuUsageUpperThreshold: Int32?

            public var downgrade: Bool?

            public var maxReadOnlyNodes: Int32?

            public var maxSpec: String?

            public var memUsageUpperThreshold: Int32?

            public var observationWindowSize: String?

            public var upgrade: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coolDownTime != nil {
                    map["CoolDownTime"] = self.coolDownTime!
                }
                if self.cpuUsageUpperThreshold != nil {
                    map["CpuUsageUpperThreshold"] = self.cpuUsageUpperThreshold!
                }
                if self.downgrade != nil {
                    map["Downgrade"] = self.downgrade!
                }
                if self.maxReadOnlyNodes != nil {
                    map["MaxReadOnlyNodes"] = self.maxReadOnlyNodes!
                }
                if self.maxSpec != nil {
                    map["MaxSpec"] = self.maxSpec!
                }
                if self.memUsageUpperThreshold != nil {
                    map["MemUsageUpperThreshold"] = self.memUsageUpperThreshold!
                }
                if self.observationWindowSize != nil {
                    map["ObservationWindowSize"] = self.observationWindowSize!
                }
                if self.upgrade != nil {
                    map["Upgrade"] = self.upgrade!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CoolDownTime"] as? String {
                    self.coolDownTime = value
                }
                if let value = dict["CpuUsageUpperThreshold"] as? Int32 {
                    self.cpuUsageUpperThreshold = value
                }
                if let value = dict["Downgrade"] as? Bool {
                    self.downgrade = value
                }
                if let value = dict["MaxReadOnlyNodes"] as? Int32 {
                    self.maxReadOnlyNodes = value
                }
                if let value = dict["MaxSpec"] as? String {
                    self.maxSpec = value
                }
                if let value = dict["MemUsageUpperThreshold"] as? Int32 {
                    self.memUsageUpperThreshold = value
                }
                if let value = dict["ObservationWindowSize"] as? String {
                    self.observationWindowSize = value
                }
                if let value = dict["Upgrade"] as? Bool {
                    self.upgrade = value
                }
            }
        }
        public class Storage : Tea.TeaModel {
            public var diskUsageUpperThreshold: Int32?

            public var maxStorage: Int32?

            public var upgrade: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskUsageUpperThreshold != nil {
                    map["DiskUsageUpperThreshold"] = self.diskUsageUpperThreshold!
                }
                if self.maxStorage != nil {
                    map["MaxStorage"] = self.maxStorage!
                }
                if self.upgrade != nil {
                    map["Upgrade"] = self.upgrade!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DiskUsageUpperThreshold"] as? Int32 {
                    self.diskUsageUpperThreshold = value
                }
                if let value = dict["MaxStorage"] as? Int32 {
                    self.maxStorage = value
                }
                if let value = dict["Upgrade"] as? Bool {
                    self.upgrade = value
                }
            }
        }
        public var bandwidth: DescribeAutoScalingConfigResponseBody.Data.Bandwidth?

        public var resource: DescribeAutoScalingConfigResponseBody.Data.Resource?

        public var shard: DescribeAutoScalingConfigResponseBody.Data.Shard?

        public var spec: DescribeAutoScalingConfigResponseBody.Data.Spec?

        public var storage: DescribeAutoScalingConfigResponseBody.Data.Storage?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.bandwidth?.validate()
            try self.resource?.validate()
            try self.shard?.validate()
            try self.spec?.validate()
            try self.storage?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth?.toMap()
            }
            if self.resource != nil {
                map["Resource"] = self.resource?.toMap()
            }
            if self.shard != nil {
                map["Shard"] = self.shard?.toMap()
            }
            if self.spec != nil {
                map["Spec"] = self.spec?.toMap()
            }
            if self.storage != nil {
                map["Storage"] = self.storage?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Bandwidth"] as? [String: Any?] {
                var model = DescribeAutoScalingConfigResponseBody.Data.Bandwidth()
                model.fromMap(value)
                self.bandwidth = model
            }
            if let value = dict["Resource"] as? [String: Any?] {
                var model = DescribeAutoScalingConfigResponseBody.Data.Resource()
                model.fromMap(value)
                self.resource = model
            }
            if let value = dict["Shard"] as? [String: Any?] {
                var model = DescribeAutoScalingConfigResponseBody.Data.Shard()
                model.fromMap(value)
                self.shard = model
            }
            if let value = dict["Spec"] as? [String: Any?] {
                var model = DescribeAutoScalingConfigResponseBody.Data.Spec()
                model.fromMap(value)
                self.spec = model
            }
            if let value = dict["Storage"] as? [String: Any?] {
                var model = DescribeAutoScalingConfigResponseBody.Data.Storage()
                model.fromMap(value)
                self.storage = model
            }
        }
    }
    public var code: String?

    public var data: DescribeAutoScalingConfigResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeAutoScalingConfigResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeAutoScalingConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoScalingConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAutoScalingConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAutoScalingHistoryRequest : Tea.TeaModel {
    public var autoScalingTaskType: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoScalingTaskType != nil {
            map["AutoScalingTaskType"] = self.autoScalingTaskType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoScalingTaskType"] as? String {
            self.autoScalingTaskType = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class DescribeAutoScalingHistoryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SpecHistory : Tea.TeaModel {
            public var errorCode: String?

            public var originCore: Int32?

            public var originInstanceClass: String?

            public var originMemory: Double?

            public var scaleType: String?

            public var targetCore: Int32?

            public var targetInstanceClass: String?

            public var targetMemory: Double?

            public var taskExcuteStatus: Bool?

            public var taskTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.originCore != nil {
                    map["OriginCore"] = self.originCore!
                }
                if self.originInstanceClass != nil {
                    map["OriginInstanceClass"] = self.originInstanceClass!
                }
                if self.originMemory != nil {
                    map["OriginMemory"] = self.originMemory!
                }
                if self.scaleType != nil {
                    map["ScaleType"] = self.scaleType!
                }
                if self.targetCore != nil {
                    map["TargetCore"] = self.targetCore!
                }
                if self.targetInstanceClass != nil {
                    map["TargetInstanceClass"] = self.targetInstanceClass!
                }
                if self.targetMemory != nil {
                    map["TargetMemory"] = self.targetMemory!
                }
                if self.taskExcuteStatus != nil {
                    map["TaskExcuteStatus"] = self.taskExcuteStatus!
                }
                if self.taskTime != nil {
                    map["TaskTime"] = self.taskTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["OriginCore"] as? Int32 {
                    self.originCore = value
                }
                if let value = dict["OriginInstanceClass"] as? String {
                    self.originInstanceClass = value
                }
                if let value = dict["OriginMemory"] as? Double {
                    self.originMemory = value
                }
                if let value = dict["ScaleType"] as? String {
                    self.scaleType = value
                }
                if let value = dict["TargetCore"] as? Int32 {
                    self.targetCore = value
                }
                if let value = dict["TargetInstanceClass"] as? String {
                    self.targetInstanceClass = value
                }
                if let value = dict["TargetMemory"] as? Double {
                    self.targetMemory = value
                }
                if let value = dict["TaskExcuteStatus"] as? Bool {
                    self.taskExcuteStatus = value
                }
                if let value = dict["TaskTime"] as? Int64 {
                    self.taskTime = value
                }
            }
        }
        public var bandwidth: [[String: Any]]?

        public var instanceId: String?

        public var resource: [[String: Any]]?

        public var shard: [[String: Any]]?

        public var specHistory: [DescribeAutoScalingHistoryResponseBody.Data.SpecHistory]?

        public var storage: [[String: Any]]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.resource != nil {
                map["Resource"] = self.resource!
            }
            if self.shard != nil {
                map["Shard"] = self.shard!
            }
            if self.specHistory != nil {
                var tmp : [Any] = []
                for k in self.specHistory! {
                    tmp.append(k.toMap())
                }
                map["SpecHistory"] = tmp
            }
            if self.storage != nil {
                map["Storage"] = self.storage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Bandwidth"] as? [[String: Any]] {
                self.bandwidth = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["Resource"] as? [[String: Any]] {
                self.resource = value
            }
            if let value = dict["Shard"] as? [[String: Any]] {
                self.shard = value
            }
            if let value = dict["SpecHistory"] as? [Any?] {
                var tmp : [DescribeAutoScalingHistoryResponseBody.Data.SpecHistory] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAutoScalingHistoryResponseBody.Data.SpecHistory()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.specHistory = tmp
            }
            if let value = dict["Storage"] as? [[String: Any]] {
                self.storage = value
            }
        }
    }
    public var code: String?

    public var data: DescribeAutoScalingHistoryResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeAutoScalingHistoryResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeAutoScalingHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoScalingHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAutoScalingHistoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCacheAnalysisJobRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
    }
}

public class DescribeCacheAnalysisJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BigKeys : Tea.TeaModel {
            public class KeyInfo : Tea.TeaModel {
                public var bytes: Int64?

                public var count: Int64?

                public var db: Int32?

                public var encoding: String?

                public var expirationTimeMillis: Int64?

                public var key: String?

                public var nodeId: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bytes != nil {
                        map["Bytes"] = self.bytes!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.db != nil {
                        map["Db"] = self.db!
                    }
                    if self.encoding != nil {
                        map["Encoding"] = self.encoding!
                    }
                    if self.expirationTimeMillis != nil {
                        map["ExpirationTimeMillis"] = self.expirationTimeMillis!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Bytes"] as? Int64 {
                        self.bytes = value
                    }
                    if let value = dict["Count"] as? Int64 {
                        self.count = value
                    }
                    if let value = dict["Db"] as? Int32 {
                        self.db = value
                    }
                    if let value = dict["Encoding"] as? String {
                        self.encoding = value
                    }
                    if let value = dict["ExpirationTimeMillis"] as? Int64 {
                        self.expirationTimeMillis = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["NodeId"] as? String {
                        self.nodeId = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var keyInfo: [DescribeCacheAnalysisJobResponseBody.Data.BigKeys.KeyInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.keyInfo != nil {
                    var tmp : [Any] = []
                    for k in self.keyInfo! {
                        tmp.append(k.toMap())
                    }
                    map["KeyInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["KeyInfo"] as? [Any?] {
                    var tmp : [DescribeCacheAnalysisJobResponseBody.Data.BigKeys.KeyInfo] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeCacheAnalysisJobResponseBody.Data.BigKeys.KeyInfo()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.keyInfo = tmp
                }
            }
        }
        public class BigKeysOfNum : Tea.TeaModel {
            public class KeyInfo : Tea.TeaModel {
                public var bytes: Int64?

                public var count: Int64?

                public var db: Int32?

                public var encoding: String?

                public var expirationTimeMillis: Int64?

                public var key: String?

                public var nodeId: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bytes != nil {
                        map["Bytes"] = self.bytes!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.db != nil {
                        map["Db"] = self.db!
                    }
                    if self.encoding != nil {
                        map["Encoding"] = self.encoding!
                    }
                    if self.expirationTimeMillis != nil {
                        map["ExpirationTimeMillis"] = self.expirationTimeMillis!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Bytes"] as? Int64 {
                        self.bytes = value
                    }
                    if let value = dict["Count"] as? Int64 {
                        self.count = value
                    }
                    if let value = dict["Db"] as? Int32 {
                        self.db = value
                    }
                    if let value = dict["Encoding"] as? String {
                        self.encoding = value
                    }
                    if let value = dict["ExpirationTimeMillis"] as? Int64 {
                        self.expirationTimeMillis = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["NodeId"] as? String {
                        self.nodeId = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var keyInfo: [DescribeCacheAnalysisJobResponseBody.Data.BigKeysOfNum.KeyInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.keyInfo != nil {
                    var tmp : [Any] = []
                    for k in self.keyInfo! {
                        tmp.append(k.toMap())
                    }
                    map["KeyInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["KeyInfo"] as? [Any?] {
                    var tmp : [DescribeCacheAnalysisJobResponseBody.Data.BigKeysOfNum.KeyInfo] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeCacheAnalysisJobResponseBody.Data.BigKeysOfNum.KeyInfo()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.keyInfo = tmp
                }
            }
        }
        public class ExpiryKeysLevelCount : Tea.TeaModel {
            public class ExpiryLevel : Tea.TeaModel {
                public var analysisTs: Int64?

                public var level: Int32?

                public var totalBytes: Int64?

                public var totalKeys: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.analysisTs != nil {
                        map["AnalysisTs"] = self.analysisTs!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.totalBytes != nil {
                        map["TotalBytes"] = self.totalBytes!
                    }
                    if self.totalKeys != nil {
                        map["TotalKeys"] = self.totalKeys!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AnalysisTs"] as? Int64 {
                        self.analysisTs = value
                    }
                    if let value = dict["Level"] as? Int32 {
                        self.level = value
                    }
                    if let value = dict["TotalBytes"] as? Int64 {
                        self.totalBytes = value
                    }
                    if let value = dict["TotalKeys"] as? Int64 {
                        self.totalKeys = value
                    }
                }
            }
            public var expiryLevel: [DescribeCacheAnalysisJobResponseBody.Data.ExpiryKeysLevelCount.ExpiryLevel]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expiryLevel != nil {
                    var tmp : [Any] = []
                    for k in self.expiryLevel! {
                        tmp.append(k.toMap())
                    }
                    map["ExpiryLevel"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ExpiryLevel"] as? [Any?] {
                    var tmp : [DescribeCacheAnalysisJobResponseBody.Data.ExpiryKeysLevelCount.ExpiryLevel] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeCacheAnalysisJobResponseBody.Data.ExpiryKeysLevelCount.ExpiryLevel()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.expiryLevel = tmp
                }
            }
        }
        public class KeyPrefixes : Tea.TeaModel {
            public class Prefix_ : Tea.TeaModel {
                public var bytes: Int64?

                public var count: Int64?

                public var keyNum: Int64?

                public var prefix_: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bytes != nil {
                        map["Bytes"] = self.bytes!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.keyNum != nil {
                        map["KeyNum"] = self.keyNum!
                    }
                    if self.prefix_ != nil {
                        map["Prefix"] = self.prefix_!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Bytes"] as? Int64 {
                        self.bytes = value
                    }
                    if let value = dict["Count"] as? Int64 {
                        self.count = value
                    }
                    if let value = dict["KeyNum"] as? Int64 {
                        self.keyNum = value
                    }
                    if let value = dict["Prefix"] as? String {
                        self.prefix_ = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var prefix_: [DescribeCacheAnalysisJobResponseBody.Data.KeyPrefixes.Prefix_]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.prefix_ != nil {
                    var tmp : [Any] = []
                    for k in self.prefix_! {
                        tmp.append(k.toMap())
                    }
                    map["Prefix"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Prefix"] as? [Any?] {
                    var tmp : [DescribeCacheAnalysisJobResponseBody.Data.KeyPrefixes.Prefix_] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeCacheAnalysisJobResponseBody.Data.KeyPrefixes.Prefix_()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.prefix_ = tmp
                }
            }
        }
        public class UnexBigKeysOfBytes : Tea.TeaModel {
            public class KeyInfo : Tea.TeaModel {
                public var bytes: Int64?

                public var count: Int64?

                public var db: Int32?

                public var encoding: String?

                public var expirationTimeMillis: Int64?

                public var key: String?

                public var nodeId: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bytes != nil {
                        map["Bytes"] = self.bytes!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.db != nil {
                        map["Db"] = self.db!
                    }
                    if self.encoding != nil {
                        map["Encoding"] = self.encoding!
                    }
                    if self.expirationTimeMillis != nil {
                        map["ExpirationTimeMillis"] = self.expirationTimeMillis!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Bytes"] as? Int64 {
                        self.bytes = value
                    }
                    if let value = dict["Count"] as? Int64 {
                        self.count = value
                    }
                    if let value = dict["Db"] as? Int32 {
                        self.db = value
                    }
                    if let value = dict["Encoding"] as? String {
                        self.encoding = value
                    }
                    if let value = dict["ExpirationTimeMillis"] as? Int64 {
                        self.expirationTimeMillis = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["NodeId"] as? String {
                        self.nodeId = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var keyInfo: [DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfBytes.KeyInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.keyInfo != nil {
                    var tmp : [Any] = []
                    for k in self.keyInfo! {
                        tmp.append(k.toMap())
                    }
                    map["KeyInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["KeyInfo"] as? [Any?] {
                    var tmp : [DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfBytes.KeyInfo] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfBytes.KeyInfo()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.keyInfo = tmp
                }
            }
        }
        public class UnexBigKeysOfNum : Tea.TeaModel {
            public class KeyInfo : Tea.TeaModel {
                public var bytes: Int64?

                public var count: Int64?

                public var db: Int32?

                public var encoding: String?

                public var expirationTimeMillis: Int64?

                public var key: String?

                public var nodeId: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bytes != nil {
                        map["Bytes"] = self.bytes!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.db != nil {
                        map["Db"] = self.db!
                    }
                    if self.encoding != nil {
                        map["Encoding"] = self.encoding!
                    }
                    if self.expirationTimeMillis != nil {
                        map["ExpirationTimeMillis"] = self.expirationTimeMillis!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Bytes"] as? Int64 {
                        self.bytes = value
                    }
                    if let value = dict["Count"] as? Int64 {
                        self.count = value
                    }
                    if let value = dict["Db"] as? Int32 {
                        self.db = value
                    }
                    if let value = dict["Encoding"] as? String {
                        self.encoding = value
                    }
                    if let value = dict["ExpirationTimeMillis"] as? Int64 {
                        self.expirationTimeMillis = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["NodeId"] as? String {
                        self.nodeId = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var keyInfo: [DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfNum.KeyInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.keyInfo != nil {
                    var tmp : [Any] = []
                    for k in self.keyInfo! {
                        tmp.append(k.toMap())
                    }
                    map["KeyInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["KeyInfo"] as? [Any?] {
                    var tmp : [DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfNum.KeyInfo] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfNum.KeyInfo()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.keyInfo = tmp
                }
            }
        }
        public var bigKeys: DescribeCacheAnalysisJobResponseBody.Data.BigKeys?

        public var bigKeysOfNum: DescribeCacheAnalysisJobResponseBody.Data.BigKeysOfNum?

        public var expiryKeysLevelCount: DescribeCacheAnalysisJobResponseBody.Data.ExpiryKeysLevelCount?

        public var instanceId: String?

        public var jobId: String?

        public var keyPrefixes: DescribeCacheAnalysisJobResponseBody.Data.KeyPrefixes?

        public var message: String?

        public var nodeId: String?

        public var taskState: String?

        public var unexBigKeysOfBytes: DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfBytes?

        public var unexBigKeysOfNum: DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfNum?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.bigKeys?.validate()
            try self.bigKeysOfNum?.validate()
            try self.expiryKeysLevelCount?.validate()
            try self.keyPrefixes?.validate()
            try self.unexBigKeysOfBytes?.validate()
            try self.unexBigKeysOfNum?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bigKeys != nil {
                map["BigKeys"] = self.bigKeys?.toMap()
            }
            if self.bigKeysOfNum != nil {
                map["BigKeysOfNum"] = self.bigKeysOfNum?.toMap()
            }
            if self.expiryKeysLevelCount != nil {
                map["ExpiryKeysLevelCount"] = self.expiryKeysLevelCount?.toMap()
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.keyPrefixes != nil {
                map["KeyPrefixes"] = self.keyPrefixes?.toMap()
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.taskState != nil {
                map["TaskState"] = self.taskState!
            }
            if self.unexBigKeysOfBytes != nil {
                map["UnexBigKeysOfBytes"] = self.unexBigKeysOfBytes?.toMap()
            }
            if self.unexBigKeysOfNum != nil {
                map["UnexBigKeysOfNum"] = self.unexBigKeysOfNum?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BigKeys"] as? [String: Any?] {
                var model = DescribeCacheAnalysisJobResponseBody.Data.BigKeys()
                model.fromMap(value)
                self.bigKeys = model
            }
            if let value = dict["BigKeysOfNum"] as? [String: Any?] {
                var model = DescribeCacheAnalysisJobResponseBody.Data.BigKeysOfNum()
                model.fromMap(value)
                self.bigKeysOfNum = model
            }
            if let value = dict["ExpiryKeysLevelCount"] as? [String: Any?] {
                var model = DescribeCacheAnalysisJobResponseBody.Data.ExpiryKeysLevelCount()
                model.fromMap(value)
                self.expiryKeysLevelCount = model
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["JobId"] as? String {
                self.jobId = value
            }
            if let value = dict["KeyPrefixes"] as? [String: Any?] {
                var model = DescribeCacheAnalysisJobResponseBody.Data.KeyPrefixes()
                model.fromMap(value)
                self.keyPrefixes = model
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["NodeId"] as? String {
                self.nodeId = value
            }
            if let value = dict["TaskState"] as? String {
                self.taskState = value
            }
            if let value = dict["UnexBigKeysOfBytes"] as? [String: Any?] {
                var model = DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfBytes()
                model.fromMap(value)
                self.unexBigKeysOfBytes = model
            }
            if let value = dict["UnexBigKeysOfNum"] as? [String: Any?] {
                var model = DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfNum()
                model.fromMap(value)
                self.unexBigKeysOfNum = model
            }
        }
    }
    public var code: String?

    public var data: DescribeCacheAnalysisJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeCacheAnalysisJobResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeCacheAnalysisJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCacheAnalysisJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCacheAnalysisJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCacheAnalysisJobsRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var pageNo: String?

    public var pageSize: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNo"] as? String {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeCacheAnalysisJobsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class CacheAnalysisJob : Tea.TeaModel {
                public class BigKeys : Tea.TeaModel {
                    public class KeyInfo : Tea.TeaModel {
                        public var bytes: Int64?

                        public var count: Int64?

                        public var db: Int32?

                        public var encoding: String?

                        public var expirationTimeMillis: Int64?

                        public var key: String?

                        public var nodeId: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bytes != nil {
                                map["Bytes"] = self.bytes!
                            }
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            if self.db != nil {
                                map["Db"] = self.db!
                            }
                            if self.encoding != nil {
                                map["Encoding"] = self.encoding!
                            }
                            if self.expirationTimeMillis != nil {
                                map["ExpirationTimeMillis"] = self.expirationTimeMillis!
                            }
                            if self.key != nil {
                                map["Key"] = self.key!
                            }
                            if self.nodeId != nil {
                                map["NodeId"] = self.nodeId!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Bytes"] as? Int64 {
                                self.bytes = value
                            }
                            if let value = dict["Count"] as? Int64 {
                                self.count = value
                            }
                            if let value = dict["Db"] as? Int32 {
                                self.db = value
                            }
                            if let value = dict["Encoding"] as? String {
                                self.encoding = value
                            }
                            if let value = dict["ExpirationTimeMillis"] as? Int64 {
                                self.expirationTimeMillis = value
                            }
                            if let value = dict["Key"] as? String {
                                self.key = value
                            }
                            if let value = dict["NodeId"] as? String {
                                self.nodeId = value
                            }
                            if let value = dict["Type"] as? String {
                                self.type = value
                            }
                        }
                    }
                    public var keyInfo: [DescribeCacheAnalysisJobsResponseBody.Data.List.CacheAnalysisJob.BigKeys.KeyInfo]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.keyInfo != nil {
                            var tmp : [Any] = []
                            for k in self.keyInfo! {
                                tmp.append(k.toMap())
                            }
                            map["KeyInfo"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["KeyInfo"] as? [Any?] {
                            var tmp : [DescribeCacheAnalysisJobsResponseBody.Data.List.CacheAnalysisJob.BigKeys.KeyInfo] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeCacheAnalysisJobsResponseBody.Data.List.CacheAnalysisJob.BigKeys.KeyInfo()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.keyInfo = tmp
                        }
                    }
                }
                public var bigKeys: DescribeCacheAnalysisJobsResponseBody.Data.List.CacheAnalysisJob.BigKeys?

                public var instanceId: String?

                public var jobId: String?

                public var message: String?

                public var nodeId: String?

                public var taskState: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.bigKeys?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bigKeys != nil {
                        map["BigKeys"] = self.bigKeys?.toMap()
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.taskState != nil {
                        map["TaskState"] = self.taskState!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BigKeys"] as? [String: Any?] {
                        var model = DescribeCacheAnalysisJobsResponseBody.Data.List.CacheAnalysisJob.BigKeys()
                        model.fromMap(value)
                        self.bigKeys = model
                    }
                    if let value = dict["InstanceId"] as? String {
                        self.instanceId = value
                    }
                    if let value = dict["JobId"] as? String {
                        self.jobId = value
                    }
                    if let value = dict["Message"] as? String {
                        self.message = value
                    }
                    if let value = dict["NodeId"] as? String {
                        self.nodeId = value
                    }
                    if let value = dict["TaskState"] as? String {
                        self.taskState = value
                    }
                }
            }
            public var cacheAnalysisJob: [DescribeCacheAnalysisJobsResponseBody.Data.List.CacheAnalysisJob]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cacheAnalysisJob != nil {
                    var tmp : [Any] = []
                    for k in self.cacheAnalysisJob! {
                        tmp.append(k.toMap())
                    }
                    map["CacheAnalysisJob"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CacheAnalysisJob"] as? [Any?] {
                    var tmp : [DescribeCacheAnalysisJobsResponseBody.Data.List.CacheAnalysisJob] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeCacheAnalysisJobsResponseBody.Data.List.CacheAnalysisJob()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.cacheAnalysisJob = tmp
                }
            }
        }
        public var extra: String?

        public var list: DescribeCacheAnalysisJobsResponseBody.Data.List?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.list?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                map["List"] = self.list?.toMap()
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Extra"] as? String {
                self.extra = value
            }
            if let value = dict["List"] as? [String: Any?] {
                var model = DescribeCacheAnalysisJobsResponseBody.Data.List()
                model.fromMap(value)
                self.list = model
            }
            if let value = dict["PageNo"] as? Int64 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: DescribeCacheAnalysisJobsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeCacheAnalysisJobsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeCacheAnalysisJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCacheAnalysisJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCacheAnalysisJobsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudBenchTasksRequest : Tea.TeaModel {
    public var endTime: String?

    public var pageNo: String?

    public var pageSize: String?

    public var startTime: String?

    public var status: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PageNo"] as? String {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
    }
}

public class DescribeCloudBenchTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class CloudbenchTasks : Tea.TeaModel {
                public var archiveJobId: String?

                public var archiveOssTableName: String?

                public var archiveState: Int32?

                public var backupId: String?

                public var backupType: String?

                public var benchStep: String?

                public var benchStepStatus: String?

                public var clientGatewayId: String?

                public var clientType: String?

                public var description_: String?

                public var dstInstanceUuid: String?

                public var dstIp: String?

                public var dstPort: Int32?

                public var dstType: String?

                public var dtsJobClass: String?

                public var dtsJobId: String?

                public var dtsJobName: String?

                public var dtsJobState: Int32?

                public var dtsJobStatus: String?

                public var ecsInstanceId: String?

                public var endState: String?

                public var errorCode: String?

                public var errorMessage: String?

                public var external: String?

                public var rate: Int32?

                public var requestDuration: Int64?

                public var smartPressureTime: Int32?

                public var source: String?

                public var sqlCompleteReuse: String?

                public var srcInstanceArea: String?

                public var srcInstanceUuid: String?

                public var srcPublicIp: String?

                public var state: String?

                public var status: String?

                public var tableSchema: String?

                public var taskId: String?

                public var taskType: String?

                public var topic: String?

                public var userId: String?

                public var version: String?

                public var workDir: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.archiveJobId != nil {
                        map["ArchiveJobId"] = self.archiveJobId!
                    }
                    if self.archiveOssTableName != nil {
                        map["ArchiveOssTableName"] = self.archiveOssTableName!
                    }
                    if self.archiveState != nil {
                        map["ArchiveState"] = self.archiveState!
                    }
                    if self.backupId != nil {
                        map["BackupId"] = self.backupId!
                    }
                    if self.backupType != nil {
                        map["BackupType"] = self.backupType!
                    }
                    if self.benchStep != nil {
                        map["BenchStep"] = self.benchStep!
                    }
                    if self.benchStepStatus != nil {
                        map["BenchStepStatus"] = self.benchStepStatus!
                    }
                    if self.clientGatewayId != nil {
                        map["ClientGatewayId"] = self.clientGatewayId!
                    }
                    if self.clientType != nil {
                        map["ClientType"] = self.clientType!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.dstInstanceUuid != nil {
                        map["DstInstanceUuid"] = self.dstInstanceUuid!
                    }
                    if self.dstIp != nil {
                        map["DstIp"] = self.dstIp!
                    }
                    if self.dstPort != nil {
                        map["DstPort"] = self.dstPort!
                    }
                    if self.dstType != nil {
                        map["DstType"] = self.dstType!
                    }
                    if self.dtsJobClass != nil {
                        map["DtsJobClass"] = self.dtsJobClass!
                    }
                    if self.dtsJobId != nil {
                        map["DtsJobId"] = self.dtsJobId!
                    }
                    if self.dtsJobName != nil {
                        map["DtsJobName"] = self.dtsJobName!
                    }
                    if self.dtsJobState != nil {
                        map["DtsJobState"] = self.dtsJobState!
                    }
                    if self.dtsJobStatus != nil {
                        map["DtsJobStatus"] = self.dtsJobStatus!
                    }
                    if self.ecsInstanceId != nil {
                        map["EcsInstanceId"] = self.ecsInstanceId!
                    }
                    if self.endState != nil {
                        map["EndState"] = self.endState!
                    }
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.external != nil {
                        map["External"] = self.external!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.requestDuration != nil {
                        map["RequestDuration"] = self.requestDuration!
                    }
                    if self.smartPressureTime != nil {
                        map["SmartPressureTime"] = self.smartPressureTime!
                    }
                    if self.source != nil {
                        map["Source"] = self.source!
                    }
                    if self.sqlCompleteReuse != nil {
                        map["SqlCompleteReuse"] = self.sqlCompleteReuse!
                    }
                    if self.srcInstanceArea != nil {
                        map["SrcInstanceArea"] = self.srcInstanceArea!
                    }
                    if self.srcInstanceUuid != nil {
                        map["SrcInstanceUuid"] = self.srcInstanceUuid!
                    }
                    if self.srcPublicIp != nil {
                        map["SrcPublicIp"] = self.srcPublicIp!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.tableSchema != nil {
                        map["TableSchema"] = self.tableSchema!
                    }
                    if self.taskId != nil {
                        map["TaskId"] = self.taskId!
                    }
                    if self.taskType != nil {
                        map["TaskType"] = self.taskType!
                    }
                    if self.topic != nil {
                        map["Topic"] = self.topic!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    if self.workDir != nil {
                        map["WorkDir"] = self.workDir!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ArchiveJobId"] as? String {
                        self.archiveJobId = value
                    }
                    if let value = dict["ArchiveOssTableName"] as? String {
                        self.archiveOssTableName = value
                    }
                    if let value = dict["ArchiveState"] as? Int32 {
                        self.archiveState = value
                    }
                    if let value = dict["BackupId"] as? String {
                        self.backupId = value
                    }
                    if let value = dict["BackupType"] as? String {
                        self.backupType = value
                    }
                    if let value = dict["BenchStep"] as? String {
                        self.benchStep = value
                    }
                    if let value = dict["BenchStepStatus"] as? String {
                        self.benchStepStatus = value
                    }
                    if let value = dict["ClientGatewayId"] as? String {
                        self.clientGatewayId = value
                    }
                    if let value = dict["ClientType"] as? String {
                        self.clientType = value
                    }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["DstInstanceUuid"] as? String {
                        self.dstInstanceUuid = value
                    }
                    if let value = dict["DstIp"] as? String {
                        self.dstIp = value
                    }
                    if let value = dict["DstPort"] as? Int32 {
                        self.dstPort = value
                    }
                    if let value = dict["DstType"] as? String {
                        self.dstType = value
                    }
                    if let value = dict["DtsJobClass"] as? String {
                        self.dtsJobClass = value
                    }
                    if let value = dict["DtsJobId"] as? String {
                        self.dtsJobId = value
                    }
                    if let value = dict["DtsJobName"] as? String {
                        self.dtsJobName = value
                    }
                    if let value = dict["DtsJobState"] as? Int32 {
                        self.dtsJobState = value
                    }
                    if let value = dict["DtsJobStatus"] as? String {
                        self.dtsJobStatus = value
                    }
                    if let value = dict["EcsInstanceId"] as? String {
                        self.ecsInstanceId = value
                    }
                    if let value = dict["EndState"] as? String {
                        self.endState = value
                    }
                    if let value = dict["ErrorCode"] as? String {
                        self.errorCode = value
                    }
                    if let value = dict["ErrorMessage"] as? String {
                        self.errorMessage = value
                    }
                    if let value = dict["External"] as? String {
                        self.external = value
                    }
                    if let value = dict["Rate"] as? Int32 {
                        self.rate = value
                    }
                    if let value = dict["RequestDuration"] as? Int64 {
                        self.requestDuration = value
                    }
                    if let value = dict["SmartPressureTime"] as? Int32 {
                        self.smartPressureTime = value
                    }
                    if let value = dict["Source"] as? String {
                        self.source = value
                    }
                    if let value = dict["SqlCompleteReuse"] as? String {
                        self.sqlCompleteReuse = value
                    }
                    if let value = dict["SrcInstanceArea"] as? String {
                        self.srcInstanceArea = value
                    }
                    if let value = dict["SrcInstanceUuid"] as? String {
                        self.srcInstanceUuid = value
                    }
                    if let value = dict["SrcPublicIp"] as? String {
                        self.srcPublicIp = value
                    }
                    if let value = dict["State"] as? String {
                        self.state = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                    if let value = dict["TableSchema"] as? String {
                        self.tableSchema = value
                    }
                    if let value = dict["TaskId"] as? String {
                        self.taskId = value
                    }
                    if let value = dict["TaskType"] as? String {
                        self.taskType = value
                    }
                    if let value = dict["Topic"] as? String {
                        self.topic = value
                    }
                    if let value = dict["UserId"] as? String {
                        self.userId = value
                    }
                    if let value = dict["Version"] as? String {
                        self.version = value
                    }
                    if let value = dict["WorkDir"] as? String {
                        self.workDir = value
                    }
                }
            }
            public var cloudbenchTasks: [DescribeCloudBenchTasksResponseBody.Data.List.CloudbenchTasks]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cloudbenchTasks != nil {
                    var tmp : [Any] = []
                    for k in self.cloudbenchTasks! {
                        tmp.append(k.toMap())
                    }
                    map["cloudbenchTasks"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["cloudbenchTasks"] as? [Any?] {
                    var tmp : [DescribeCloudBenchTasksResponseBody.Data.List.CloudbenchTasks] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeCloudBenchTasksResponseBody.Data.List.CloudbenchTasks()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.cloudbenchTasks = tmp
                }
            }
        }
        public var extra: String?

        public var list: DescribeCloudBenchTasksResponseBody.Data.List?

        public var pageNo: Int32?

        public var pageSize: Int32?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.list?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                map["List"] = self.list?.toMap()
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Extra"] as? String {
                self.extra = value
            }
            if let value = dict["List"] as? [String: Any?] {
                var model = DescribeCloudBenchTasksResponseBody.Data.List()
                model.fromMap(value)
                self.list = model
            }
            if let value = dict["PageNo"] as? Int32 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: DescribeCloudBenchTasksResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeCloudBenchTasksResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeCloudBenchTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudBenchTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudBenchTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudbenchTaskRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class DescribeCloudbenchTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var archiveJobId: String?

        public var archiveOssTableName: String?

        public var archiveState: Int32?

        public var backupId: String?

        public var backupType: String?

        public var benchStep: String?

        public var benchStepStatus: String?

        public var clientGatewayId: String?

        public var clientType: String?

        public var description_: String?

        public var dstInstanceUuid: String?

        public var dstIp: String?

        public var dstPort: Int32?

        public var dstType: String?

        public var dtsJobClass: String?

        public var dtsJobId: String?

        public var dtsJobName: String?

        public var dtsJobState: Int32?

        public var dtsJobStatus: String?

        public var ecsInstanceId: String?

        public var endState: String?

        public var errorCode: String?

        public var errorMessage: String?

        public var external: String?

        public var rate: Int64?

        public var requestDuration: Int64?

        public var smartPressureTime: Int32?

        public var source: String?

        public var sqlCompleteReuse: String?

        public var srcInstanceArea: String?

        public var srcInstanceUuid: String?

        public var srcPublicIp: String?

        public var state: String?

        public var status: String?

        public var tableSchema: String?

        public var taskId: String?

        public var taskType: String?

        public var topic: String?

        public var userId: String?

        public var version: String?

        public var workDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.archiveJobId != nil {
                map["ArchiveJobId"] = self.archiveJobId!
            }
            if self.archiveOssTableName != nil {
                map["ArchiveOssTableName"] = self.archiveOssTableName!
            }
            if self.archiveState != nil {
                map["ArchiveState"] = self.archiveState!
            }
            if self.backupId != nil {
                map["BackupId"] = self.backupId!
            }
            if self.backupType != nil {
                map["BackupType"] = self.backupType!
            }
            if self.benchStep != nil {
                map["BenchStep"] = self.benchStep!
            }
            if self.benchStepStatus != nil {
                map["BenchStepStatus"] = self.benchStepStatus!
            }
            if self.clientGatewayId != nil {
                map["ClientGatewayId"] = self.clientGatewayId!
            }
            if self.clientType != nil {
                map["ClientType"] = self.clientType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dstInstanceUuid != nil {
                map["DstInstanceUuid"] = self.dstInstanceUuid!
            }
            if self.dstIp != nil {
                map["DstIp"] = self.dstIp!
            }
            if self.dstPort != nil {
                map["DstPort"] = self.dstPort!
            }
            if self.dstType != nil {
                map["DstType"] = self.dstType!
            }
            if self.dtsJobClass != nil {
                map["DtsJobClass"] = self.dtsJobClass!
            }
            if self.dtsJobId != nil {
                map["DtsJobId"] = self.dtsJobId!
            }
            if self.dtsJobName != nil {
                map["DtsJobName"] = self.dtsJobName!
            }
            if self.dtsJobState != nil {
                map["DtsJobState"] = self.dtsJobState!
            }
            if self.dtsJobStatus != nil {
                map["DtsJobStatus"] = self.dtsJobStatus!
            }
            if self.ecsInstanceId != nil {
                map["EcsInstanceId"] = self.ecsInstanceId!
            }
            if self.endState != nil {
                map["EndState"] = self.endState!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.external != nil {
                map["External"] = self.external!
            }
            if self.rate != nil {
                map["Rate"] = self.rate!
            }
            if self.requestDuration != nil {
                map["RequestDuration"] = self.requestDuration!
            }
            if self.smartPressureTime != nil {
                map["SmartPressureTime"] = self.smartPressureTime!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.sqlCompleteReuse != nil {
                map["SqlCompleteReuse"] = self.sqlCompleteReuse!
            }
            if self.srcInstanceArea != nil {
                map["SrcInstanceArea"] = self.srcInstanceArea!
            }
            if self.srcInstanceUuid != nil {
                map["SrcInstanceUuid"] = self.srcInstanceUuid!
            }
            if self.srcPublicIp != nil {
                map["SrcPublicIp"] = self.srcPublicIp!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tableSchema != nil {
                map["TableSchema"] = self.tableSchema!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.topic != nil {
                map["Topic"] = self.topic!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.workDir != nil {
                map["WorkDir"] = self.workDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ArchiveJobId"] as? String {
                self.archiveJobId = value
            }
            if let value = dict["ArchiveOssTableName"] as? String {
                self.archiveOssTableName = value
            }
            if let value = dict["ArchiveState"] as? Int32 {
                self.archiveState = value
            }
            if let value = dict["BackupId"] as? String {
                self.backupId = value
            }
            if let value = dict["BackupType"] as? String {
                self.backupType = value
            }
            if let value = dict["BenchStep"] as? String {
                self.benchStep = value
            }
            if let value = dict["BenchStepStatus"] as? String {
                self.benchStepStatus = value
            }
            if let value = dict["ClientGatewayId"] as? String {
                self.clientGatewayId = value
            }
            if let value = dict["ClientType"] as? String {
                self.clientType = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DstInstanceUuid"] as? String {
                self.dstInstanceUuid = value
            }
            if let value = dict["DstIp"] as? String {
                self.dstIp = value
            }
            if let value = dict["DstPort"] as? Int32 {
                self.dstPort = value
            }
            if let value = dict["DstType"] as? String {
                self.dstType = value
            }
            if let value = dict["DtsJobClass"] as? String {
                self.dtsJobClass = value
            }
            if let value = dict["DtsJobId"] as? String {
                self.dtsJobId = value
            }
            if let value = dict["DtsJobName"] as? String {
                self.dtsJobName = value
            }
            if let value = dict["DtsJobState"] as? Int32 {
                self.dtsJobState = value
            }
            if let value = dict["DtsJobStatus"] as? String {
                self.dtsJobStatus = value
            }
            if let value = dict["EcsInstanceId"] as? String {
                self.ecsInstanceId = value
            }
            if let value = dict["EndState"] as? String {
                self.endState = value
            }
            if let value = dict["ErrorCode"] as? String {
                self.errorCode = value
            }
            if let value = dict["ErrorMessage"] as? String {
                self.errorMessage = value
            }
            if let value = dict["External"] as? String {
                self.external = value
            }
            if let value = dict["Rate"] as? Int64 {
                self.rate = value
            }
            if let value = dict["RequestDuration"] as? Int64 {
                self.requestDuration = value
            }
            if let value = dict["SmartPressureTime"] as? Int32 {
                self.smartPressureTime = value
            }
            if let value = dict["Source"] as? String {
                self.source = value
            }
            if let value = dict["SqlCompleteReuse"] as? String {
                self.sqlCompleteReuse = value
            }
            if let value = dict["SrcInstanceArea"] as? String {
                self.srcInstanceArea = value
            }
            if let value = dict["SrcInstanceUuid"] as? String {
                self.srcInstanceUuid = value
            }
            if let value = dict["SrcPublicIp"] as? String {
                self.srcPublicIp = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TableSchema"] as? String {
                self.tableSchema = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
            if let value = dict["TaskType"] as? String {
                self.taskType = value
            }
            if let value = dict["Topic"] as? String {
                self.topic = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
            if let value = dict["Version"] as? String {
                self.version = value
            }
            if let value = dict["WorkDir"] as? String {
                self.workDir = value
            }
        }
    }
    public var code: String?

    public var data: DescribeCloudbenchTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeCloudbenchTaskResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeCloudbenchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudbenchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudbenchTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudbenchTaskConfigRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class DescribeCloudbenchTaskConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var archiveFolder: String?

        public var benchCmd: String?

        public var clientJarPath: String?

        public var jarOnOss: String?

        public var loadCmd: String?

        public var metaFileName: String?

        public var metaFileOnOss: String?

        public var metaFilePath: String?

        public var parseCmd: String?

        public var parseFilePath: String?

        public var rocksDbPath: String?

        public var sqlFileName: String?

        public var sqlFileOnOss: String?

        public var sqlFilePath: String?

        public var taskId: String?

        public var userId: String?

        public var workDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.archiveFolder != nil {
                map["ArchiveFolder"] = self.archiveFolder!
            }
            if self.benchCmd != nil {
                map["BenchCmd"] = self.benchCmd!
            }
            if self.clientJarPath != nil {
                map["ClientJarPath"] = self.clientJarPath!
            }
            if self.jarOnOss != nil {
                map["JarOnOss"] = self.jarOnOss!
            }
            if self.loadCmd != nil {
                map["LoadCmd"] = self.loadCmd!
            }
            if self.metaFileName != nil {
                map["MetaFileName"] = self.metaFileName!
            }
            if self.metaFileOnOss != nil {
                map["MetaFileOnOss"] = self.metaFileOnOss!
            }
            if self.metaFilePath != nil {
                map["MetaFilePath"] = self.metaFilePath!
            }
            if self.parseCmd != nil {
                map["ParseCmd"] = self.parseCmd!
            }
            if self.parseFilePath != nil {
                map["ParseFilePath"] = self.parseFilePath!
            }
            if self.rocksDbPath != nil {
                map["RocksDbPath"] = self.rocksDbPath!
            }
            if self.sqlFileName != nil {
                map["SqlFileName"] = self.sqlFileName!
            }
            if self.sqlFileOnOss != nil {
                map["SqlFileOnOss"] = self.sqlFileOnOss!
            }
            if self.sqlFilePath != nil {
                map["SqlFilePath"] = self.sqlFilePath!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.workDir != nil {
                map["WorkDir"] = self.workDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ArchiveFolder"] as? String {
                self.archiveFolder = value
            }
            if let value = dict["BenchCmd"] as? String {
                self.benchCmd = value
            }
            if let value = dict["ClientJarPath"] as? String {
                self.clientJarPath = value
            }
            if let value = dict["JarOnOss"] as? String {
                self.jarOnOss = value
            }
            if let value = dict["LoadCmd"] as? String {
                self.loadCmd = value
            }
            if let value = dict["MetaFileName"] as? String {
                self.metaFileName = value
            }
            if let value = dict["MetaFileOnOss"] as? String {
                self.metaFileOnOss = value
            }
            if let value = dict["MetaFilePath"] as? String {
                self.metaFilePath = value
            }
            if let value = dict["ParseCmd"] as? String {
                self.parseCmd = value
            }
            if let value = dict["ParseFilePath"] as? String {
                self.parseFilePath = value
            }
            if let value = dict["RocksDbPath"] as? String {
                self.rocksDbPath = value
            }
            if let value = dict["SqlFileName"] as? String {
                self.sqlFileName = value
            }
            if let value = dict["SqlFileOnOss"] as? String {
                self.sqlFileOnOss = value
            }
            if let value = dict["SqlFilePath"] as? String {
                self.sqlFilePath = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
            if let value = dict["WorkDir"] as? String {
                self.workDir = value
            }
        }
    }
    public var code: String?

    public var data: DescribeCloudbenchTaskConfigResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeCloudbenchTaskConfigResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeCloudbenchTaskConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudbenchTaskConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudbenchTaskConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDiagnosticReportListRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var endTime: String?

    public var pageNo: String?

    public var pageSize: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PageNo"] as? String {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeDiagnosticReportListResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
        if let value = dict["Synchro"] as? String {
            self.synchro = value
        }
    }
}

public class DescribeDiagnosticReportListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosticReportListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDiagnosticReportListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeHotBigKeysRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public var nodeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
    }
}

public class DescribeHotBigKeysResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BigKeys : Tea.TeaModel {
            public class BigKey : Tea.TeaModel {
                public var db: Int32?

                public var key: String?

                public var keyType: String?

                public var nodeId: String?

                public var size: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.db != nil {
                        map["Db"] = self.db!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.keyType != nil {
                        map["KeyType"] = self.keyType!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.size != nil {
                        map["Size"] = self.size!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Db"] as? Int32 {
                        self.db = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["KeyType"] as? String {
                        self.keyType = value
                    }
                    if let value = dict["NodeId"] as? String {
                        self.nodeId = value
                    }
                    if let value = dict["Size"] as? Int64 {
                        self.size = value
                    }
                }
            }
            public var bigKey: [DescribeHotBigKeysResponseBody.Data.BigKeys.BigKey]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bigKey != nil {
                    var tmp : [Any] = []
                    for k in self.bigKey! {
                        tmp.append(k.toMap())
                    }
                    map["BigKey"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BigKey"] as? [Any?] {
                    var tmp : [DescribeHotBigKeysResponseBody.Data.BigKeys.BigKey] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeHotBigKeysResponseBody.Data.BigKeys.BigKey()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.bigKey = tmp
                }
            }
        }
        public class HotKeys : Tea.TeaModel {
            public class HotKey : Tea.TeaModel {
                public var db: Int32?

                public var hot: String?

                public var key: String?

                public var keyType: String?

                public var lfu: Int32?

                public var nodeId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.db != nil {
                        map["Db"] = self.db!
                    }
                    if self.hot != nil {
                        map["Hot"] = self.hot!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.keyType != nil {
                        map["KeyType"] = self.keyType!
                    }
                    if self.lfu != nil {
                        map["Lfu"] = self.lfu!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Db"] as? Int32 {
                        self.db = value
                    }
                    if let value = dict["Hot"] as? String {
                        self.hot = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["KeyType"] as? String {
                        self.keyType = value
                    }
                    if let value = dict["Lfu"] as? Int32 {
                        self.lfu = value
                    }
                    if let value = dict["NodeId"] as? String {
                        self.nodeId = value
                    }
                }
            }
            public var hotKey: [DescribeHotBigKeysResponseBody.Data.HotKeys.HotKey]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hotKey != nil {
                    var tmp : [Any] = []
                    for k in self.hotKey! {
                        tmp.append(k.toMap())
                    }
                    map["HotKey"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["HotKey"] as? [Any?] {
                    var tmp : [DescribeHotBigKeysResponseBody.Data.HotKeys.HotKey] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeHotBigKeysResponseBody.Data.HotKeys.HotKey()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.hotKey = tmp
                }
            }
        }
        public var bigKeyMsg: String?

        public var bigKeys: DescribeHotBigKeysResponseBody.Data.BigKeys?

        public var hotKeyMsg: String?

        public var hotKeys: DescribeHotBigKeysResponseBody.Data.HotKeys?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.bigKeys?.validate()
            try self.hotKeys?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bigKeyMsg != nil {
                map["BigKeyMsg"] = self.bigKeyMsg!
            }
            if self.bigKeys != nil {
                map["BigKeys"] = self.bigKeys?.toMap()
            }
            if self.hotKeyMsg != nil {
                map["HotKeyMsg"] = self.hotKeyMsg!
            }
            if self.hotKeys != nil {
                map["HotKeys"] = self.hotKeys?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BigKeyMsg"] as? String {
                self.bigKeyMsg = value
            }
            if let value = dict["BigKeys"] as? [String: Any?] {
                var model = DescribeHotBigKeysResponseBody.Data.BigKeys()
                model.fromMap(value)
                self.bigKeys = model
            }
            if let value = dict["HotKeyMsg"] as? String {
                self.hotKeyMsg = value
            }
            if let value = dict["HotKeys"] as? [String: Any?] {
                var model = DescribeHotBigKeysResponseBody.Data.HotKeys()
                model.fromMap(value)
                self.hotKeys = model
            }
        }
    }
    public var code: String?

    public var data: DescribeHotBigKeysResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeHotBigKeysResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeHotBigKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHotBigKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeHotBigKeysResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeHotKeysRequest : Tea.TeaModel {
    public var instanceId: String?

    public var nodeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
    }
}

public class DescribeHotKeysResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class HotKey : Tea.TeaModel {
            public var db: Int32?

            public var hot: String?

            public var key: String?

            public var keyType: String?

            public var size: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.db != nil {
                    map["Db"] = self.db!
                }
                if self.hot != nil {
                    map["Hot"] = self.hot!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.keyType != nil {
                    map["KeyType"] = self.keyType!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Db"] as? Int32 {
                    self.db = value
                }
                if let value = dict["Hot"] as? String {
                    self.hot = value
                }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["KeyType"] as? String {
                    self.keyType = value
                }
                if let value = dict["Size"] as? Int64 {
                    self.size = value
                }
            }
        }
        public var hotKey: [DescribeHotKeysResponseBody.Data.HotKey]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hotKey != nil {
                var tmp : [Any] = []
                for k in self.hotKey! {
                    tmp.append(k.toMap())
                }
                map["HotKey"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HotKey"] as? [Any?] {
                var tmp : [DescribeHotKeysResponseBody.Data.HotKey] = []
                for v in value {
                    if v != nil {
                        var model = DescribeHotKeysResponseBody.Data.HotKey()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.hotKey = tmp
            }
        }
    }
    public var code: String?

    public var data: DescribeHotKeysResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeHotKeysResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeHotKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHotKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeHotKeysResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceDasProRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DescribeInstanceDasProResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeInstanceDasProResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceDasProResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceDasProResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeQueryExplainRequest : Tea.TeaModel {
    public var dbName: String?

    public var instanceId: String?

    public var nodeId: String?

    public var schema: String?

    public var sql: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.sql != nil {
            map["Sql"] = self.sql!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DbName"] as? String {
            self.dbName = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["Schema"] as? String {
            self.schema = value
        }
        if let value = dict["Sql"] as? String {
            self.sql = value
        }
    }
}

public class DescribeQueryExplainResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var argument: String?

        public var avgRowSize: String?

        public var definedValues: String?

        public var estimateCPU: String?

        public var estimateExecutions: String?

        public var estimateIO: String?

        public var estimateRows: String?

        public var extra: String?

        public var id: String?

        public var indexList: [String]?

        public var key: String?

        public var keyLen: String?

        public var logicalOp: String?

        public var logicalPlanList: [String]?

        public var nodeId: String?

        public var outputList: String?

        public var parallel: String?

        public var parent: String?

        public var physicalOp: String?

        public var possibleKeys: String?

        public var queryPlan: String?

        public var ref: String?

        public var rows: String?

        public var selectType: String?

        public var stmtId: String?

        public var stmtText: String?

        public var table: String?

        public var tableList: [String]?

        public var totalSubtreeCost: String?

        public var type: String?

        public var warnings: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.argument != nil {
                map["Argument"] = self.argument!
            }
            if self.avgRowSize != nil {
                map["AvgRowSize"] = self.avgRowSize!
            }
            if self.definedValues != nil {
                map["DefinedValues"] = self.definedValues!
            }
            if self.estimateCPU != nil {
                map["EstimateCPU"] = self.estimateCPU!
            }
            if self.estimateExecutions != nil {
                map["EstimateExecutions"] = self.estimateExecutions!
            }
            if self.estimateIO != nil {
                map["EstimateIO"] = self.estimateIO!
            }
            if self.estimateRows != nil {
                map["EstimateRows"] = self.estimateRows!
            }
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.indexList != nil {
                map["IndexList"] = self.indexList!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.keyLen != nil {
                map["KeyLen"] = self.keyLen!
            }
            if self.logicalOp != nil {
                map["LogicalOp"] = self.logicalOp!
            }
            if self.logicalPlanList != nil {
                map["LogicalPlanList"] = self.logicalPlanList!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.outputList != nil {
                map["OutputList"] = self.outputList!
            }
            if self.parallel != nil {
                map["Parallel"] = self.parallel!
            }
            if self.parent != nil {
                map["Parent"] = self.parent!
            }
            if self.physicalOp != nil {
                map["PhysicalOp"] = self.physicalOp!
            }
            if self.possibleKeys != nil {
                map["PossibleKeys"] = self.possibleKeys!
            }
            if self.queryPlan != nil {
                map["QueryPlan"] = self.queryPlan!
            }
            if self.ref != nil {
                map["Ref"] = self.ref!
            }
            if self.rows != nil {
                map["Rows"] = self.rows!
            }
            if self.selectType != nil {
                map["SelectType"] = self.selectType!
            }
            if self.stmtId != nil {
                map["StmtId"] = self.stmtId!
            }
            if self.stmtText != nil {
                map["StmtText"] = self.stmtText!
            }
            if self.table != nil {
                map["Table"] = self.table!
            }
            if self.tableList != nil {
                map["TableList"] = self.tableList!
            }
            if self.totalSubtreeCost != nil {
                map["TotalSubtreeCost"] = self.totalSubtreeCost!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.warnings != nil {
                map["Warnings"] = self.warnings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Argument"] as? String {
                self.argument = value
            }
            if let value = dict["AvgRowSize"] as? String {
                self.avgRowSize = value
            }
            if let value = dict["DefinedValues"] as? String {
                self.definedValues = value
            }
            if let value = dict["EstimateCPU"] as? String {
                self.estimateCPU = value
            }
            if let value = dict["EstimateExecutions"] as? String {
                self.estimateExecutions = value
            }
            if let value = dict["EstimateIO"] as? String {
                self.estimateIO = value
            }
            if let value = dict["EstimateRows"] as? String {
                self.estimateRows = value
            }
            if let value = dict["Extra"] as? String {
                self.extra = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["IndexList"] as? [String] {
                self.indexList = value
            }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["KeyLen"] as? String {
                self.keyLen = value
            }
            if let value = dict["LogicalOp"] as? String {
                self.logicalOp = value
            }
            if let value = dict["LogicalPlanList"] as? [String] {
                self.logicalPlanList = value
            }
            if let value = dict["NodeId"] as? String {
                self.nodeId = value
            }
            if let value = dict["OutputList"] as? String {
                self.outputList = value
            }
            if let value = dict["Parallel"] as? String {
                self.parallel = value
            }
            if let value = dict["Parent"] as? String {
                self.parent = value
            }
            if let value = dict["PhysicalOp"] as? String {
                self.physicalOp = value
            }
            if let value = dict["PossibleKeys"] as? String {
                self.possibleKeys = value
            }
            if let value = dict["QueryPlan"] as? String {
                self.queryPlan = value
            }
            if let value = dict["Ref"] as? String {
                self.ref = value
            }
            if let value = dict["Rows"] as? String {
                self.rows = value
            }
            if let value = dict["SelectType"] as? String {
                self.selectType = value
            }
            if let value = dict["StmtId"] as? String {
                self.stmtId = value
            }
            if let value = dict["StmtText"] as? String {
                self.stmtText = value
            }
            if let value = dict["Table"] as? String {
                self.table = value
            }
            if let value = dict["TableList"] as? [String] {
                self.tableList = value
            }
            if let value = dict["TotalSubtreeCost"] as? String {
                self.totalSubtreeCost = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["Warnings"] as? String {
                self.warnings = value
            }
        }
    }
    public var code: String?

    public var data: [DescribeQueryExplainResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribeQueryExplainResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribeQueryExplainResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeQueryExplainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeQueryExplainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeQueryExplainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSlowLogHistogramAsyncRequest : Tea.TeaModel {
    public class Filters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var endTime: Int64?

    public var filters: [DescribeSlowLogHistogramAsyncRequest.Filters]?

    public var instanceId: String?

    public var nodeId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filters != nil {
            var tmp : [Any] = []
            for k in self.filters! {
                tmp.append(k.toMap())
            }
            map["Filters"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["Filters"] as? [Any?] {
            var tmp : [DescribeSlowLogHistogramAsyncRequest.Filters] = []
            for v in value {
                if v != nil {
                    var model = DescribeSlowLogHistogramAsyncRequest.Filters()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filters = tmp
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class DescribeSlowLogHistogramAsyncResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class Item : Tea.TeaModel {
                public class InsItems : Tea.TeaModel {
                    public var count: [Int64]?

                    public var insId: String?

                    public var insRole: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.insId != nil {
                            map["InsId"] = self.insId!
                        }
                        if self.insRole != nil {
                            map["InsRole"] = self.insRole!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Count"] as? [Int64] {
                            self.count = value
                        }
                        if let value = dict["InsId"] as? String {
                            self.insId = value
                        }
                        if let value = dict["InsRole"] as? String {
                            self.insRole = value
                        }
                    }
                }
                public var count: [Int64]?

                public var insItems: [DescribeSlowLogHistogramAsyncResponseBody.Data.Data.Item.InsItems]?

                public var nodeId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.insItems != nil {
                        var tmp : [Any] = []
                        for k in self.insItems! {
                            tmp.append(k.toMap())
                        }
                        map["InsItems"] = tmp
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Count"] as? [Int64] {
                        self.count = value
                    }
                    if let value = dict["InsItems"] as? [Any?] {
                        var tmp : [DescribeSlowLogHistogramAsyncResponseBody.Data.Data.Item.InsItems] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeSlowLogHistogramAsyncResponseBody.Data.Data.Item.InsItems()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.insItems = tmp
                    }
                    if let value = dict["NodeId"] as? String {
                        self.nodeId = value
                    }
                }
            }
            public var avgCPUTime: [Double]?

            public var avgDocExamined: [Double]?

            public var avgFrows: [Double]?

            public var avgIOWrites: [Double]?

            public var avgKeysExamined: [Double]?

            public var avgLastRowsCountAffected: [Double]?

            public var avgLockTime: [Double]?

            public var avgLogicalIOReads: [Double]?

            public var avgPhysicalIOReads: [Double]?

            public var avgReturnNum: [Double]?

            public var avgRows: [Double]?

            public var avgRowsCountAffected: [Double]?

            public var avgRowsExamined: [Double]?

            public var avgRowsSent: [Double]?

            public var avgRt: [Double]?

            public var avgScnt: [Double]?

            public var CPUTime: [Double]?

            public var count: [Int64]?

            public var docExamined: [Int64]?

            public var frows: [Int64]?

            public var IOWrites: [Int64]?

            public var item: [DescribeSlowLogHistogramAsyncResponseBody.Data.Data.Item]?

            public var keysExamined: [Int64]?

            public var lastRowsCountAffected: [Int64]?

            public var lockTime: [Double]?

            public var logicalIOReads: [Int64]?

            public var maxCPUTime: [Double]?

            public var maxDocExamined: [Int64]?

            public var maxFrows: [Int64]?

            public var maxIOWrites: [Int64]?

            public var maxKeysExamined: [Int64]?

            public var maxLastRowsCountAffected: [Int64]?

            public var maxLockTime: [Double]?

            public var maxLogicalIOReads: [Int64]?

            public var maxPhysicalIOReads: [Int64]?

            public var maxReturnNum: [Int64]?

            public var maxRows: [Int64]?

            public var maxRowsCountAffected: [Int64]?

            public var maxRowsExamined: [Int64]?

            public var maxRowsSent: [Int64]?

            public var maxRt: [Double]?

            public var maxScnt: [Int64]?

            public var physicalIOReads: [Int64]?

            public var returnNum: [Int64]?

            public var rows: [Int64]?

            public var rowsCountAffected: [Int64]?

            public var rowsExamined: [Int64]?

            public var rowsSent: [Int64]?

            public var rt: [Double]?

            public var scnt: [Int64]?

            public var total: Int64?

            public var ts: [Int64]?

            public var tsEnd: [Int64]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgCPUTime != nil {
                    map["AvgCPUTime"] = self.avgCPUTime!
                }
                if self.avgDocExamined != nil {
                    map["AvgDocExamined"] = self.avgDocExamined!
                }
                if self.avgFrows != nil {
                    map["AvgFrows"] = self.avgFrows!
                }
                if self.avgIOWrites != nil {
                    map["AvgIOWrites"] = self.avgIOWrites!
                }
                if self.avgKeysExamined != nil {
                    map["AvgKeysExamined"] = self.avgKeysExamined!
                }
                if self.avgLastRowsCountAffected != nil {
                    map["AvgLastRowsCountAffected"] = self.avgLastRowsCountAffected!
                }
                if self.avgLockTime != nil {
                    map["AvgLockTime"] = self.avgLockTime!
                }
                if self.avgLogicalIOReads != nil {
                    map["AvgLogicalIOReads"] = self.avgLogicalIOReads!
                }
                if self.avgPhysicalIOReads != nil {
                    map["AvgPhysicalIOReads"] = self.avgPhysicalIOReads!
                }
                if self.avgReturnNum != nil {
                    map["AvgReturnNum"] = self.avgReturnNum!
                }
                if self.avgRows != nil {
                    map["AvgRows"] = self.avgRows!
                }
                if self.avgRowsCountAffected != nil {
                    map["AvgRowsCountAffected"] = self.avgRowsCountAffected!
                }
                if self.avgRowsExamined != nil {
                    map["AvgRowsExamined"] = self.avgRowsExamined!
                }
                if self.avgRowsSent != nil {
                    map["AvgRowsSent"] = self.avgRowsSent!
                }
                if self.avgRt != nil {
                    map["AvgRt"] = self.avgRt!
                }
                if self.avgScnt != nil {
                    map["AvgScnt"] = self.avgScnt!
                }
                if self.CPUTime != nil {
                    map["CPUTime"] = self.CPUTime!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.docExamined != nil {
                    map["DocExamined"] = self.docExamined!
                }
                if self.frows != nil {
                    map["Frows"] = self.frows!
                }
                if self.IOWrites != nil {
                    map["IOWrites"] = self.IOWrites!
                }
                if self.item != nil {
                    var tmp : [Any] = []
                    for k in self.item! {
                        tmp.append(k.toMap())
                    }
                    map["Item"] = tmp
                }
                if self.keysExamined != nil {
                    map["KeysExamined"] = self.keysExamined!
                }
                if self.lastRowsCountAffected != nil {
                    map["LastRowsCountAffected"] = self.lastRowsCountAffected!
                }
                if self.lockTime != nil {
                    map["LockTime"] = self.lockTime!
                }
                if self.logicalIOReads != nil {
                    map["LogicalIOReads"] = self.logicalIOReads!
                }
                if self.maxCPUTime != nil {
                    map["MaxCPUTime"] = self.maxCPUTime!
                }
                if self.maxDocExamined != nil {
                    map["MaxDocExamined"] = self.maxDocExamined!
                }
                if self.maxFrows != nil {
                    map["MaxFrows"] = self.maxFrows!
                }
                if self.maxIOWrites != nil {
                    map["MaxIOWrites"] = self.maxIOWrites!
                }
                if self.maxKeysExamined != nil {
                    map["MaxKeysExamined"] = self.maxKeysExamined!
                }
                if self.maxLastRowsCountAffected != nil {
                    map["MaxLastRowsCountAffected"] = self.maxLastRowsCountAffected!
                }
                if self.maxLockTime != nil {
                    map["MaxLockTime"] = self.maxLockTime!
                }
                if self.maxLogicalIOReads != nil {
                    map["MaxLogicalIOReads"] = self.maxLogicalIOReads!
                }
                if self.maxPhysicalIOReads != nil {
                    map["MaxPhysicalIOReads"] = self.maxPhysicalIOReads!
                }
                if self.maxReturnNum != nil {
                    map["MaxReturnNum"] = self.maxReturnNum!
                }
                if self.maxRows != nil {
                    map["MaxRows"] = self.maxRows!
                }
                if self.maxRowsCountAffected != nil {
                    map["MaxRowsCountAffected"] = self.maxRowsCountAffected!
                }
                if self.maxRowsExamined != nil {
                    map["MaxRowsExamined"] = self.maxRowsExamined!
                }
                if self.maxRowsSent != nil {
                    map["MaxRowsSent"] = self.maxRowsSent!
                }
                if self.maxRt != nil {
                    map["MaxRt"] = self.maxRt!
                }
                if self.maxScnt != nil {
                    map["MaxScnt"] = self.maxScnt!
                }
                if self.physicalIOReads != nil {
                    map["PhysicalIOReads"] = self.physicalIOReads!
                }
                if self.returnNum != nil {
                    map["ReturnNum"] = self.returnNum!
                }
                if self.rows != nil {
                    map["Rows"] = self.rows!
                }
                if self.rowsCountAffected != nil {
                    map["RowsCountAffected"] = self.rowsCountAffected!
                }
                if self.rowsExamined != nil {
                    map["RowsExamined"] = self.rowsExamined!
                }
                if self.rowsSent != nil {
                    map["RowsSent"] = self.rowsSent!
                }
                if self.rt != nil {
                    map["Rt"] = self.rt!
                }
                if self.scnt != nil {
                    map["Scnt"] = self.scnt!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.ts != nil {
                    map["Ts"] = self.ts!
                }
                if self.tsEnd != nil {
                    map["TsEnd"] = self.tsEnd!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AvgCPUTime"] as? [Double] {
                    self.avgCPUTime = value
                }
                if let value = dict["AvgDocExamined"] as? [Double] {
                    self.avgDocExamined = value
                }
                if let value = dict["AvgFrows"] as? [Double] {
                    self.avgFrows = value
                }
                if let value = dict["AvgIOWrites"] as? [Double] {
                    self.avgIOWrites = value
                }
                if let value = dict["AvgKeysExamined"] as? [Double] {
                    self.avgKeysExamined = value
                }
                if let value = dict["AvgLastRowsCountAffected"] as? [Double] {
                    self.avgLastRowsCountAffected = value
                }
                if let value = dict["AvgLockTime"] as? [Double] {
                    self.avgLockTime = value
                }
                if let value = dict["AvgLogicalIOReads"] as? [Double] {
                    self.avgLogicalIOReads = value
                }
                if let value = dict["AvgPhysicalIOReads"] as? [Double] {
                    self.avgPhysicalIOReads = value
                }
                if let value = dict["AvgReturnNum"] as? [Double] {
                    self.avgReturnNum = value
                }
                if let value = dict["AvgRows"] as? [Double] {
                    self.avgRows = value
                }
                if let value = dict["AvgRowsCountAffected"] as? [Double] {
                    self.avgRowsCountAffected = value
                }
                if let value = dict["AvgRowsExamined"] as? [Double] {
                    self.avgRowsExamined = value
                }
                if let value = dict["AvgRowsSent"] as? [Double] {
                    self.avgRowsSent = value
                }
                if let value = dict["AvgRt"] as? [Double] {
                    self.avgRt = value
                }
                if let value = dict["AvgScnt"] as? [Double] {
                    self.avgScnt = value
                }
                if let value = dict["CPUTime"] as? [Double] {
                    self.CPUTime = value
                }
                if let value = dict["Count"] as? [Int64] {
                    self.count = value
                }
                if let value = dict["DocExamined"] as? [Int64] {
                    self.docExamined = value
                }
                if let value = dict["Frows"] as? [Int64] {
                    self.frows = value
                }
                if let value = dict["IOWrites"] as? [Int64] {
                    self.IOWrites = value
                }
                if let value = dict["Item"] as? [Any?] {
                    var tmp : [DescribeSlowLogHistogramAsyncResponseBody.Data.Data.Item] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeSlowLogHistogramAsyncResponseBody.Data.Data.Item()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.item = tmp
                }
                if let value = dict["KeysExamined"] as? [Int64] {
                    self.keysExamined = value
                }
                if let value = dict["LastRowsCountAffected"] as? [Int64] {
                    self.lastRowsCountAffected = value
                }
                if let value = dict["LockTime"] as? [Double] {
                    self.lockTime = value
                }
                if let value = dict["LogicalIOReads"] as? [Int64] {
                    self.logicalIOReads = value
                }
                if let value = dict["MaxCPUTime"] as? [Double] {
                    self.maxCPUTime = value
                }
                if let value = dict["MaxDocExamined"] as? [Int64] {
                    self.maxDocExamined = value
                }
                if let value = dict["MaxFrows"] as? [Int64] {
                    self.maxFrows = value
                }
                if let value = dict["MaxIOWrites"] as? [Int64] {
                    self.maxIOWrites = value
                }
                if let value = dict["MaxKeysExamined"] as? [Int64] {
                    self.maxKeysExamined = value
                }
                if let value = dict["MaxLastRowsCountAffected"] as? [Int64] {
                    self.maxLastRowsCountAffected = value
                }
                if let value = dict["MaxLockTime"] as? [Double] {
                    self.maxLockTime = value
                }
                if let value = dict["MaxLogicalIOReads"] as? [Int64] {
                    self.maxLogicalIOReads = value
                }
                if let value = dict["MaxPhysicalIOReads"] as? [Int64] {
                    self.maxPhysicalIOReads = value
                }
                if let value = dict["MaxReturnNum"] as? [Int64] {
                    self.maxReturnNum = value
                }
                if let value = dict["MaxRows"] as? [Int64] {
                    self.maxRows = value
                }
                if let value = dict["MaxRowsCountAffected"] as? [Int64] {
                    self.maxRowsCountAffected = value
                }
                if let value = dict["MaxRowsExamined"] as? [Int64] {
                    self.maxRowsExamined = value
                }
                if let value = dict["MaxRowsSent"] as? [Int64] {
                    self.maxRowsSent = value
                }
                if let value = dict["MaxRt"] as? [Double] {
                    self.maxRt = value
                }
                if let value = dict["MaxScnt"] as? [Int64] {
                    self.maxScnt = value
                }
                if let value = dict["PhysicalIOReads"] as? [Int64] {
                    self.physicalIOReads = value
                }
                if let value = dict["ReturnNum"] as? [Int64] {
                    self.returnNum = value
                }
                if let value = dict["Rows"] as? [Int64] {
                    self.rows = value
                }
                if let value = dict["RowsCountAffected"] as? [Int64] {
                    self.rowsCountAffected = value
                }
                if let value = dict["RowsExamined"] as? [Int64] {
                    self.rowsExamined = value
                }
                if let value = dict["RowsSent"] as? [Int64] {
                    self.rowsSent = value
                }
                if let value = dict["Rt"] as? [Double] {
                    self.rt = value
                }
                if let value = dict["Scnt"] as? [Int64] {
                    self.scnt = value
                }
                if let value = dict["Total"] as? Int64 {
                    self.total = value
                }
                if let value = dict["Ts"] as? [Int64] {
                    self.ts = value
                }
                if let value = dict["TsEnd"] as? [Int64] {
                    self.tsEnd = value
                }
            }
        }
        public var data: DescribeSlowLogHistogramAsyncResponseBody.Data.Data?

        public var errorCode: Int32?

        public var isFinish: Bool?

        public var message: String?

        public var requestKey: String?

        public var resultId: String?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.isFinish != nil {
                map["IsFinish"] = self.isFinish!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.requestKey != nil {
                map["RequestKey"] = self.requestKey!
            }
            if self.resultId != nil {
                map["ResultId"] = self.resultId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Data"] as? [String: Any?] {
                var model = DescribeSlowLogHistogramAsyncResponseBody.Data.Data()
                model.fromMap(value)
                self.data = model
            }
            if let value = dict["ErrorCode"] as? Int32 {
                self.errorCode = value
            }
            if let value = dict["IsFinish"] as? Bool {
                self.isFinish = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["RequestKey"] as? String {
                self.requestKey = value
            }
            if let value = dict["ResultId"] as? String {
                self.resultId = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
        }
    }
    public var code: String?

    public var data: DescribeSlowLogHistogramAsyncResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeSlowLogHistogramAsyncResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeSlowLogHistogramAsyncResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSlowLogHistogramAsyncResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSlowLogHistogramAsyncResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSlowLogRecordsRequest : Tea.TeaModel {
    public class Filters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var asc: Bool?

    public var endTime: Int64?

    public var filters: [DescribeSlowLogRecordsRequest.Filters]?

    public var instanceId: String?

    public var nodeId: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filters != nil {
            var tmp : [Any] = []
            for k in self.filters! {
                tmp.append(k.toMap())
            }
            map["Filters"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Asc"] as? Bool {
            self.asc = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["Filters"] as? [Any?] {
            var tmp : [DescribeSlowLogRecordsRequest.Filters] = []
            for v in value {
                if v != nil {
                    var model = DescribeSlowLogRecordsRequest.Filters()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filters = tmp
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class DescribeSlowLogRecordsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Logs : Tea.TeaModel {
            public class SqlTag : Tea.TeaModel {
                public var comments: String?

                public var sqlId: String?

                public var tags: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.comments != nil {
                        map["Comments"] = self.comments!
                    }
                    if self.sqlId != nil {
                        map["SqlId"] = self.sqlId!
                    }
                    if self.tags != nil {
                        map["Tags"] = self.tags!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Comments"] as? String {
                        self.comments = value
                    }
                    if let value = dict["SqlId"] as? String {
                        self.sqlId = value
                    }
                    if let value = dict["Tags"] as? String {
                        self.tags = value
                    }
                }
            }
            public var accountName: String?

            public var applicationName: String?

            public var CPUTime: Double?

            public var CPUTimeSeconds: Double?

            public var command: String?

            public var DBName: String?

            public var dbInstanceName: String?

            public var docsExamined: String?

            public var frows: Int64?

            public var hostAddress: String?

            public var IOWrites: Int64?

            public var insName: String?

            public var keysExamined: String?

            public var lastRowsCountAffected: Int64?

            public var lockTime: Double?

            public var lockTimeSeconds: Double?

            public var logicalIOReads: Int64?

            public var namespace: String?

            public var physicalIOReads: Int64?

            public var psql: String?

            public var queryId: String?

            public var queryStartTime: String?

            public var queryTime: Int64?

            public var queryTimeSeconds: Double?

            public var returnItemNumbers: String?

            public var returnNum: String?

            public var rows: Int64?

            public var rowsCountAffected: Int64?

            public var rowsExamined: Int64?

            public var rowsSent: Int64?

            public var SQLText: String?

            public var scheme: String?

            public var scnt: Int64?

            public var sqlId: String?

            public var sqlTag: DescribeSlowLogRecordsResponseBody.Data.Logs.SqlTag?

            public var sqlType: String?

            public var subInstanceId: String?

            public var tableName: String?

            public var templateId: String?

            public var threadId: String?

            public var timestamp: Int64?

            public var traceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.sqlTag?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountName != nil {
                    map["AccountName"] = self.accountName!
                }
                if self.applicationName != nil {
                    map["ApplicationName"] = self.applicationName!
                }
                if self.CPUTime != nil {
                    map["CPUTime"] = self.CPUTime!
                }
                if self.CPUTimeSeconds != nil {
                    map["CPUTimeSeconds"] = self.CPUTimeSeconds!
                }
                if self.command != nil {
                    map["Command"] = self.command!
                }
                if self.DBName != nil {
                    map["DBName"] = self.DBName!
                }
                if self.dbInstanceName != nil {
                    map["DbInstanceName"] = self.dbInstanceName!
                }
                if self.docsExamined != nil {
                    map["DocsExamined"] = self.docsExamined!
                }
                if self.frows != nil {
                    map["Frows"] = self.frows!
                }
                if self.hostAddress != nil {
                    map["HostAddress"] = self.hostAddress!
                }
                if self.IOWrites != nil {
                    map["IOWrites"] = self.IOWrites!
                }
                if self.insName != nil {
                    map["InsName"] = self.insName!
                }
                if self.keysExamined != nil {
                    map["KeysExamined"] = self.keysExamined!
                }
                if self.lastRowsCountAffected != nil {
                    map["LastRowsCountAffected"] = self.lastRowsCountAffected!
                }
                if self.lockTime != nil {
                    map["LockTime"] = self.lockTime!
                }
                if self.lockTimeSeconds != nil {
                    map["LockTimeSeconds"] = self.lockTimeSeconds!
                }
                if self.logicalIOReads != nil {
                    map["LogicalIOReads"] = self.logicalIOReads!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.physicalIOReads != nil {
                    map["PhysicalIOReads"] = self.physicalIOReads!
                }
                if self.psql != nil {
                    map["Psql"] = self.psql!
                }
                if self.queryId != nil {
                    map["QueryId"] = self.queryId!
                }
                if self.queryStartTime != nil {
                    map["QueryStartTime"] = self.queryStartTime!
                }
                if self.queryTime != nil {
                    map["QueryTime"] = self.queryTime!
                }
                if self.queryTimeSeconds != nil {
                    map["QueryTimeSeconds"] = self.queryTimeSeconds!
                }
                if self.returnItemNumbers != nil {
                    map["ReturnItemNumbers"] = self.returnItemNumbers!
                }
                if self.returnNum != nil {
                    map["ReturnNum"] = self.returnNum!
                }
                if self.rows != nil {
                    map["Rows"] = self.rows!
                }
                if self.rowsCountAffected != nil {
                    map["RowsCountAffected"] = self.rowsCountAffected!
                }
                if self.rowsExamined != nil {
                    map["RowsExamined"] = self.rowsExamined!
                }
                if self.rowsSent != nil {
                    map["RowsSent"] = self.rowsSent!
                }
                if self.SQLText != nil {
                    map["SQLText"] = self.SQLText!
                }
                if self.scheme != nil {
                    map["Scheme"] = self.scheme!
                }
                if self.scnt != nil {
                    map["Scnt"] = self.scnt!
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.sqlTag != nil {
                    map["SqlTag"] = self.sqlTag?.toMap()
                }
                if self.sqlType != nil {
                    map["SqlType"] = self.sqlType!
                }
                if self.subInstanceId != nil {
                    map["SubInstanceId"] = self.subInstanceId!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.threadId != nil {
                    map["ThreadId"] = self.threadId!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.traceId != nil {
                    map["TraceId"] = self.traceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountName"] as? String {
                    self.accountName = value
                }
                if let value = dict["ApplicationName"] as? String {
                    self.applicationName = value
                }
                if let value = dict["CPUTime"] as? Double {
                    self.CPUTime = value
                }
                if let value = dict["CPUTimeSeconds"] as? Double {
                    self.CPUTimeSeconds = value
                }
                if let value = dict["Command"] as? String {
                    self.command = value
                }
                if let value = dict["DBName"] as? String {
                    self.DBName = value
                }
                if let value = dict["DbInstanceName"] as? String {
                    self.dbInstanceName = value
                }
                if let value = dict["DocsExamined"] as? String {
                    self.docsExamined = value
                }
                if let value = dict["Frows"] as? Int64 {
                    self.frows = value
                }
                if let value = dict["HostAddress"] as? String {
                    self.hostAddress = value
                }
                if let value = dict["IOWrites"] as? Int64 {
                    self.IOWrites = value
                }
                if let value = dict["InsName"] as? String {
                    self.insName = value
                }
                if let value = dict["KeysExamined"] as? String {
                    self.keysExamined = value
                }
                if let value = dict["LastRowsCountAffected"] as? Int64 {
                    self.lastRowsCountAffected = value
                }
                if let value = dict["LockTime"] as? Double {
                    self.lockTime = value
                }
                if let value = dict["LockTimeSeconds"] as? Double {
                    self.lockTimeSeconds = value
                }
                if let value = dict["LogicalIOReads"] as? Int64 {
                    self.logicalIOReads = value
                }
                if let value = dict["Namespace"] as? String {
                    self.namespace = value
                }
                if let value = dict["PhysicalIOReads"] as? Int64 {
                    self.physicalIOReads = value
                }
                if let value = dict["Psql"] as? String {
                    self.psql = value
                }
                if let value = dict["QueryId"] as? String {
                    self.queryId = value
                }
                if let value = dict["QueryStartTime"] as? String {
                    self.queryStartTime = value
                }
                if let value = dict["QueryTime"] as? Int64 {
                    self.queryTime = value
                }
                if let value = dict["QueryTimeSeconds"] as? Double {
                    self.queryTimeSeconds = value
                }
                if let value = dict["ReturnItemNumbers"] as? String {
                    self.returnItemNumbers = value
                }
                if let value = dict["ReturnNum"] as? String {
                    self.returnNum = value
                }
                if let value = dict["Rows"] as? Int64 {
                    self.rows = value
                }
                if let value = dict["RowsCountAffected"] as? Int64 {
                    self.rowsCountAffected = value
                }
                if let value = dict["RowsExamined"] as? Int64 {
                    self.rowsExamined = value
                }
                if let value = dict["RowsSent"] as? Int64 {
                    self.rowsSent = value
                }
                if let value = dict["SQLText"] as? String {
                    self.SQLText = value
                }
                if let value = dict["Scheme"] as? String {
                    self.scheme = value
                }
                if let value = dict["Scnt"] as? Int64 {
                    self.scnt = value
                }
                if let value = dict["SqlId"] as? String {
                    self.sqlId = value
                }
                if let value = dict["SqlTag"] as? [String: Any?] {
                    var model = DescribeSlowLogRecordsResponseBody.Data.Logs.SqlTag()
                    model.fromMap(value)
                    self.sqlTag = model
                }
                if let value = dict["SqlType"] as? String {
                    self.sqlType = value
                }
                if let value = dict["SubInstanceId"] as? String {
                    self.subInstanceId = value
                }
                if let value = dict["TableName"] as? String {
                    self.tableName = value
                }
                if let value = dict["TemplateId"] as? String {
                    self.templateId = value
                }
                if let value = dict["ThreadId"] as? String {
                    self.threadId = value
                }
                if let value = dict["Timestamp"] as? Int64 {
                    self.timestamp = value
                }
                if let value = dict["TraceId"] as? String {
                    self.traceId = value
                }
            }
        }
        public var dbInstanceId: Int64?

        public var dbInstanceName: String?

        public var endTime: String?

        public var itemsNumbers: Int64?

        public var logs: [DescribeSlowLogRecordsResponseBody.Data.Logs]?

        public var maxRecordsPerPage: Int32?

        public var nodeId: String?

        public var pageNumbers: Int32?

        public var startTime: String?

        public var totalRecords: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbInstanceId != nil {
                map["DbInstanceId"] = self.dbInstanceId!
            }
            if self.dbInstanceName != nil {
                map["DbInstanceName"] = self.dbInstanceName!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.itemsNumbers != nil {
                map["ItemsNumbers"] = self.itemsNumbers!
            }
            if self.logs != nil {
                var tmp : [Any] = []
                for k in self.logs! {
                    tmp.append(k.toMap())
                }
                map["Logs"] = tmp
            }
            if self.maxRecordsPerPage != nil {
                map["MaxRecordsPerPage"] = self.maxRecordsPerPage!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.pageNumbers != nil {
                map["PageNumbers"] = self.pageNumbers!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.totalRecords != nil {
                map["TotalRecords"] = self.totalRecords!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DbInstanceId"] as? Int64 {
                self.dbInstanceId = value
            }
            if let value = dict["DbInstanceName"] as? String {
                self.dbInstanceName = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["ItemsNumbers"] as? Int64 {
                self.itemsNumbers = value
            }
            if let value = dict["Logs"] as? [Any?] {
                var tmp : [DescribeSlowLogRecordsResponseBody.Data.Logs] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSlowLogRecordsResponseBody.Data.Logs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.logs = tmp
            }
            if let value = dict["MaxRecordsPerPage"] as? Int32 {
                self.maxRecordsPerPage = value
            }
            if let value = dict["NodeId"] as? String {
                self.nodeId = value
            }
            if let value = dict["PageNumbers"] as? Int32 {
                self.pageNumbers = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["TotalRecords"] as? Int64 {
                self.totalRecords = value
            }
        }
    }
    public var code: String?

    public var data: DescribeSlowLogRecordsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeSlowLogRecordsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeSlowLogRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSlowLogRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSlowLogRecordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSlowLogStatisticRequest : Tea.TeaModel {
    public class Filters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var asc: Bool?

    public var endTime: Int64?

    public var filters: [DescribeSlowLogStatisticRequest.Filters]?

    public var instanceId: String?

    public var nodeId: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public var templateId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filters != nil {
            var tmp : [Any] = []
            for k in self.filters! {
                tmp.append(k.toMap())
            }
            map["Filters"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Asc"] as? Bool {
            self.asc = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["Filters"] as? [Any?] {
            var tmp : [DescribeSlowLogStatisticRequest.Filters] = []
            for v in value {
                if v != nil {
                    var model = DescribeSlowLogStatisticRequest.Filters()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filters = tmp
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribeSlowLogStatisticResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class Logs : Tea.TeaModel {
                public class Histogram : Tea.TeaModel {
                    public class Item : Tea.TeaModel {
                        public var count: [Int64]?

                        public var nodeId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            if self.nodeId != nil {
                                map["NodeId"] = self.nodeId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Count"] as? [Int64] {
                                self.count = value
                            }
                            if let value = dict["NodeId"] as? String {
                                self.nodeId = value
                            }
                        }
                    }
                    public var avgLockTime: [Double]?

                    public var avgRowsExamined: [Double]?

                    public var avgRowsSent: [Double]?

                    public var avgRt: [Double]?

                    public var count: [Int64]?

                    public var item: [DescribeSlowLogStatisticResponseBody.Data.Data.Logs.Histogram.Item]?

                    public var lockTime: [Double]?

                    public var maxLockTime: [Double]?

                    public var maxRowsExamined: [Int64]?

                    public var maxRowsSent: [Int64]?

                    public var maxRt: [Double]?

                    public var rowsExamined: [Int64]?

                    public var rowsSent: [Int64]?

                    public var rt: [Double]?

                    public var total: Int64?

                    public var ts: [Int64]?

                    public var tsEnd: [Int64]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.avgLockTime != nil {
                            map["AvgLockTime"] = self.avgLockTime!
                        }
                        if self.avgRowsExamined != nil {
                            map["AvgRowsExamined"] = self.avgRowsExamined!
                        }
                        if self.avgRowsSent != nil {
                            map["AvgRowsSent"] = self.avgRowsSent!
                        }
                        if self.avgRt != nil {
                            map["AvgRt"] = self.avgRt!
                        }
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.item != nil {
                            var tmp : [Any] = []
                            for k in self.item! {
                                tmp.append(k.toMap())
                            }
                            map["Item"] = tmp
                        }
                        if self.lockTime != nil {
                            map["LockTime"] = self.lockTime!
                        }
                        if self.maxLockTime != nil {
                            map["MaxLockTime"] = self.maxLockTime!
                        }
                        if self.maxRowsExamined != nil {
                            map["MaxRowsExamined"] = self.maxRowsExamined!
                        }
                        if self.maxRowsSent != nil {
                            map["MaxRowsSent"] = self.maxRowsSent!
                        }
                        if self.maxRt != nil {
                            map["MaxRt"] = self.maxRt!
                        }
                        if self.rowsExamined != nil {
                            map["RowsExamined"] = self.rowsExamined!
                        }
                        if self.rowsSent != nil {
                            map["RowsSent"] = self.rowsSent!
                        }
                        if self.rt != nil {
                            map["Rt"] = self.rt!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        if self.ts != nil {
                            map["Ts"] = self.ts!
                        }
                        if self.tsEnd != nil {
                            map["TsEnd"] = self.tsEnd!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AvgLockTime"] as? [Double] {
                            self.avgLockTime = value
                        }
                        if let value = dict["AvgRowsExamined"] as? [Double] {
                            self.avgRowsExamined = value
                        }
                        if let value = dict["AvgRowsSent"] as? [Double] {
                            self.avgRowsSent = value
                        }
                        if let value = dict["AvgRt"] as? [Double] {
                            self.avgRt = value
                        }
                        if let value = dict["Count"] as? [Int64] {
                            self.count = value
                        }
                        if let value = dict["Item"] as? [Any?] {
                            var tmp : [DescribeSlowLogStatisticResponseBody.Data.Data.Logs.Histogram.Item] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeSlowLogStatisticResponseBody.Data.Data.Logs.Histogram.Item()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.item = tmp
                        }
                        if let value = dict["LockTime"] as? [Double] {
                            self.lockTime = value
                        }
                        if let value = dict["MaxLockTime"] as? [Double] {
                            self.maxLockTime = value
                        }
                        if let value = dict["MaxRowsExamined"] as? [Int64] {
                            self.maxRowsExamined = value
                        }
                        if let value = dict["MaxRowsSent"] as? [Int64] {
                            self.maxRowsSent = value
                        }
                        if let value = dict["MaxRt"] as? [Double] {
                            self.maxRt = value
                        }
                        if let value = dict["RowsExamined"] as? [Int64] {
                            self.rowsExamined = value
                        }
                        if let value = dict["RowsSent"] as? [Int64] {
                            self.rowsSent = value
                        }
                        if let value = dict["Rt"] as? [Double] {
                            self.rt = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                        if let value = dict["Ts"] as? [Int64] {
                            self.ts = value
                        }
                        if let value = dict["TsEnd"] as? [Int64] {
                            self.tsEnd = value
                        }
                    }
                }
                public class SqlTag : Tea.TeaModel {
                    public var comments: String?

                    public var sqlId: String?

                    public var tags: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.comments != nil {
                            map["Comments"] = self.comments!
                        }
                        if self.sqlId != nil {
                            map["SqlId"] = self.sqlId!
                        }
                        if self.tags != nil {
                            map["Tags"] = self.tags!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Comments"] as? String {
                            self.comments = value
                        }
                        if let value = dict["SqlId"] as? String {
                            self.sqlId = value
                        }
                        if let value = dict["Tags"] as? String {
                            self.tags = value
                        }
                    }
                }
                public class Trend : Tea.TeaModel {
                    public var timestamp: Int64?

                    public var value: Any?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Timestamp"] as? Int64 {
                            self.timestamp = value
                        }
                        if let value = dict["Value"] as? Any {
                            self.value = value
                        }
                    }
                }
                public var accountName: String?

                public var avgCPUTime: Double?

                public var avgCPUTimeSeconds: Double?

                public var avgDocExamined: Double?

                public var avgFrows: Double?

                public var avgIOWrites: Double?

                public var avgKeysExamined: Double?

                public var avgLastRowsCountAffected: Double?

                public var avgLockTime: Double?

                public var avgLockTimeSeconds: Double?

                public var avgLogicalIOReads: Double?

                public var avgPhysicalIOReads: Double?

                public var avgQueryTime: Double?

                public var avgQueryTimeSeconds: Double?

                public var avgReturnNum: Double?

                public var avgRows: Double?

                public var avgRowsCountAffected: Double?

                public var avgRowsExamined: Double?

                public var avgRowsSent: Double?

                public var avgScnt: Double?

                public var CPUTime: Double?

                public var CPUTimeSeconds: Double?

                public var command: String?

                public var count: Int64?

                public var countRate: Double?

                public var DBName: String?

                public var database: String?

                public var dbInstanceName: String?

                public var docExamined: Int64?

                public var docsExamined: Int64?

                public var frows: Int64?

                public var histogram: DescribeSlowLogStatisticResponseBody.Data.Data.Logs.Histogram?

                public var hostAddress: String?

                public var hostInsId: String?

                public var IOWrites: Int64?

                public var insName: String?

                public var insRole: String?

                public var keysExamined: Int64?

                public var lastRowsCountAffected: Int64?

                public var lockTime: Double?

                public var lockTimeSeconds: Double?

                public var logicalIOReads: Int64?

                public var maxCPUTime: Double?

                public var maxCPUTimeSeconds: Double?

                public var maxDocExamined: Int64?

                public var maxFrows: Int64?

                public var maxIOWrites: Int64?

                public var maxKeysExamined: Int64?

                public var maxLastRowsCountAffected: Int64?

                public var maxLockTime: Double?

                public var maxLockTimeSeconds: Double?

                public var maxLogicalIOReads: Int64?

                public var maxPhysicalIOReads: Int64?

                public var maxQueryTime: Double?

                public var maxQueryTimeSeconds: Double?

                public var maxReturnNum: Int64?

                public var maxRows: Int64?

                public var maxRowsCountAffected: Int64?

                public var maxRowsExamined: Int64?

                public var maxRowsSent: Int64?

                public var maxScnt: Int64?

                public var namespace: String?

                public var nodeType: String?

                public var opType: String?

                public var originAlias: String?

                public var physicalIOReads: Int64?

                public var psql: String?

                public var queryId: String?

                public var queryStartTime: String?

                public var queryTime: Int64?

                public var queryTimeRate: Double?

                public var queryTimeSeconds: Double?

                public var returnItemNumbers: String?

                public var returnNum: Int64?

                public var rows: Int64?

                public var rowsCountAffected: Int64?

                public var rowsExamined: Int64?

                public var rowsSent: Int64?

                public var ruleId: String?

                public var SQLText: String?

                public var scheme: String?

                public var scnt: Int64?

                public var sqlId: String?

                public var sqlTag: DescribeSlowLogStatisticResponseBody.Data.Data.Logs.SqlTag?

                public var sqlType: String?

                public var subInstanceId: String?

                public var tableName: String?

                public var threadId: String?

                public var timestamp: Int64?

                public var trend: [DescribeSlowLogStatisticResponseBody.Data.Data.Logs.Trend]?

                public var user: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.histogram?.validate()
                    try self.sqlTag?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accountName != nil {
                        map["AccountName"] = self.accountName!
                    }
                    if self.avgCPUTime != nil {
                        map["AvgCPUTime"] = self.avgCPUTime!
                    }
                    if self.avgCPUTimeSeconds != nil {
                        map["AvgCPUTimeSeconds"] = self.avgCPUTimeSeconds!
                    }
                    if self.avgDocExamined != nil {
                        map["AvgDocExamined"] = self.avgDocExamined!
                    }
                    if self.avgFrows != nil {
                        map["AvgFrows"] = self.avgFrows!
                    }
                    if self.avgIOWrites != nil {
                        map["AvgIOWrites"] = self.avgIOWrites!
                    }
                    if self.avgKeysExamined != nil {
                        map["AvgKeysExamined"] = self.avgKeysExamined!
                    }
                    if self.avgLastRowsCountAffected != nil {
                        map["AvgLastRowsCountAffected"] = self.avgLastRowsCountAffected!
                    }
                    if self.avgLockTime != nil {
                        map["AvgLockTime"] = self.avgLockTime!
                    }
                    if self.avgLockTimeSeconds != nil {
                        map["AvgLockTimeSeconds"] = self.avgLockTimeSeconds!
                    }
                    if self.avgLogicalIOReads != nil {
                        map["AvgLogicalIOReads"] = self.avgLogicalIOReads!
                    }
                    if self.avgPhysicalIOReads != nil {
                        map["AvgPhysicalIOReads"] = self.avgPhysicalIOReads!
                    }
                    if self.avgQueryTime != nil {
                        map["AvgQueryTime"] = self.avgQueryTime!
                    }
                    if self.avgQueryTimeSeconds != nil {
                        map["AvgQueryTimeSeconds"] = self.avgQueryTimeSeconds!
                    }
                    if self.avgReturnNum != nil {
                        map["AvgReturnNum"] = self.avgReturnNum!
                    }
                    if self.avgRows != nil {
                        map["AvgRows"] = self.avgRows!
                    }
                    if self.avgRowsCountAffected != nil {
                        map["AvgRowsCountAffected"] = self.avgRowsCountAffected!
                    }
                    if self.avgRowsExamined != nil {
                        map["AvgRowsExamined"] = self.avgRowsExamined!
                    }
                    if self.avgRowsSent != nil {
                        map["AvgRowsSent"] = self.avgRowsSent!
                    }
                    if self.avgScnt != nil {
                        map["AvgScnt"] = self.avgScnt!
                    }
                    if self.CPUTime != nil {
                        map["CPUTime"] = self.CPUTime!
                    }
                    if self.CPUTimeSeconds != nil {
                        map["CPUTimeSeconds"] = self.CPUTimeSeconds!
                    }
                    if self.command != nil {
                        map["Command"] = self.command!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.countRate != nil {
                        map["CountRate"] = self.countRate!
                    }
                    if self.DBName != nil {
                        map["DBName"] = self.DBName!
                    }
                    if self.database != nil {
                        map["Database"] = self.database!
                    }
                    if self.dbInstanceName != nil {
                        map["DbInstanceName"] = self.dbInstanceName!
                    }
                    if self.docExamined != nil {
                        map["DocExamined"] = self.docExamined!
                    }
                    if self.docsExamined != nil {
                        map["DocsExamined"] = self.docsExamined!
                    }
                    if self.frows != nil {
                        map["Frows"] = self.frows!
                    }
                    if self.histogram != nil {
                        map["Histogram"] = self.histogram?.toMap()
                    }
                    if self.hostAddress != nil {
                        map["HostAddress"] = self.hostAddress!
                    }
                    if self.hostInsId != nil {
                        map["HostInsId"] = self.hostInsId!
                    }
                    if self.IOWrites != nil {
                        map["IOWrites"] = self.IOWrites!
                    }
                    if self.insName != nil {
                        map["InsName"] = self.insName!
                    }
                    if self.insRole != nil {
                        map["InsRole"] = self.insRole!
                    }
                    if self.keysExamined != nil {
                        map["KeysExamined"] = self.keysExamined!
                    }
                    if self.lastRowsCountAffected != nil {
                        map["LastRowsCountAffected"] = self.lastRowsCountAffected!
                    }
                    if self.lockTime != nil {
                        map["LockTime"] = self.lockTime!
                    }
                    if self.lockTimeSeconds != nil {
                        map["LockTimeSeconds"] = self.lockTimeSeconds!
                    }
                    if self.logicalIOReads != nil {
                        map["LogicalIOReads"] = self.logicalIOReads!
                    }
                    if self.maxCPUTime != nil {
                        map["MaxCPUTime"] = self.maxCPUTime!
                    }
                    if self.maxCPUTimeSeconds != nil {
                        map["MaxCPUTimeSeconds"] = self.maxCPUTimeSeconds!
                    }
                    if self.maxDocExamined != nil {
                        map["MaxDocExamined"] = self.maxDocExamined!
                    }
                    if self.maxFrows != nil {
                        map["MaxFrows"] = self.maxFrows!
                    }
                    if self.maxIOWrites != nil {
                        map["MaxIOWrites"] = self.maxIOWrites!
                    }
                    if self.maxKeysExamined != nil {
                        map["MaxKeysExamined"] = self.maxKeysExamined!
                    }
                    if self.maxLastRowsCountAffected != nil {
                        map["MaxLastRowsCountAffected"] = self.maxLastRowsCountAffected!
                    }
                    if self.maxLockTime != nil {
                        map["MaxLockTime"] = self.maxLockTime!
                    }
                    if self.maxLockTimeSeconds != nil {
                        map["MaxLockTimeSeconds"] = self.maxLockTimeSeconds!
                    }
                    if self.maxLogicalIOReads != nil {
                        map["MaxLogicalIOReads"] = self.maxLogicalIOReads!
                    }
                    if self.maxPhysicalIOReads != nil {
                        map["MaxPhysicalIOReads"] = self.maxPhysicalIOReads!
                    }
                    if self.maxQueryTime != nil {
                        map["MaxQueryTime"] = self.maxQueryTime!
                    }
                    if self.maxQueryTimeSeconds != nil {
                        map["MaxQueryTimeSeconds"] = self.maxQueryTimeSeconds!
                    }
                    if self.maxReturnNum != nil {
                        map["MaxReturnNum"] = self.maxReturnNum!
                    }
                    if self.maxRows != nil {
                        map["MaxRows"] = self.maxRows!
                    }
                    if self.maxRowsCountAffected != nil {
                        map["MaxRowsCountAffected"] = self.maxRowsCountAffected!
                    }
                    if self.maxRowsExamined != nil {
                        map["MaxRowsExamined"] = self.maxRowsExamined!
                    }
                    if self.maxRowsSent != nil {
                        map["MaxRowsSent"] = self.maxRowsSent!
                    }
                    if self.maxScnt != nil {
                        map["MaxScnt"] = self.maxScnt!
                    }
                    if self.namespace != nil {
                        map["Namespace"] = self.namespace!
                    }
                    if self.nodeType != nil {
                        map["NodeType"] = self.nodeType!
                    }
                    if self.opType != nil {
                        map["OpType"] = self.opType!
                    }
                    if self.originAlias != nil {
                        map["OriginAlias"] = self.originAlias!
                    }
                    if self.physicalIOReads != nil {
                        map["PhysicalIOReads"] = self.physicalIOReads!
                    }
                    if self.psql != nil {
                        map["Psql"] = self.psql!
                    }
                    if self.queryId != nil {
                        map["QueryId"] = self.queryId!
                    }
                    if self.queryStartTime != nil {
                        map["QueryStartTime"] = self.queryStartTime!
                    }
                    if self.queryTime != nil {
                        map["QueryTime"] = self.queryTime!
                    }
                    if self.queryTimeRate != nil {
                        map["QueryTimeRate"] = self.queryTimeRate!
                    }
                    if self.queryTimeSeconds != nil {
                        map["QueryTimeSeconds"] = self.queryTimeSeconds!
                    }
                    if self.returnItemNumbers != nil {
                        map["ReturnItemNumbers"] = self.returnItemNumbers!
                    }
                    if self.returnNum != nil {
                        map["ReturnNum"] = self.returnNum!
                    }
                    if self.rows != nil {
                        map["Rows"] = self.rows!
                    }
                    if self.rowsCountAffected != nil {
                        map["RowsCountAffected"] = self.rowsCountAffected!
                    }
                    if self.rowsExamined != nil {
                        map["RowsExamined"] = self.rowsExamined!
                    }
                    if self.rowsSent != nil {
                        map["RowsSent"] = self.rowsSent!
                    }
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    if self.SQLText != nil {
                        map["SQLText"] = self.SQLText!
                    }
                    if self.scheme != nil {
                        map["Scheme"] = self.scheme!
                    }
                    if self.scnt != nil {
                        map["Scnt"] = self.scnt!
                    }
                    if self.sqlId != nil {
                        map["SqlId"] = self.sqlId!
                    }
                    if self.sqlTag != nil {
                        map["SqlTag"] = self.sqlTag?.toMap()
                    }
                    if self.sqlType != nil {
                        map["SqlType"] = self.sqlType!
                    }
                    if self.subInstanceId != nil {
                        map["SubInstanceId"] = self.subInstanceId!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    if self.threadId != nil {
                        map["ThreadId"] = self.threadId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.trend != nil {
                        var tmp : [Any] = []
                        for k in self.trend! {
                            tmp.append(k.toMap())
                        }
                        map["Trend"] = tmp
                    }
                    if self.user != nil {
                        map["User"] = self.user!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AccountName"] as? String {
                        self.accountName = value
                    }
                    if let value = dict["AvgCPUTime"] as? Double {
                        self.avgCPUTime = value
                    }
                    if let value = dict["AvgCPUTimeSeconds"] as? Double {
                        self.avgCPUTimeSeconds = value
                    }
                    if let value = dict["AvgDocExamined"] as? Double {
                        self.avgDocExamined = value
                    }
                    if let value = dict["AvgFrows"] as? Double {
                        self.avgFrows = value
                    }
                    if let value = dict["AvgIOWrites"] as? Double {
                        self.avgIOWrites = value
                    }
                    if let value = dict["AvgKeysExamined"] as? Double {
                        self.avgKeysExamined = value
                    }
                    if let value = dict["AvgLastRowsCountAffected"] as? Double {
                        self.avgLastRowsCountAffected = value
                    }
                    if let value = dict["AvgLockTime"] as? Double {
                        self.avgLockTime = value
                    }
                    if let value = dict["AvgLockTimeSeconds"] as? Double {
                        self.avgLockTimeSeconds = value
                    }
                    if let value = dict["AvgLogicalIOReads"] as? Double {
                        self.avgLogicalIOReads = value
                    }
                    if let value = dict["AvgPhysicalIOReads"] as? Double {
                        self.avgPhysicalIOReads = value
                    }
                    if let value = dict["AvgQueryTime"] as? Double {
                        self.avgQueryTime = value
                    }
                    if let value = dict["AvgQueryTimeSeconds"] as? Double {
                        self.avgQueryTimeSeconds = value
                    }
                    if let value = dict["AvgReturnNum"] as? Double {
                        self.avgReturnNum = value
                    }
                    if let value = dict["AvgRows"] as? Double {
                        self.avgRows = value
                    }
                    if let value = dict["AvgRowsCountAffected"] as? Double {
                        self.avgRowsCountAffected = value
                    }
                    if let value = dict["AvgRowsExamined"] as? Double {
                        self.avgRowsExamined = value
                    }
                    if let value = dict["AvgRowsSent"] as? Double {
                        self.avgRowsSent = value
                    }
                    if let value = dict["AvgScnt"] as? Double {
                        self.avgScnt = value
                    }
                    if let value = dict["CPUTime"] as? Double {
                        self.CPUTime = value
                    }
                    if let value = dict["CPUTimeSeconds"] as? Double {
                        self.CPUTimeSeconds = value
                    }
                    if let value = dict["Command"] as? String {
                        self.command = value
                    }
                    if let value = dict["Count"] as? Int64 {
                        self.count = value
                    }
                    if let value = dict["CountRate"] as? Double {
                        self.countRate = value
                    }
                    if let value = dict["DBName"] as? String {
                        self.DBName = value
                    }
                    if let value = dict["Database"] as? String {
                        self.database = value
                    }
                    if let value = dict["DbInstanceName"] as? String {
                        self.dbInstanceName = value
                    }
                    if let value = dict["DocExamined"] as? Int64 {
                        self.docExamined = value
                    }
                    if let value = dict["DocsExamined"] as? Int64 {
                        self.docsExamined = value
                    }
                    if let value = dict["Frows"] as? Int64 {
                        self.frows = value
                    }
                    if let value = dict["Histogram"] as? [String: Any?] {
                        var model = DescribeSlowLogStatisticResponseBody.Data.Data.Logs.Histogram()
                        model.fromMap(value)
                        self.histogram = model
                    }
                    if let value = dict["HostAddress"] as? String {
                        self.hostAddress = value
                    }
                    if let value = dict["HostInsId"] as? String {
                        self.hostInsId = value
                    }
                    if let value = dict["IOWrites"] as? Int64 {
                        self.IOWrites = value
                    }
                    if let value = dict["InsName"] as? String {
                        self.insName = value
                    }
                    if let value = dict["InsRole"] as? String {
                        self.insRole = value
                    }
                    if let value = dict["KeysExamined"] as? Int64 {
                        self.keysExamined = value
                    }
                    if let value = dict["LastRowsCountAffected"] as? Int64 {
                        self.lastRowsCountAffected = value
                    }
                    if let value = dict["LockTime"] as? Double {
                        self.lockTime = value
                    }
                    if let value = dict["LockTimeSeconds"] as? Double {
                        self.lockTimeSeconds = value
                    }
                    if let value = dict["LogicalIOReads"] as? Int64 {
                        self.logicalIOReads = value
                    }
                    if let value = dict["MaxCPUTime"] as? Double {
                        self.maxCPUTime = value
                    }
                    if let value = dict["MaxCPUTimeSeconds"] as? Double {
                        self.maxCPUTimeSeconds = value
                    }
                    if let value = dict["MaxDocExamined"] as? Int64 {
                        self.maxDocExamined = value
                    }
                    if let value = dict["MaxFrows"] as? Int64 {
                        self.maxFrows = value
                    }
                    if let value = dict["MaxIOWrites"] as? Int64 {
                        self.maxIOWrites = value
                    }
                    if let value = dict["MaxKeysExamined"] as? Int64 {
                        self.maxKeysExamined = value
                    }
                    if let value = dict["MaxLastRowsCountAffected"] as? Int64 {
                        self.maxLastRowsCountAffected = value
                    }
                    if let value = dict["MaxLockTime"] as? Double {
                        self.maxLockTime = value
                    }
                    if let value = dict["MaxLockTimeSeconds"] as? Double {
                        self.maxLockTimeSeconds = value
                    }
                    if let value = dict["MaxLogicalIOReads"] as? Int64 {
                        self.maxLogicalIOReads = value
                    }
                    if let value = dict["MaxPhysicalIOReads"] as? Int64 {
                        self.maxPhysicalIOReads = value
                    }
                    if let value = dict["MaxQueryTime"] as? Double {
                        self.maxQueryTime = value
                    }
                    if let value = dict["MaxQueryTimeSeconds"] as? Double {
                        self.maxQueryTimeSeconds = value
                    }
                    if let value = dict["MaxReturnNum"] as? Int64 {
                        self.maxReturnNum = value
                    }
                    if let value = dict["MaxRows"] as? Int64 {
                        self.maxRows = value
                    }
                    if let value = dict["MaxRowsCountAffected"] as? Int64 {
                        self.maxRowsCountAffected = value
                    }
                    if let value = dict["MaxRowsExamined"] as? Int64 {
                        self.maxRowsExamined = value
                    }
                    if let value = dict["MaxRowsSent"] as? Int64 {
                        self.maxRowsSent = value
                    }
                    if let value = dict["MaxScnt"] as? Int64 {
                        self.maxScnt = value
                    }
                    if let value = dict["Namespace"] as? String {
                        self.namespace = value
                    }
                    if let value = dict["NodeType"] as? String {
                        self.nodeType = value
                    }
                    if let value = dict["OpType"] as? String {
                        self.opType = value
                    }
                    if let value = dict["OriginAlias"] as? String {
                        self.originAlias = value
                    }
                    if let value = dict["PhysicalIOReads"] as? Int64 {
                        self.physicalIOReads = value
                    }
                    if let value = dict["Psql"] as? String {
                        self.psql = value
                    }
                    if let value = dict["QueryId"] as? String {
                        self.queryId = value
                    }
                    if let value = dict["QueryStartTime"] as? String {
                        self.queryStartTime = value
                    }
                    if let value = dict["QueryTime"] as? Int64 {
                        self.queryTime = value
                    }
                    if let value = dict["QueryTimeRate"] as? Double {
                        self.queryTimeRate = value
                    }
                    if let value = dict["QueryTimeSeconds"] as? Double {
                        self.queryTimeSeconds = value
                    }
                    if let value = dict["ReturnItemNumbers"] as? String {
                        self.returnItemNumbers = value
                    }
                    if let value = dict["ReturnNum"] as? Int64 {
                        self.returnNum = value
                    }
                    if let value = dict["Rows"] as? Int64 {
                        self.rows = value
                    }
                    if let value = dict["RowsCountAffected"] as? Int64 {
                        self.rowsCountAffected = value
                    }
                    if let value = dict["RowsExamined"] as? Int64 {
                        self.rowsExamined = value
                    }
                    if let value = dict["RowsSent"] as? Int64 {
                        self.rowsSent = value
                    }
                    if let value = dict["RuleId"] as? String {
                        self.ruleId = value
                    }
                    if let value = dict["SQLText"] as? String {
                        self.SQLText = value
                    }
                    if let value = dict["Scheme"] as? String {
                        self.scheme = value
                    }
                    if let value = dict["Scnt"] as? Int64 {
                        self.scnt = value
                    }
                    if let value = dict["SqlId"] as? String {
                        self.sqlId = value
                    }
                    if let value = dict["SqlTag"] as? [String: Any?] {
                        var model = DescribeSlowLogStatisticResponseBody.Data.Data.Logs.SqlTag()
                        model.fromMap(value)
                        self.sqlTag = model
                    }
                    if let value = dict["SqlType"] as? String {
                        self.sqlType = value
                    }
                    if let value = dict["SubInstanceId"] as? String {
                        self.subInstanceId = value
                    }
                    if let value = dict["TableName"] as? String {
                        self.tableName = value
                    }
                    if let value = dict["ThreadId"] as? String {
                        self.threadId = value
                    }
                    if let value = dict["Timestamp"] as? Int64 {
                        self.timestamp = value
                    }
                    if let value = dict["Trend"] as? [Any?] {
                        var tmp : [DescribeSlowLogStatisticResponseBody.Data.Data.Logs.Trend] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeSlowLogStatisticResponseBody.Data.Data.Logs.Trend()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.trend = tmp
                    }
                    if let value = dict["User"] as? String {
                        self.user = value
                    }
                }
            }
            public var dbInstanceId: Int64?

            public var dbInstanceName: String?

            public var endTime: String?

            public var itemsNumbers: Int64?

            public var logs: [DescribeSlowLogStatisticResponseBody.Data.Data.Logs]?

            public var maxRecordsPerPage: Int32?

            public var nodeId: String?

            public var pageNumbers: Int32?

            public var startTime: String?

            public var totalRecords: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbInstanceId != nil {
                    map["DbInstanceId"] = self.dbInstanceId!
                }
                if self.dbInstanceName != nil {
                    map["DbInstanceName"] = self.dbInstanceName!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.itemsNumbers != nil {
                    map["ItemsNumbers"] = self.itemsNumbers!
                }
                if self.logs != nil {
                    var tmp : [Any] = []
                    for k in self.logs! {
                        tmp.append(k.toMap())
                    }
                    map["Logs"] = tmp
                }
                if self.maxRecordsPerPage != nil {
                    map["MaxRecordsPerPage"] = self.maxRecordsPerPage!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.pageNumbers != nil {
                    map["PageNumbers"] = self.pageNumbers!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.totalRecords != nil {
                    map["TotalRecords"] = self.totalRecords!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DbInstanceId"] as? Int64 {
                    self.dbInstanceId = value
                }
                if let value = dict["DbInstanceName"] as? String {
                    self.dbInstanceName = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["ItemsNumbers"] as? Int64 {
                    self.itemsNumbers = value
                }
                if let value = dict["Logs"] as? [Any?] {
                    var tmp : [DescribeSlowLogStatisticResponseBody.Data.Data.Logs] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeSlowLogStatisticResponseBody.Data.Data.Logs()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.logs = tmp
                }
                if let value = dict["MaxRecordsPerPage"] as? Int32 {
                    self.maxRecordsPerPage = value
                }
                if let value = dict["NodeId"] as? String {
                    self.nodeId = value
                }
                if let value = dict["PageNumbers"] as? Int32 {
                    self.pageNumbers = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["TotalRecords"] as? Int64 {
                    self.totalRecords = value
                }
            }
        }
        public var data: DescribeSlowLogStatisticResponseBody.Data.Data?

        public var errorCode: Int32?

        public var isFinish: Bool?

        public var message: String?

        public var requestKey: String?

        public var resultId: String?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.isFinish != nil {
                map["IsFinish"] = self.isFinish!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.requestKey != nil {
                map["RequestKey"] = self.requestKey!
            }
            if self.resultId != nil {
                map["ResultId"] = self.resultId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Data"] as? [String: Any?] {
                var model = DescribeSlowLogStatisticResponseBody.Data.Data()
                model.fromMap(value)
                self.data = model
            }
            if let value = dict["ErrorCode"] as? Int32 {
                self.errorCode = value
            }
            if let value = dict["IsFinish"] as? Bool {
                self.isFinish = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["RequestKey"] as? String {
                self.requestKey = value
            }
            if let value = dict["ResultId"] as? String {
                self.resultId = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
        }
    }
    public var code: String?

    public var data: DescribeSlowLogStatisticResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeSlowLogStatisticResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeSlowLogStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSlowLogStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSlowLogStatisticResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSqlLogConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DescribeSqlLogConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var coldEnable: Bool?

        public var coldRetention: Int32?

        public var coldStartTime: Int64?

        public var collectorVersion: String?

        public var hotEnable: Bool?

        public var hotRetention: Int32?

        public var hotStartTime: Int64?

        public var logFilter: String?

        public var requestEnable: Bool?

        public var requestStartTime: Int64?

        public var requestStopTime: Int64?

        public var retention: Int32?

        public var sqlLogEnable: Bool?

        public var sqlLogSource: String?

        public var sqlLogState: String?

        public var sqlLogVisibleTime: Int64?

        public var supportMigration: Bool?

        public var supportVersion: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coldEnable != nil {
                map["ColdEnable"] = self.coldEnable!
            }
            if self.coldRetention != nil {
                map["ColdRetention"] = self.coldRetention!
            }
            if self.coldStartTime != nil {
                map["ColdStartTime"] = self.coldStartTime!
            }
            if self.collectorVersion != nil {
                map["CollectorVersion"] = self.collectorVersion!
            }
            if self.hotEnable != nil {
                map["HotEnable"] = self.hotEnable!
            }
            if self.hotRetention != nil {
                map["HotRetention"] = self.hotRetention!
            }
            if self.hotStartTime != nil {
                map["HotStartTime"] = self.hotStartTime!
            }
            if self.logFilter != nil {
                map["LogFilter"] = self.logFilter!
            }
            if self.requestEnable != nil {
                map["RequestEnable"] = self.requestEnable!
            }
            if self.requestStartTime != nil {
                map["RequestStartTime"] = self.requestStartTime!
            }
            if self.requestStopTime != nil {
                map["RequestStopTime"] = self.requestStopTime!
            }
            if self.retention != nil {
                map["Retention"] = self.retention!
            }
            if self.sqlLogEnable != nil {
                map["SqlLogEnable"] = self.sqlLogEnable!
            }
            if self.sqlLogSource != nil {
                map["SqlLogSource"] = self.sqlLogSource!
            }
            if self.sqlLogState != nil {
                map["SqlLogState"] = self.sqlLogState!
            }
            if self.sqlLogVisibleTime != nil {
                map["SqlLogVisibleTime"] = self.sqlLogVisibleTime!
            }
            if self.supportMigration != nil {
                map["SupportMigration"] = self.supportMigration!
            }
            if self.supportVersion != nil {
                map["SupportVersion"] = self.supportVersion!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ColdEnable"] as? Bool {
                self.coldEnable = value
            }
            if let value = dict["ColdRetention"] as? Int32 {
                self.coldRetention = value
            }
            if let value = dict["ColdStartTime"] as? Int64 {
                self.coldStartTime = value
            }
            if let value = dict["CollectorVersion"] as? String {
                self.collectorVersion = value
            }
            if let value = dict["HotEnable"] as? Bool {
                self.hotEnable = value
            }
            if let value = dict["HotRetention"] as? Int32 {
                self.hotRetention = value
            }
            if let value = dict["HotStartTime"] as? Int64 {
                self.hotStartTime = value
            }
            if let value = dict["LogFilter"] as? String {
                self.logFilter = value
            }
            if let value = dict["RequestEnable"] as? Bool {
                self.requestEnable = value
            }
            if let value = dict["RequestStartTime"] as? Int64 {
                self.requestStartTime = value
            }
            if let value = dict["RequestStopTime"] as? Int64 {
                self.requestStopTime = value
            }
            if let value = dict["Retention"] as? Int32 {
                self.retention = value
            }
            if let value = dict["SqlLogEnable"] as? Bool {
                self.sqlLogEnable = value
            }
            if let value = dict["SqlLogSource"] as? String {
                self.sqlLogSource = value
            }
            if let value = dict["SqlLogState"] as? String {
                self.sqlLogState = value
            }
            if let value = dict["SqlLogVisibleTime"] as? Int64 {
                self.sqlLogVisibleTime = value
            }
            if let value = dict["SupportMigration"] as? Bool {
                self.supportMigration = value
            }
            if let value = dict["SupportVersion"] as? String {
                self.supportVersion = value
            }
            if let value = dict["Version"] as? String {
                self.version = value
            }
        }
    }
    public var code: String?

    public var data: DescribeSqlLogConfigResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeSqlLogConfigResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeSqlLogConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSqlLogConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSqlLogConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSqlLogRecordsRequest : Tea.TeaModel {
    public class Filters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var endTime: Int64?

    public var filters: [DescribeSqlLogRecordsRequest.Filters]?

    public var instanceId: String?

    public var nodeId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var role: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filters != nil {
            var tmp : [Any] = []
            for k in self.filters! {
                tmp.append(k.toMap())
            }
            map["Filters"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["Filters"] as? [Any?] {
            var tmp : [DescribeSqlLogRecordsRequest.Filters] = []
            for v in value {
                if v != nil {
                    var model = DescribeSqlLogRecordsRequest.Filters()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filters = tmp
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Role"] as? String {
            self.role = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class DescribeSqlLogRecordsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Items : Tea.TeaModel {
            public class SQLLogRecord : Tea.TeaModel {
                public var accountName: String?

                public var collection: String?

                public var consume: Int64?

                public var cpuTime: Int64?

                public var DBName: String?

                public var executeTime: String?

                public var ext: String?

                public var frows: Int64?

                public var hostAddress: String?

                public var lockTime: Int64?

                public var logicRead: Int64?

                public var nodeId: String?

                public var originTime: Int64?

                public var parallelDegree: String?

                public var parallelQueueTime: String?

                public var physicAsyncRead: Int64?

                public var physicRead: Int64?

                public var physicSyncRead: Int64?

                public var returnRows: Int64?

                public var rows: Int64?

                public var scanRows: Int64?

                public var scnt: Int64?

                public var sqlId: String?

                public var sqlText: String?

                public var sqlType: String?

                public var state: String?

                public var threadId: Int64?

                public var traceId: String?

                public var trxId: String?

                public var updateRows: Int64?

                public var useImciEngine: String?

                public var vip: String?

                public var writes: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accountName != nil {
                        map["AccountName"] = self.accountName!
                    }
                    if self.collection != nil {
                        map["Collection"] = self.collection!
                    }
                    if self.consume != nil {
                        map["Consume"] = self.consume!
                    }
                    if self.cpuTime != nil {
                        map["CpuTime"] = self.cpuTime!
                    }
                    if self.DBName != nil {
                        map["DBName"] = self.DBName!
                    }
                    if self.executeTime != nil {
                        map["ExecuteTime"] = self.executeTime!
                    }
                    if self.ext != nil {
                        map["Ext"] = self.ext!
                    }
                    if self.frows != nil {
                        map["Frows"] = self.frows!
                    }
                    if self.hostAddress != nil {
                        map["HostAddress"] = self.hostAddress!
                    }
                    if self.lockTime != nil {
                        map["LockTime"] = self.lockTime!
                    }
                    if self.logicRead != nil {
                        map["LogicRead"] = self.logicRead!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.originTime != nil {
                        map["OriginTime"] = self.originTime!
                    }
                    if self.parallelDegree != nil {
                        map["ParallelDegree"] = self.parallelDegree!
                    }
                    if self.parallelQueueTime != nil {
                        map["ParallelQueueTime"] = self.parallelQueueTime!
                    }
                    if self.physicAsyncRead != nil {
                        map["PhysicAsyncRead"] = self.physicAsyncRead!
                    }
                    if self.physicRead != nil {
                        map["PhysicRead"] = self.physicRead!
                    }
                    if self.physicSyncRead != nil {
                        map["PhysicSyncRead"] = self.physicSyncRead!
                    }
                    if self.returnRows != nil {
                        map["ReturnRows"] = self.returnRows!
                    }
                    if self.rows != nil {
                        map["Rows"] = self.rows!
                    }
                    if self.scanRows != nil {
                        map["ScanRows"] = self.scanRows!
                    }
                    if self.scnt != nil {
                        map["Scnt"] = self.scnt!
                    }
                    if self.sqlId != nil {
                        map["SqlId"] = self.sqlId!
                    }
                    if self.sqlText != nil {
                        map["SqlText"] = self.sqlText!
                    }
                    if self.sqlType != nil {
                        map["SqlType"] = self.sqlType!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    if self.threadId != nil {
                        map["ThreadId"] = self.threadId!
                    }
                    if self.traceId != nil {
                        map["TraceId"] = self.traceId!
                    }
                    if self.trxId != nil {
                        map["TrxId"] = self.trxId!
                    }
                    if self.updateRows != nil {
                        map["UpdateRows"] = self.updateRows!
                    }
                    if self.useImciEngine != nil {
                        map["UseImciEngine"] = self.useImciEngine!
                    }
                    if self.vip != nil {
                        map["Vip"] = self.vip!
                    }
                    if self.writes != nil {
                        map["Writes"] = self.writes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AccountName"] as? String {
                        self.accountName = value
                    }
                    if let value = dict["Collection"] as? String {
                        self.collection = value
                    }
                    if let value = dict["Consume"] as? Int64 {
                        self.consume = value
                    }
                    if let value = dict["CpuTime"] as? Int64 {
                        self.cpuTime = value
                    }
                    if let value = dict["DBName"] as? String {
                        self.DBName = value
                    }
                    if let value = dict["ExecuteTime"] as? String {
                        self.executeTime = value
                    }
                    if let value = dict["Ext"] as? String {
                        self.ext = value
                    }
                    if let value = dict["Frows"] as? Int64 {
                        self.frows = value
                    }
                    if let value = dict["HostAddress"] as? String {
                        self.hostAddress = value
                    }
                    if let value = dict["LockTime"] as? Int64 {
                        self.lockTime = value
                    }
                    if let value = dict["LogicRead"] as? Int64 {
                        self.logicRead = value
                    }
                    if let value = dict["NodeId"] as? String {
                        self.nodeId = value
                    }
                    if let value = dict["OriginTime"] as? Int64 {
                        self.originTime = value
                    }
                    if let value = dict["ParallelDegree"] as? String {
                        self.parallelDegree = value
                    }
                    if let value = dict["ParallelQueueTime"] as? String {
                        self.parallelQueueTime = value
                    }
                    if let value = dict["PhysicAsyncRead"] as? Int64 {
                        self.physicAsyncRead = value
                    }
                    if let value = dict["PhysicRead"] as? Int64 {
                        self.physicRead = value
                    }
                    if let value = dict["PhysicSyncRead"] as? Int64 {
                        self.physicSyncRead = value
                    }
                    if let value = dict["ReturnRows"] as? Int64 {
                        self.returnRows = value
                    }
                    if let value = dict["Rows"] as? Int64 {
                        self.rows = value
                    }
                    if let value = dict["ScanRows"] as? Int64 {
                        self.scanRows = value
                    }
                    if let value = dict["Scnt"] as? Int64 {
                        self.scnt = value
                    }
                    if let value = dict["SqlId"] as? String {
                        self.sqlId = value
                    }
                    if let value = dict["SqlText"] as? String {
                        self.sqlText = value
                    }
                    if let value = dict["SqlType"] as? String {
                        self.sqlType = value
                    }
                    if let value = dict["State"] as? String {
                        self.state = value
                    }
                    if let value = dict["ThreadId"] as? Int64 {
                        self.threadId = value
                    }
                    if let value = dict["TraceId"] as? String {
                        self.traceId = value
                    }
                    if let value = dict["TrxId"] as? String {
                        self.trxId = value
                    }
                    if let value = dict["UpdateRows"] as? Int64 {
                        self.updateRows = value
                    }
                    if let value = dict["UseImciEngine"] as? String {
                        self.useImciEngine = value
                    }
                    if let value = dict["Vip"] as? String {
                        self.vip = value
                    }
                    if let value = dict["Writes"] as? Int64 {
                        self.writes = value
                    }
                }
            }
            public var SQLLogRecord: [DescribeSqlLogRecordsResponseBody.Data.Items.SQLLogRecord]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.SQLLogRecord != nil {
                    var tmp : [Any] = []
                    for k in self.SQLLogRecord! {
                        tmp.append(k.toMap())
                    }
                    map["SQLLogRecord"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["SQLLogRecord"] as? [Any?] {
                    var tmp : [DescribeSqlLogRecordsResponseBody.Data.Items.SQLLogRecord] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeSqlLogRecordsResponseBody.Data.Items.SQLLogRecord()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.SQLLogRecord = tmp
                }
            }
        }
        public var endTime: Int64?

        public var finish: String?

        public var items: DescribeSqlLogRecordsResponseBody.Data.Items?

        public var jobId: String?

        public var startTime: Int64?

        public var totalRecords: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.items?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.finish != nil {
                map["Finish"] = self.finish!
            }
            if self.items != nil {
                map["Items"] = self.items?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.totalRecords != nil {
                map["TotalRecords"] = self.totalRecords!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EndTime"] as? Int64 {
                self.endTime = value
            }
            if let value = dict["Finish"] as? String {
                self.finish = value
            }
            if let value = dict["Items"] as? [String: Any?] {
                var model = DescribeSqlLogRecordsResponseBody.Data.Items()
                model.fromMap(value)
                self.items = model
            }
            if let value = dict["JobId"] as? String {
                self.jobId = value
            }
            if let value = dict["StartTime"] as? Int64 {
                self.startTime = value
            }
            if let value = dict["TotalRecords"] as? Int64 {
                self.totalRecords = value
            }
        }
    }
    public var code: String?

    public var data: DescribeSqlLogRecordsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeSqlLogRecordsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeSqlLogRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSqlLogRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSqlLogRecordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSqlLogStatisticRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DescribeSqlLogStatisticResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var coldSqlSize: Int64?

        public var freeColdSqlSize: Int64?

        public var freeHotSqlSize: Int64?

        public var hotSqlSize: Int64?

        public var importSqlSize: Int64?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coldSqlSize != nil {
                map["ColdSqlSize"] = self.coldSqlSize!
            }
            if self.freeColdSqlSize != nil {
                map["FreeColdSqlSize"] = self.freeColdSqlSize!
            }
            if self.freeHotSqlSize != nil {
                map["FreeHotSqlSize"] = self.freeHotSqlSize!
            }
            if self.hotSqlSize != nil {
                map["HotSqlSize"] = self.hotSqlSize!
            }
            if self.importSqlSize != nil {
                map["ImportSqlSize"] = self.importSqlSize!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ColdSqlSize"] as? Int64 {
                self.coldSqlSize = value
            }
            if let value = dict["FreeColdSqlSize"] as? Int64 {
                self.freeColdSqlSize = value
            }
            if let value = dict["FreeHotSqlSize"] as? Int64 {
                self.freeHotSqlSize = value
            }
            if let value = dict["HotSqlSize"] as? Int64 {
                self.hotSqlSize = value
            }
            if let value = dict["ImportSqlSize"] as? Int64 {
                self.importSqlSize = value
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
        }
    }
    public var code: String?

    public var data: DescribeSqlLogStatisticResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeSqlLogStatisticResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeSqlLogStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSqlLogStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSqlLogStatisticResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSqlLogTaskRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class DescribeSqlLogTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Filters : Tea.TeaModel {
            public var key: String?

            public var value: Any?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? Any {
                    self.value = value
                }
            }
        }
        public class Queries : Tea.TeaModel {
            public var accountName: String?

            public var collection: String?

            public var consume: Int64?

            public var cpuTime: Int64?

            public var DBName: String?

            public var executeTime: String?

            public var ext: String?

            public var frows: Int64?

            public var hostAddress: String?

            public var lockTime: Int64?

            public var logicRead: Int64?

            public var nodeId: String?

            public var originTime: Int64?

            public var parallelDegree: String?

            public var parallelQueueTime: String?

            public var physicAsyncRead: Int64?

            public var physicRead: Int64?

            public var physicSyncRead: Int64?

            public var returnRows: Int64?

            public var rows: Int64?

            public var scanRows: Int64?

            public var scnt: Int64?

            public var sqlCommand: Int64?

            public var sqlId: String?

            public var sqlText: String?

            public var sqlType: String?

            public var state: String?

            public var threadId: Int64?

            public var traceId: String?

            public var trxId: String?

            public var updateRows: Int64?

            public var useImciEngine: String?

            public var vip: String?

            public var writes: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountName != nil {
                    map["AccountName"] = self.accountName!
                }
                if self.collection != nil {
                    map["Collection"] = self.collection!
                }
                if self.consume != nil {
                    map["Consume"] = self.consume!
                }
                if self.cpuTime != nil {
                    map["CpuTime"] = self.cpuTime!
                }
                if self.DBName != nil {
                    map["DBName"] = self.DBName!
                }
                if self.executeTime != nil {
                    map["ExecuteTime"] = self.executeTime!
                }
                if self.ext != nil {
                    map["Ext"] = self.ext!
                }
                if self.frows != nil {
                    map["Frows"] = self.frows!
                }
                if self.hostAddress != nil {
                    map["HostAddress"] = self.hostAddress!
                }
                if self.lockTime != nil {
                    map["LockTime"] = self.lockTime!
                }
                if self.logicRead != nil {
                    map["LogicRead"] = self.logicRead!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.originTime != nil {
                    map["OriginTime"] = self.originTime!
                }
                if self.parallelDegree != nil {
                    map["ParallelDegree"] = self.parallelDegree!
                }
                if self.parallelQueueTime != nil {
                    map["ParallelQueueTime"] = self.parallelQueueTime!
                }
                if self.physicAsyncRead != nil {
                    map["PhysicAsyncRead"] = self.physicAsyncRead!
                }
                if self.physicRead != nil {
                    map["PhysicRead"] = self.physicRead!
                }
                if self.physicSyncRead != nil {
                    map["PhysicSyncRead"] = self.physicSyncRead!
                }
                if self.returnRows != nil {
                    map["ReturnRows"] = self.returnRows!
                }
                if self.rows != nil {
                    map["Rows"] = self.rows!
                }
                if self.scanRows != nil {
                    map["ScanRows"] = self.scanRows!
                }
                if self.scnt != nil {
                    map["Scnt"] = self.scnt!
                }
                if self.sqlCommand != nil {
                    map["SqlCommand"] = self.sqlCommand!
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.sqlText != nil {
                    map["SqlText"] = self.sqlText!
                }
                if self.sqlType != nil {
                    map["SqlType"] = self.sqlType!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.threadId != nil {
                    map["ThreadId"] = self.threadId!
                }
                if self.traceId != nil {
                    map["TraceId"] = self.traceId!
                }
                if self.trxId != nil {
                    map["TrxId"] = self.trxId!
                }
                if self.updateRows != nil {
                    map["UpdateRows"] = self.updateRows!
                }
                if self.useImciEngine != nil {
                    map["UseImciEngine"] = self.useImciEngine!
                }
                if self.vip != nil {
                    map["Vip"] = self.vip!
                }
                if self.writes != nil {
                    map["Writes"] = self.writes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountName"] as? String {
                    self.accountName = value
                }
                if let value = dict["Collection"] as? String {
                    self.collection = value
                }
                if let value = dict["Consume"] as? Int64 {
                    self.consume = value
                }
                if let value = dict["CpuTime"] as? Int64 {
                    self.cpuTime = value
                }
                if let value = dict["DBName"] as? String {
                    self.DBName = value
                }
                if let value = dict["ExecuteTime"] as? String {
                    self.executeTime = value
                }
                if let value = dict["Ext"] as? String {
                    self.ext = value
                }
                if let value = dict["Frows"] as? Int64 {
                    self.frows = value
                }
                if let value = dict["HostAddress"] as? String {
                    self.hostAddress = value
                }
                if let value = dict["LockTime"] as? Int64 {
                    self.lockTime = value
                }
                if let value = dict["LogicRead"] as? Int64 {
                    self.logicRead = value
                }
                if let value = dict["NodeId"] as? String {
                    self.nodeId = value
                }
                if let value = dict["OriginTime"] as? Int64 {
                    self.originTime = value
                }
                if let value = dict["ParallelDegree"] as? String {
                    self.parallelDegree = value
                }
                if let value = dict["ParallelQueueTime"] as? String {
                    self.parallelQueueTime = value
                }
                if let value = dict["PhysicAsyncRead"] as? Int64 {
                    self.physicAsyncRead = value
                }
                if let value = dict["PhysicRead"] as? Int64 {
                    self.physicRead = value
                }
                if let value = dict["PhysicSyncRead"] as? Int64 {
                    self.physicSyncRead = value
                }
                if let value = dict["ReturnRows"] as? Int64 {
                    self.returnRows = value
                }
                if let value = dict["Rows"] as? Int64 {
                    self.rows = value
                }
                if let value = dict["ScanRows"] as? Int64 {
                    self.scanRows = value
                }
                if let value = dict["Scnt"] as? Int64 {
                    self.scnt = value
                }
                if let value = dict["SqlCommand"] as? Int64 {
                    self.sqlCommand = value
                }
                if let value = dict["SqlId"] as? String {
                    self.sqlId = value
                }
                if let value = dict["SqlText"] as? String {
                    self.sqlText = value
                }
                if let value = dict["SqlType"] as? String {
                    self.sqlType = value
                }
                if let value = dict["State"] as? String {
                    self.state = value
                }
                if let value = dict["ThreadId"] as? Int64 {
                    self.threadId = value
                }
                if let value = dict["TraceId"] as? String {
                    self.traceId = value
                }
                if let value = dict["TrxId"] as? String {
                    self.trxId = value
                }
                if let value = dict["UpdateRows"] as? Int64 {
                    self.updateRows = value
                }
                if let value = dict["UseImciEngine"] as? String {
                    self.useImciEngine = value
                }
                if let value = dict["Vip"] as? String {
                    self.vip = value
                }
                if let value = dict["Writes"] as? Int64 {
                    self.writes = value
                }
            }
        }
        public var createTime: Int64?

        public var end: Int64?

        public var expire: Bool?

        public var export: String?

        public var filters: [DescribeSqlLogTaskResponseBody.Data.Filters]?

        public var name: String?

        public var queries: [DescribeSqlLogTaskResponseBody.Data.Queries]?

        public var start: Int64?

        public var status: String?

        public var taskId: String?

        public var taskType: String?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.expire != nil {
                map["Expire"] = self.expire!
            }
            if self.export != nil {
                map["Export"] = self.export!
            }
            if self.filters != nil {
                var tmp : [Any] = []
                for k in self.filters! {
                    tmp.append(k.toMap())
                }
                map["Filters"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.queries != nil {
                var tmp : [Any] = []
                for k in self.queries! {
                    tmp.append(k.toMap())
                }
                map["Queries"] = tmp
            }
            if self.start != nil {
                map["Start"] = self.start!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["End"] as? Int64 {
                self.end = value
            }
            if let value = dict["Expire"] as? Bool {
                self.expire = value
            }
            if let value = dict["Export"] as? String {
                self.export = value
            }
            if let value = dict["Filters"] as? [Any?] {
                var tmp : [DescribeSqlLogTaskResponseBody.Data.Filters] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSqlLogTaskResponseBody.Data.Filters()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.filters = tmp
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Queries"] as? [Any?] {
                var tmp : [DescribeSqlLogTaskResponseBody.Data.Queries] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSqlLogTaskResponseBody.Data.Queries()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.queries = tmp
            }
            if let value = dict["Start"] as? Int64 {
                self.start = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
            if let value = dict["TaskType"] as? String {
                self.taskType = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: DescribeSqlLogTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeSqlLogTaskResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeSqlLogTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSqlLogTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSqlLogTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSqlLogTasksRequest : Tea.TeaModel {
    public class Filters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var endTime: Int64?

    public var filters: [DescribeSqlLogTasksRequest.Filters]?

    public var instanceId: String?

    public var nodeId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filters != nil {
            var tmp : [Any] = []
            for k in self.filters! {
                tmp.append(k.toMap())
            }
            map["Filters"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["Filters"] as? [Any?] {
            var tmp : [DescribeSqlLogTasksRequest.Filters] = []
            for v in value {
                if v != nil {
                    var model = DescribeSqlLogTasksRequest.Filters()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filters = tmp
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class DescribeSqlLogTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class Filters : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var analysisTaskFinishTime: Int64?

            public var analysisTaskStatus: String?

            public var createTime: Int64?

            public var end: Int64?

            public var expire: Bool?

            public var filters: [DescribeSqlLogTasksResponseBody.Data.List.Filters]?

            public var instanceId: String?

            public var logCount: Int64?

            public var name: String?

            public var progress: Int32?

            public var result: String?

            public var scanFileSize: Int64?

            public var start: Int64?

            public var status: String?

            public var taskId: String?

            public var taskType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.analysisTaskFinishTime != nil {
                    map["AnalysisTaskFinishTime"] = self.analysisTaskFinishTime!
                }
                if self.analysisTaskStatus != nil {
                    map["AnalysisTaskStatus"] = self.analysisTaskStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.end != nil {
                    map["End"] = self.end!
                }
                if self.expire != nil {
                    map["Expire"] = self.expire!
                }
                if self.filters != nil {
                    var tmp : [Any] = []
                    for k in self.filters! {
                        tmp.append(k.toMap())
                    }
                    map["Filters"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.logCount != nil {
                    map["LogCount"] = self.logCount!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.result != nil {
                    map["Result"] = self.result!
                }
                if self.scanFileSize != nil {
                    map["ScanFileSize"] = self.scanFileSize!
                }
                if self.start != nil {
                    map["Start"] = self.start!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AnalysisTaskFinishTime"] as? Int64 {
                    self.analysisTaskFinishTime = value
                }
                if let value = dict["AnalysisTaskStatus"] as? String {
                    self.analysisTaskStatus = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["End"] as? Int64 {
                    self.end = value
                }
                if let value = dict["Expire"] as? Bool {
                    self.expire = value
                }
                if let value = dict["Filters"] as? [Any?] {
                    var tmp : [DescribeSqlLogTasksResponseBody.Data.List.Filters] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeSqlLogTasksResponseBody.Data.List.Filters()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.filters = tmp
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["LogCount"] as? Int64 {
                    self.logCount = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Progress"] as? Int32 {
                    self.progress = value
                }
                if let value = dict["Result"] as? String {
                    self.result = value
                }
                if let value = dict["ScanFileSize"] as? Int64 {
                    self.scanFileSize = value
                }
                if let value = dict["Start"] as? Int64 {
                    self.start = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["TaskId"] as? String {
                    self.taskId = value
                }
                if let value = dict["TaskType"] as? String {
                    self.taskType = value
                }
            }
        }
        public var list: [DescribeSqlLogTasksResponseBody.Data.List]?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["List"] as? [Any?] {
                var tmp : [DescribeSqlLogTasksResponseBody.Data.List] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSqlLogTasksResponseBody.Data.List()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.list = tmp
            }
            if let value = dict["PageNo"] as? Int64 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: DescribeSqlLogTasksResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeSqlLogTasksResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeSqlLogTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSqlLogTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSqlLogTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTopBigKeysRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var endTime: String?

    public var instanceId: String?

    public var nodeId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeTopBigKeysResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BigKey : Tea.TeaModel {
            public var db: Int32?

            public var key: String?

            public var keyType: String?

            public var nodeId: String?

            public var size: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.db != nil {
                    map["Db"] = self.db!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.keyType != nil {
                    map["KeyType"] = self.keyType!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Db"] as? Int32 {
                    self.db = value
                }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["KeyType"] as? String {
                    self.keyType = value
                }
                if let value = dict["NodeId"] as? String {
                    self.nodeId = value
                }
                if let value = dict["Size"] as? Int64 {
                    self.size = value
                }
            }
        }
        public var bigKey: [DescribeTopBigKeysResponseBody.Data.BigKey]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bigKey != nil {
                var tmp : [Any] = []
                for k in self.bigKey! {
                    tmp.append(k.toMap())
                }
                map["BigKey"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BigKey"] as? [Any?] {
                var tmp : [DescribeTopBigKeysResponseBody.Data.BigKey] = []
                for v in value {
                    if v != nil {
                        var model = DescribeTopBigKeysResponseBody.Data.BigKey()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.bigKey = tmp
            }
        }
    }
    public var code: String?

    public var data: DescribeTopBigKeysResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeTopBigKeysResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeTopBigKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTopBigKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTopBigKeysResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTopHotKeysRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var endTime: String?

    public var instanceId: String?

    public var nodeId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeTopHotKeysResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class HotKey : Tea.TeaModel {
            public var db: Int32?

            public var hot: String?

            public var key: String?

            public var keyType: String?

            public var lfu: Int32?

            public var nodeId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.db != nil {
                    map["Db"] = self.db!
                }
                if self.hot != nil {
                    map["Hot"] = self.hot!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.keyType != nil {
                    map["KeyType"] = self.keyType!
                }
                if self.lfu != nil {
                    map["Lfu"] = self.lfu!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Db"] as? Int32 {
                    self.db = value
                }
                if let value = dict["Hot"] as? String {
                    self.hot = value
                }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["KeyType"] as? String {
                    self.keyType = value
                }
                if let value = dict["Lfu"] as? Int32 {
                    self.lfu = value
                }
                if let value = dict["NodeId"] as? String {
                    self.nodeId = value
                }
            }
        }
        public var hotKey: [DescribeTopHotKeysResponseBody.Data.HotKey]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hotKey != nil {
                var tmp : [Any] = []
                for k in self.hotKey! {
                    tmp.append(k.toMap())
                }
                map["HotKey"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HotKey"] as? [Any?] {
                var tmp : [DescribeTopHotKeysResponseBody.Data.HotKey] = []
                for v in value {
                    if v != nil {
                        var model = DescribeTopHotKeysResponseBody.Data.HotKey()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.hotKey = tmp
            }
        }
    }
    public var code: String?

    public var data: DescribeTopHotKeysResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeTopHotKeysResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeTopHotKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTopHotKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTopHotKeysResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableAllSqlConcurrencyControlRulesRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DisableAllSqlConcurrencyControlRulesResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DisableAllSqlConcurrencyControlRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableAllSqlConcurrencyControlRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableAllSqlConcurrencyControlRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableAutoResourceOptimizeRulesRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
    }
}

public class DisableAutoResourceOptimizeRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ConfigFailInstanceList : Tea.TeaModel {
            public var configSuccess: Bool?

            public var errorMessage: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configSuccess != nil {
                    map["ConfigSuccess"] = self.configSuccess!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigSuccess"] as? Bool {
                    self.configSuccess = value
                }
                if let value = dict["ErrorMessage"] as? String {
                    self.errorMessage = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
            }
        }
        public class ConfigSuccessInstanceList : Tea.TeaModel {
            public var configSuccess: Bool?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configSuccess != nil {
                    map["ConfigSuccess"] = self.configSuccess!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigSuccess"] as? Bool {
                    self.configSuccess = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
            }
        }
        public var configFailInstanceCount: Int64?

        public var configFailInstanceList: [DisableAutoResourceOptimizeRulesResponseBody.Data.ConfigFailInstanceList]?

        public var configSuccessInstanceCount: Int64?

        public var configSuccessInstanceList: [DisableAutoResourceOptimizeRulesResponseBody.Data.ConfigSuccessInstanceList]?

        public var totalInstanceCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configFailInstanceCount != nil {
                map["ConfigFailInstanceCount"] = self.configFailInstanceCount!
            }
            if self.configFailInstanceList != nil {
                var tmp : [Any] = []
                for k in self.configFailInstanceList! {
                    tmp.append(k.toMap())
                }
                map["ConfigFailInstanceList"] = tmp
            }
            if self.configSuccessInstanceCount != nil {
                map["ConfigSuccessInstanceCount"] = self.configSuccessInstanceCount!
            }
            if self.configSuccessInstanceList != nil {
                var tmp : [Any] = []
                for k in self.configSuccessInstanceList! {
                    tmp.append(k.toMap())
                }
                map["ConfigSuccessInstanceList"] = tmp
            }
            if self.totalInstanceCount != nil {
                map["TotalInstanceCount"] = self.totalInstanceCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigFailInstanceCount"] as? Int64 {
                self.configFailInstanceCount = value
            }
            if let value = dict["ConfigFailInstanceList"] as? [Any?] {
                var tmp : [DisableAutoResourceOptimizeRulesResponseBody.Data.ConfigFailInstanceList] = []
                for v in value {
                    if v != nil {
                        var model = DisableAutoResourceOptimizeRulesResponseBody.Data.ConfigFailInstanceList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configFailInstanceList = tmp
            }
            if let value = dict["ConfigSuccessInstanceCount"] as? Int64 {
                self.configSuccessInstanceCount = value
            }
            if let value = dict["ConfigSuccessInstanceList"] as? [Any?] {
                var tmp : [DisableAutoResourceOptimizeRulesResponseBody.Data.ConfigSuccessInstanceList] = []
                for v in value {
                    if v != nil {
                        var model = DisableAutoResourceOptimizeRulesResponseBody.Data.ConfigSuccessInstanceList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configSuccessInstanceList = tmp
            }
            if let value = dict["TotalInstanceCount"] as? Int64 {
                self.totalInstanceCount = value
            }
        }
    }
    public var code: Int64?

    public var data: DisableAutoResourceOptimizeRulesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DisableAutoResourceOptimizeRulesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DisableAutoResourceOptimizeRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableAutoResourceOptimizeRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableAutoResourceOptimizeRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableAutoThrottleRulesRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
    }
}

public class DisableAutoThrottleRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ConfigFailInstanceList : Tea.TeaModel {
            public var configSuccess: Bool?

            public var errorMessage: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configSuccess != nil {
                    map["ConfigSuccess"] = self.configSuccess!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigSuccess"] as? Bool {
                    self.configSuccess = value
                }
                if let value = dict["ErrorMessage"] as? String {
                    self.errorMessage = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
            }
        }
        public class ConfigSuccessInstanceList : Tea.TeaModel {
            public var configSuccess: Bool?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configSuccess != nil {
                    map["ConfigSuccess"] = self.configSuccess!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigSuccess"] as? Bool {
                    self.configSuccess = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
            }
        }
        public var configFailInstanceCount: Int64?

        public var configFailInstanceList: [DisableAutoThrottleRulesResponseBody.Data.ConfigFailInstanceList]?

        public var configSuccessInstanceCount: Int64?

        public var configSuccessInstanceList: [DisableAutoThrottleRulesResponseBody.Data.ConfigSuccessInstanceList]?

        public var totalInstanceCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configFailInstanceCount != nil {
                map["ConfigFailInstanceCount"] = self.configFailInstanceCount!
            }
            if self.configFailInstanceList != nil {
                var tmp : [Any] = []
                for k in self.configFailInstanceList! {
                    tmp.append(k.toMap())
                }
                map["ConfigFailInstanceList"] = tmp
            }
            if self.configSuccessInstanceCount != nil {
                map["ConfigSuccessInstanceCount"] = self.configSuccessInstanceCount!
            }
            if self.configSuccessInstanceList != nil {
                var tmp : [Any] = []
                for k in self.configSuccessInstanceList! {
                    tmp.append(k.toMap())
                }
                map["ConfigSuccessInstanceList"] = tmp
            }
            if self.totalInstanceCount != nil {
                map["TotalInstanceCount"] = self.totalInstanceCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigFailInstanceCount"] as? Int64 {
                self.configFailInstanceCount = value
            }
            if let value = dict["ConfigFailInstanceList"] as? [Any?] {
                var tmp : [DisableAutoThrottleRulesResponseBody.Data.ConfigFailInstanceList] = []
                for v in value {
                    if v != nil {
                        var model = DisableAutoThrottleRulesResponseBody.Data.ConfigFailInstanceList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configFailInstanceList = tmp
            }
            if let value = dict["ConfigSuccessInstanceCount"] as? Int64 {
                self.configSuccessInstanceCount = value
            }
            if let value = dict["ConfigSuccessInstanceList"] as? [Any?] {
                var tmp : [DisableAutoThrottleRulesResponseBody.Data.ConfigSuccessInstanceList] = []
                for v in value {
                    if v != nil {
                        var model = DisableAutoThrottleRulesResponseBody.Data.ConfigSuccessInstanceList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configSuccessInstanceList = tmp
            }
            if let value = dict["TotalInstanceCount"] as? Int64 {
                self.totalInstanceCount = value
            }
        }
    }
    public var code: Int64?

    public var data: DisableAutoThrottleRulesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DisableAutoThrottleRulesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DisableAutoThrottleRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableAutoThrottleRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableAutoThrottleRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableDasProRequest : Tea.TeaModel {
    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class DisableDasProResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
        if let value = dict["Synchro"] as? String {
            self.synchro = value
        }
    }
}

public class DisableDasProResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableDasProResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableDasProResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableInstanceDasConfigRequest : Tea.TeaModel {
    public var engine: String?

    public var instanceId: String?

    public var scaleType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scaleType != nil {
            map["ScaleType"] = self.scaleType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["ScaleType"] as? String {
            self.scaleType = value
        }
    }
}

public class DisableInstanceDasConfigResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DisableInstanceDasConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableInstanceDasConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableInstanceDasConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableSqlConcurrencyControlRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public var itemId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["ItemId"] as? Int64 {
            self.itemId = value
        }
    }
}

public class DisableSqlConcurrencyControlResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DisableSqlConcurrencyControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableSqlConcurrencyControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableSqlConcurrencyControlResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableDasProRequest : Tea.TeaModel {
    public var instanceId: String?

    public var sqlRetention: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sqlRetention != nil {
            map["SqlRetention"] = self.sqlRetention!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["SqlRetention"] as? Int32 {
            self.sqlRetention = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class EnableDasProResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
        if let value = dict["Synchro"] as? String {
            self.synchro = value
        }
    }
}

public class EnableDasProResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableDasProResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableDasProResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableSqlConcurrencyControlRequest : Tea.TeaModel {
    public var concurrencyControlTime: Int64?

    public var consoleContext: String?

    public var instanceId: String?

    public var maxConcurrency: Int64?

    public var sqlKeywords: String?

    public var sqlType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.concurrencyControlTime != nil {
            map["ConcurrencyControlTime"] = self.concurrencyControlTime!
        }
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxConcurrency != nil {
            map["MaxConcurrency"] = self.maxConcurrency!
        }
        if self.sqlKeywords != nil {
            map["SqlKeywords"] = self.sqlKeywords!
        }
        if self.sqlType != nil {
            map["SqlType"] = self.sqlType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConcurrencyControlTime"] as? Int64 {
            self.concurrencyControlTime = value
        }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["MaxConcurrency"] as? Int64 {
            self.maxConcurrency = value
        }
        if let value = dict["SqlKeywords"] as? String {
            self.sqlKeywords = value
        }
        if let value = dict["SqlType"] as? String {
            self.sqlType = value
        }
    }
}

public class EnableSqlConcurrencyControlResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class EnableSqlConcurrencyControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableSqlConcurrencyControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableSqlConcurrencyControlResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAsyncErrorRequestListByCodeRequest : Tea.TeaModel {
    public var end: Int64?

    public var errorCode: String?

    public var instanceId: String?

    public var nodeId: String?

    public var start: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["End"] as? Int64 {
            self.end = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["Start"] as? Int64 {
            self.start = value
        }
    }
}

public class GetAsyncErrorRequestListByCodeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var instanceId: String?

            public var sqlId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["instanceId"] = self.instanceId!
                }
                if self.sqlId != nil {
                    map["sqlId"] = self.sqlId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["instanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["sqlId"] as? String {
                    self.sqlId = value
                }
            }
        }
        public var complete: Bool?

        public var fail: Bool?

        public var isFinish: Bool?

        public var result: [GetAsyncErrorRequestListByCodeResponseBody.Data.Result]?

        public var resultId: String?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complete != nil {
                map["complete"] = self.complete!
            }
            if self.fail != nil {
                map["fail"] = self.fail!
            }
            if self.isFinish != nil {
                map["isFinish"] = self.isFinish!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["result"] = tmp
            }
            if self.resultId != nil {
                map["resultId"] = self.resultId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.timestamp != nil {
                map["timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["complete"] as? Bool {
                self.complete = value
            }
            if let value = dict["fail"] as? Bool {
                self.fail = value
            }
            if let value = dict["isFinish"] as? Bool {
                self.isFinish = value
            }
            if let value = dict["result"] as? [Any?] {
                var tmp : [GetAsyncErrorRequestListByCodeResponseBody.Data.Result] = []
                for v in value {
                    if v != nil {
                        var model = GetAsyncErrorRequestListByCodeResponseBody.Data.Result()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.result = tmp
            }
            if let value = dict["resultId"] as? String {
                self.resultId = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
            if let value = dict["timestamp"] as? Int64 {
                self.timestamp = value
            }
        }
    }
    public var code: Int64?

    public var data: GetAsyncErrorRequestListByCodeResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetAsyncErrorRequestListByCodeResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetAsyncErrorRequestListByCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAsyncErrorRequestListByCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAsyncErrorRequestListByCodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAsyncErrorRequestStatByCodeRequest : Tea.TeaModel {
    public var dbName: String?

    public var end: Int64?

    public var instanceId: String?

    public var nodeId: String?

    public var start: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DbName"] as? String {
            self.dbName = value
        }
        if let value = dict["End"] as? Int64 {
            self.end = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["Start"] as? Int64 {
            self.start = value
        }
    }
}

public class GetAsyncErrorRequestStatByCodeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var count: Int32?

            public var errorCode: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["count"] = self.count!
                }
                if self.errorCode != nil {
                    map["errorCode"] = self.errorCode!
                }
                if self.instanceId != nil {
                    map["instanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["count"] as? Int32 {
                    self.count = value
                }
                if let value = dict["errorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["instanceId"] as? String {
                    self.instanceId = value
                }
            }
        }
        public var complete: Bool?

        public var fail: Bool?

        public var isFinish: Bool?

        public var result: [GetAsyncErrorRequestStatByCodeResponseBody.Data.Result]?

        public var resultId: String?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complete != nil {
                map["complete"] = self.complete!
            }
            if self.fail != nil {
                map["fail"] = self.fail!
            }
            if self.isFinish != nil {
                map["isFinish"] = self.isFinish!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["result"] = tmp
            }
            if self.resultId != nil {
                map["resultId"] = self.resultId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.timestamp != nil {
                map["timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["complete"] as? Bool {
                self.complete = value
            }
            if let value = dict["fail"] as? Bool {
                self.fail = value
            }
            if let value = dict["isFinish"] as? Bool {
                self.isFinish = value
            }
            if let value = dict["result"] as? [Any?] {
                var tmp : [GetAsyncErrorRequestStatByCodeResponseBody.Data.Result] = []
                for v in value {
                    if v != nil {
                        var model = GetAsyncErrorRequestStatByCodeResponseBody.Data.Result()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.result = tmp
            }
            if let value = dict["resultId"] as? String {
                self.resultId = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
            if let value = dict["timestamp"] as? Int64 {
                self.timestamp = value
            }
        }
    }
    public var code: Int64?

    public var data: GetAsyncErrorRequestStatByCodeResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetAsyncErrorRequestStatByCodeResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetAsyncErrorRequestStatByCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAsyncErrorRequestStatByCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAsyncErrorRequestStatByCodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAsyncErrorRequestStatResultRequest : Tea.TeaModel {
    public var dbName: String?

    public var end: Int64?

    public var instanceId: String?

    public var nodeId: String?

    public var sqlIdList: String?

    public var start: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.sqlIdList != nil {
            map["SqlIdList"] = self.sqlIdList!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DbName"] as? String {
            self.dbName = value
        }
        if let value = dict["End"] as? Int64 {
            self.end = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["SqlIdList"] as? String {
            self.sqlIdList = value
        }
        if let value = dict["Start"] as? Int64 {
            self.start = value
        }
    }
}

public class GetAsyncErrorRequestStatResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var complete: Bool?

        public var fail: Bool?

        public var isFinish: Bool?

        public var result: [String: DataResultValue]?

        public var resultId: String?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complete != nil {
                map["complete"] = self.complete!
            }
            if self.fail != nil {
                map["fail"] = self.fail!
            }
            if self.isFinish != nil {
                map["isFinish"] = self.isFinish!
            }
            if self.result != nil {
                var tmp : [String: Any] = [:]
                for (k, v) in self.result! {
                    tmp[k] = v.toMap()
                }
                map["result"] = tmp
            }
            if self.resultId != nil {
                map["resultId"] = self.resultId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.timestamp != nil {
                map["timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["complete"] as? Bool {
                self.complete = value
            }
            if let value = dict["fail"] as? Bool {
                self.fail = value
            }
            if let value = dict["isFinish"] as? Bool {
                self.isFinish = value
            }
            if let value = dict["result"] as? [String: Any?] {
                var tmp : [String: DataResultValue] = [:]
                for (k, v) in value {
                    if v != nil {
                        var model = DataResultValue()
                        model.fromMap(v as? [String: Any?])
                        tmp[k] = model
                    }
                }
                self.result = tmp
            }
            if let value = dict["resultId"] as? String {
                self.resultId = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
            if let value = dict["timestamp"] as? Int64 {
                self.timestamp = value
            }
        }
    }
    public var code: Int64?

    public var data: GetAsyncErrorRequestStatResultResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetAsyncErrorRequestStatResultResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetAsyncErrorRequestStatResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAsyncErrorRequestStatResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAsyncErrorRequestStatResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAutoIncrementUsageStatisticRequest : Tea.TeaModel {
    public var dbNames: String?

    public var instanceId: String?

    public var ratioFilter: Double?

    public var realTime: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbNames != nil {
            map["DbNames"] = self.dbNames!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ratioFilter != nil {
            map["RatioFilter"] = self.ratioFilter!
        }
        if self.realTime != nil {
            map["RealTime"] = self.realTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DbNames"] as? String {
            self.dbNames = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RatioFilter"] as? Double {
            self.ratioFilter = value
        }
        if let value = dict["RealTime"] as? Bool {
            self.realTime = value
        }
    }
}

public class GetAutoIncrementUsageStatisticResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AutoIncrementUsageList : Tea.TeaModel {
            public var autoIncrementCurrentValue: Int64?

            public var autoIncrementRatio: Double?

            public var columnName: String?

            public var dbName: String?

            public var maximumValue: Int64?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoIncrementCurrentValue != nil {
                    map["AutoIncrementCurrentValue"] = self.autoIncrementCurrentValue!
                }
                if self.autoIncrementRatio != nil {
                    map["AutoIncrementRatio"] = self.autoIncrementRatio!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.dbName != nil {
                    map["DbName"] = self.dbName!
                }
                if self.maximumValue != nil {
                    map["MaximumValue"] = self.maximumValue!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoIncrementCurrentValue"] as? Int64 {
                    self.autoIncrementCurrentValue = value
                }
                if let value = dict["AutoIncrementRatio"] as? Double {
                    self.autoIncrementRatio = value
                }
                if let value = dict["ColumnName"] as? String {
                    self.columnName = value
                }
                if let value = dict["DbName"] as? String {
                    self.dbName = value
                }
                if let value = dict["MaximumValue"] as? Int64 {
                    self.maximumValue = value
                }
                if let value = dict["TableName"] as? String {
                    self.tableName = value
                }
            }
        }
        public var autoIncrementUsageList: [GetAutoIncrementUsageStatisticResponseBody.Data.AutoIncrementUsageList]?

        public var errorInfo: String?

        public var finish: Bool?

        public var taskStatus: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoIncrementUsageList != nil {
                var tmp : [Any] = []
                for k in self.autoIncrementUsageList! {
                    tmp.append(k.toMap())
                }
                map["AutoIncrementUsageList"] = tmp
            }
            if self.errorInfo != nil {
                map["ErrorInfo"] = self.errorInfo!
            }
            if self.finish != nil {
                map["Finish"] = self.finish!
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoIncrementUsageList"] as? [Any?] {
                var tmp : [GetAutoIncrementUsageStatisticResponseBody.Data.AutoIncrementUsageList] = []
                for v in value {
                    if v != nil {
                        var model = GetAutoIncrementUsageStatisticResponseBody.Data.AutoIncrementUsageList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.autoIncrementUsageList = tmp
            }
            if let value = dict["ErrorInfo"] as? String {
                self.errorInfo = value
            }
            if let value = dict["Finish"] as? Bool {
                self.finish = value
            }
            if let value = dict["TaskStatus"] as? String {
                self.taskStatus = value
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
        }
    }
    public var code: Int64?

    public var data: GetAutoIncrementUsageStatisticResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetAutoIncrementUsageStatisticResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetAutoIncrementUsageStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAutoIncrementUsageStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAutoIncrementUsageStatisticResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAutoResourceOptimizeRulesRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
    }
}

public class GetAutoResourceOptimizeRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EnableAutoResourceOptimizeList : Tea.TeaModel {
            public var autoDefragment: Bool?

            public var dasProOn: Bool?

            public var instanceId: String?

            public var tableFragmentationRatio: Double?

            public var tableSpaceSize: Double?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoDefragment != nil {
                    map["AutoDefragment"] = self.autoDefragment!
                }
                if self.dasProOn != nil {
                    map["DasProOn"] = self.dasProOn!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.tableFragmentationRatio != nil {
                    map["TableFragmentationRatio"] = self.tableFragmentationRatio!
                }
                if self.tableSpaceSize != nil {
                    map["TableSpaceSize"] = self.tableSpaceSize!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoDefragment"] as? Bool {
                    self.autoDefragment = value
                }
                if let value = dict["DasProOn"] as? Bool {
                    self.dasProOn = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["TableFragmentationRatio"] as? Double {
                    self.tableFragmentationRatio = value
                }
                if let value = dict["TableSpaceSize"] as? Double {
                    self.tableSpaceSize = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public class HasEnableRuleButNotDasProList : Tea.TeaModel {
            public var autoDefragment: Bool?

            public var dasProOn: Bool?

            public var instanceId: String?

            public var tableFragmentationRatio: Double?

            public var tableSpaceSize: Double?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoDefragment != nil {
                    map["AutoDefragment"] = self.autoDefragment!
                }
                if self.dasProOn != nil {
                    map["DasProOn"] = self.dasProOn!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.tableFragmentationRatio != nil {
                    map["TableFragmentationRatio"] = self.tableFragmentationRatio!
                }
                if self.tableSpaceSize != nil {
                    map["TableSpaceSize"] = self.tableSpaceSize!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoDefragment"] as? Bool {
                    self.autoDefragment = value
                }
                if let value = dict["DasProOn"] as? Bool {
                    self.dasProOn = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["TableFragmentationRatio"] as? Double {
                    self.tableFragmentationRatio = value
                }
                if let value = dict["TableSpaceSize"] as? Double {
                    self.tableSpaceSize = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public class TurnOffAutoResourceOptimizeList : Tea.TeaModel {
            public var autoDefragment: Bool?

            public var dasProOn: Bool?

            public var instanceId: String?

            public var tableFragmentationRatio: Double?

            public var tableSpaceSize: Double?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoDefragment != nil {
                    map["AutoDefragment"] = self.autoDefragment!
                }
                if self.dasProOn != nil {
                    map["DasProOn"] = self.dasProOn!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.tableFragmentationRatio != nil {
                    map["TableFragmentationRatio"] = self.tableFragmentationRatio!
                }
                if self.tableSpaceSize != nil {
                    map["TableSpaceSize"] = self.tableSpaceSize!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoDefragment"] as? Bool {
                    self.autoDefragment = value
                }
                if let value = dict["DasProOn"] as? Bool {
                    self.dasProOn = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["TableFragmentationRatio"] as? Double {
                    self.tableFragmentationRatio = value
                }
                if let value = dict["TableSpaceSize"] as? Double {
                    self.tableSpaceSize = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public var enableAutoResourceOptimizeCount: Int64?

        public var enableAutoResourceOptimizeList: [GetAutoResourceOptimizeRulesResponseBody.Data.EnableAutoResourceOptimizeList]?

        public var hasEnableRuleButNotDasProCount: Int64?

        public var hasEnableRuleButNotDasProList: [GetAutoResourceOptimizeRulesResponseBody.Data.HasEnableRuleButNotDasProList]?

        public var neverEnableAutoResourceOptimizeOrReleasedInstanceCount: Int64?

        public var neverEnableAutoResourceOptimizeOrReleasedInstanceIdList: [String]?

        public var totalAutoResourceOptimizeRulesCount: Int64?

        public var turnOffAutoResourceOptimizeCount: Int64?

        public var turnOffAutoResourceOptimizeList: [GetAutoResourceOptimizeRulesResponseBody.Data.TurnOffAutoResourceOptimizeList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableAutoResourceOptimizeCount != nil {
                map["EnableAutoResourceOptimizeCount"] = self.enableAutoResourceOptimizeCount!
            }
            if self.enableAutoResourceOptimizeList != nil {
                var tmp : [Any] = []
                for k in self.enableAutoResourceOptimizeList! {
                    tmp.append(k.toMap())
                }
                map["EnableAutoResourceOptimizeList"] = tmp
            }
            if self.hasEnableRuleButNotDasProCount != nil {
                map["HasEnableRuleButNotDasProCount"] = self.hasEnableRuleButNotDasProCount!
            }
            if self.hasEnableRuleButNotDasProList != nil {
                var tmp : [Any] = []
                for k in self.hasEnableRuleButNotDasProList! {
                    tmp.append(k.toMap())
                }
                map["HasEnableRuleButNotDasProList"] = tmp
            }
            if self.neverEnableAutoResourceOptimizeOrReleasedInstanceCount != nil {
                map["NeverEnableAutoResourceOptimizeOrReleasedInstanceCount"] = self.neverEnableAutoResourceOptimizeOrReleasedInstanceCount!
            }
            if self.neverEnableAutoResourceOptimizeOrReleasedInstanceIdList != nil {
                map["NeverEnableAutoResourceOptimizeOrReleasedInstanceIdList"] = self.neverEnableAutoResourceOptimizeOrReleasedInstanceIdList!
            }
            if self.totalAutoResourceOptimizeRulesCount != nil {
                map["TotalAutoResourceOptimizeRulesCount"] = self.totalAutoResourceOptimizeRulesCount!
            }
            if self.turnOffAutoResourceOptimizeCount != nil {
                map["TurnOffAutoResourceOptimizeCount"] = self.turnOffAutoResourceOptimizeCount!
            }
            if self.turnOffAutoResourceOptimizeList != nil {
                var tmp : [Any] = []
                for k in self.turnOffAutoResourceOptimizeList! {
                    tmp.append(k.toMap())
                }
                map["TurnOffAutoResourceOptimizeList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableAutoResourceOptimizeCount"] as? Int64 {
                self.enableAutoResourceOptimizeCount = value
            }
            if let value = dict["EnableAutoResourceOptimizeList"] as? [Any?] {
                var tmp : [GetAutoResourceOptimizeRulesResponseBody.Data.EnableAutoResourceOptimizeList] = []
                for v in value {
                    if v != nil {
                        var model = GetAutoResourceOptimizeRulesResponseBody.Data.EnableAutoResourceOptimizeList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.enableAutoResourceOptimizeList = tmp
            }
            if let value = dict["HasEnableRuleButNotDasProCount"] as? Int64 {
                self.hasEnableRuleButNotDasProCount = value
            }
            if let value = dict["HasEnableRuleButNotDasProList"] as? [Any?] {
                var tmp : [GetAutoResourceOptimizeRulesResponseBody.Data.HasEnableRuleButNotDasProList] = []
                for v in value {
                    if v != nil {
                        var model = GetAutoResourceOptimizeRulesResponseBody.Data.HasEnableRuleButNotDasProList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.hasEnableRuleButNotDasProList = tmp
            }
            if let value = dict["NeverEnableAutoResourceOptimizeOrReleasedInstanceCount"] as? Int64 {
                self.neverEnableAutoResourceOptimizeOrReleasedInstanceCount = value
            }
            if let value = dict["NeverEnableAutoResourceOptimizeOrReleasedInstanceIdList"] as? [String] {
                self.neverEnableAutoResourceOptimizeOrReleasedInstanceIdList = value
            }
            if let value = dict["TotalAutoResourceOptimizeRulesCount"] as? Int64 {
                self.totalAutoResourceOptimizeRulesCount = value
            }
            if let value = dict["TurnOffAutoResourceOptimizeCount"] as? Int64 {
                self.turnOffAutoResourceOptimizeCount = value
            }
            if let value = dict["TurnOffAutoResourceOptimizeList"] as? [Any?] {
                var tmp : [GetAutoResourceOptimizeRulesResponseBody.Data.TurnOffAutoResourceOptimizeList] = []
                for v in value {
                    if v != nil {
                        var model = GetAutoResourceOptimizeRulesResponseBody.Data.TurnOffAutoResourceOptimizeList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.turnOffAutoResourceOptimizeList = tmp
            }
        }
    }
    public var code: Int64?

    public var data: GetAutoResourceOptimizeRulesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetAutoResourceOptimizeRulesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetAutoResourceOptimizeRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAutoResourceOptimizeRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAutoResourceOptimizeRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAutoThrottleRulesRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
    }
}

public class GetAutoThrottleRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EnableAutoThrottleList : Tea.TeaModel {
            public var abnormalDuration: Double?

            public var activeSessions: Int64?

            public var allowThrottleEndTime: String?

            public var allowThrottleStartTime: String?

            public var autoKillSession: Bool?

            public var cpuSessionRelation: String?

            public var cpuUsage: Double?

            public var instanceId: String?

            public var maxThrottleTime: Double?

            public var userId: String?

            public var visible: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abnormalDuration != nil {
                    map["AbnormalDuration"] = self.abnormalDuration!
                }
                if self.activeSessions != nil {
                    map["ActiveSessions"] = self.activeSessions!
                }
                if self.allowThrottleEndTime != nil {
                    map["AllowThrottleEndTime"] = self.allowThrottleEndTime!
                }
                if self.allowThrottleStartTime != nil {
                    map["AllowThrottleStartTime"] = self.allowThrottleStartTime!
                }
                if self.autoKillSession != nil {
                    map["AutoKillSession"] = self.autoKillSession!
                }
                if self.cpuSessionRelation != nil {
                    map["CpuSessionRelation"] = self.cpuSessionRelation!
                }
                if self.cpuUsage != nil {
                    map["CpuUsage"] = self.cpuUsage!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.maxThrottleTime != nil {
                    map["MaxThrottleTime"] = self.maxThrottleTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.visible != nil {
                    map["Visible"] = self.visible!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AbnormalDuration"] as? Double {
                    self.abnormalDuration = value
                }
                if let value = dict["ActiveSessions"] as? Int64 {
                    self.activeSessions = value
                }
                if let value = dict["AllowThrottleEndTime"] as? String {
                    self.allowThrottleEndTime = value
                }
                if let value = dict["AllowThrottleStartTime"] as? String {
                    self.allowThrottleStartTime = value
                }
                if let value = dict["AutoKillSession"] as? Bool {
                    self.autoKillSession = value
                }
                if let value = dict["CpuSessionRelation"] as? String {
                    self.cpuSessionRelation = value
                }
                if let value = dict["CpuUsage"] as? Double {
                    self.cpuUsage = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["MaxThrottleTime"] as? Double {
                    self.maxThrottleTime = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
                if let value = dict["Visible"] as? Bool {
                    self.visible = value
                }
            }
        }
        public class TurnOffAutoThrottleList : Tea.TeaModel {
            public var abnormalDuration: Double?

            public var activeSessions: Int64?

            public var allowThrottleEndTime: String?

            public var allowThrottleStartTime: String?

            public var autoKillSession: Bool?

            public var cpuSessionRelation: String?

            public var cpuUsage: Double?

            public var instanceId: String?

            public var maxThrottleTime: Double?

            public var userId: String?

            public var visible: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abnormalDuration != nil {
                    map["AbnormalDuration"] = self.abnormalDuration!
                }
                if self.activeSessions != nil {
                    map["ActiveSessions"] = self.activeSessions!
                }
                if self.allowThrottleEndTime != nil {
                    map["AllowThrottleEndTime"] = self.allowThrottleEndTime!
                }
                if self.allowThrottleStartTime != nil {
                    map["AllowThrottleStartTime"] = self.allowThrottleStartTime!
                }
                if self.autoKillSession != nil {
                    map["AutoKillSession"] = self.autoKillSession!
                }
                if self.cpuSessionRelation != nil {
                    map["CpuSessionRelation"] = self.cpuSessionRelation!
                }
                if self.cpuUsage != nil {
                    map["CpuUsage"] = self.cpuUsage!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.maxThrottleTime != nil {
                    map["MaxThrottleTime"] = self.maxThrottleTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.visible != nil {
                    map["Visible"] = self.visible!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AbnormalDuration"] as? Double {
                    self.abnormalDuration = value
                }
                if let value = dict["ActiveSessions"] as? Int64 {
                    self.activeSessions = value
                }
                if let value = dict["AllowThrottleEndTime"] as? String {
                    self.allowThrottleEndTime = value
                }
                if let value = dict["AllowThrottleStartTime"] as? String {
                    self.allowThrottleStartTime = value
                }
                if let value = dict["AutoKillSession"] as? Bool {
                    self.autoKillSession = value
                }
                if let value = dict["CpuSessionRelation"] as? String {
                    self.cpuSessionRelation = value
                }
                if let value = dict["CpuUsage"] as? Double {
                    self.cpuUsage = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["MaxThrottleTime"] as? Double {
                    self.maxThrottleTime = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
                if let value = dict["Visible"] as? Bool {
                    self.visible = value
                }
            }
        }
        public var enableAutoThrottleCount: Int64?

        public var enableAutoThrottleList: [GetAutoThrottleRulesResponseBody.Data.EnableAutoThrottleList]?

        public var neverEnableAutoThrottleOrReleasedInstanceCount: Int64?

        public var neverEnableAutoThrottleOrReleasedInstanceIdList: [String]?

        public var totalAutoThrottleRulesCount: Int64?

        public var turnOffAutoThrottleCount: Int64?

        public var turnOffAutoThrottleList: [GetAutoThrottleRulesResponseBody.Data.TurnOffAutoThrottleList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableAutoThrottleCount != nil {
                map["EnableAutoThrottleCount"] = self.enableAutoThrottleCount!
            }
            if self.enableAutoThrottleList != nil {
                var tmp : [Any] = []
                for k in self.enableAutoThrottleList! {
                    tmp.append(k.toMap())
                }
                map["EnableAutoThrottleList"] = tmp
            }
            if self.neverEnableAutoThrottleOrReleasedInstanceCount != nil {
                map["NeverEnableAutoThrottleOrReleasedInstanceCount"] = self.neverEnableAutoThrottleOrReleasedInstanceCount!
            }
            if self.neverEnableAutoThrottleOrReleasedInstanceIdList != nil {
                map["NeverEnableAutoThrottleOrReleasedInstanceIdList"] = self.neverEnableAutoThrottleOrReleasedInstanceIdList!
            }
            if self.totalAutoThrottleRulesCount != nil {
                map["TotalAutoThrottleRulesCount"] = self.totalAutoThrottleRulesCount!
            }
            if self.turnOffAutoThrottleCount != nil {
                map["TurnOffAutoThrottleCount"] = self.turnOffAutoThrottleCount!
            }
            if self.turnOffAutoThrottleList != nil {
                var tmp : [Any] = []
                for k in self.turnOffAutoThrottleList! {
                    tmp.append(k.toMap())
                }
                map["TurnOffAutoThrottleList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableAutoThrottleCount"] as? Int64 {
                self.enableAutoThrottleCount = value
            }
            if let value = dict["EnableAutoThrottleList"] as? [Any?] {
                var tmp : [GetAutoThrottleRulesResponseBody.Data.EnableAutoThrottleList] = []
                for v in value {
                    if v != nil {
                        var model = GetAutoThrottleRulesResponseBody.Data.EnableAutoThrottleList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.enableAutoThrottleList = tmp
            }
            if let value = dict["NeverEnableAutoThrottleOrReleasedInstanceCount"] as? Int64 {
                self.neverEnableAutoThrottleOrReleasedInstanceCount = value
            }
            if let value = dict["NeverEnableAutoThrottleOrReleasedInstanceIdList"] as? [String] {
                self.neverEnableAutoThrottleOrReleasedInstanceIdList = value
            }
            if let value = dict["TotalAutoThrottleRulesCount"] as? Int64 {
                self.totalAutoThrottleRulesCount = value
            }
            if let value = dict["TurnOffAutoThrottleCount"] as? Int64 {
                self.turnOffAutoThrottleCount = value
            }
            if let value = dict["TurnOffAutoThrottleList"] as? [Any?] {
                var tmp : [GetAutoThrottleRulesResponseBody.Data.TurnOffAutoThrottleList] = []
                for v in value {
                    if v != nil {
                        var model = GetAutoThrottleRulesResponseBody.Data.TurnOffAutoThrottleList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.turnOffAutoThrottleList = tmp
            }
        }
    }
    public var code: Int64?

    public var data: GetAutoThrottleRulesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetAutoThrottleRulesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetAutoThrottleRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAutoThrottleRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAutoThrottleRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAutonomousNotifyEventContentRequest : Tea.TeaModel {
    public var instanceId: String?

    public var spanId: String?

    public var context: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.spanId != nil {
            map["SpanId"] = self.spanId!
        }
        if self.context != nil {
            map["__context"] = self.context!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["SpanId"] as? String {
            self.spanId = value
        }
        if let value = dict["__context"] as? String {
            self.context = value
        }
    }
}

public class GetAutonomousNotifyEventContentResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetAutonomousNotifyEventContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAutonomousNotifyEventContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAutonomousNotifyEventContentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAutonomousNotifyEventsInRangeRequest : Tea.TeaModel {
    public var endTime: String?

    public var eventContext: String?

    public var instanceId: String?

    public var level: String?

    public var minLevel: String?

    public var nodeId: String?

    public var pageOffset: String?

    public var pageSize: String?

    public var startTime: String?

    public var context: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eventContext != nil {
            map["EventContext"] = self.eventContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.minLevel != nil {
            map["MinLevel"] = self.minLevel!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.pageOffset != nil {
            map["PageOffset"] = self.pageOffset!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.context != nil {
            map["__context"] = self.context!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["EventContext"] as? String {
            self.eventContext = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Level"] as? String {
            self.level = value
        }
        if let value = dict["MinLevel"] as? String {
            self.minLevel = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["PageOffset"] as? String {
            self.pageOffset = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["__context"] as? String {
            self.context = value
        }
    }
}

public class GetAutonomousNotifyEventsInRangeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var t: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.t != nil {
                    map["T"] = self.t!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["T"] as? [String] {
                    self.t = value
                }
            }
        }
        public var extra: String?

        public var list: GetAutonomousNotifyEventsInRangeResponseBody.Data.List?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.list?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                map["List"] = self.list?.toMap()
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Extra"] as? String {
                self.extra = value
            }
            if let value = dict["List"] as? [String: Any?] {
                var model = GetAutonomousNotifyEventsInRangeResponseBody.Data.List()
                model.fromMap(value)
                self.list = model
            }
            if let value = dict["PageNo"] as? Int64 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: GetAutonomousNotifyEventsInRangeResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetAutonomousNotifyEventsInRangeResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetAutonomousNotifyEventsInRangeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAutonomousNotifyEventsInRangeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAutonomousNotifyEventsInRangeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetBlockingDetailListRequest : Tea.TeaModel {
    public var dbNameList: String?

    public var endTime: String?

    public var instanceId: String?

    public var pageNo: String?

    public var pageSize: String?

    public var queryHash: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbNameList != nil {
            map["DbNameList"] = self.dbNameList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queryHash != nil {
            map["QueryHash"] = self.queryHash!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DbNameList"] as? String {
            self.dbNameList = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNo"] as? String {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["QueryHash"] as? String {
            self.queryHash = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class GetBlockingDetailListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var batchId: Int64?

            public var clientAppName: String?

            public var currentCollectionTime: Int64?

            public var dataBase: String?

            public var hostName: String?

            public var loginId: String?

            public var queryHash: String?

            public var spid: String?

            public var sqlText: String?

            public var startTime: String?

            public var waitTimeMs: Int64?

            public var waitType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.batchId != nil {
                    map["BatchId"] = self.batchId!
                }
                if self.clientAppName != nil {
                    map["ClientAppName"] = self.clientAppName!
                }
                if self.currentCollectionTime != nil {
                    map["CurrentCollectionTime"] = self.currentCollectionTime!
                }
                if self.dataBase != nil {
                    map["DataBase"] = self.dataBase!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.loginId != nil {
                    map["LoginId"] = self.loginId!
                }
                if self.queryHash != nil {
                    map["QueryHash"] = self.queryHash!
                }
                if self.spid != nil {
                    map["Spid"] = self.spid!
                }
                if self.sqlText != nil {
                    map["SqlText"] = self.sqlText!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.waitTimeMs != nil {
                    map["WaitTimeMs"] = self.waitTimeMs!
                }
                if self.waitType != nil {
                    map["WaitType"] = self.waitType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BatchId"] as? Int64 {
                    self.batchId = value
                }
                if let value = dict["ClientAppName"] as? String {
                    self.clientAppName = value
                }
                if let value = dict["CurrentCollectionTime"] as? Int64 {
                    self.currentCollectionTime = value
                }
                if let value = dict["DataBase"] as? String {
                    self.dataBase = value
                }
                if let value = dict["HostName"] as? String {
                    self.hostName = value
                }
                if let value = dict["LoginId"] as? String {
                    self.loginId = value
                }
                if let value = dict["QueryHash"] as? String {
                    self.queryHash = value
                }
                if let value = dict["Spid"] as? String {
                    self.spid = value
                }
                if let value = dict["SqlText"] as? String {
                    self.sqlText = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["WaitTimeMs"] as? Int64 {
                    self.waitTimeMs = value
                }
                if let value = dict["WaitType"] as? String {
                    self.waitType = value
                }
            }
        }
        public var list: [GetBlockingDetailListResponseBody.Data.List]?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["List"] as? [Any?] {
                var tmp : [GetBlockingDetailListResponseBody.Data.List] = []
                for v in value {
                    if v != nil {
                        var model = GetBlockingDetailListResponseBody.Data.List()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.list = tmp
            }
            if let value = dict["PageNo"] as? Int64 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: GetBlockingDetailListResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetBlockingDetailListResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetBlockingDetailListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBlockingDetailListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetBlockingDetailListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDBInstanceConnectivityDiagnosisRequest : Tea.TeaModel {
    public var instanceId: String?

    public var srcIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.srcIp != nil {
            map["SrcIp"] = self.srcIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["SrcIp"] as? String {
            self.srcIp = value
        }
    }
}

public class GetDBInstanceConnectivityDiagnosisResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var connCheckErrorCode: String?

        public var connCheckErrorMessage: String?

        public var failType: String?

        public var instanceId: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connCheckErrorCode != nil {
                map["connCheckErrorCode"] = self.connCheckErrorCode!
            }
            if self.connCheckErrorMessage != nil {
                map["connCheckErrorMessage"] = self.connCheckErrorMessage!
            }
            if self.failType != nil {
                map["failType"] = self.failType!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.success != nil {
                map["success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["connCheckErrorCode"] as? String {
                self.connCheckErrorCode = value
            }
            if let value = dict["connCheckErrorMessage"] as? String {
                self.connCheckErrorMessage = value
            }
            if let value = dict["failType"] as? String {
                self.failType = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["success"] as? Bool {
                self.success = value
            }
        }
    }
    public var code: String?

    public var data: GetDBInstanceConnectivityDiagnosisResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDBInstanceConnectivityDiagnosisResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetDBInstanceConnectivityDiagnosisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDBInstanceConnectivityDiagnosisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDBInstanceConnectivityDiagnosisResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDasProServiceUsageRequest : Tea.TeaModel {
    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class GetDasProServiceUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var commodityInstanceId: String?

        public var engine: String?

        public var expireTime: Int64?

        public var instanceAlias: String?

        public var instanceId: String?

        public var ip: String?

        public var isSpare: Bool?

        public var migrationPredictRemainingTime: Int64?

        public var port: Int32?

        public var region: String?

        public var serviceUnitId: String?

        public var sqlRetention: String?

        public var startTime: Int64?

        public var storageFreeQuotaInMB: Double?

        public var storageUsed: Int64?

        public var userId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commodityInstanceId != nil {
                map["commodityInstanceId"] = self.commodityInstanceId!
            }
            if self.engine != nil {
                map["engine"] = self.engine!
            }
            if self.expireTime != nil {
                map["expireTime"] = self.expireTime!
            }
            if self.instanceAlias != nil {
                map["instanceAlias"] = self.instanceAlias!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.ip != nil {
                map["ip"] = self.ip!
            }
            if self.isSpare != nil {
                map["isSpare"] = self.isSpare!
            }
            if self.migrationPredictRemainingTime != nil {
                map["migrationPredictRemainingTime"] = self.migrationPredictRemainingTime!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.region != nil {
                map["region"] = self.region!
            }
            if self.serviceUnitId != nil {
                map["serviceUnitId"] = self.serviceUnitId!
            }
            if self.sqlRetention != nil {
                map["sqlRetention"] = self.sqlRetention!
            }
            if self.startTime != nil {
                map["startTime"] = self.startTime!
            }
            if self.storageFreeQuotaInMB != nil {
                map["storageFreeQuotaInMB"] = self.storageFreeQuotaInMB!
            }
            if self.storageUsed != nil {
                map["storageUsed"] = self.storageUsed!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["commodityInstanceId"] as? String {
                self.commodityInstanceId = value
            }
            if let value = dict["engine"] as? String {
                self.engine = value
            }
            if let value = dict["expireTime"] as? Int64 {
                self.expireTime = value
            }
            if let value = dict["instanceAlias"] as? String {
                self.instanceAlias = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["ip"] as? String {
                self.ip = value
            }
            if let value = dict["isSpare"] as? Bool {
                self.isSpare = value
            }
            if let value = dict["migrationPredictRemainingTime"] as? Int64 {
                self.migrationPredictRemainingTime = value
            }
            if let value = dict["port"] as? Int32 {
                self.port = value
            }
            if let value = dict["region"] as? String {
                self.region = value
            }
            if let value = dict["serviceUnitId"] as? String {
                self.serviceUnitId = value
            }
            if let value = dict["sqlRetention"] as? String {
                self.sqlRetention = value
            }
            if let value = dict["startTime"] as? Int64 {
                self.startTime = value
            }
            if let value = dict["storageFreeQuotaInMB"] as? Double {
                self.storageFreeQuotaInMB = value
            }
            if let value = dict["storageUsed"] as? Int64 {
                self.storageUsed = value
            }
            if let value = dict["userId"] as? String {
                self.userId = value
            }
            if let value = dict["vpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var code: Int64?

    public var data: GetDasProServiceUsageResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDasProServiceUsageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetDasProServiceUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDasProServiceUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDasProServiceUsageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDasSQLLogHotDataRequest : Tea.TeaModel {
    public var accountName: String?

    public var childDBInstanceIDs: String?

    public var DBName: String?

    public var end: Int64?

    public var fail: String?

    public var hostAddress: String?

    public var instanceId: String?

    public var logicalOperator: String?

    public var maxLatancy: Int64?

    public var maxRecordsPerPage: Int64?

    public var maxRows: Int64?

    public var maxScanRows: Int64?

    public var maxSpillCnt: Int64?

    public var minLatancy: Int64?

    public var minRows: Int64?

    public var minScanRows: Int64?

    public var minSpillCnt: Int64?

    public var pageNumbers: Int64?

    public var queryKeyword: String?

    public var role: String?

    public var sortKey: String?

    public var sortMethod: String?

    public var sqlType: String?

    public var start: Int64?

    public var state: String?

    public var threadID: String?

    public var traceId: String?

    public var transactionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.childDBInstanceIDs != nil {
            map["ChildDBInstanceIDs"] = self.childDBInstanceIDs!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.fail != nil {
            map["Fail"] = self.fail!
        }
        if self.hostAddress != nil {
            map["HostAddress"] = self.hostAddress!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.logicalOperator != nil {
            map["LogicalOperator"] = self.logicalOperator!
        }
        if self.maxLatancy != nil {
            map["MaxLatancy"] = self.maxLatancy!
        }
        if self.maxRecordsPerPage != nil {
            map["MaxRecordsPerPage"] = self.maxRecordsPerPage!
        }
        if self.maxRows != nil {
            map["MaxRows"] = self.maxRows!
        }
        if self.maxScanRows != nil {
            map["MaxScanRows"] = self.maxScanRows!
        }
        if self.maxSpillCnt != nil {
            map["MaxSpillCnt"] = self.maxSpillCnt!
        }
        if self.minLatancy != nil {
            map["MinLatancy"] = self.minLatancy!
        }
        if self.minRows != nil {
            map["MinRows"] = self.minRows!
        }
        if self.minScanRows != nil {
            map["MinScanRows"] = self.minScanRows!
        }
        if self.minSpillCnt != nil {
            map["MinSpillCnt"] = self.minSpillCnt!
        }
        if self.pageNumbers != nil {
            map["PageNumbers"] = self.pageNumbers!
        }
        if self.queryKeyword != nil {
            map["QueryKeyword"] = self.queryKeyword!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.sortKey != nil {
            map["SortKey"] = self.sortKey!
        }
        if self.sortMethod != nil {
            map["SortMethod"] = self.sortMethod!
        }
        if self.sqlType != nil {
            map["SqlType"] = self.sqlType!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.threadID != nil {
            map["ThreadID"] = self.threadID!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        if self.transactionId != nil {
            map["TransactionId"] = self.transactionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["ChildDBInstanceIDs"] as? String {
            self.childDBInstanceIDs = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["End"] as? Int64 {
            self.end = value
        }
        if let value = dict["Fail"] as? String {
            self.fail = value
        }
        if let value = dict["HostAddress"] as? String {
            self.hostAddress = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["LogicalOperator"] as? String {
            self.logicalOperator = value
        }
        if let value = dict["MaxLatancy"] as? Int64 {
            self.maxLatancy = value
        }
        if let value = dict["MaxRecordsPerPage"] as? Int64 {
            self.maxRecordsPerPage = value
        }
        if let value = dict["MaxRows"] as? Int64 {
            self.maxRows = value
        }
        if let value = dict["MaxScanRows"] as? Int64 {
            self.maxScanRows = value
        }
        if let value = dict["MaxSpillCnt"] as? Int64 {
            self.maxSpillCnt = value
        }
        if let value = dict["MinLatancy"] as? Int64 {
            self.minLatancy = value
        }
        if let value = dict["MinRows"] as? Int64 {
            self.minRows = value
        }
        if let value = dict["MinScanRows"] as? Int64 {
            self.minScanRows = value
        }
        if let value = dict["MinSpillCnt"] as? Int64 {
            self.minSpillCnt = value
        }
        if let value = dict["PageNumbers"] as? Int64 {
            self.pageNumbers = value
        }
        if let value = dict["QueryKeyword"] as? String {
            self.queryKeyword = value
        }
        if let value = dict["Role"] as? String {
            self.role = value
        }
        if let value = dict["SortKey"] as? String {
            self.sortKey = value
        }
        if let value = dict["SortMethod"] as? String {
            self.sortMethod = value
        }
        if let value = dict["SqlType"] as? String {
            self.sqlType = value
        }
        if let value = dict["Start"] as? Int64 {
            self.start = value
        }
        if let value = dict["State"] as? String {
            self.state = value
        }
        if let value = dict["ThreadID"] as? String {
            self.threadID = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
        if let value = dict["TransactionId"] as? String {
            self.transactionId = value
        }
    }
}

public class GetDasSQLLogHotDataResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var accountName: String?

            public var DBName: String?

            public var executeTime: String?

            public var ext: String?

            public var hostAddress: String?

            public var latancy: Int64?

            public var lockTime: Int64?

            public var logicRead: Int64?

            public var originTime: String?

            public var physicAsyncRead: Int64?

            public var physicSyncRead: Int64?

            public var returnRows: Int64?

            public var SQLText: String?

            public var scanRows: Int64?

            public var sqlType: String?

            public var state: String?

            public var threadID: Int64?

            public var transactionId: String?

            public var updateRows: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountName != nil {
                    map["AccountName"] = self.accountName!
                }
                if self.DBName != nil {
                    map["DBName"] = self.DBName!
                }
                if self.executeTime != nil {
                    map["ExecuteTime"] = self.executeTime!
                }
                if self.ext != nil {
                    map["Ext"] = self.ext!
                }
                if self.hostAddress != nil {
                    map["HostAddress"] = self.hostAddress!
                }
                if self.latancy != nil {
                    map["Latancy"] = self.latancy!
                }
                if self.lockTime != nil {
                    map["LockTime"] = self.lockTime!
                }
                if self.logicRead != nil {
                    map["LogicRead"] = self.logicRead!
                }
                if self.originTime != nil {
                    map["OriginTime"] = self.originTime!
                }
                if self.physicAsyncRead != nil {
                    map["PhysicAsyncRead"] = self.physicAsyncRead!
                }
                if self.physicSyncRead != nil {
                    map["PhysicSyncRead"] = self.physicSyncRead!
                }
                if self.returnRows != nil {
                    map["ReturnRows"] = self.returnRows!
                }
                if self.SQLText != nil {
                    map["SQLText"] = self.SQLText!
                }
                if self.scanRows != nil {
                    map["ScanRows"] = self.scanRows!
                }
                if self.sqlType != nil {
                    map["SqlType"] = self.sqlType!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.threadID != nil {
                    map["ThreadID"] = self.threadID!
                }
                if self.transactionId != nil {
                    map["TransactionId"] = self.transactionId!
                }
                if self.updateRows != nil {
                    map["UpdateRows"] = self.updateRows!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountName"] as? String {
                    self.accountName = value
                }
                if let value = dict["DBName"] as? String {
                    self.DBName = value
                }
                if let value = dict["ExecuteTime"] as? String {
                    self.executeTime = value
                }
                if let value = dict["Ext"] as? String {
                    self.ext = value
                }
                if let value = dict["HostAddress"] as? String {
                    self.hostAddress = value
                }
                if let value = dict["Latancy"] as? Int64 {
                    self.latancy = value
                }
                if let value = dict["LockTime"] as? Int64 {
                    self.lockTime = value
                }
                if let value = dict["LogicRead"] as? Int64 {
                    self.logicRead = value
                }
                if let value = dict["OriginTime"] as? String {
                    self.originTime = value
                }
                if let value = dict["PhysicAsyncRead"] as? Int64 {
                    self.physicAsyncRead = value
                }
                if let value = dict["PhysicSyncRead"] as? Int64 {
                    self.physicSyncRead = value
                }
                if let value = dict["ReturnRows"] as? Int64 {
                    self.returnRows = value
                }
                if let value = dict["SQLText"] as? String {
                    self.SQLText = value
                }
                if let value = dict["ScanRows"] as? Int64 {
                    self.scanRows = value
                }
                if let value = dict["SqlType"] as? String {
                    self.sqlType = value
                }
                if let value = dict["State"] as? String {
                    self.state = value
                }
                if let value = dict["ThreadID"] as? Int64 {
                    self.threadID = value
                }
                if let value = dict["TransactionId"] as? String {
                    self.transactionId = value
                }
                if let value = dict["UpdateRows"] as? Int64 {
                    self.updateRows = value
                }
            }
        }
        public var extra: Any?

        public var list: [GetDasSQLLogHotDataResponseBody.Data.List]?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Extra"] as? Any {
                self.extra = value
            }
            if let value = dict["List"] as? [Any?] {
                var tmp : [GetDasSQLLogHotDataResponseBody.Data.List] = []
                for v in value {
                    if v != nil {
                        var model = GetDasSQLLogHotDataResponseBody.Data.List()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.list = tmp
            }
            if let value = dict["PageNo"] as? Int64 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: GetDasSQLLogHotDataResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDasSQLLogHotDataResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetDasSQLLogHotDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDasSQLLogHotDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDasSQLLogHotDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDeadLockDetailRequest : Tea.TeaModel {
    public var instanceId: String?

    public var nodeId: String?

    public var source: String?

    public var textId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.textId != nil {
            map["TextId"] = self.textId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["Source"] as? String {
            self.source = value
        }
        if let value = dict["TextId"] as? String {
            self.textId = value
        }
    }
}

public class GetDeadLockDetailResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
        if let value = dict["Synchro"] as? String {
            self.synchro = value
        }
    }
}

public class GetDeadLockDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeadLockDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDeadLockDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDeadLockDetailListRequest : Tea.TeaModel {
    public var dbNameList: String?

    public var endTime: String?

    public var instanceId: String?

    public var pageNo: String?

    public var pageSize: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbNameList != nil {
            map["DbNameList"] = self.dbNameList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DbNameList"] as? String {
            self.dbNameList = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNo"] as? String {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class GetDeadLockDetailListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class BlockProcessList : Tea.TeaModel {
                public var clientApp: String?

                public var databaseName: String?

                public var hostName: String?

                public var lastTranStarted: Int64?

                public var lockMode: String?

                public var logUsed: Int64?

                public var loginName: String?

                public var objectOwned: String?

                public var objectRequested: String?

                public var ownMode: String?

                public var spid: Int64?

                public var sqlText: String?

                public var status: String?

                public var victim: Int64?

                public var waitMode: String?

                public var waitResource: String?

                public var waitResourceDescription: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clientApp != nil {
                        map["ClientApp"] = self.clientApp!
                    }
                    if self.databaseName != nil {
                        map["DatabaseName"] = self.databaseName!
                    }
                    if self.hostName != nil {
                        map["HostName"] = self.hostName!
                    }
                    if self.lastTranStarted != nil {
                        map["LastTranStarted"] = self.lastTranStarted!
                    }
                    if self.lockMode != nil {
                        map["LockMode"] = self.lockMode!
                    }
                    if self.logUsed != nil {
                        map["LogUsed"] = self.logUsed!
                    }
                    if self.loginName != nil {
                        map["LoginName"] = self.loginName!
                    }
                    if self.objectOwned != nil {
                        map["ObjectOwned"] = self.objectOwned!
                    }
                    if self.objectRequested != nil {
                        map["ObjectRequested"] = self.objectRequested!
                    }
                    if self.ownMode != nil {
                        map["OwnMode"] = self.ownMode!
                    }
                    if self.spid != nil {
                        map["Spid"] = self.spid!
                    }
                    if self.sqlText != nil {
                        map["SqlText"] = self.sqlText!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.victim != nil {
                        map["Victim"] = self.victim!
                    }
                    if self.waitMode != nil {
                        map["WaitMode"] = self.waitMode!
                    }
                    if self.waitResource != nil {
                        map["WaitResource"] = self.waitResource!
                    }
                    if self.waitResourceDescription != nil {
                        map["WaitResourceDescription"] = self.waitResourceDescription!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ClientApp"] as? String {
                        self.clientApp = value
                    }
                    if let value = dict["DatabaseName"] as? String {
                        self.databaseName = value
                    }
                    if let value = dict["HostName"] as? String {
                        self.hostName = value
                    }
                    if let value = dict["LastTranStarted"] as? Int64 {
                        self.lastTranStarted = value
                    }
                    if let value = dict["LockMode"] as? String {
                        self.lockMode = value
                    }
                    if let value = dict["LogUsed"] as? Int64 {
                        self.logUsed = value
                    }
                    if let value = dict["LoginName"] as? String {
                        self.loginName = value
                    }
                    if let value = dict["ObjectOwned"] as? String {
                        self.objectOwned = value
                    }
                    if let value = dict["ObjectRequested"] as? String {
                        self.objectRequested = value
                    }
                    if let value = dict["OwnMode"] as? String {
                        self.ownMode = value
                    }
                    if let value = dict["Spid"] as? Int64 {
                        self.spid = value
                    }
                    if let value = dict["SqlText"] as? String {
                        self.sqlText = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                    if let value = dict["Victim"] as? Int64 {
                        self.victim = value
                    }
                    if let value = dict["WaitMode"] as? String {
                        self.waitMode = value
                    }
                    if let value = dict["WaitResource"] as? String {
                        self.waitResource = value
                    }
                    if let value = dict["WaitResourceDescription"] as? String {
                        self.waitResourceDescription = value
                    }
                }
            }
            public var batchId: Int64?

            public var blockProcessList: [GetDeadLockDetailListResponseBody.Data.List.BlockProcessList]?

            public var clientApp: String?

            public var databaseName: String?

            public var hostName: String?

            public var lastTranStarted: Int64?

            public var lockMode: String?

            public var logUsed: Int64?

            public var loginName: String?

            public var objectOwned: String?

            public var objectRequested: String?

            public var ownMode: String?

            public var spid: Int64?

            public var sqlText: String?

            public var status: String?

            public var victim: Int64?

            public var waitMode: String?

            public var waitResource: String?

            public var waitResourceDescription: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.batchId != nil {
                    map["BatchId"] = self.batchId!
                }
                if self.blockProcessList != nil {
                    var tmp : [Any] = []
                    for k in self.blockProcessList! {
                        tmp.append(k.toMap())
                    }
                    map["BlockProcessList"] = tmp
                }
                if self.clientApp != nil {
                    map["ClientApp"] = self.clientApp!
                }
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.lastTranStarted != nil {
                    map["LastTranStarted"] = self.lastTranStarted!
                }
                if self.lockMode != nil {
                    map["LockMode"] = self.lockMode!
                }
                if self.logUsed != nil {
                    map["LogUsed"] = self.logUsed!
                }
                if self.loginName != nil {
                    map["LoginName"] = self.loginName!
                }
                if self.objectOwned != nil {
                    map["ObjectOwned"] = self.objectOwned!
                }
                if self.objectRequested != nil {
                    map["ObjectRequested"] = self.objectRequested!
                }
                if self.ownMode != nil {
                    map["OwnMode"] = self.ownMode!
                }
                if self.spid != nil {
                    map["Spid"] = self.spid!
                }
                if self.sqlText != nil {
                    map["SqlText"] = self.sqlText!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.victim != nil {
                    map["Victim"] = self.victim!
                }
                if self.waitMode != nil {
                    map["WaitMode"] = self.waitMode!
                }
                if self.waitResource != nil {
                    map["WaitResource"] = self.waitResource!
                }
                if self.waitResourceDescription != nil {
                    map["WaitResourceDescription"] = self.waitResourceDescription!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BatchId"] as? Int64 {
                    self.batchId = value
                }
                if let value = dict["BlockProcessList"] as? [Any?] {
                    var tmp : [GetDeadLockDetailListResponseBody.Data.List.BlockProcessList] = []
                    for v in value {
                        if v != nil {
                            var model = GetDeadLockDetailListResponseBody.Data.List.BlockProcessList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.blockProcessList = tmp
                }
                if let value = dict["ClientApp"] as? String {
                    self.clientApp = value
                }
                if let value = dict["DatabaseName"] as? String {
                    self.databaseName = value
                }
                if let value = dict["HostName"] as? String {
                    self.hostName = value
                }
                if let value = dict["LastTranStarted"] as? Int64 {
                    self.lastTranStarted = value
                }
                if let value = dict["LockMode"] as? String {
                    self.lockMode = value
                }
                if let value = dict["LogUsed"] as? Int64 {
                    self.logUsed = value
                }
                if let value = dict["LoginName"] as? String {
                    self.loginName = value
                }
                if let value = dict["ObjectOwned"] as? String {
                    self.objectOwned = value
                }
                if let value = dict["ObjectRequested"] as? String {
                    self.objectRequested = value
                }
                if let value = dict["OwnMode"] as? String {
                    self.ownMode = value
                }
                if let value = dict["Spid"] as? Int64 {
                    self.spid = value
                }
                if let value = dict["SqlText"] as? String {
                    self.sqlText = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Victim"] as? Int64 {
                    self.victim = value
                }
                if let value = dict["WaitMode"] as? String {
                    self.waitMode = value
                }
                if let value = dict["WaitResource"] as? String {
                    self.waitResource = value
                }
                if let value = dict["WaitResourceDescription"] as? String {
                    self.waitResourceDescription = value
                }
            }
        }
        public var list: [GetDeadLockDetailListResponseBody.Data.List]?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["List"] as? [Any?] {
                var tmp : [GetDeadLockDetailListResponseBody.Data.List] = []
                for v in value {
                    if v != nil {
                        var model = GetDeadLockDetailListResponseBody.Data.List()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.list = tmp
            }
            if let value = dict["PageNo"] as? Int64 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: GetDeadLockDetailListResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDeadLockDetailListResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetDeadLockDetailListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeadLockDetailListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDeadLockDetailListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDeadLockHistoryRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var nodeId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var source: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Source"] as? String {
            self.source = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class GetDeadLockHistoryResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
        if let value = dict["Synchro"] as? String {
            self.synchro = value
        }
    }
}

public class GetDeadLockHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeadLockHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDeadLockHistoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDeadlockHistogramRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var nodeId: String?

    public var startTime: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class GetDeadlockHistogramResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var endTime: String?

        public var instanceId: String?

        public var lockNumber: Int32?

        public var nodeId: String?

        public var startTime: String?

        public var status: String?

        public var taskId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lockNumber != nil {
                map["LockNumber"] = self.lockNumber!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LockNumber"] as? Int32 {
                self.lockNumber = value
            }
            if let value = dict["NodeId"] as? String {
                self.nodeId = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
        }
    }
    public var code: Int64?

    public var data: [GetDeadlockHistogramResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [GetDeadlockHistogramResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = GetDeadlockHistogramResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetDeadlockHistogramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeadlockHistogramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDeadlockHistogramResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetEndpointSwitchTaskRequest : Tea.TeaModel {
    public var taskId: String?

    public var uid: String?

    public var userId: String?

    public var context: String?

    public var accessKey: String?

    public var signature: String?

    public var skipAuth: String?

    public var timestamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.context != nil {
            map["__context"] = self.context!
        }
        if self.accessKey != nil {
            map["accessKey"] = self.accessKey!
        }
        if self.signature != nil {
            map["signature"] = self.signature!
        }
        if self.skipAuth != nil {
            map["skipAuth"] = self.skipAuth!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
        if let value = dict["Uid"] as? String {
            self.uid = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
        if let value = dict["__context"] as? String {
            self.context = value
        }
        if let value = dict["accessKey"] as? String {
            self.accessKey = value
        }
        if let value = dict["signature"] as? String {
            self.signature = value
        }
        if let value = dict["skipAuth"] as? String {
            self.skipAuth = value
        }
        if let value = dict["timestamp"] as? String {
            self.timestamp = value
        }
    }
}

public class GetEndpointSwitchTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accountId: String?

        public var dbLinkId: Int64?

        public var errMsg: String?

        public var oriUuid: String?

        public var status: String?

        public var taskId: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.dbLinkId != nil {
                map["DbLinkId"] = self.dbLinkId!
            }
            if self.errMsg != nil {
                map["ErrMsg"] = self.errMsg!
            }
            if self.oriUuid != nil {
                map["OriUuid"] = self.oriUuid!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? String {
                self.accountId = value
            }
            if let value = dict["DbLinkId"] as? Int64 {
                self.dbLinkId = value
            }
            if let value = dict["ErrMsg"] as? String {
                self.errMsg = value
            }
            if let value = dict["OriUuid"] as? String {
                self.oriUuid = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
            if let value = dict["Uuid"] as? String {
                self.uuid = value
            }
        }
    }
    public var code: String?

    public var data: GetEndpointSwitchTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetEndpointSwitchTaskResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
        if let value = dict["Synchro"] as? String {
            self.synchro = value
        }
    }
}

public class GetEndpointSwitchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEndpointSwitchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetEndpointSwitchTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetErrorRequestSampleRequest : Tea.TeaModel {
    public var dbName: String?

    public var end: Int64?

    public var instanceId: String?

    public var nodeId: String?

    public var sqlId: String?

    public var start: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DbName"] as? String {
            self.dbName = value
        }
        if let value = dict["End"] as? Int64 {
            self.end = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["SqlId"] as? String {
            self.sqlId = value
        }
        if let value = dict["Start"] as? Int64 {
            self.start = value
        }
    }
}

public class GetErrorRequestSampleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var database: String?

        public var errorCode: String?

        public var instanceId: String?

        public var originHost: String?

        public var sql: String?

        public var sqlId: String?

        public var tables: [String]?

        public var timestamp: Int64?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.database != nil {
                map["database"] = self.database!
            }
            if self.errorCode != nil {
                map["errorCode"] = self.errorCode!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.originHost != nil {
                map["originHost"] = self.originHost!
            }
            if self.sql != nil {
                map["sql"] = self.sql!
            }
            if self.sqlId != nil {
                map["sqlId"] = self.sqlId!
            }
            if self.tables != nil {
                map["tables"] = self.tables!
            }
            if self.timestamp != nil {
                map["timestamp"] = self.timestamp!
            }
            if self.user != nil {
                map["user"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["database"] as? String {
                self.database = value
            }
            if let value = dict["errorCode"] as? String {
                self.errorCode = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["originHost"] as? String {
                self.originHost = value
            }
            if let value = dict["sql"] as? String {
                self.sql = value
            }
            if let value = dict["sqlId"] as? String {
                self.sqlId = value
            }
            if let value = dict["tables"] as? [String] {
                self.tables = value
            }
            if let value = dict["timestamp"] as? Int64 {
                self.timestamp = value
            }
            if let value = dict["user"] as? String {
                self.user = value
            }
        }
    }
    public var code: Int64?

    public var data: [GetErrorRequestSampleResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [GetErrorRequestSampleResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = GetErrorRequestSampleResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetErrorRequestSampleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetErrorRequestSampleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetErrorRequestSampleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetEventSubscriptionRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetEventSubscriptionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ContactGroups : Tea.TeaModel {
            public var contacts: String?

            public var description_: String?

            public var name: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contacts != nil {
                    map["contacts"] = self.contacts!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["contacts"] as? String {
                    self.contacts = value
                }
                if let value = dict["description"] as? String {
                    self.description_ = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["userId"] as? String {
                    self.userId = value
                }
            }
        }
        public class Contacts : Tea.TeaModel {
            public var dingtalkHook: String?

            public var email: String?

            public var groups: [String]?

            public var isCmsReduplicated: Bool?

            public var name: String?

            public var phone: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dingtalkHook != nil {
                    map["dingtalkHook"] = self.dingtalkHook!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.groups != nil {
                    map["groups"] = self.groups!
                }
                if self.isCmsReduplicated != nil {
                    map["isCmsReduplicated"] = self.isCmsReduplicated!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.phone != nil {
                    map["phone"] = self.phone!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["dingtalkHook"] as? String {
                    self.dingtalkHook = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["groups"] as? [String] {
                    self.groups = value
                }
                if let value = dict["isCmsReduplicated"] as? Bool {
                    self.isCmsReduplicated = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["phone"] as? String {
                    self.phone = value
                }
                if let value = dict["userId"] as? String {
                    self.userId = value
                }
            }
        }
        public var active: Int32?

        public var channelType: String?

        public var contactGroupName: String?

        public var contactGroups: [GetEventSubscriptionResponseBody.Data.ContactGroups]?

        public var contactName: String?

        public var contacts: [GetEventSubscriptionResponseBody.Data.Contacts]?

        public var eventContext: String?

        public var eventSendGroup: [String]?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var instanceId: String?

        public var lang: String?

        public var level: String?

        public var minInterval: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.active != nil {
                map["active"] = self.active!
            }
            if self.channelType != nil {
                map["channelType"] = self.channelType!
            }
            if self.contactGroupName != nil {
                map["contactGroupName"] = self.contactGroupName!
            }
            if self.contactGroups != nil {
                var tmp : [Any] = []
                for k in self.contactGroups! {
                    tmp.append(k.toMap())
                }
                map["contactGroups"] = tmp
            }
            if self.contactName != nil {
                map["contactName"] = self.contactName!
            }
            if self.contacts != nil {
                var tmp : [Any] = []
                for k in self.contacts! {
                    tmp.append(k.toMap())
                }
                map["contacts"] = tmp
            }
            if self.eventContext != nil {
                map["eventContext"] = self.eventContext!
            }
            if self.eventSendGroup != nil {
                map["eventSendGroup"] = self.eventSendGroup!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.lang != nil {
                map["lang"] = self.lang!
            }
            if self.level != nil {
                map["level"] = self.level!
            }
            if self.minInterval != nil {
                map["minInterval"] = self.minInterval!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["active"] as? Int32 {
                self.active = value
            }
            if let value = dict["channelType"] as? String {
                self.channelType = value
            }
            if let value = dict["contactGroupName"] as? String {
                self.contactGroupName = value
            }
            if let value = dict["contactGroups"] as? [Any?] {
                var tmp : [GetEventSubscriptionResponseBody.Data.ContactGroups] = []
                for v in value {
                    if v != nil {
                        var model = GetEventSubscriptionResponseBody.Data.ContactGroups()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.contactGroups = tmp
            }
            if let value = dict["contactName"] as? String {
                self.contactName = value
            }
            if let value = dict["contacts"] as? [Any?] {
                var tmp : [GetEventSubscriptionResponseBody.Data.Contacts] = []
                for v in value {
                    if v != nil {
                        var model = GetEventSubscriptionResponseBody.Data.Contacts()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.contacts = tmp
            }
            if let value = dict["eventContext"] as? String {
                self.eventContext = value
            }
            if let value = dict["eventSendGroup"] as? [String] {
                self.eventSendGroup = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["lang"] as? String {
                self.lang = value
            }
            if let value = dict["level"] as? String {
                self.level = value
            }
            if let value = dict["minInterval"] as? String {
                self.minInterval = value
            }
            if let value = dict["userId"] as? String {
                self.userId = value
            }
        }
    }
    public var code: String?

    public var data: GetEventSubscriptionResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetEventSubscriptionResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetEventSubscriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEventSubscriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetEventSubscriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetFullRequestOriginStatByInstanceIdRequest : Tea.TeaModel {
    public var asc: Bool?

    public var end: Int64?

    public var instanceId: String?

    public var nodeId: String?

    public var orderBy: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var role: String?

    public var sqlType: String?

    public var start: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.sqlType != nil {
            map["SqlType"] = self.sqlType!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Asc"] as? Bool {
            self.asc = value
        }
        if let value = dict["End"] as? Int64 {
            self.end = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Role"] as? String {
            self.role = value
        }
        if let value = dict["SqlType"] as? String {
            self.sqlType = value
        }
        if let value = dict["Start"] as? Int64 {
            self.start = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class GetFullRequestOriginStatByInstanceIdResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var avgExaminedRows: Double?

            public var avgFetchRows: Int64?

            public var avgLockWaitTime: Double?

            public var avgLogicalRead: Double?

            public var avgPhysicalAsyncRead: Int64?

            public var avgPhysicalSyncRead: Double?

            public var avgReturnedRows: Double?

            public var avgRows: Int64?

            public var avgRt: Double?

            public var avgSqlCount: Int64?

            public var avgUpdatedRows: Double?

            public var count: Int64?

            public var countRate: Double?

            public var database: String?

            public var errorCount: Int64?

            public var examinedRows: Int64?

            public var fetchRows: Int64?

            public var ip: String?

            public var key: String?

            public var lockWaitTime: Double?

            public var logicalRead: Int64?

            public var originHost: String?

            public var physicalAsyncRead: Int64?

            public var physicalSyncRead: Int64?

            public var port: Int64?

            public var rows: Int64?

            public var rtGreaterThanOneSecondCount: Int64?

            public var rtRate: Double?

            public var sqlCount: Int64?

            public var sumUpdatedRows: Int64?

            public var version: Int64?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgExaminedRows != nil {
                    map["AvgExaminedRows"] = self.avgExaminedRows!
                }
                if self.avgFetchRows != nil {
                    map["AvgFetchRows"] = self.avgFetchRows!
                }
                if self.avgLockWaitTime != nil {
                    map["AvgLockWaitTime"] = self.avgLockWaitTime!
                }
                if self.avgLogicalRead != nil {
                    map["AvgLogicalRead"] = self.avgLogicalRead!
                }
                if self.avgPhysicalAsyncRead != nil {
                    map["AvgPhysicalAsyncRead"] = self.avgPhysicalAsyncRead!
                }
                if self.avgPhysicalSyncRead != nil {
                    map["AvgPhysicalSyncRead"] = self.avgPhysicalSyncRead!
                }
                if self.avgReturnedRows != nil {
                    map["AvgReturnedRows"] = self.avgReturnedRows!
                }
                if self.avgRows != nil {
                    map["AvgRows"] = self.avgRows!
                }
                if self.avgRt != nil {
                    map["AvgRt"] = self.avgRt!
                }
                if self.avgSqlCount != nil {
                    map["AvgSqlCount"] = self.avgSqlCount!
                }
                if self.avgUpdatedRows != nil {
                    map["AvgUpdatedRows"] = self.avgUpdatedRows!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.countRate != nil {
                    map["CountRate"] = self.countRate!
                }
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.errorCount != nil {
                    map["ErrorCount"] = self.errorCount!
                }
                if self.examinedRows != nil {
                    map["ExaminedRows"] = self.examinedRows!
                }
                if self.fetchRows != nil {
                    map["FetchRows"] = self.fetchRows!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.lockWaitTime != nil {
                    map["LockWaitTime"] = self.lockWaitTime!
                }
                if self.logicalRead != nil {
                    map["LogicalRead"] = self.logicalRead!
                }
                if self.originHost != nil {
                    map["OriginHost"] = self.originHost!
                }
                if self.physicalAsyncRead != nil {
                    map["PhysicalAsyncRead"] = self.physicalAsyncRead!
                }
                if self.physicalSyncRead != nil {
                    map["PhysicalSyncRead"] = self.physicalSyncRead!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.rows != nil {
                    map["Rows"] = self.rows!
                }
                if self.rtGreaterThanOneSecondCount != nil {
                    map["RtGreaterThanOneSecondCount"] = self.rtGreaterThanOneSecondCount!
                }
                if self.rtRate != nil {
                    map["RtRate"] = self.rtRate!
                }
                if self.sqlCount != nil {
                    map["SqlCount"] = self.sqlCount!
                }
                if self.sumUpdatedRows != nil {
                    map["SumUpdatedRows"] = self.sumUpdatedRows!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AvgExaminedRows"] as? Double {
                    self.avgExaminedRows = value
                }
                if let value = dict["AvgFetchRows"] as? Int64 {
                    self.avgFetchRows = value
                }
                if let value = dict["AvgLockWaitTime"] as? Double {
                    self.avgLockWaitTime = value
                }
                if let value = dict["AvgLogicalRead"] as? Double {
                    self.avgLogicalRead = value
                }
                if let value = dict["AvgPhysicalAsyncRead"] as? Int64 {
                    self.avgPhysicalAsyncRead = value
                }
                if let value = dict["AvgPhysicalSyncRead"] as? Double {
                    self.avgPhysicalSyncRead = value
                }
                if let value = dict["AvgReturnedRows"] as? Double {
                    self.avgReturnedRows = value
                }
                if let value = dict["AvgRows"] as? Int64 {
                    self.avgRows = value
                }
                if let value = dict["AvgRt"] as? Double {
                    self.avgRt = value
                }
                if let value = dict["AvgSqlCount"] as? Int64 {
                    self.avgSqlCount = value
                }
                if let value = dict["AvgUpdatedRows"] as? Double {
                    self.avgUpdatedRows = value
                }
                if let value = dict["Count"] as? Int64 {
                    self.count = value
                }
                if let value = dict["CountRate"] as? Double {
                    self.countRate = value
                }
                if let value = dict["Database"] as? String {
                    self.database = value
                }
                if let value = dict["ErrorCount"] as? Int64 {
                    self.errorCount = value
                }
                if let value = dict["ExaminedRows"] as? Int64 {
                    self.examinedRows = value
                }
                if let value = dict["FetchRows"] as? Int64 {
                    self.fetchRows = value
                }
                if let value = dict["Ip"] as? String {
                    self.ip = value
                }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["LockWaitTime"] as? Double {
                    self.lockWaitTime = value
                }
                if let value = dict["LogicalRead"] as? Int64 {
                    self.logicalRead = value
                }
                if let value = dict["OriginHost"] as? String {
                    self.originHost = value
                }
                if let value = dict["PhysicalAsyncRead"] as? Int64 {
                    self.physicalAsyncRead = value
                }
                if let value = dict["PhysicalSyncRead"] as? Int64 {
                    self.physicalSyncRead = value
                }
                if let value = dict["Port"] as? Int64 {
                    self.port = value
                }
                if let value = dict["Rows"] as? Int64 {
                    self.rows = value
                }
                if let value = dict["RtGreaterThanOneSecondCount"] as? Int64 {
                    self.rtGreaterThanOneSecondCount = value
                }
                if let value = dict["RtRate"] as? Double {
                    self.rtRate = value
                }
                if let value = dict["SqlCount"] as? Int64 {
                    self.sqlCount = value
                }
                if let value = dict["SumUpdatedRows"] as? Int64 {
                    self.sumUpdatedRows = value
                }
                if let value = dict["Version"] as? Int64 {
                    self.version = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var list: [GetFullRequestOriginStatByInstanceIdResponseBody.Data.List]?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["List"] as? [Any?] {
                var tmp : [GetFullRequestOriginStatByInstanceIdResponseBody.Data.List] = []
                for v in value {
                    if v != nil {
                        var model = GetFullRequestOriginStatByInstanceIdResponseBody.Data.List()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.list = tmp
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: Int64?

    public var data: GetFullRequestOriginStatByInstanceIdResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetFullRequestOriginStatByInstanceIdResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetFullRequestOriginStatByInstanceIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFullRequestOriginStatByInstanceIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetFullRequestOriginStatByInstanceIdResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetFullRequestSampleByInstanceIdRequest : Tea.TeaModel {
    public var end: Int64?

    public var instanceId: String?

    public var role: String?

    public var sqlId: String?

    public var start: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["End"] as? Int64 {
            self.end = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Role"] as? String {
            self.role = value
        }
        if let value = dict["SqlId"] as? String {
            self.sqlId = value
        }
        if let value = dict["Start"] as? Int64 {
            self.start = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class GetFullRequestSampleByInstanceIdResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var database: String?

        public var frows: Int64?

        public var lockWaitTime: Double?

        public var logicalRead: Double?

        public var originHost: String?

        public var physicalAsyncRead: Double?

        public var physicalSyncRead: Double?

        public var rows: Int64?

        public var rowsExamined: Int64?

        public var rowsReturned: Int64?

        public var rt: Double?

        public var scanRows: Int64?

        public var scnt: Int64?

        public var sql: String?

        public var sqlId: String?

        public var sqlType: String?

        public var timestamp: Int64?

        public var updateRows: Int64?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.database != nil {
                map["Database"] = self.database!
            }
            if self.frows != nil {
                map["Frows"] = self.frows!
            }
            if self.lockWaitTime != nil {
                map["LockWaitTime"] = self.lockWaitTime!
            }
            if self.logicalRead != nil {
                map["LogicalRead"] = self.logicalRead!
            }
            if self.originHost != nil {
                map["OriginHost"] = self.originHost!
            }
            if self.physicalAsyncRead != nil {
                map["PhysicalAsyncRead"] = self.physicalAsyncRead!
            }
            if self.physicalSyncRead != nil {
                map["PhysicalSyncRead"] = self.physicalSyncRead!
            }
            if self.rows != nil {
                map["Rows"] = self.rows!
            }
            if self.rowsExamined != nil {
                map["RowsExamined"] = self.rowsExamined!
            }
            if self.rowsReturned != nil {
                map["RowsReturned"] = self.rowsReturned!
            }
            if self.rt != nil {
                map["Rt"] = self.rt!
            }
            if self.scanRows != nil {
                map["ScanRows"] = self.scanRows!
            }
            if self.scnt != nil {
                map["Scnt"] = self.scnt!
            }
            if self.sql != nil {
                map["Sql"] = self.sql!
            }
            if self.sqlId != nil {
                map["SqlId"] = self.sqlId!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.updateRows != nil {
                map["UpdateRows"] = self.updateRows!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Database"] as? String {
                self.database = value
            }
            if let value = dict["Frows"] as? Int64 {
                self.frows = value
            }
            if let value = dict["LockWaitTime"] as? Double {
                self.lockWaitTime = value
            }
            if let value = dict["LogicalRead"] as? Double {
                self.logicalRead = value
            }
            if let value = dict["OriginHost"] as? String {
                self.originHost = value
            }
            if let value = dict["PhysicalAsyncRead"] as? Double {
                self.physicalAsyncRead = value
            }
            if let value = dict["PhysicalSyncRead"] as? Double {
                self.physicalSyncRead = value
            }
            if let value = dict["Rows"] as? Int64 {
                self.rows = value
            }
            if let value = dict["RowsExamined"] as? Int64 {
                self.rowsExamined = value
            }
            if let value = dict["RowsReturned"] as? Int64 {
                self.rowsReturned = value
            }
            if let value = dict["Rt"] as? Double {
                self.rt = value
            }
            if let value = dict["ScanRows"] as? Int64 {
                self.scanRows = value
            }
            if let value = dict["Scnt"] as? Int64 {
                self.scnt = value
            }
            if let value = dict["Sql"] as? String {
                self.sql = value
            }
            if let value = dict["SqlId"] as? String {
                self.sqlId = value
            }
            if let value = dict["SqlType"] as? String {
                self.sqlType = value
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
            if let value = dict["UpdateRows"] as? Int64 {
                self.updateRows = value
            }
            if let value = dict["User"] as? String {
                self.user = value
            }
        }
    }
    public var code: Int64?

    public var data: [GetFullRequestSampleByInstanceIdResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [GetFullRequestSampleByInstanceIdResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = GetFullRequestSampleByInstanceIdResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetFullRequestSampleByInstanceIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFullRequestSampleByInstanceIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetFullRequestSampleByInstanceIdResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetFullRequestStatResultByInstanceIdRequest : Tea.TeaModel {
    public var asc: Bool?

    public var dbName: String?

    public var end: Int64?

    public var instanceId: String?

    public var keyword: String?

    public var nodeId: String?

    public var orderBy: String?

    public var originHost: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var role: String?

    public var sqlId: String?

    public var sqlType: String?

    public var start: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.originHost != nil {
            map["OriginHost"] = self.originHost!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.sqlType != nil {
            map["SqlType"] = self.sqlType!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Asc"] as? Bool {
            self.asc = value
        }
        if let value = dict["DbName"] as? String {
            self.dbName = value
        }
        if let value = dict["End"] as? Int64 {
            self.end = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["OriginHost"] as? String {
            self.originHost = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Role"] as? String {
            self.role = value
        }
        if let value = dict["SqlId"] as? String {
            self.sqlId = value
        }
        if let value = dict["SqlType"] as? String {
            self.sqlType = value
        }
        if let value = dict["Start"] as? Int64 {
            self.start = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class GetFullRequestStatResultByInstanceIdResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class List : Tea.TeaModel {
                public var avgExaminedRows: Double?

                public var avgFetchRows: Int64?

                public var avgLockWaitTime: Double?

                public var avgLogicalRead: Double?

                public var avgPhysicalAsyncRead: Int64?

                public var avgPhysicalSyncRead: Int64?

                public var avgReturnedRows: Double?

                public var avgRt: Double?

                public var avgSqlCount: Int64?

                public var avgUpdatedRows: Int64?

                public var count: Int64?

                public var countRate: Double?

                public var database: String?

                public var errorCount: Int64?

                public var examinedRows: Int64?

                public var fetchRows: Int64?

                public var ip: String?

                public var lockWaitTime: Double?

                public var logicalRead: Int64?

                public var physicalAsyncRead: Int64?

                public var physicalSyncRead: Int64?

                public var port: Int64?

                public var psql: String?

                public var rows: Int64?

                public var rtGreaterThanOneSecondCount: Int64?

                public var rtRate: Double?

                public var sqlCount: Int64?

                public var sqlId: String?

                public var sumUpdatedRows: Int64?

                public var tables: [String]?

                public var version: Int64?

                public var vpcId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgExaminedRows != nil {
                        map["AvgExaminedRows"] = self.avgExaminedRows!
                    }
                    if self.avgFetchRows != nil {
                        map["AvgFetchRows"] = self.avgFetchRows!
                    }
                    if self.avgLockWaitTime != nil {
                        map["AvgLockWaitTime"] = self.avgLockWaitTime!
                    }
                    if self.avgLogicalRead != nil {
                        map["AvgLogicalRead"] = self.avgLogicalRead!
                    }
                    if self.avgPhysicalAsyncRead != nil {
                        map["AvgPhysicalAsyncRead"] = self.avgPhysicalAsyncRead!
                    }
                    if self.avgPhysicalSyncRead != nil {
                        map["AvgPhysicalSyncRead"] = self.avgPhysicalSyncRead!
                    }
                    if self.avgReturnedRows != nil {
                        map["AvgReturnedRows"] = self.avgReturnedRows!
                    }
                    if self.avgRt != nil {
                        map["AvgRt"] = self.avgRt!
                    }
                    if self.avgSqlCount != nil {
                        map["AvgSqlCount"] = self.avgSqlCount!
                    }
                    if self.avgUpdatedRows != nil {
                        map["AvgUpdatedRows"] = self.avgUpdatedRows!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.countRate != nil {
                        map["CountRate"] = self.countRate!
                    }
                    if self.database != nil {
                        map["Database"] = self.database!
                    }
                    if self.errorCount != nil {
                        map["ErrorCount"] = self.errorCount!
                    }
                    if self.examinedRows != nil {
                        map["ExaminedRows"] = self.examinedRows!
                    }
                    if self.fetchRows != nil {
                        map["FetchRows"] = self.fetchRows!
                    }
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    if self.lockWaitTime != nil {
                        map["LockWaitTime"] = self.lockWaitTime!
                    }
                    if self.logicalRead != nil {
                        map["LogicalRead"] = self.logicalRead!
                    }
                    if self.physicalAsyncRead != nil {
                        map["PhysicalAsyncRead"] = self.physicalAsyncRead!
                    }
                    if self.physicalSyncRead != nil {
                        map["PhysicalSyncRead"] = self.physicalSyncRead!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.psql != nil {
                        map["Psql"] = self.psql!
                    }
                    if self.rows != nil {
                        map["Rows"] = self.rows!
                    }
                    if self.rtGreaterThanOneSecondCount != nil {
                        map["RtGreaterThanOneSecondCount"] = self.rtGreaterThanOneSecondCount!
                    }
                    if self.rtRate != nil {
                        map["RtRate"] = self.rtRate!
                    }
                    if self.sqlCount != nil {
                        map["SqlCount"] = self.sqlCount!
                    }
                    if self.sqlId != nil {
                        map["SqlId"] = self.sqlId!
                    }
                    if self.sumUpdatedRows != nil {
                        map["SumUpdatedRows"] = self.sumUpdatedRows!
                    }
                    if self.tables != nil {
                        map["Tables"] = self.tables!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AvgExaminedRows"] as? Double {
                        self.avgExaminedRows = value
                    }
                    if let value = dict["AvgFetchRows"] as? Int64 {
                        self.avgFetchRows = value
                    }
                    if let value = dict["AvgLockWaitTime"] as? Double {
                        self.avgLockWaitTime = value
                    }
                    if let value = dict["AvgLogicalRead"] as? Double {
                        self.avgLogicalRead = value
                    }
                    if let value = dict["AvgPhysicalAsyncRead"] as? Int64 {
                        self.avgPhysicalAsyncRead = value
                    }
                    if let value = dict["AvgPhysicalSyncRead"] as? Int64 {
                        self.avgPhysicalSyncRead = value
                    }
                    if let value = dict["AvgReturnedRows"] as? Double {
                        self.avgReturnedRows = value
                    }
                    if let value = dict["AvgRt"] as? Double {
                        self.avgRt = value
                    }
                    if let value = dict["AvgSqlCount"] as? Int64 {
                        self.avgSqlCount = value
                    }
                    if let value = dict["AvgUpdatedRows"] as? Int64 {
                        self.avgUpdatedRows = value
                    }
                    if let value = dict["Count"] as? Int64 {
                        self.count = value
                    }
                    if let value = dict["CountRate"] as? Double {
                        self.countRate = value
                    }
                    if let value = dict["Database"] as? String {
                        self.database = value
                    }
                    if let value = dict["ErrorCount"] as? Int64 {
                        self.errorCount = value
                    }
                    if let value = dict["ExaminedRows"] as? Int64 {
                        self.examinedRows = value
                    }
                    if let value = dict["FetchRows"] as? Int64 {
                        self.fetchRows = value
                    }
                    if let value = dict["Ip"] as? String {
                        self.ip = value
                    }
                    if let value = dict["LockWaitTime"] as? Double {
                        self.lockWaitTime = value
                    }
                    if let value = dict["LogicalRead"] as? Int64 {
                        self.logicalRead = value
                    }
                    if let value = dict["PhysicalAsyncRead"] as? Int64 {
                        self.physicalAsyncRead = value
                    }
                    if let value = dict["PhysicalSyncRead"] as? Int64 {
                        self.physicalSyncRead = value
                    }
                    if let value = dict["Port"] as? Int64 {
                        self.port = value
                    }
                    if let value = dict["Psql"] as? String {
                        self.psql = value
                    }
                    if let value = dict["Rows"] as? Int64 {
                        self.rows = value
                    }
                    if let value = dict["RtGreaterThanOneSecondCount"] as? Int64 {
                        self.rtGreaterThanOneSecondCount = value
                    }
                    if let value = dict["RtRate"] as? Double {
                        self.rtRate = value
                    }
                    if let value = dict["SqlCount"] as? Int64 {
                        self.sqlCount = value
                    }
                    if let value = dict["SqlId"] as? String {
                        self.sqlId = value
                    }
                    if let value = dict["SumUpdatedRows"] as? Int64 {
                        self.sumUpdatedRows = value
                    }
                    if let value = dict["Tables"] as? [String] {
                        self.tables = value
                    }
                    if let value = dict["Version"] as? Int64 {
                        self.version = value
                    }
                    if let value = dict["VpcId"] as? String {
                        self.vpcId = value
                    }
                }
            }
            public var list: [GetFullRequestStatResultByInstanceIdResponseBody.Data.Result.List]?

            public var total: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.list != nil {
                    var tmp : [Any] = []
                    for k in self.list! {
                        tmp.append(k.toMap())
                    }
                    map["List"] = tmp
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["List"] as? [Any?] {
                    var tmp : [GetFullRequestStatResultByInstanceIdResponseBody.Data.Result.List] = []
                    for v in value {
                        if v != nil {
                            var model = GetFullRequestStatResultByInstanceIdResponseBody.Data.Result.List()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.list = tmp
                }
                if let value = dict["Total"] as? Int64 {
                    self.total = value
                }
            }
        }
        public var fail: Bool?

        public var isFinish: Bool?

        public var result: GetFullRequestStatResultByInstanceIdResponseBody.Data.Result?

        public var resultId: String?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.result?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fail != nil {
                map["Fail"] = self.fail!
            }
            if self.isFinish != nil {
                map["IsFinish"] = self.isFinish!
            }
            if self.result != nil {
                map["Result"] = self.result?.toMap()
            }
            if self.resultId != nil {
                map["ResultId"] = self.resultId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Fail"] as? Bool {
                self.fail = value
            }
            if let value = dict["IsFinish"] as? Bool {
                self.isFinish = value
            }
            if let value = dict["Result"] as? [String: Any?] {
                var model = GetFullRequestStatResultByInstanceIdResponseBody.Data.Result()
                model.fromMap(value)
                self.result = model
            }
            if let value = dict["ResultId"] as? String {
                self.resultId = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
        }
    }
    public var code: Int64?

    public var data: GetFullRequestStatResultByInstanceIdResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetFullRequestStatResultByInstanceIdResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetFullRequestStatResultByInstanceIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFullRequestStatResultByInstanceIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetFullRequestStatResultByInstanceIdResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetHDMAliyunResourceSyncResultRequest : Tea.TeaModel {
    public var taskId: String?

    public var uid: String?

    public var userId: String?

    public var context: String?

    public var accessKey: String?

    public var signature: String?

    public var skipAuth: String?

    public var timestamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.context != nil {
            map["__context"] = self.context!
        }
        if self.accessKey != nil {
            map["accessKey"] = self.accessKey!
        }
        if self.signature != nil {
            map["signature"] = self.signature!
        }
        if self.skipAuth != nil {
            map["skipAuth"] = self.skipAuth!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
        if let value = dict["Uid"] as? String {
            self.uid = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
        if let value = dict["__context"] as? String {
            self.context = value
        }
        if let value = dict["accessKey"] as? String {
            self.accessKey = value
        }
        if let value = dict["signature"] as? String {
            self.signature = value
        }
        if let value = dict["skipAuth"] as? String {
            self.skipAuth = value
        }
        if let value = dict["timestamp"] as? String {
            self.timestamp = value
        }
    }
}

public class GetHDMAliyunResourceSyncResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SubResults : Tea.TeaModel {
            public class ResourceSyncSubResult : Tea.TeaModel {
                public var errMsg: String?

                public var resourceType: String?

                public var success: Bool?

                public var syncCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errMsg != nil {
                        map["ErrMsg"] = self.errMsg!
                    }
                    if self.resourceType != nil {
                        map["ResourceType"] = self.resourceType!
                    }
                    if self.success != nil {
                        map["Success"] = self.success!
                    }
                    if self.syncCount != nil {
                        map["SyncCount"] = self.syncCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ErrMsg"] as? String {
                        self.errMsg = value
                    }
                    if let value = dict["ResourceType"] as? String {
                        self.resourceType = value
                    }
                    if let value = dict["Success"] as? Bool {
                        self.success = value
                    }
                    if let value = dict["SyncCount"] as? Int32 {
                        self.syncCount = value
                    }
                }
            }
            public var resourceSyncSubResult: [GetHDMAliyunResourceSyncResultResponseBody.Data.SubResults.ResourceSyncSubResult]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceSyncSubResult != nil {
                    var tmp : [Any] = []
                    for k in self.resourceSyncSubResult! {
                        tmp.append(k.toMap())
                    }
                    map["ResourceSyncSubResult"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceSyncSubResult"] as? [Any?] {
                    var tmp : [GetHDMAliyunResourceSyncResultResponseBody.Data.SubResults.ResourceSyncSubResult] = []
                    for v in value {
                        if v != nil {
                            var model = GetHDMAliyunResourceSyncResultResponseBody.Data.SubResults.ResourceSyncSubResult()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.resourceSyncSubResult = tmp
                }
            }
        }
        public var errorMsg: String?

        public var results: String?

        public var subResults: GetHDMAliyunResourceSyncResultResponseBody.Data.SubResults?

        public var syncStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.subResults?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMsg != nil {
                map["ErrorMsg"] = self.errorMsg!
            }
            if self.results != nil {
                map["Results"] = self.results!
            }
            if self.subResults != nil {
                map["SubResults"] = self.subResults?.toMap()
            }
            if self.syncStatus != nil {
                map["SyncStatus"] = self.syncStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ErrorMsg"] as? String {
                self.errorMsg = value
            }
            if let value = dict["Results"] as? String {
                self.results = value
            }
            if let value = dict["SubResults"] as? [String: Any?] {
                var model = GetHDMAliyunResourceSyncResultResponseBody.Data.SubResults()
                model.fromMap(value)
                self.subResults = model
            }
            if let value = dict["SyncStatus"] as? String {
                self.syncStatus = value
            }
        }
    }
    public var code: String?

    public var data: GetHDMAliyunResourceSyncResultResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetHDMAliyunResourceSyncResultResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
        if let value = dict["Synchro"] as? String {
            self.synchro = value
        }
    }
}

public class GetHDMAliyunResourceSyncResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHDMAliyunResourceSyncResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetHDMAliyunResourceSyncResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetHDMLastAliyunResourceSyncResultRequest : Tea.TeaModel {
    public var uid: String?

    public var userId: String?

    public var context: String?

    public var accessKey: String?

    public var signature: String?

    public var skipAuth: String?

    public var timestamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.context != nil {
            map["__context"] = self.context!
        }
        if self.accessKey != nil {
            map["accessKey"] = self.accessKey!
        }
        if self.signature != nil {
            map["signature"] = self.signature!
        }
        if self.skipAuth != nil {
            map["skipAuth"] = self.skipAuth!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Uid"] as? String {
            self.uid = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
        if let value = dict["__context"] as? String {
            self.context = value
        }
        if let value = dict["accessKey"] as? String {
            self.accessKey = value
        }
        if let value = dict["signature"] as? String {
            self.signature = value
        }
        if let value = dict["skipAuth"] as? String {
            self.skipAuth = value
        }
        if let value = dict["timestamp"] as? String {
            self.timestamp = value
        }
    }
}

public class GetHDMLastAliyunResourceSyncResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SubResults : Tea.TeaModel {
            public class ResourceSyncSubResult : Tea.TeaModel {
                public var errMsg: String?

                public var resourceType: String?

                public var success: Bool?

                public var syncCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errMsg != nil {
                        map["ErrMsg"] = self.errMsg!
                    }
                    if self.resourceType != nil {
                        map["ResourceType"] = self.resourceType!
                    }
                    if self.success != nil {
                        map["Success"] = self.success!
                    }
                    if self.syncCount != nil {
                        map["SyncCount"] = self.syncCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ErrMsg"] as? String {
                        self.errMsg = value
                    }
                    if let value = dict["ResourceType"] as? String {
                        self.resourceType = value
                    }
                    if let value = dict["Success"] as? Bool {
                        self.success = value
                    }
                    if let value = dict["SyncCount"] as? Int32 {
                        self.syncCount = value
                    }
                }
            }
            public var resourceSyncSubResult: [GetHDMLastAliyunResourceSyncResultResponseBody.Data.SubResults.ResourceSyncSubResult]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceSyncSubResult != nil {
                    var tmp : [Any] = []
                    for k in self.resourceSyncSubResult! {
                        tmp.append(k.toMap())
                    }
                    map["ResourceSyncSubResult"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceSyncSubResult"] as? [Any?] {
                    var tmp : [GetHDMLastAliyunResourceSyncResultResponseBody.Data.SubResults.ResourceSyncSubResult] = []
                    for v in value {
                        if v != nil {
                            var model = GetHDMLastAliyunResourceSyncResultResponseBody.Data.SubResults.ResourceSyncSubResult()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.resourceSyncSubResult = tmp
                }
            }
        }
        public var errorMsg: String?

        public var results: String?

        public var subResults: GetHDMLastAliyunResourceSyncResultResponseBody.Data.SubResults?

        public var syncStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.subResults?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMsg != nil {
                map["ErrorMsg"] = self.errorMsg!
            }
            if self.results != nil {
                map["Results"] = self.results!
            }
            if self.subResults != nil {
                map["SubResults"] = self.subResults?.toMap()
            }
            if self.syncStatus != nil {
                map["SyncStatus"] = self.syncStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ErrorMsg"] as? String {
                self.errorMsg = value
            }
            if let value = dict["Results"] as? String {
                self.results = value
            }
            if let value = dict["SubResults"] as? [String: Any?] {
                var model = GetHDMLastAliyunResourceSyncResultResponseBody.Data.SubResults()
                model.fromMap(value)
                self.subResults = model
            }
            if let value = dict["SyncStatus"] as? String {
                self.syncStatus = value
            }
        }
    }
    public var code: String?

    public var data: GetHDMLastAliyunResourceSyncResultResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetHDMLastAliyunResourceSyncResultResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
        if let value = dict["Synchro"] as? String {
            self.synchro = value
        }
    }
}

public class GetHDMLastAliyunResourceSyncResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHDMLastAliyunResourceSyncResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetHDMLastAliyunResourceSyncResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetInstanceInspectionsRequest : Tea.TeaModel {
    public var endTime: String?

    public var engine: String?

    public var instanceArea: String?

    public var pageNo: String?

    public var pageSize: String?

    public var resourceGroupId: String?

    public var searchMap: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceArea != nil {
            map["InstanceArea"] = self.instanceArea!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.searchMap != nil {
            map["SearchMap"] = self.searchMap!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["InstanceArea"] as? String {
            self.instanceArea = value
        }
        if let value = dict["PageNo"] as? String {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SearchMap"] as? String {
            self.searchMap = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class GetInstanceInspectionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class AutoFunction : Tea.TeaModel {
                public var autoIndex: Int32?

                public var autoLimitedSql: Int32?

                public var autoResourceOptimize: Int32?

                public var autoScale: Int32?

                public var eventSubscription: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.autoIndex != nil {
                        map["AutoIndex"] = self.autoIndex!
                    }
                    if self.autoLimitedSql != nil {
                        map["AutoLimitedSql"] = self.autoLimitedSql!
                    }
                    if self.autoResourceOptimize != nil {
                        map["AutoResourceOptimize"] = self.autoResourceOptimize!
                    }
                    if self.autoScale != nil {
                        map["AutoScale"] = self.autoScale!
                    }
                    if self.eventSubscription != nil {
                        map["EventSubscription"] = self.eventSubscription!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AutoIndex"] as? Int32 {
                        self.autoIndex = value
                    }
                    if let value = dict["AutoLimitedSql"] as? Int32 {
                        self.autoLimitedSql = value
                    }
                    if let value = dict["AutoResourceOptimize"] as? Int32 {
                        self.autoResourceOptimize = value
                    }
                    if let value = dict["AutoScale"] as? Int32 {
                        self.autoScale = value
                    }
                    if let value = dict["EventSubscription"] as? Int32 {
                        self.eventSubscription = value
                    }
                }
            }
            public class Instance : Tea.TeaModel {
                public var accountId: String?

                public var category: String?

                public var cpu: String?

                public var engine: String?

                public var engineVersion: String?

                public var instanceAlias: String?

                public var instanceArea: String?

                public var instanceClass: String?

                public var instanceId: String?

                public var memory: Int32?

                public var networkType: String?

                public var nodeId: String?

                public var region: String?

                public var storage: Int32?

                public var uuid: String?

                public var vpcId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accountId != nil {
                        map["AccountId"] = self.accountId!
                    }
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.cpu != nil {
                        map["Cpu"] = self.cpu!
                    }
                    if self.engine != nil {
                        map["Engine"] = self.engine!
                    }
                    if self.engineVersion != nil {
                        map["EngineVersion"] = self.engineVersion!
                    }
                    if self.instanceAlias != nil {
                        map["InstanceAlias"] = self.instanceAlias!
                    }
                    if self.instanceArea != nil {
                        map["InstanceArea"] = self.instanceArea!
                    }
                    if self.instanceClass != nil {
                        map["InstanceClass"] = self.instanceClass!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.memory != nil {
                        map["Memory"] = self.memory!
                    }
                    if self.networkType != nil {
                        map["NetworkType"] = self.networkType!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.storage != nil {
                        map["Storage"] = self.storage!
                    }
                    if self.uuid != nil {
                        map["Uuid"] = self.uuid!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AccountId"] as? String {
                        self.accountId = value
                    }
                    if let value = dict["Category"] as? String {
                        self.category = value
                    }
                    if let value = dict["Cpu"] as? String {
                        self.cpu = value
                    }
                    if let value = dict["Engine"] as? String {
                        self.engine = value
                    }
                    if let value = dict["EngineVersion"] as? String {
                        self.engineVersion = value
                    }
                    if let value = dict["InstanceAlias"] as? String {
                        self.instanceAlias = value
                    }
                    if let value = dict["InstanceArea"] as? String {
                        self.instanceArea = value
                    }
                    if let value = dict["InstanceClass"] as? String {
                        self.instanceClass = value
                    }
                    if let value = dict["InstanceId"] as? String {
                        self.instanceId = value
                    }
                    if let value = dict["Memory"] as? Int32 {
                        self.memory = value
                    }
                    if let value = dict["NetworkType"] as? String {
                        self.networkType = value
                    }
                    if let value = dict["NodeId"] as? String {
                        self.nodeId = value
                    }
                    if let value = dict["Region"] as? String {
                        self.region = value
                    }
                    if let value = dict["Storage"] as? Int32 {
                        self.storage = value
                    }
                    if let value = dict["Uuid"] as? String {
                        self.uuid = value
                    }
                    if let value = dict["VpcId"] as? String {
                        self.vpcId = value
                    }
                }
            }
            public var autoFunction: GetInstanceInspectionsResponseBody.Data.List.AutoFunction?

            public var data: [String: Any]?

            public var enableDasPro: Int32?

            public var endTime: Int64?

            public var gmtCreate: Int64?

            public var instance: GetInstanceInspectionsResponseBody.Data.List.Instance?

            public var score: Int32?

            public var scoreMap: [String: Any]?

            public var startTime: Int64?

            public var state: Int32?

            public var taskType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.autoFunction?.validate()
                try self.instance?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoFunction != nil {
                    map["AutoFunction"] = self.autoFunction?.toMap()
                }
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.enableDasPro != nil {
                    map["EnableDasPro"] = self.enableDasPro!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.instance != nil {
                    map["Instance"] = self.instance?.toMap()
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.scoreMap != nil {
                    map["ScoreMap"] = self.scoreMap!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoFunction"] as? [String: Any?] {
                    var model = GetInstanceInspectionsResponseBody.Data.List.AutoFunction()
                    model.fromMap(value)
                    self.autoFunction = model
                }
                if let value = dict["Data"] as? [String: Any] {
                    self.data = value
                }
                if let value = dict["EnableDasPro"] as? Int32 {
                    self.enableDasPro = value
                }
                if let value = dict["EndTime"] as? Int64 {
                    self.endTime = value
                }
                if let value = dict["GmtCreate"] as? Int64 {
                    self.gmtCreate = value
                }
                if let value = dict["Instance"] as? [String: Any?] {
                    var model = GetInstanceInspectionsResponseBody.Data.List.Instance()
                    model.fromMap(value)
                    self.instance = model
                }
                if let value = dict["Score"] as? Int32 {
                    self.score = value
                }
                if let value = dict["ScoreMap"] as? [String: Any] {
                    self.scoreMap = value
                }
                if let value = dict["StartTime"] as? Int64 {
                    self.startTime = value
                }
                if let value = dict["State"] as? Int32 {
                    self.state = value
                }
                if let value = dict["TaskType"] as? Int32 {
                    self.taskType = value
                }
            }
        }
        public var list: [GetInstanceInspectionsResponseBody.Data.List]?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["List"] as? [Any?] {
                var tmp : [GetInstanceInspectionsResponseBody.Data.List] = []
                for v in value {
                    if v != nil {
                        var model = GetInstanceInspectionsResponseBody.Data.List()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.list = tmp
            }
            if let value = dict["PageNo"] as? Int64 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: GetInstanceInspectionsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetInstanceInspectionsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetInstanceInspectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceInspectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetInstanceInspectionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetInstanceMissingIndexListRequest : Tea.TeaModel {
    public var avgTotalUserCost: String?

    public var avgUserImpact: String?

    public var endTime: String?

    public var indexCount: String?

    public var instanceId: String?

    public var objectName: String?

    public var pageNo: String?

    public var pageSize: String?

    public var reservedPages: String?

    public var reservedSize: String?

    public var rowCount: String?

    public var startTime: String?

    public var uniqueCompiles: String?

    public var userScans: String?

    public var userSeeks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avgTotalUserCost != nil {
            map["AvgTotalUserCost"] = self.avgTotalUserCost!
        }
        if self.avgUserImpact != nil {
            map["AvgUserImpact"] = self.avgUserImpact!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.indexCount != nil {
            map["IndexCount"] = self.indexCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.objectName != nil {
            map["ObjectName"] = self.objectName!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.reservedPages != nil {
            map["ReservedPages"] = self.reservedPages!
        }
        if self.reservedSize != nil {
            map["ReservedSize"] = self.reservedSize!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.uniqueCompiles != nil {
            map["UniqueCompiles"] = self.uniqueCompiles!
        }
        if self.userScans != nil {
            map["UserScans"] = self.userScans!
        }
        if self.userSeeks != nil {
            map["UserSeeks"] = self.userSeeks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AvgTotalUserCost"] as? String {
            self.avgTotalUserCost = value
        }
        if let value = dict["AvgUserImpact"] as? String {
            self.avgUserImpact = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["IndexCount"] as? String {
            self.indexCount = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["ObjectName"] as? String {
            self.objectName = value
        }
        if let value = dict["PageNo"] as? String {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["ReservedPages"] as? String {
            self.reservedPages = value
        }
        if let value = dict["ReservedSize"] as? String {
            self.reservedSize = value
        }
        if let value = dict["RowCount"] as? String {
            self.rowCount = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["UniqueCompiles"] as? String {
            self.uniqueCompiles = value
        }
        if let value = dict["UserScans"] as? String {
            self.userScans = value
        }
        if let value = dict["UserSeeks"] as? String {
            self.userSeeks = value
        }
    }
}

public class GetInstanceMissingIndexListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var avgTotalUserCost: Double?

            public var avgUserImpact: Double?

            public var createIndex: String?

            public var databaseName: String?

            public var equalityColumns: String?

            public var includedColumns: String?

            public var indexCount: Int64?

            public var inequalityColumns: String?

            public var lastUserSeek: Int64?

            public var objectName: String?

            public var reservedPages: Int64?

            public var reservedSize: Double?

            public var rowCount: Int64?

            public var schemaName: String?

            public var systemScans: Int64?

            public var systemSeeks: Int64?

            public var uniqueCompiles: Int64?

            public var userScans: Int64?

            public var userSeeks: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgTotalUserCost != nil {
                    map["AvgTotalUserCost"] = self.avgTotalUserCost!
                }
                if self.avgUserImpact != nil {
                    map["AvgUserImpact"] = self.avgUserImpact!
                }
                if self.createIndex != nil {
                    map["CreateIndex"] = self.createIndex!
                }
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.equalityColumns != nil {
                    map["EqualityColumns"] = self.equalityColumns!
                }
                if self.includedColumns != nil {
                    map["IncludedColumns"] = self.includedColumns!
                }
                if self.indexCount != nil {
                    map["IndexCount"] = self.indexCount!
                }
                if self.inequalityColumns != nil {
                    map["InequalityColumns"] = self.inequalityColumns!
                }
                if self.lastUserSeek != nil {
                    map["LastUserSeek"] = self.lastUserSeek!
                }
                if self.objectName != nil {
                    map["ObjectName"] = self.objectName!
                }
                if self.reservedPages != nil {
                    map["ReservedPages"] = self.reservedPages!
                }
                if self.reservedSize != nil {
                    map["ReservedSize"] = self.reservedSize!
                }
                if self.rowCount != nil {
                    map["RowCount"] = self.rowCount!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.systemScans != nil {
                    map["SystemScans"] = self.systemScans!
                }
                if self.systemSeeks != nil {
                    map["SystemSeeks"] = self.systemSeeks!
                }
                if self.uniqueCompiles != nil {
                    map["UniqueCompiles"] = self.uniqueCompiles!
                }
                if self.userScans != nil {
                    map["UserScans"] = self.userScans!
                }
                if self.userSeeks != nil {
                    map["UserSeeks"] = self.userSeeks!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AvgTotalUserCost"] as? Double {
                    self.avgTotalUserCost = value
                }
                if let value = dict["AvgUserImpact"] as? Double {
                    self.avgUserImpact = value
                }
                if let value = dict["CreateIndex"] as? String {
                    self.createIndex = value
                }
                if let value = dict["DatabaseName"] as? String {
                    self.databaseName = value
                }
                if let value = dict["EqualityColumns"] as? String {
                    self.equalityColumns = value
                }
                if let value = dict["IncludedColumns"] as? String {
                    self.includedColumns = value
                }
                if let value = dict["IndexCount"] as? Int64 {
                    self.indexCount = value
                }
                if let value = dict["InequalityColumns"] as? String {
                    self.inequalityColumns = value
                }
                if let value = dict["LastUserSeek"] as? Int64 {
                    self.lastUserSeek = value
                }
                if let value = dict["ObjectName"] as? String {
                    self.objectName = value
                }
                if let value = dict["ReservedPages"] as? Int64 {
                    self.reservedPages = value
                }
                if let value = dict["ReservedSize"] as? Double {
                    self.reservedSize = value
                }
                if let value = dict["RowCount"] as? Int64 {
                    self.rowCount = value
                }
                if let value = dict["SchemaName"] as? String {
                    self.schemaName = value
                }
                if let value = dict["SystemScans"] as? Int64 {
                    self.systemScans = value
                }
                if let value = dict["SystemSeeks"] as? Int64 {
                    self.systemSeeks = value
                }
                if let value = dict["UniqueCompiles"] as? Int64 {
                    self.uniqueCompiles = value
                }
                if let value = dict["UserScans"] as? Int64 {
                    self.userScans = value
                }
                if let value = dict["UserSeeks"] as? Int64 {
                    self.userSeeks = value
                }
            }
        }
        public var list: [GetInstanceMissingIndexListResponseBody.Data.List]?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["List"] as? [Any?] {
                var tmp : [GetInstanceMissingIndexListResponseBody.Data.List] = []
                for v in value {
                    if v != nil {
                        var model = GetInstanceMissingIndexListResponseBody.Data.List()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.list = tmp
            }
            if let value = dict["PageNo"] as? Int64 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: GetInstanceMissingIndexListResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetInstanceMissingIndexListResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetInstanceMissingIndexListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceMissingIndexListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetInstanceMissingIndexListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetInstanceSqlOptimizeStatisticRequest : Tea.TeaModel {
    public var endTime: String?

    public var filterEnable: String?

    public var instanceId: String?

    public var nodeId: String?

    public var startTime: String?

    public var threshold: String?

    public var useMerging: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filterEnable != nil {
            map["FilterEnable"] = self.filterEnable!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        if self.useMerging != nil {
            map["UseMerging"] = self.useMerging!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["FilterEnable"] as? String {
            self.filterEnable = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Threshold"] as? String {
            self.threshold = value
        }
        if let value = dict["UseMerging"] as? String {
            self.useMerging = value
        }
    }
}

public class GetInstanceSqlOptimizeStatisticResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var count: Int32?

        public var improvement: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["count"] = self.count!
            }
            if self.improvement != nil {
                map["improvement"] = self.improvement!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["count"] as? Int32 {
                self.count = value
            }
            if let value = dict["improvement"] as? Double {
                self.improvement = value
            }
        }
    }
    public var code: String?

    public var data: GetInstanceSqlOptimizeStatisticResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetInstanceSqlOptimizeStatisticResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetInstanceSqlOptimizeStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceSqlOptimizeStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetInstanceSqlOptimizeStatisticResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetKillInstanceSessionTaskResultRequest : Tea.TeaModel {
    public var instanceId: String?

    public var nodeId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class GetKillInstanceSessionTaskResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var active: Bool?

            public var command: String?

            public var db: String?

            public var host: String?

            public var id: Int64?

            public var info: String?

            public var reason: String?

            public var state: String?

            public var taskId: String?

            public var time: Int64?

            public var user: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.active != nil {
                    map["Active"] = self.active!
                }
                if self.command != nil {
                    map["Command"] = self.command!
                }
                if self.db != nil {
                    map["Db"] = self.db!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.info != nil {
                    map["Info"] = self.info!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                if self.user != nil {
                    map["User"] = self.user!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Active"] as? Bool {
                    self.active = value
                }
                if let value = dict["Command"] as? String {
                    self.command = value
                }
                if let value = dict["Db"] as? String {
                    self.db = value
                }
                if let value = dict["Host"] as? String {
                    self.host = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Info"] as? String {
                    self.info = value
                }
                if let value = dict["Reason"] as? String {
                    self.reason = value
                }
                if let value = dict["State"] as? String {
                    self.state = value
                }
                if let value = dict["TaskId"] as? String {
                    self.taskId = value
                }
                if let value = dict["Time"] as? Int64 {
                    self.time = value
                }
                if let value = dict["User"] as? String {
                    self.user = value
                }
            }
        }
        public var ignoredUserSessionCount: Int64?

        public var instanceId: String?

        public var killFailCount: Int64?

        public var killSuccessCount: Int64?

        public var nodeId: String?

        public var result: [GetKillInstanceSessionTaskResultResponseBody.Data.Result]?

        public var sessions: [Int64]?

        public var taskId: String?

        public var taskState: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ignoredUserSessionCount != nil {
                map["IgnoredUserSessionCount"] = self.ignoredUserSessionCount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.killFailCount != nil {
                map["KillFailCount"] = self.killFailCount!
            }
            if self.killSuccessCount != nil {
                map["KillSuccessCount"] = self.killSuccessCount!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.sessions != nil {
                map["Sessions"] = self.sessions!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskState != nil {
                map["TaskState"] = self.taskState!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IgnoredUserSessionCount"] as? Int64 {
                self.ignoredUserSessionCount = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["KillFailCount"] as? Int64 {
                self.killFailCount = value
            }
            if let value = dict["KillSuccessCount"] as? Int64 {
                self.killSuccessCount = value
            }
            if let value = dict["NodeId"] as? String {
                self.nodeId = value
            }
            if let value = dict["Result"] as? [Any?] {
                var tmp : [GetKillInstanceSessionTaskResultResponseBody.Data.Result] = []
                for v in value {
                    if v != nil {
                        var model = GetKillInstanceSessionTaskResultResponseBody.Data.Result()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.result = tmp
            }
            if let value = dict["Sessions"] as? [Int64] {
                self.sessions = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
            if let value = dict["TaskState"] as? String {
                self.taskState = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
        }
    }
    public var code: Int64?

    public var data: GetKillInstanceSessionTaskResultResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetKillInstanceSessionTaskResultResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetKillInstanceSessionTaskResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetKillInstanceSessionTaskResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetKillInstanceSessionTaskResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMongoDBCurrentOpRequest : Tea.TeaModel {
    public var filterDoc: String?

    public var instanceId: String?

    public var nodeId: String?

    public var role: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filterDoc != nil {
            map["FilterDoc"] = self.filterDoc!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FilterDoc"] as? String {
            self.filterDoc = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["Role"] as? String {
            self.role = value
        }
    }
}

public class GetMongoDBCurrentOpResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SessionList : Tea.TeaModel {
            public var active: Bool?

            public var client: String?

            public var command: String?

            public var connectionId: Int64?

            public var desc: String?

            public var driver: String?

            public var host: String?

            public var killPending: Bool?

            public var ns: String?

            public var op: String?

            public var opId: String?

            public var osArch: String?

            public var osName: String?

            public var osType: String?

            public var planSummary: String?

            public var platform: String?

            public var secsRunning: Int64?

            public var shard: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.active != nil {
                    map["Active"] = self.active!
                }
                if self.client != nil {
                    map["Client"] = self.client!
                }
                if self.command != nil {
                    map["Command"] = self.command!
                }
                if self.connectionId != nil {
                    map["ConnectionId"] = self.connectionId!
                }
                if self.desc != nil {
                    map["Desc"] = self.desc!
                }
                if self.driver != nil {
                    map["Driver"] = self.driver!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.killPending != nil {
                    map["KillPending"] = self.killPending!
                }
                if self.ns != nil {
                    map["Ns"] = self.ns!
                }
                if self.op != nil {
                    map["Op"] = self.op!
                }
                if self.opId != nil {
                    map["OpId"] = self.opId!
                }
                if self.osArch != nil {
                    map["OsArch"] = self.osArch!
                }
                if self.osName != nil {
                    map["OsName"] = self.osName!
                }
                if self.osType != nil {
                    map["OsType"] = self.osType!
                }
                if self.planSummary != nil {
                    map["PlanSummary"] = self.planSummary!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.secsRunning != nil {
                    map["SecsRunning"] = self.secsRunning!
                }
                if self.shard != nil {
                    map["Shard"] = self.shard!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Active"] as? Bool {
                    self.active = value
                }
                if let value = dict["Client"] as? String {
                    self.client = value
                }
                if let value = dict["Command"] as? String {
                    self.command = value
                }
                if let value = dict["ConnectionId"] as? Int64 {
                    self.connectionId = value
                }
                if let value = dict["Desc"] as? String {
                    self.desc = value
                }
                if let value = dict["Driver"] as? String {
                    self.driver = value
                }
                if let value = dict["Host"] as? String {
                    self.host = value
                }
                if let value = dict["KillPending"] as? Bool {
                    self.killPending = value
                }
                if let value = dict["Ns"] as? String {
                    self.ns = value
                }
                if let value = dict["Op"] as? String {
                    self.op = value
                }
                if let value = dict["OpId"] as? String {
                    self.opId = value
                }
                if let value = dict["OsArch"] as? String {
                    self.osArch = value
                }
                if let value = dict["OsName"] as? String {
                    self.osName = value
                }
                if let value = dict["OsType"] as? String {
                    self.osType = value
                }
                if let value = dict["PlanSummary"] as? String {
                    self.planSummary = value
                }
                if let value = dict["Platform"] as? String {
                    self.platform = value
                }
                if let value = dict["SecsRunning"] as? Int64 {
                    self.secsRunning = value
                }
                if let value = dict["Shard"] as? String {
                    self.shard = value
                }
            }
        }
        public class SessionStat : Tea.TeaModel {
            public var activeCount: Int64?

            public var clientStats: [String: DataSessionStatClientStatsValue]?

            public var dbStats: [String: DataSessionStatDbStatsValue]?

            public var longestSecsRunning: Int64?

            public var totalCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activeCount != nil {
                    map["ActiveCount"] = self.activeCount!
                }
                if self.clientStats != nil {
                    var tmp : [String: Any] = [:]
                    for (k, v) in self.clientStats! {
                        tmp[k] = v.toMap()
                    }
                    map["ClientStats"] = tmp
                }
                if self.dbStats != nil {
                    var tmp : [String: Any] = [:]
                    for (k, v) in self.dbStats! {
                        tmp[k] = v.toMap()
                    }
                    map["DbStats"] = tmp
                }
                if self.longestSecsRunning != nil {
                    map["LongestSecsRunning"] = self.longestSecsRunning!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ActiveCount"] as? Int64 {
                    self.activeCount = value
                }
                if let value = dict["ClientStats"] as? [String: Any?] {
                    var tmp : [String: DataSessionStatClientStatsValue] = [:]
                    for (k, v) in value {
                        if v != nil {
                            var model = DataSessionStatClientStatsValue()
                            model.fromMap(v as? [String: Any?])
                            tmp[k] = model
                        }
                    }
                    self.clientStats = tmp
                }
                if let value = dict["DbStats"] as? [String: Any?] {
                    var tmp : [String: DataSessionStatDbStatsValue] = [:]
                    for (k, v) in value {
                        if v != nil {
                            var model = DataSessionStatDbStatsValue()
                            model.fromMap(v as? [String: Any?])
                            tmp[k] = model
                        }
                    }
                    self.dbStats = tmp
                }
                if let value = dict["LongestSecsRunning"] as? Int64 {
                    self.longestSecsRunning = value
                }
                if let value = dict["TotalCount"] as? Int64 {
                    self.totalCount = value
                }
            }
        }
        public var sessionList: [GetMongoDBCurrentOpResponseBody.Data.SessionList]?

        public var sessionStat: GetMongoDBCurrentOpResponseBody.Data.SessionStat?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sessionStat?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sessionList != nil {
                var tmp : [Any] = []
                for k in self.sessionList! {
                    tmp.append(k.toMap())
                }
                map["SessionList"] = tmp
            }
            if self.sessionStat != nil {
                map["SessionStat"] = self.sessionStat?.toMap()
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SessionList"] as? [Any?] {
                var tmp : [GetMongoDBCurrentOpResponseBody.Data.SessionList] = []
                for v in value {
                    if v != nil {
                        var model = GetMongoDBCurrentOpResponseBody.Data.SessionList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sessionList = tmp
            }
            if let value = dict["SessionStat"] as? [String: Any?] {
                var model = GetMongoDBCurrentOpResponseBody.Data.SessionStat()
                model.fromMap(value)
                self.sessionStat = model
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
        }
    }
    public var code: Int64?

    public var data: GetMongoDBCurrentOpResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetMongoDBCurrentOpResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMongoDBCurrentOpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMongoDBCurrentOpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMongoDBCurrentOpResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMySQLAllSessionAsyncRequest : Tea.TeaModel {
    public var instanceId: String?

    public var nodeId: String?

    public var resultId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.resultId != nil {
            map["ResultId"] = self.resultId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["ResultId"] as? String {
            self.resultId = value
        }
    }
}

public class GetMySQLAllSessionAsyncResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SessionData : Tea.TeaModel {
            public class ClientStats : Tea.TeaModel {
                public var activeCount: Int64?

                public var key: String?

                public var threadIdList: [Int64]?

                public var totalCount: Int64?

                public var userList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.activeCount != nil {
                        map["ActiveCount"] = self.activeCount!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.threadIdList != nil {
                        map["ThreadIdList"] = self.threadIdList!
                    }
                    if self.totalCount != nil {
                        map["TotalCount"] = self.totalCount!
                    }
                    if self.userList != nil {
                        map["UserList"] = self.userList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ActiveCount"] as? Int64 {
                        self.activeCount = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["ThreadIdList"] as? [Int64] {
                        self.threadIdList = value
                    }
                    if let value = dict["TotalCount"] as? Int64 {
                        self.totalCount = value
                    }
                    if let value = dict["UserList"] as? [String] {
                        self.userList = value
                    }
                }
            }
            public class DbStats : Tea.TeaModel {
                public var activeCount: Int64?

                public var key: String?

                public var threadIdList: [Int64]?

                public var totalCount: Int64?

                public var userList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.activeCount != nil {
                        map["ActiveCount"] = self.activeCount!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.threadIdList != nil {
                        map["ThreadIdList"] = self.threadIdList!
                    }
                    if self.totalCount != nil {
                        map["TotalCount"] = self.totalCount!
                    }
                    if self.userList != nil {
                        map["UserList"] = self.userList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ActiveCount"] as? Int64 {
                        self.activeCount = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["ThreadIdList"] as? [Int64] {
                        self.threadIdList = value
                    }
                    if let value = dict["TotalCount"] as? Int64 {
                        self.totalCount = value
                    }
                    if let value = dict["UserList"] as? [String] {
                        self.userList = value
                    }
                }
            }
            public class SessionList : Tea.TeaModel {
                public var client: String?

                public var command: String?

                public var dbName: String?

                public var sessionId: Int64?

                public var sqlTemplateId: String?

                public var sqlText: String?

                public var state: String?

                public var time: Int64?

                public var trxDuration: Int64?

                public var trxId: String?

                public var user: String?

                public var userClientAlias: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.client != nil {
                        map["Client"] = self.client!
                    }
                    if self.command != nil {
                        map["Command"] = self.command!
                    }
                    if self.dbName != nil {
                        map["DbName"] = self.dbName!
                    }
                    if self.sessionId != nil {
                        map["SessionId"] = self.sessionId!
                    }
                    if self.sqlTemplateId != nil {
                        map["SqlTemplateId"] = self.sqlTemplateId!
                    }
                    if self.sqlText != nil {
                        map["SqlText"] = self.sqlText!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    if self.time != nil {
                        map["Time"] = self.time!
                    }
                    if self.trxDuration != nil {
                        map["TrxDuration"] = self.trxDuration!
                    }
                    if self.trxId != nil {
                        map["TrxId"] = self.trxId!
                    }
                    if self.user != nil {
                        map["User"] = self.user!
                    }
                    if self.userClientAlias != nil {
                        map["UserClientAlias"] = self.userClientAlias!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Client"] as? String {
                        self.client = value
                    }
                    if let value = dict["Command"] as? String {
                        self.command = value
                    }
                    if let value = dict["DbName"] as? String {
                        self.dbName = value
                    }
                    if let value = dict["SessionId"] as? Int64 {
                        self.sessionId = value
                    }
                    if let value = dict["SqlTemplateId"] as? String {
                        self.sqlTemplateId = value
                    }
                    if let value = dict["SqlText"] as? String {
                        self.sqlText = value
                    }
                    if let value = dict["State"] as? String {
                        self.state = value
                    }
                    if let value = dict["Time"] as? Int64 {
                        self.time = value
                    }
                    if let value = dict["TrxDuration"] as? Int64 {
                        self.trxDuration = value
                    }
                    if let value = dict["TrxId"] as? String {
                        self.trxId = value
                    }
                    if let value = dict["User"] as? String {
                        self.user = value
                    }
                    if let value = dict["UserClientAlias"] as? String {
                        self.userClientAlias = value
                    }
                }
            }
            public class UserStats : Tea.TeaModel {
                public var activeCount: Int64?

                public var key: String?

                public var threadIdList: [Int64]?

                public var totalCount: Int64?

                public var userList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.activeCount != nil {
                        map["ActiveCount"] = self.activeCount!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.threadIdList != nil {
                        map["ThreadIdList"] = self.threadIdList!
                    }
                    if self.totalCount != nil {
                        map["TotalCount"] = self.totalCount!
                    }
                    if self.userList != nil {
                        map["UserList"] = self.userList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ActiveCount"] as? Int64 {
                        self.activeCount = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["ThreadIdList"] as? [Int64] {
                        self.threadIdList = value
                    }
                    if let value = dict["TotalCount"] as? Int64 {
                        self.totalCount = value
                    }
                    if let value = dict["UserList"] as? [String] {
                        self.userList = value
                    }
                }
            }
            public var activeSessionCount: Int64?

            public var clientStats: [GetMySQLAllSessionAsyncResponseBody.Data.SessionData.ClientStats]?

            public var dbStats: [GetMySQLAllSessionAsyncResponseBody.Data.SessionData.DbStats]?

            public var maxActiveTime: Int64?

            public var sessionList: [GetMySQLAllSessionAsyncResponseBody.Data.SessionData.SessionList]?

            public var timeStamp: Int64?

            public var totalSessionCount: Int64?

            public var userStats: [GetMySQLAllSessionAsyncResponseBody.Data.SessionData.UserStats]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activeSessionCount != nil {
                    map["ActiveSessionCount"] = self.activeSessionCount!
                }
                if self.clientStats != nil {
                    var tmp : [Any] = []
                    for k in self.clientStats! {
                        tmp.append(k.toMap())
                    }
                    map["ClientStats"] = tmp
                }
                if self.dbStats != nil {
                    var tmp : [Any] = []
                    for k in self.dbStats! {
                        tmp.append(k.toMap())
                    }
                    map["DbStats"] = tmp
                }
                if self.maxActiveTime != nil {
                    map["MaxActiveTime"] = self.maxActiveTime!
                }
                if self.sessionList != nil {
                    var tmp : [Any] = []
                    for k in self.sessionList! {
                        tmp.append(k.toMap())
                    }
                    map["SessionList"] = tmp
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.totalSessionCount != nil {
                    map["TotalSessionCount"] = self.totalSessionCount!
                }
                if self.userStats != nil {
                    var tmp : [Any] = []
                    for k in self.userStats! {
                        tmp.append(k.toMap())
                    }
                    map["UserStats"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ActiveSessionCount"] as? Int64 {
                    self.activeSessionCount = value
                }
                if let value = dict["ClientStats"] as? [Any?] {
                    var tmp : [GetMySQLAllSessionAsyncResponseBody.Data.SessionData.ClientStats] = []
                    for v in value {
                        if v != nil {
                            var model = GetMySQLAllSessionAsyncResponseBody.Data.SessionData.ClientStats()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.clientStats = tmp
                }
                if let value = dict["DbStats"] as? [Any?] {
                    var tmp : [GetMySQLAllSessionAsyncResponseBody.Data.SessionData.DbStats] = []
                    for v in value {
                        if v != nil {
                            var model = GetMySQLAllSessionAsyncResponseBody.Data.SessionData.DbStats()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.dbStats = tmp
                }
                if let value = dict["MaxActiveTime"] as? Int64 {
                    self.maxActiveTime = value
                }
                if let value = dict["SessionList"] as? [Any?] {
                    var tmp : [GetMySQLAllSessionAsyncResponseBody.Data.SessionData.SessionList] = []
                    for v in value {
                        if v != nil {
                            var model = GetMySQLAllSessionAsyncResponseBody.Data.SessionData.SessionList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.sessionList = tmp
                }
                if let value = dict["TimeStamp"] as? Int64 {
                    self.timeStamp = value
                }
                if let value = dict["TotalSessionCount"] as? Int64 {
                    self.totalSessionCount = value
                }
                if let value = dict["UserStats"] as? [Any?] {
                    var tmp : [GetMySQLAllSessionAsyncResponseBody.Data.SessionData.UserStats] = []
                    for v in value {
                        if v != nil {
                            var model = GetMySQLAllSessionAsyncResponseBody.Data.SessionData.UserStats()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.userStats = tmp
                }
            }
        }
        public var complete: Bool?

        public var fail: Bool?

        public var isFinish: Bool?

        public var resultId: String?

        public var sessionData: GetMySQLAllSessionAsyncResponseBody.Data.SessionData?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sessionData?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complete != nil {
                map["Complete"] = self.complete!
            }
            if self.fail != nil {
                map["Fail"] = self.fail!
            }
            if self.isFinish != nil {
                map["IsFinish"] = self.isFinish!
            }
            if self.resultId != nil {
                map["ResultId"] = self.resultId!
            }
            if self.sessionData != nil {
                map["SessionData"] = self.sessionData?.toMap()
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Complete"] as? Bool {
                self.complete = value
            }
            if let value = dict["Fail"] as? Bool {
                self.fail = value
            }
            if let value = dict["IsFinish"] as? Bool {
                self.isFinish = value
            }
            if let value = dict["ResultId"] as? String {
                self.resultId = value
            }
            if let value = dict["SessionData"] as? [String: Any?] {
                var model = GetMySQLAllSessionAsyncResponseBody.Data.SessionData()
                model.fromMap(value)
                self.sessionData = model
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
        }
    }
    public var code: Int64?

    public var data: GetMySQLAllSessionAsyncResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetMySQLAllSessionAsyncResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMySQLAllSessionAsyncResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMySQLAllSessionAsyncResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMySQLAllSessionAsyncResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPartitionsHeatmapRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public var timeRange: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.timeRange != nil {
            map["TimeRange"] = self.timeRange!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["TimeRange"] as? String {
            self.timeRange = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class GetPartitionsHeatmapResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetPartitionsHeatmapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPartitionsHeatmapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPartitionsHeatmapResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPfsMetricTrendsRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var metric: String?

    public var nodeId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.metric != nil {
            map["Metric"] = self.metric!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Metric"] as? String {
            self.metric = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class GetPfsMetricTrendsResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: [String: [DataValue]]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.data! {
                var l1 : [Any] = []
                for k1 in v {
                    l1.append(k1.toMap())
                }
                tmp[k] = l1
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var tmp : [String: [DataValue]] = [:]
            for (k, v) in value {
                var l1 : [DataValue] = []
                for v1 in v as! [Any?] {
                    if v1 != nil {
                        var model = DataValue()
                        if v1 != nil {
                            model.fromMap(v1 as? [String: Any?])
                        }
                        l1.append(model)
                    }
                }
                tmp[k] = l1
            }
            self.data = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetPfsMetricTrendsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPfsMetricTrendsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPfsMetricTrendsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPfsSqlSampleRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var nodeId: String?

    public var sqlId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["SqlId"] as? String {
            self.sqlId = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class GetPfsSqlSampleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createTmpDiskTables: Int32?

        public var createTmpTables: Int32?

        public var db: String?

        public var endEventId: Int32?

        public var errors: Int32?

        public var eventId: Int32?

        public var eventName: String?

        public var instanceId: String?

        public var latency: Double?

        public var lockLatency: Double?

        public var logicId: String?

        public var noGoodIndexUsed: Int32?

        public var noIndexUsed: Int32?

        public var nodeId: String?

        public var rowsAffected: Int32?

        public var rowsExamined: Int32?

        public var rowsSent: Int32?

        public var selectFullJoin: Int32?

        public var selectFullRangeJoin: Int32?

        public var selectRange: Int32?

        public var selectRangeCheck: Int32?

        public var selectScan: Int32?

        public var sortMergePasses: Int32?

        public var sortRange: Int32?

        public var sortRows: Int32?

        public var sortScan: Int32?

        public var sql: String?

        public var sqlId: String?

        public var threadId: Int32?

        public var timestamp: Int64?

        public var userId: String?

        public var warnings: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTmpDiskTables != nil {
                map["CreateTmpDiskTables"] = self.createTmpDiskTables!
            }
            if self.createTmpTables != nil {
                map["CreateTmpTables"] = self.createTmpTables!
            }
            if self.db != nil {
                map["Db"] = self.db!
            }
            if self.endEventId != nil {
                map["EndEventId"] = self.endEventId!
            }
            if self.errors != nil {
                map["Errors"] = self.errors!
            }
            if self.eventId != nil {
                map["EventId"] = self.eventId!
            }
            if self.eventName != nil {
                map["EventName"] = self.eventName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.latency != nil {
                map["Latency"] = self.latency!
            }
            if self.lockLatency != nil {
                map["LockLatency"] = self.lockLatency!
            }
            if self.logicId != nil {
                map["LogicId"] = self.logicId!
            }
            if self.noGoodIndexUsed != nil {
                map["NoGoodIndexUsed"] = self.noGoodIndexUsed!
            }
            if self.noIndexUsed != nil {
                map["NoIndexUsed"] = self.noIndexUsed!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.rowsAffected != nil {
                map["RowsAffected"] = self.rowsAffected!
            }
            if self.rowsExamined != nil {
                map["RowsExamined"] = self.rowsExamined!
            }
            if self.rowsSent != nil {
                map["RowsSent"] = self.rowsSent!
            }
            if self.selectFullJoin != nil {
                map["SelectFullJoin"] = self.selectFullJoin!
            }
            if self.selectFullRangeJoin != nil {
                map["SelectFullRangeJoin"] = self.selectFullRangeJoin!
            }
            if self.selectRange != nil {
                map["SelectRange"] = self.selectRange!
            }
            if self.selectRangeCheck != nil {
                map["SelectRangeCheck"] = self.selectRangeCheck!
            }
            if self.selectScan != nil {
                map["SelectScan"] = self.selectScan!
            }
            if self.sortMergePasses != nil {
                map["SortMergePasses"] = self.sortMergePasses!
            }
            if self.sortRange != nil {
                map["SortRange"] = self.sortRange!
            }
            if self.sortRows != nil {
                map["SortRows"] = self.sortRows!
            }
            if self.sortScan != nil {
                map["SortScan"] = self.sortScan!
            }
            if self.sql != nil {
                map["Sql"] = self.sql!
            }
            if self.sqlId != nil {
                map["SqlId"] = self.sqlId!
            }
            if self.threadId != nil {
                map["ThreadId"] = self.threadId!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.warnings != nil {
                map["Warnings"] = self.warnings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTmpDiskTables"] as? Int32 {
                self.createTmpDiskTables = value
            }
            if let value = dict["CreateTmpTables"] as? Int32 {
                self.createTmpTables = value
            }
            if let value = dict["Db"] as? String {
                self.db = value
            }
            if let value = dict["EndEventId"] as? Int32 {
                self.endEventId = value
            }
            if let value = dict["Errors"] as? Int32 {
                self.errors = value
            }
            if let value = dict["EventId"] as? Int32 {
                self.eventId = value
            }
            if let value = dict["EventName"] as? String {
                self.eventName = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["Latency"] as? Double {
                self.latency = value
            }
            if let value = dict["LockLatency"] as? Double {
                self.lockLatency = value
            }
            if let value = dict["LogicId"] as? String {
                self.logicId = value
            }
            if let value = dict["NoGoodIndexUsed"] as? Int32 {
                self.noGoodIndexUsed = value
            }
            if let value = dict["NoIndexUsed"] as? Int32 {
                self.noIndexUsed = value
            }
            if let value = dict["NodeId"] as? String {
                self.nodeId = value
            }
            if let value = dict["RowsAffected"] as? Int32 {
                self.rowsAffected = value
            }
            if let value = dict["RowsExamined"] as? Int32 {
                self.rowsExamined = value
            }
            if let value = dict["RowsSent"] as? Int32 {
                self.rowsSent = value
            }
            if let value = dict["SelectFullJoin"] as? Int32 {
                self.selectFullJoin = value
            }
            if let value = dict["SelectFullRangeJoin"] as? Int32 {
                self.selectFullRangeJoin = value
            }
            if let value = dict["SelectRange"] as? Int32 {
                self.selectRange = value
            }
            if let value = dict["SelectRangeCheck"] as? Int32 {
                self.selectRangeCheck = value
            }
            if let value = dict["SelectScan"] as? Int32 {
                self.selectScan = value
            }
            if let value = dict["SortMergePasses"] as? Int32 {
                self.sortMergePasses = value
            }
            if let value = dict["SortRange"] as? Int32 {
                self.sortRange = value
            }
            if let value = dict["SortRows"] as? Int32 {
                self.sortRows = value
            }
            if let value = dict["SortScan"] as? Int32 {
                self.sortScan = value
            }
            if let value = dict["Sql"] as? String {
                self.sql = value
            }
            if let value = dict["SqlId"] as? String {
                self.sqlId = value
            }
            if let value = dict["ThreadId"] as? Int32 {
                self.threadId = value
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
            if let value = dict["Warnings"] as? Int32 {
                self.warnings = value
            }
        }
    }
    public var code: Int64?

    public var data: [GetPfsSqlSampleResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [GetPfsSqlSampleResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = GetPfsSqlSampleResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetPfsSqlSampleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPfsSqlSampleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPfsSqlSampleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPfsSqlSummariesRequest : Tea.TeaModel {
    public var asc: Bool?

    public var endTime: Int64?

    public var instanceId: String?

    public var keywords: String?

    public var nodeId: String?

    public var orderBy: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sqlId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keywords != nil {
            map["Keywords"] = self.keywords!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Asc"] as? Bool {
            self.asc = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Keywords"] as? String {
            self.keywords = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SqlId"] as? String {
            self.sqlId = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class GetPfsSqlSummariesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var avgLatency: Double?

            public var count: Int64?

            public var countRate: Double?

            public var cpuRate: Double?

            public var cpuTime: Double?

            public var dataReadTime: Double?

            public var dataReads: Int32?

            public var dataWriteTime: Double?

            public var dataWrites: Int32?

            public var db: String?

            public var elapsedTime: Double?

            public var errCount: Int64?

            public var firstTime: Int64?

            public var fullScan: Bool?

            public var id: Int64?

            public var instanceId: String?

            public var lastTime: Int64?

            public var lockLatencyAvg: Double?

            public var logicId: Int64?

            public var logicReads: Int64?

            public var maxLatency: Double?

            public var mutexSpins: Int32?

            public var mutexWaits: Int32?

            public var nodeId: String?

            public var physicalAsyncReads: Int64?

            public var physicalReads: Int64?

            public var psql: String?

            public var redoWrites: Int64?

            public var rowsAffected: Int64?

            public var rowsAffectedAvg: Double?

            public var rowsExamined: Int64?

            public var rowsExaminedAvg: Double?

            public var rowsSendAvg: Double?

            public var rowsSent: Int64?

            public var rowsSentAvg: Double?

            public var rowsSorted: Int64?

            public var rtRate: Double?

            public var rwlockOsWaits: Int32?

            public var rwlockSpinRounds: Int32?

            public var rwlockSpinWaits: Int32?

            public var selectFullJoinAvg: Double?

            public var selectFullRangeJoinAvg: Double?

            public var selectRangeAvg: Double?

            public var selectScanAvg: Double?

            public var semisyncDelayTime: Double?

            public var serverLockTime: Double?

            public var sortMergePasses: Int64?

            public var sortRangeAvg: Double?

            public var sortRowsAvg: Double?

            public var sortScanAvg: Double?

            public var sqlId: String?

            public var sqlType: String?

            public var tables: [String]?

            public var timerWaitAvg: Double?

            public var timestamp: Int64?

            public var tmpDiskTables: Int64?

            public var tmpDiskTablesAvg: Double?

            public var tmpTables: Int64?

            public var tmpTablesAvg: Double?

            public var totalLatency: Double?

            public var transactionLockTime: Double?

            public var userId: String?

            public var warnCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgLatency != nil {
                    map["AvgLatency"] = self.avgLatency!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.countRate != nil {
                    map["CountRate"] = self.countRate!
                }
                if self.cpuRate != nil {
                    map["CpuRate"] = self.cpuRate!
                }
                if self.cpuTime != nil {
                    map["CpuTime"] = self.cpuTime!
                }
                if self.dataReadTime != nil {
                    map["DataReadTime"] = self.dataReadTime!
                }
                if self.dataReads != nil {
                    map["DataReads"] = self.dataReads!
                }
                if self.dataWriteTime != nil {
                    map["DataWriteTime"] = self.dataWriteTime!
                }
                if self.dataWrites != nil {
                    map["DataWrites"] = self.dataWrites!
                }
                if self.db != nil {
                    map["Db"] = self.db!
                }
                if self.elapsedTime != nil {
                    map["ElapsedTime"] = self.elapsedTime!
                }
                if self.errCount != nil {
                    map["ErrCount"] = self.errCount!
                }
                if self.firstTime != nil {
                    map["FirstTime"] = self.firstTime!
                }
                if self.fullScan != nil {
                    map["FullScan"] = self.fullScan!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.lastTime != nil {
                    map["LastTime"] = self.lastTime!
                }
                if self.lockLatencyAvg != nil {
                    map["LockLatencyAvg"] = self.lockLatencyAvg!
                }
                if self.logicId != nil {
                    map["LogicId"] = self.logicId!
                }
                if self.logicReads != nil {
                    map["LogicReads"] = self.logicReads!
                }
                if self.maxLatency != nil {
                    map["MaxLatency"] = self.maxLatency!
                }
                if self.mutexSpins != nil {
                    map["MutexSpins"] = self.mutexSpins!
                }
                if self.mutexWaits != nil {
                    map["MutexWaits"] = self.mutexWaits!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.physicalAsyncReads != nil {
                    map["PhysicalAsyncReads"] = self.physicalAsyncReads!
                }
                if self.physicalReads != nil {
                    map["PhysicalReads"] = self.physicalReads!
                }
                if self.psql != nil {
                    map["Psql"] = self.psql!
                }
                if self.redoWrites != nil {
                    map["RedoWrites"] = self.redoWrites!
                }
                if self.rowsAffected != nil {
                    map["RowsAffected"] = self.rowsAffected!
                }
                if self.rowsAffectedAvg != nil {
                    map["RowsAffectedAvg"] = self.rowsAffectedAvg!
                }
                if self.rowsExamined != nil {
                    map["RowsExamined"] = self.rowsExamined!
                }
                if self.rowsExaminedAvg != nil {
                    map["RowsExaminedAvg"] = self.rowsExaminedAvg!
                }
                if self.rowsSendAvg != nil {
                    map["RowsSendAvg"] = self.rowsSendAvg!
                }
                if self.rowsSent != nil {
                    map["RowsSent"] = self.rowsSent!
                }
                if self.rowsSentAvg != nil {
                    map["RowsSentAvg"] = self.rowsSentAvg!
                }
                if self.rowsSorted != nil {
                    map["RowsSorted"] = self.rowsSorted!
                }
                if self.rtRate != nil {
                    map["RtRate"] = self.rtRate!
                }
                if self.rwlockOsWaits != nil {
                    map["RwlockOsWaits"] = self.rwlockOsWaits!
                }
                if self.rwlockSpinRounds != nil {
                    map["RwlockSpinRounds"] = self.rwlockSpinRounds!
                }
                if self.rwlockSpinWaits != nil {
                    map["RwlockSpinWaits"] = self.rwlockSpinWaits!
                }
                if self.selectFullJoinAvg != nil {
                    map["SelectFullJoinAvg"] = self.selectFullJoinAvg!
                }
                if self.selectFullRangeJoinAvg != nil {
                    map["SelectFullRangeJoinAvg"] = self.selectFullRangeJoinAvg!
                }
                if self.selectRangeAvg != nil {
                    map["SelectRangeAvg"] = self.selectRangeAvg!
                }
                if self.selectScanAvg != nil {
                    map["SelectScanAvg"] = self.selectScanAvg!
                }
                if self.semisyncDelayTime != nil {
                    map["SemisyncDelayTime"] = self.semisyncDelayTime!
                }
                if self.serverLockTime != nil {
                    map["ServerLockTime"] = self.serverLockTime!
                }
                if self.sortMergePasses != nil {
                    map["SortMergePasses"] = self.sortMergePasses!
                }
                if self.sortRangeAvg != nil {
                    map["SortRangeAvg"] = self.sortRangeAvg!
                }
                if self.sortRowsAvg != nil {
                    map["SortRowsAvg"] = self.sortRowsAvg!
                }
                if self.sortScanAvg != nil {
                    map["SortScanAvg"] = self.sortScanAvg!
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.sqlType != nil {
                    map["SqlType"] = self.sqlType!
                }
                if self.tables != nil {
                    map["Tables"] = self.tables!
                }
                if self.timerWaitAvg != nil {
                    map["TimerWaitAvg"] = self.timerWaitAvg!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.tmpDiskTables != nil {
                    map["TmpDiskTables"] = self.tmpDiskTables!
                }
                if self.tmpDiskTablesAvg != nil {
                    map["TmpDiskTablesAvg"] = self.tmpDiskTablesAvg!
                }
                if self.tmpTables != nil {
                    map["TmpTables"] = self.tmpTables!
                }
                if self.tmpTablesAvg != nil {
                    map["TmpTablesAvg"] = self.tmpTablesAvg!
                }
                if self.totalLatency != nil {
                    map["TotalLatency"] = self.totalLatency!
                }
                if self.transactionLockTime != nil {
                    map["TransactionLockTime"] = self.transactionLockTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.warnCount != nil {
                    map["WarnCount"] = self.warnCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AvgLatency"] as? Double {
                    self.avgLatency = value
                }
                if let value = dict["Count"] as? Int64 {
                    self.count = value
                }
                if let value = dict["CountRate"] as? Double {
                    self.countRate = value
                }
                if let value = dict["CpuRate"] as? Double {
                    self.cpuRate = value
                }
                if let value = dict["CpuTime"] as? Double {
                    self.cpuTime = value
                }
                if let value = dict["DataReadTime"] as? Double {
                    self.dataReadTime = value
                }
                if let value = dict["DataReads"] as? Int32 {
                    self.dataReads = value
                }
                if let value = dict["DataWriteTime"] as? Double {
                    self.dataWriteTime = value
                }
                if let value = dict["DataWrites"] as? Int32 {
                    self.dataWrites = value
                }
                if let value = dict["Db"] as? String {
                    self.db = value
                }
                if let value = dict["ElapsedTime"] as? Double {
                    self.elapsedTime = value
                }
                if let value = dict["ErrCount"] as? Int64 {
                    self.errCount = value
                }
                if let value = dict["FirstTime"] as? Int64 {
                    self.firstTime = value
                }
                if let value = dict["FullScan"] as? Bool {
                    self.fullScan = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["LastTime"] as? Int64 {
                    self.lastTime = value
                }
                if let value = dict["LockLatencyAvg"] as? Double {
                    self.lockLatencyAvg = value
                }
                if let value = dict["LogicId"] as? Int64 {
                    self.logicId = value
                }
                if let value = dict["LogicReads"] as? Int64 {
                    self.logicReads = value
                }
                if let value = dict["MaxLatency"] as? Double {
                    self.maxLatency = value
                }
                if let value = dict["MutexSpins"] as? Int32 {
                    self.mutexSpins = value
                }
                if let value = dict["MutexWaits"] as? Int32 {
                    self.mutexWaits = value
                }
                if let value = dict["NodeId"] as? String {
                    self.nodeId = value
                }
                if let value = dict["PhysicalAsyncReads"] as? Int64 {
                    self.physicalAsyncReads = value
                }
                if let value = dict["PhysicalReads"] as? Int64 {
                    self.physicalReads = value
                }
                if let value = dict["Psql"] as? String {
                    self.psql = value
                }
                if let value = dict["RedoWrites"] as? Int64 {
                    self.redoWrites = value
                }
                if let value = dict["RowsAffected"] as? Int64 {
                    self.rowsAffected = value
                }
                if let value = dict["RowsAffectedAvg"] as? Double {
                    self.rowsAffectedAvg = value
                }
                if let value = dict["RowsExamined"] as? Int64 {
                    self.rowsExamined = value
                }
                if let value = dict["RowsExaminedAvg"] as? Double {
                    self.rowsExaminedAvg = value
                }
                if let value = dict["RowsSendAvg"] as? Double {
                    self.rowsSendAvg = value
                }
                if let value = dict["RowsSent"] as? Int64 {
                    self.rowsSent = value
                }
                if let value = dict["RowsSentAvg"] as? Double {
                    self.rowsSentAvg = value
                }
                if let value = dict["RowsSorted"] as? Int64 {
                    self.rowsSorted = value
                }
                if let value = dict["RtRate"] as? Double {
                    self.rtRate = value
                }
                if let value = dict["RwlockOsWaits"] as? Int32 {
                    self.rwlockOsWaits = value
                }
                if let value = dict["RwlockSpinRounds"] as? Int32 {
                    self.rwlockSpinRounds = value
                }
                if let value = dict["RwlockSpinWaits"] as? Int32 {
                    self.rwlockSpinWaits = value
                }
                if let value = dict["SelectFullJoinAvg"] as? Double {
                    self.selectFullJoinAvg = value
                }
                if let value = dict["SelectFullRangeJoinAvg"] as? Double {
                    self.selectFullRangeJoinAvg = value
                }
                if let value = dict["SelectRangeAvg"] as? Double {
                    self.selectRangeAvg = value
                }
                if let value = dict["SelectScanAvg"] as? Double {
                    self.selectScanAvg = value
                }
                if let value = dict["SemisyncDelayTime"] as? Double {
                    self.semisyncDelayTime = value
                }
                if let value = dict["ServerLockTime"] as? Double {
                    self.serverLockTime = value
                }
                if let value = dict["SortMergePasses"] as? Int64 {
                    self.sortMergePasses = value
                }
                if let value = dict["SortRangeAvg"] as? Double {
                    self.sortRangeAvg = value
                }
                if let value = dict["SortRowsAvg"] as? Double {
                    self.sortRowsAvg = value
                }
                if let value = dict["SortScanAvg"] as? Double {
                    self.sortScanAvg = value
                }
                if let value = dict["SqlId"] as? String {
                    self.sqlId = value
                }
                if let value = dict["SqlType"] as? String {
                    self.sqlType = value
                }
                if let value = dict["Tables"] as? [String] {
                    self.tables = value
                }
                if let value = dict["TimerWaitAvg"] as? Double {
                    self.timerWaitAvg = value
                }
                if let value = dict["Timestamp"] as? Int64 {
                    self.timestamp = value
                }
                if let value = dict["TmpDiskTables"] as? Int64 {
                    self.tmpDiskTables = value
                }
                if let value = dict["TmpDiskTablesAvg"] as? Double {
                    self.tmpDiskTablesAvg = value
                }
                if let value = dict["TmpTables"] as? Int64 {
                    self.tmpTables = value
                }
                if let value = dict["TmpTablesAvg"] as? Double {
                    self.tmpTablesAvg = value
                }
                if let value = dict["TotalLatency"] as? Double {
                    self.totalLatency = value
                }
                if let value = dict["TransactionLockTime"] as? Double {
                    self.transactionLockTime = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
                if let value = dict["WarnCount"] as? Int64 {
                    self.warnCount = value
                }
            }
        }
        public var extra: Any?

        public var list: [GetPfsSqlSummariesResponseBody.Data.List]?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Extra"] as? Any {
                self.extra = value
            }
            if let value = dict["List"] as? [Any?] {
                var tmp : [GetPfsSqlSummariesResponseBody.Data.List] = []
                for v in value {
                    if v != nil {
                        var model = GetPfsSqlSummariesResponseBody.Data.List()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.list = tmp
            }
            if let value = dict["PageNo"] as? Int64 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: Int64?

    public var data: GetPfsSqlSummariesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetPfsSqlSummariesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetPfsSqlSummariesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPfsSqlSummariesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPfsSqlSummariesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetQueryOptimizeDataStatsRequest : Tea.TeaModel {
    public var asc: String?

    public var dbNames: String?

    public var engine: String?

    public var instanceIds: String?

    public var keywords: String?

    public var logicalOperator: String?

    public var onlyOptimizedSql: String?

    public var orderBy: String?

    public var pageNo: String?

    public var pageSize: String?

    public var region: String?

    public var rules: String?

    public var sqlIds: String?

    public var tagNames: String?

    public var time: String?

    public var user: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.dbNames != nil {
            map["DbNames"] = self.dbNames!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.keywords != nil {
            map["Keywords"] = self.keywords!
        }
        if self.logicalOperator != nil {
            map["LogicalOperator"] = self.logicalOperator!
        }
        if self.onlyOptimizedSql != nil {
            map["OnlyOptimizedSql"] = self.onlyOptimizedSql!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.rules != nil {
            map["Rules"] = self.rules!
        }
        if self.sqlIds != nil {
            map["SqlIds"] = self.sqlIds!
        }
        if self.tagNames != nil {
            map["TagNames"] = self.tagNames!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        if self.user != nil {
            map["User"] = self.user!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Asc"] as? String {
            self.asc = value
        }
        if let value = dict["DbNames"] as? String {
            self.dbNames = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["Keywords"] as? String {
            self.keywords = value
        }
        if let value = dict["LogicalOperator"] as? String {
            self.logicalOperator = value
        }
        if let value = dict["OnlyOptimizedSql"] as? String {
            self.onlyOptimizedSql = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNo"] as? String {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["Rules"] as? String {
            self.rules = value
        }
        if let value = dict["SqlIds"] as? String {
            self.sqlIds = value
        }
        if let value = dict["TagNames"] as? String {
            self.tagNames = value
        }
        if let value = dict["Time"] as? String {
            self.time = value
        }
        if let value = dict["User"] as? String {
            self.user = value
        }
    }
}

public class GetQueryOptimizeDataStatsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class RuleList : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var avgLockTime: Double?

            public var avgQueryTime: Double?

            public var avgRowsAffected: Double?

            public var avgRowsExamined: Double?

            public var avgRowsSent: Double?

            public var count: Int32?

            public var dbname: String?

            public var instanceId: String?

            public var maxLockTime: Double?

            public var maxQueryTime: Double?

            public var maxRowsAffected: Int64?

            public var maxRowsExamined: Int64?

            public var maxRowsSent: Int64?

            public var psql: String?

            public var ruleList: [GetQueryOptimizeDataStatsResponseBody.Data.List.RuleList]?

            public var sqlId: String?

            public var sqlSample: String?

            public var sqlType: String?

            public var user: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgLockTime != nil {
                    map["AvgLockTime"] = self.avgLockTime!
                }
                if self.avgQueryTime != nil {
                    map["AvgQueryTime"] = self.avgQueryTime!
                }
                if self.avgRowsAffected != nil {
                    map["AvgRowsAffected"] = self.avgRowsAffected!
                }
                if self.avgRowsExamined != nil {
                    map["AvgRowsExamined"] = self.avgRowsExamined!
                }
                if self.avgRowsSent != nil {
                    map["AvgRowsSent"] = self.avgRowsSent!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.dbname != nil {
                    map["Dbname"] = self.dbname!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.maxLockTime != nil {
                    map["MaxLockTime"] = self.maxLockTime!
                }
                if self.maxQueryTime != nil {
                    map["MaxQueryTime"] = self.maxQueryTime!
                }
                if self.maxRowsAffected != nil {
                    map["MaxRowsAffected"] = self.maxRowsAffected!
                }
                if self.maxRowsExamined != nil {
                    map["MaxRowsExamined"] = self.maxRowsExamined!
                }
                if self.maxRowsSent != nil {
                    map["MaxRowsSent"] = self.maxRowsSent!
                }
                if self.psql != nil {
                    map["Psql"] = self.psql!
                }
                if self.ruleList != nil {
                    var tmp : [Any] = []
                    for k in self.ruleList! {
                        tmp.append(k.toMap())
                    }
                    map["RuleList"] = tmp
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.sqlSample != nil {
                    map["SqlSample"] = self.sqlSample!
                }
                if self.sqlType != nil {
                    map["SqlType"] = self.sqlType!
                }
                if self.user != nil {
                    map["User"] = self.user!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AvgLockTime"] as? Double {
                    self.avgLockTime = value
                }
                if let value = dict["AvgQueryTime"] as? Double {
                    self.avgQueryTime = value
                }
                if let value = dict["AvgRowsAffected"] as? Double {
                    self.avgRowsAffected = value
                }
                if let value = dict["AvgRowsExamined"] as? Double {
                    self.avgRowsExamined = value
                }
                if let value = dict["AvgRowsSent"] as? Double {
                    self.avgRowsSent = value
                }
                if let value = dict["Count"] as? Int32 {
                    self.count = value
                }
                if let value = dict["Dbname"] as? String {
                    self.dbname = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["MaxLockTime"] as? Double {
                    self.maxLockTime = value
                }
                if let value = dict["MaxQueryTime"] as? Double {
                    self.maxQueryTime = value
                }
                if let value = dict["MaxRowsAffected"] as? Int64 {
                    self.maxRowsAffected = value
                }
                if let value = dict["MaxRowsExamined"] as? Int64 {
                    self.maxRowsExamined = value
                }
                if let value = dict["MaxRowsSent"] as? Int64 {
                    self.maxRowsSent = value
                }
                if let value = dict["Psql"] as? String {
                    self.psql = value
                }
                if let value = dict["RuleList"] as? [Any?] {
                    var tmp : [GetQueryOptimizeDataStatsResponseBody.Data.List.RuleList] = []
                    for v in value {
                        if v != nil {
                            var model = GetQueryOptimizeDataStatsResponseBody.Data.List.RuleList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.ruleList = tmp
                }
                if let value = dict["SqlId"] as? String {
                    self.sqlId = value
                }
                if let value = dict["SqlSample"] as? String {
                    self.sqlSample = value
                }
                if let value = dict["SqlType"] as? String {
                    self.sqlType = value
                }
                if let value = dict["User"] as? String {
                    self.user = value
                }
            }
        }
        public var extra: String?

        public var list: [GetQueryOptimizeDataStatsResponseBody.Data.List]?

        public var pageNo: Int32?

        public var pageSize: Int32?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Extra"] as? String {
                self.extra = value
            }
            if let value = dict["List"] as? [Any?] {
                var tmp : [GetQueryOptimizeDataStatsResponseBody.Data.List] = []
                for v in value {
                    if v != nil {
                        var model = GetQueryOptimizeDataStatsResponseBody.Data.List()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.list = tmp
            }
            if let value = dict["PageNo"] as? Int32 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: GetQueryOptimizeDataStatsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetQueryOptimizeDataStatsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetQueryOptimizeDataStatsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeDataStatsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetQueryOptimizeDataStatsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetQueryOptimizeDataTopRequest : Tea.TeaModel {
    public var engine: String?

    public var instanceIds: String?

    public var region: String?

    public var tagNames: String?

    public var time: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.tagNames != nil {
            map["TagNames"] = self.tagNames!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["TagNames"] as? String {
            self.tagNames = value
        }
        if let value = dict["Time"] as? String {
            self.time = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class GetQueryOptimizeDataTopResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var instanceId: String?

            public var type: String?

            public var value: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Value"] as? Double {
                    self.value = value
                }
            }
        }
        public var extra: String?

        public var list: [GetQueryOptimizeDataTopResponseBody.Data.List]?

        public var pageNo: Int32?

        public var pageSize: Int32?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Extra"] as? String {
                self.extra = value
            }
            if let value = dict["List"] as? [Any?] {
                var tmp : [GetQueryOptimizeDataTopResponseBody.Data.List] = []
                for v in value {
                    if v != nil {
                        var model = GetQueryOptimizeDataTopResponseBody.Data.List()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.list = tmp
            }
            if let value = dict["PageNo"] as? Int32 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: GetQueryOptimizeDataTopResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetQueryOptimizeDataTopResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetQueryOptimizeDataTopResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeDataTopResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetQueryOptimizeDataTopResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetQueryOptimizeDataTrendRequest : Tea.TeaModel {
    public var end: String?

    public var engine: String?

    public var instanceIds: String?

    public var region: String?

    public var start: String?

    public var tagNames: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        if self.tagNames != nil {
            map["TagNames"] = self.tagNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["End"] as? String {
            self.end = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["Start"] as? String {
            self.start = value
        }
        if let value = dict["TagNames"] as? String {
            self.tagNames = value
        }
    }
}

public class GetQueryOptimizeDataTrendResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var kpi: String?

            public var timestamp: Int64?

            public var value: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.kpi != nil {
                    map["Kpi"] = self.kpi!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Kpi"] as? String {
                    self.kpi = value
                }
                if let value = dict["Timestamp"] as? Int64 {
                    self.timestamp = value
                }
                if let value = dict["Value"] as? Double {
                    self.value = value
                }
            }
        }
        public var extra: String?

        public var list: [GetQueryOptimizeDataTrendResponseBody.Data.List]?

        public var pageNo: Int32?

        public var pageSize: Int32?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Extra"] as? String {
                self.extra = value
            }
            if let value = dict["List"] as? [Any?] {
                var tmp : [GetQueryOptimizeDataTrendResponseBody.Data.List] = []
                for v in value {
                    if v != nil {
                        var model = GetQueryOptimizeDataTrendResponseBody.Data.List()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.list = tmp
            }
            if let value = dict["PageNo"] as? Int32 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: GetQueryOptimizeDataTrendResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetQueryOptimizeDataTrendResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetQueryOptimizeDataTrendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeDataTrendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetQueryOptimizeDataTrendResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetQueryOptimizeExecErrorSampleRequest : Tea.TeaModel {
    public var engine: String?

    public var instanceId: String?

    public var sqlId: String?

    public var time: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["SqlId"] as? String {
            self.sqlId = value
        }
        if let value = dict["Time"] as? String {
            self.time = value
        }
    }
}

public class GetQueryOptimizeExecErrorSampleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var dbname: String?

            public var errorCode: String?

            public var origHost: String?

            public var sqlId: String?

            public var sqlText: String?

            public var timestamp: Int64?

            public var user: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbname != nil {
                    map["Dbname"] = self.dbname!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.origHost != nil {
                    map["OrigHost"] = self.origHost!
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.sqlText != nil {
                    map["SqlText"] = self.sqlText!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.user != nil {
                    map["User"] = self.user!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Dbname"] as? String {
                    self.dbname = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["OrigHost"] as? String {
                    self.origHost = value
                }
                if let value = dict["SqlId"] as? String {
                    self.sqlId = value
                }
                if let value = dict["SqlText"] as? String {
                    self.sqlText = value
                }
                if let value = dict["Timestamp"] as? Int64 {
                    self.timestamp = value
                }
                if let value = dict["User"] as? String {
                    self.user = value
                }
            }
        }
        public var extra: String?

        public var list: [GetQueryOptimizeExecErrorSampleResponseBody.Data.List]?

        public var pageNo: Int32?

        public var pageSize: Int32?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Extra"] as? String {
                self.extra = value
            }
            if let value = dict["List"] as? [Any?] {
                var tmp : [GetQueryOptimizeExecErrorSampleResponseBody.Data.List] = []
                for v in value {
                    if v != nil {
                        var model = GetQueryOptimizeExecErrorSampleResponseBody.Data.List()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.list = tmp
            }
            if let value = dict["PageNo"] as? Int32 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: GetQueryOptimizeExecErrorSampleResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetQueryOptimizeExecErrorSampleResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetQueryOptimizeExecErrorSampleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeExecErrorSampleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetQueryOptimizeExecErrorSampleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetQueryOptimizeExecErrorStatsRequest : Tea.TeaModel {
    public var asc: String?

    public var dbNames: String?

    public var engine: String?

    public var instanceIds: String?

    public var keywords: String?

    public var logicalOperator: String?

    public var orderBy: String?

    public var pageNo: String?

    public var pageSize: String?

    public var region: String?

    public var time: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.dbNames != nil {
            map["DbNames"] = self.dbNames!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.keywords != nil {
            map["Keywords"] = self.keywords!
        }
        if self.logicalOperator != nil {
            map["LogicalOperator"] = self.logicalOperator!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Asc"] as? String {
            self.asc = value
        }
        if let value = dict["DbNames"] as? String {
            self.dbNames = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["Keywords"] as? String {
            self.keywords = value
        }
        if let value = dict["LogicalOperator"] as? String {
            self.logicalOperator = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNo"] as? String {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["Time"] as? String {
            self.time = value
        }
    }
}

public class GetQueryOptimizeExecErrorStatsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var dbname: String?

            public var errorCode: String?

            public var errorCount: Int64?

            public var instanceId: String?

            public var instanceName: String?

            public var sqlId: String?

            public var sqlText: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbname != nil {
                    map["Dbname"] = self.dbname!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorCount != nil {
                    map["ErrorCount"] = self.errorCount!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.sqlText != nil {
                    map["SqlText"] = self.sqlText!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Dbname"] as? String {
                    self.dbname = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["ErrorCount"] as? Int64 {
                    self.errorCount = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceName"] as? String {
                    self.instanceName = value
                }
                if let value = dict["SqlId"] as? String {
                    self.sqlId = value
                }
                if let value = dict["SqlText"] as? String {
                    self.sqlText = value
                }
            }
        }
        public var extra: String?

        public var list: [GetQueryOptimizeExecErrorStatsResponseBody.Data.List]?

        public var pageNo: Int32?

        public var pageSize: Int32?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Extra"] as? String {
                self.extra = value
            }
            if let value = dict["List"] as? [Any?] {
                var tmp : [GetQueryOptimizeExecErrorStatsResponseBody.Data.List] = []
                for v in value {
                    if v != nil {
                        var model = GetQueryOptimizeExecErrorStatsResponseBody.Data.List()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.list = tmp
            }
            if let value = dict["PageNo"] as? Int32 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: GetQueryOptimizeExecErrorStatsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetQueryOptimizeExecErrorStatsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetQueryOptimizeExecErrorStatsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeExecErrorStatsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetQueryOptimizeExecErrorStatsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetQueryOptimizeRuleListRequest : Tea.TeaModel {
    public var engine: String?

    public var instanceIds: String?

    public var region: String?

    public var tagNames: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.tagNames != nil {
            map["TagNames"] = self.tagNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["TagNames"] as? String {
            self.tagNames = value
        }
    }
}

public class GetQueryOptimizeRuleListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var name: String?

            public var ruleId: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["RuleId"] as? String {
                    self.ruleId = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var extra: String?

        public var list: [GetQueryOptimizeRuleListResponseBody.Data.List]?

        public var pageNo: Int32?

        public var pageSize: Int32?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Extra"] as? String {
                self.extra = value
            }
            if let value = dict["List"] as? [Any?] {
                var tmp : [GetQueryOptimizeRuleListResponseBody.Data.List] = []
                for v in value {
                    if v != nil {
                        var model = GetQueryOptimizeRuleListResponseBody.Data.List()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.list = tmp
            }
            if let value = dict["PageNo"] as? Int32 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: GetQueryOptimizeRuleListResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetQueryOptimizeRuleListResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetQueryOptimizeRuleListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeRuleListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetQueryOptimizeRuleListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetQueryOptimizeShareUrlRequest : Tea.TeaModel {
    public var asc: Bool?

    public var dbNames: String?

    public var engine: String?

    public var instanceIds: String?

    public var keywords: String?

    public var logicalOperator: String?

    public var onlyOptimizedSql: Bool?

    public var orderBy: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var region: String?

    public var rules: String?

    public var sqlIds: String?

    public var tagNames: String?

    public var time: Int64?

    public var user: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.dbNames != nil {
            map["DbNames"] = self.dbNames!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.keywords != nil {
            map["Keywords"] = self.keywords!
        }
        if self.logicalOperator != nil {
            map["LogicalOperator"] = self.logicalOperator!
        }
        if self.onlyOptimizedSql != nil {
            map["OnlyOptimizedSql"] = self.onlyOptimizedSql!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.rules != nil {
            map["Rules"] = self.rules!
        }
        if self.sqlIds != nil {
            map["SqlIds"] = self.sqlIds!
        }
        if self.tagNames != nil {
            map["TagNames"] = self.tagNames!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        if self.user != nil {
            map["User"] = self.user!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Asc"] as? Bool {
            self.asc = value
        }
        if let value = dict["DbNames"] as? String {
            self.dbNames = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["Keywords"] as? String {
            self.keywords = value
        }
        if let value = dict["LogicalOperator"] as? String {
            self.logicalOperator = value
        }
        if let value = dict["OnlyOptimizedSql"] as? Bool {
            self.onlyOptimizedSql = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["Rules"] as? String {
            self.rules = value
        }
        if let value = dict["SqlIds"] as? String {
            self.sqlIds = value
        }
        if let value = dict["TagNames"] as? String {
            self.tagNames = value
        }
        if let value = dict["Time"] as? Int64 {
            self.time = value
        }
        if let value = dict["User"] as? String {
            self.user = value
        }
    }
}

public class GetQueryOptimizeShareUrlResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetQueryOptimizeShareUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeShareUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetQueryOptimizeShareUrlResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetQueryOptimizeSolutionRequest : Tea.TeaModel {
    public var engine: String?

    public var instanceId: String?

    public var ruleIds: String?

    public var sqlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ruleIds != nil {
            map["RuleIds"] = self.ruleIds!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RuleIds"] as? String {
            self.ruleIds = value
        }
        if let value = dict["SqlId"] as? String {
            self.sqlId = value
        }
    }
}

public class GetQueryOptimizeSolutionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var level: String?

            public var ruleId: String?

            public var solution: String?

            public var solutionExt: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.solution != nil {
                    map["Solution"] = self.solution!
                }
                if self.solutionExt != nil {
                    map["SolutionExt"] = self.solutionExt!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Level"] as? String {
                    self.level = value
                }
                if let value = dict["RuleId"] as? String {
                    self.ruleId = value
                }
                if let value = dict["Solution"] as? String {
                    self.solution = value
                }
                if let value = dict["SolutionExt"] as? String {
                    self.solutionExt = value
                }
            }
        }
        public var extra: String?

        public var list: [GetQueryOptimizeSolutionResponseBody.Data.List]?

        public var pageNo: Int32?

        public var pageSize: Int32?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Extra"] as? String {
                self.extra = value
            }
            if let value = dict["List"] as? [Any?] {
                var tmp : [GetQueryOptimizeSolutionResponseBody.Data.List] = []
                for v in value {
                    if v != nil {
                        var model = GetQueryOptimizeSolutionResponseBody.Data.List()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.list = tmp
            }
            if let value = dict["PageNo"] as? Int32 {
                self.pageNo = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: GetQueryOptimizeSolutionResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetQueryOptimizeSolutionResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetQueryOptimizeSolutionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeSolutionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetQueryOptimizeSolutionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetQueryOptimizeTagRequest : Tea.TeaModel {
    public var engine: String?

    public var instanceId: String?

    public var sqlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["SqlId"] as? String {
            self.sqlId = value
        }
    }
}

public class GetQueryOptimizeTagResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var comments: String?

        public var sqlId: String?

        public var tags: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comments != nil {
                map["Comments"] = self.comments!
            }
            if self.sqlId != nil {
                map["SqlId"] = self.sqlId!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Comments"] as? String {
                self.comments = value
            }
            if let value = dict["SqlId"] as? String {
                self.sqlId = value
            }
            if let value = dict["Tags"] as? String {
                self.tags = value
            }
        }
    }
    public var code: String?

    public var data: GetQueryOptimizeTagResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetQueryOptimizeTagResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetQueryOptimizeTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetQueryOptimizeTagResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetRedisAllSessionRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetRedisAllSessionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Sessions : Tea.TeaModel {
            public var addr: String?

            public var age: String?

            public var client: String?

            public var clientDesc: String?

            public var cmd: String?

            public var db: Int64?

            public var events: String?

            public var fd: Int64?

            public var flags: String?

            public var id: Int64?

            public var idle: Int64?

            public var multi: Int64?

            public var name: String?

            public var nodeId: String?

            public var obl: Int64?

            public var oll: Int64?

            public var omem: Int64?

            public var psub: Int64?

            public var qbuf: Int64?

            public var qbufFree: Int64?

            public var sub: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addr != nil {
                    map["Addr"] = self.addr!
                }
                if self.age != nil {
                    map["Age"] = self.age!
                }
                if self.client != nil {
                    map["Client"] = self.client!
                }
                if self.clientDesc != nil {
                    map["ClientDesc"] = self.clientDesc!
                }
                if self.cmd != nil {
                    map["Cmd"] = self.cmd!
                }
                if self.db != nil {
                    map["Db"] = self.db!
                }
                if self.events != nil {
                    map["Events"] = self.events!
                }
                if self.fd != nil {
                    map["Fd"] = self.fd!
                }
                if self.flags != nil {
                    map["Flags"] = self.flags!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.idle != nil {
                    map["Idle"] = self.idle!
                }
                if self.multi != nil {
                    map["Multi"] = self.multi!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.obl != nil {
                    map["Obl"] = self.obl!
                }
                if self.oll != nil {
                    map["Oll"] = self.oll!
                }
                if self.omem != nil {
                    map["Omem"] = self.omem!
                }
                if self.psub != nil {
                    map["Psub"] = self.psub!
                }
                if self.qbuf != nil {
                    map["Qbuf"] = self.qbuf!
                }
                if self.qbufFree != nil {
                    map["QbufFree"] = self.qbufFree!
                }
                if self.sub != nil {
                    map["Sub"] = self.sub!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Addr"] as? String {
                    self.addr = value
                }
                if let value = dict["Age"] as? String {
                    self.age = value
                }
                if let value = dict["Client"] as? String {
                    self.client = value
                }
                if let value = dict["ClientDesc"] as? String {
                    self.clientDesc = value
                }
                if let value = dict["Cmd"] as? String {
                    self.cmd = value
                }
                if let value = dict["Db"] as? Int64 {
                    self.db = value
                }
                if let value = dict["Events"] as? String {
                    self.events = value
                }
                if let value = dict["Fd"] as? Int64 {
                    self.fd = value
                }
                if let value = dict["Flags"] as? String {
                    self.flags = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Idle"] as? Int64 {
                    self.idle = value
                }
                if let value = dict["Multi"] as? Int64 {
                    self.multi = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["NodeId"] as? String {
                    self.nodeId = value
                }
                if let value = dict["Obl"] as? Int64 {
                    self.obl = value
                }
                if let value = dict["Oll"] as? Int64 {
                    self.oll = value
                }
                if let value = dict["Omem"] as? Int64 {
                    self.omem = value
                }
                if let value = dict["Psub"] as? Int64 {
                    self.psub = value
                }
                if let value = dict["Qbuf"] as? Int64 {
                    self.qbuf = value
                }
                if let value = dict["QbufFree"] as? Int64 {
                    self.qbufFree = value
                }
                if let value = dict["Sub"] as? Int64 {
                    self.sub = value
                }
            }
        }
        public class SourceStats : Tea.TeaModel {
            public var count: String?

            public var ids: [Int64]?

            public var key: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.ids != nil {
                    map["Ids"] = self.ids!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? String {
                    self.count = value
                }
                if let value = dict["Ids"] as? [Int64] {
                    self.ids = value
                }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
            }
        }
        public var sessions: [GetRedisAllSessionResponseBody.Data.Sessions]?

        public var sourceStats: [GetRedisAllSessionResponseBody.Data.SourceStats]?

        public var timestamp: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sessions != nil {
                var tmp : [Any] = []
                for k in self.sessions! {
                    tmp.append(k.toMap())
                }
                map["Sessions"] = tmp
            }
            if self.sourceStats != nil {
                var tmp : [Any] = []
                for k in self.sourceStats! {
                    tmp.append(k.toMap())
                }
                map["SourceStats"] = tmp
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Sessions"] as? [Any?] {
                var tmp : [GetRedisAllSessionResponseBody.Data.Sessions] = []
                for v in value {
                    if v != nil {
                        var model = GetRedisAllSessionResponseBody.Data.Sessions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sessions = tmp
            }
            if let value = dict["SourceStats"] as? [Any?] {
                var tmp : [GetRedisAllSessionResponseBody.Data.SourceStats] = []
                for v in value {
                    if v != nil {
                        var model = GetRedisAllSessionResponseBody.Data.SourceStats()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sourceStats = tmp
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: Int64?

    public var data: GetRedisAllSessionResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetRedisAllSessionResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetRedisAllSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRedisAllSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetRedisAllSessionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetRequestDiagnosisPageRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var nodeId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class GetRequestDiagnosisPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var accountId: String?

            public var dbSchema: String?

            public var engine: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var messageId: String?

            public var param: String?

            public var result: String?

            public var sqlId: String?

            public var state: Int32?

            public var uuid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["accountId"] = self.accountId!
                }
                if self.dbSchema != nil {
                    map["dbSchema"] = self.dbSchema!
                }
                if self.engine != nil {
                    map["engine"] = self.engine!
                }
                if self.gmtCreate != nil {
                    map["gmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["gmtModified"] = self.gmtModified!
                }
                if self.messageId != nil {
                    map["messageId"] = self.messageId!
                }
                if self.param != nil {
                    map["param"] = self.param!
                }
                if self.result != nil {
                    map["result"] = self.result!
                }
                if self.sqlId != nil {
                    map["sqlId"] = self.sqlId!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.uuid != nil {
                    map["uuid"] = self.uuid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["accountId"] as? String {
                    self.accountId = value
                }
                if let value = dict["dbSchema"] as? String {
                    self.dbSchema = value
                }
                if let value = dict["engine"] as? String {
                    self.engine = value
                }
                if let value = dict["gmtCreate"] as? String {
                    self.gmtCreate = value
                }
                if let value = dict["gmtModified"] as? String {
                    self.gmtModified = value
                }
                if let value = dict["messageId"] as? String {
                    self.messageId = value
                }
                if let value = dict["param"] as? String {
                    self.param = value
                }
                if let value = dict["result"] as? String {
                    self.result = value
                }
                if let value = dict["sqlId"] as? String {
                    self.sqlId = value
                }
                if let value = dict["state"] as? Int32 {
                    self.state = value
                }
                if let value = dict["uuid"] as? String {
                    self.uuid = value
                }
            }
        }
        public var extra: String?

        public var list: [GetRequestDiagnosisPageResponseBody.Data.List]?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["list"] = tmp
            }
            if self.pageNo != nil {
                map["pageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["pageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["extra"] as? String {
                self.extra = value
            }
            if let value = dict["list"] as? [Any?] {
                var tmp : [GetRequestDiagnosisPageResponseBody.Data.List] = []
                for v in value {
                    if v != nil {
                        var model = GetRequestDiagnosisPageResponseBody.Data.List()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.list = tmp
            }
            if let value = dict["pageNo"] as? Int64 {
                self.pageNo = value
            }
            if let value = dict["pageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: GetRequestDiagnosisPageResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetRequestDiagnosisPageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetRequestDiagnosisPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRequestDiagnosisPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetRequestDiagnosisPageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetRequestDiagnosisResultRequest : Tea.TeaModel {
    public var instanceId: String?

    public var messageId: String?

    public var nodeId: String?

    public var source: String?

    public var sqlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["MessageId"] as? String {
            self.messageId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["Source"] as? String {
            self.source = value
        }
        if let value = dict["SqlId"] as? String {
            self.sqlId = value
        }
    }
}

public class GetRequestDiagnosisResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accountId: String?

        public var dbSchema: String?

        public var engine: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var messageId: String?

        public var param: String?

        public var result: String?

        public var sqlId: String?

        public var state: Int32?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            if self.dbSchema != nil {
                map["dbSchema"] = self.dbSchema!
            }
            if self.engine != nil {
                map["engine"] = self.engine!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.messageId != nil {
                map["messageId"] = self.messageId!
            }
            if self.param != nil {
                map["param"] = self.param!
            }
            if self.result != nil {
                map["result"] = self.result!
            }
            if self.sqlId != nil {
                map["sqlId"] = self.sqlId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.uuid != nil {
                map["uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accountId"] as? String {
                self.accountId = value
            }
            if let value = dict["dbSchema"] as? String {
                self.dbSchema = value
            }
            if let value = dict["engine"] as? String {
                self.engine = value
            }
            if let value = dict["gmtCreate"] as? String {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? String {
                self.gmtModified = value
            }
            if let value = dict["messageId"] as? String {
                self.messageId = value
            }
            if let value = dict["param"] as? String {
                self.param = value
            }
            if let value = dict["result"] as? String {
                self.result = value
            }
            if let value = dict["sqlId"] as? String {
                self.sqlId = value
            }
            if let value = dict["state"] as? Int32 {
                self.state = value
            }
            if let value = dict["uuid"] as? String {
                self.uuid = value
            }
        }
    }
    public var code: String?

    public var data: GetRequestDiagnosisResultResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetRequestDiagnosisResultResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetRequestDiagnosisResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRequestDiagnosisResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetRequestDiagnosisResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetRunningSqlConcurrencyControlRulesRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNo"] as? Int64 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class GetRunningSqlConcurrencyControlRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class RunningRules : Tea.TeaModel {
                public var concurrencyControlTime: Int64?

                public var instanceId: String?

                public var itemId: Int64?

                public var keywordsHash: String?

                public var maxConcurrency: String?

                public var sqlKeywords: String?

                public var sqlType: String?

                public var startTime: Int64?

                public var status: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.concurrencyControlTime != nil {
                        map["ConcurrencyControlTime"] = self.concurrencyControlTime!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.itemId != nil {
                        map["ItemId"] = self.itemId!
                    }
                    if self.keywordsHash != nil {
                        map["KeywordsHash"] = self.keywordsHash!
                    }
                    if self.maxConcurrency != nil {
                        map["MaxConcurrency"] = self.maxConcurrency!
                    }
                    if self.sqlKeywords != nil {
                        map["SqlKeywords"] = self.sqlKeywords!
                    }
                    if self.sqlType != nil {
                        map["SqlType"] = self.sqlType!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ConcurrencyControlTime"] as? Int64 {
                        self.concurrencyControlTime = value
                    }
                    if let value = dict["InstanceId"] as? String {
                        self.instanceId = value
                    }
                    if let value = dict["ItemId"] as? Int64 {
                        self.itemId = value
                    }
                    if let value = dict["KeywordsHash"] as? String {
                        self.keywordsHash = value
                    }
                    if let value = dict["MaxConcurrency"] as? String {
                        self.maxConcurrency = value
                    }
                    if let value = dict["SqlKeywords"] as? String {
                        self.sqlKeywords = value
                    }
                    if let value = dict["SqlType"] as? String {
                        self.sqlType = value
                    }
                    if let value = dict["StartTime"] as? Int64 {
                        self.startTime = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                    if let value = dict["UserId"] as? String {
                        self.userId = value
                    }
                }
            }
            public var runningRules: [GetRunningSqlConcurrencyControlRulesResponseBody.Data.List.RunningRules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.runningRules != nil {
                    var tmp : [Any] = []
                    for k in self.runningRules! {
                        tmp.append(k.toMap())
                    }
                    map["runningRules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["runningRules"] as? [Any?] {
                    var tmp : [GetRunningSqlConcurrencyControlRulesResponseBody.Data.List.RunningRules] = []
                    for v in value {
                        if v != nil {
                            var model = GetRunningSqlConcurrencyControlRulesResponseBody.Data.List.RunningRules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.runningRules = tmp
                }
            }
        }
        public var list: GetRunningSqlConcurrencyControlRulesResponseBody.Data.List?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.list?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                map["List"] = self.list?.toMap()
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["List"] as? [String: Any?] {
                var model = GetRunningSqlConcurrencyControlRulesResponseBody.Data.List()
                model.fromMap(value)
                self.list = model
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: GetRunningSqlConcurrencyControlRulesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetRunningSqlConcurrencyControlRulesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetRunningSqlConcurrencyControlRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRunningSqlConcurrencyControlRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetRunningSqlConcurrencyControlRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSqlConcurrencyControlKeywordsFromSqlTextRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public var sqlText: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sqlText != nil {
            map["SqlText"] = self.sqlText!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["SqlText"] as? String {
            self.sqlText = value
        }
    }
}

public class GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetSqlConcurrencyControlKeywordsFromSqlTextResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSqlConcurrencyControlRulesHistoryRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNo"] as? Int64 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class GetSqlConcurrencyControlRulesHistoryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class Rules : Tea.TeaModel {
                public var concurrencyControlTime: Int64?

                public var instanceId: String?

                public var itemId: Int64?

                public var keywordsHash: String?

                public var maxConcurrency: Int64?

                public var sqlKeywords: String?

                public var sqlType: String?

                public var startTime: Int64?

                public var status: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.concurrencyControlTime != nil {
                        map["ConcurrencyControlTime"] = self.concurrencyControlTime!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.itemId != nil {
                        map["ItemId"] = self.itemId!
                    }
                    if self.keywordsHash != nil {
                        map["KeywordsHash"] = self.keywordsHash!
                    }
                    if self.maxConcurrency != nil {
                        map["MaxConcurrency"] = self.maxConcurrency!
                    }
                    if self.sqlKeywords != nil {
                        map["SqlKeywords"] = self.sqlKeywords!
                    }
                    if self.sqlType != nil {
                        map["SqlType"] = self.sqlType!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ConcurrencyControlTime"] as? Int64 {
                        self.concurrencyControlTime = value
                    }
                    if let value = dict["InstanceId"] as? String {
                        self.instanceId = value
                    }
                    if let value = dict["ItemId"] as? Int64 {
                        self.itemId = value
                    }
                    if let value = dict["KeywordsHash"] as? String {
                        self.keywordsHash = value
                    }
                    if let value = dict["MaxConcurrency"] as? Int64 {
                        self.maxConcurrency = value
                    }
                    if let value = dict["SqlKeywords"] as? String {
                        self.sqlKeywords = value
                    }
                    if let value = dict["SqlType"] as? String {
                        self.sqlType = value
                    }
                    if let value = dict["StartTime"] as? Int64 {
                        self.startTime = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                    if let value = dict["UserId"] as? String {
                        self.userId = value
                    }
                }
            }
            public var rules: [GetSqlConcurrencyControlRulesHistoryResponseBody.Data.List.Rules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rules != nil {
                    var tmp : [Any] = []
                    for k in self.rules! {
                        tmp.append(k.toMap())
                    }
                    map["rules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["rules"] as? [Any?] {
                    var tmp : [GetSqlConcurrencyControlRulesHistoryResponseBody.Data.List.Rules] = []
                    for v in value {
                        if v != nil {
                            var model = GetSqlConcurrencyControlRulesHistoryResponseBody.Data.List.Rules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.rules = tmp
                }
            }
        }
        public var list: GetSqlConcurrencyControlRulesHistoryResponseBody.Data.List?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.list?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                map["List"] = self.list?.toMap()
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["List"] as? [String: Any?] {
                var model = GetSqlConcurrencyControlRulesHistoryResponseBody.Data.List()
                model.fromMap(value)
                self.list = model
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: GetSqlConcurrencyControlRulesHistoryResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetSqlConcurrencyControlRulesHistoryResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetSqlConcurrencyControlRulesHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSqlConcurrencyControlRulesHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSqlConcurrencyControlRulesHistoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSqlOptimizeAdviceRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var endDt: String?

    public var engine: String?

    public var instanceIds: String?

    public var region: String?

    public var startDt: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.endDt != nil {
            map["EndDt"] = self.endDt!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startDt != nil {
            map["StartDt"] = self.startDt!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["EndDt"] as? String {
            self.endDt = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["StartDt"] as? String {
            self.startDt = value
        }
    }
}

public class GetSqlOptimizeAdviceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createTime: String?

        public var downloadUrl: String?

        public var expireTime: String?

        public var status: String?

        public var statusCode: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.downloadUrl != nil {
                map["DownloadUrl"] = self.downloadUrl!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusCode != nil {
                map["StatusCode"] = self.statusCode!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["DownloadUrl"] as? String {
                self.downloadUrl = value
            }
            if let value = dict["ExpireTime"] as? String {
                self.expireTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["StatusCode"] as? String {
                self.statusCode = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
        }
    }
    public var code: String?

    public var data: GetSqlOptimizeAdviceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetSqlOptimizeAdviceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetSqlOptimizeAdviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSqlOptimizeAdviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSqlOptimizeAdviceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetStorageAnalysisResultRequest : Tea.TeaModel {
    public var instanceId: String?

    public var nodeId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class GetStorageAnalysisResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class StorageAnalysisResult : Tea.TeaModel {
            public class NeedOptimizeItemList : Tea.TeaModel {
                public var associatedData: String?

                public var dbName: String?

                public var optimizeAdvice: String?

                public var optimizeItemName: String?

                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.associatedData != nil {
                        map["AssociatedData"] = self.associatedData!
                    }
                    if self.dbName != nil {
                        map["DbName"] = self.dbName!
                    }
                    if self.optimizeAdvice != nil {
                        map["OptimizeAdvice"] = self.optimizeAdvice!
                    }
                    if self.optimizeItemName != nil {
                        map["OptimizeItemName"] = self.optimizeItemName!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AssociatedData"] as? String {
                        self.associatedData = value
                    }
                    if let value = dict["DbName"] as? String {
                        self.dbName = value
                    }
                    if let value = dict["OptimizeAdvice"] as? String {
                        self.optimizeAdvice = value
                    }
                    if let value = dict["OptimizeItemName"] as? String {
                        self.optimizeItemName = value
                    }
                    if let value = dict["TableName"] as? String {
                        self.tableName = value
                    }
                }
            }
            public class TableStats : Tea.TeaModel {
                public var avgRowLength: Int64?

                public var dataFree: Int64?

                public var dataSize: Int64?

                public var dbName: String?

                public var engine: String?

                public var fragmentSize: Int64?

                public var indexSize: Int64?

                public var phyTotalSize: Int64?

                public var physicalFileSize: Int64?

                public var tableName: String?

                public var tableRows: Int64?

                public var tableType: String?

                public var totalSize: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgRowLength != nil {
                        map["AvgRowLength"] = self.avgRowLength!
                    }
                    if self.dataFree != nil {
                        map["DataFree"] = self.dataFree!
                    }
                    if self.dataSize != nil {
                        map["DataSize"] = self.dataSize!
                    }
                    if self.dbName != nil {
                        map["DbName"] = self.dbName!
                    }
                    if self.engine != nil {
                        map["Engine"] = self.engine!
                    }
                    if self.fragmentSize != nil {
                        map["FragmentSize"] = self.fragmentSize!
                    }
                    if self.indexSize != nil {
                        map["IndexSize"] = self.indexSize!
                    }
                    if self.phyTotalSize != nil {
                        map["PhyTotalSize"] = self.phyTotalSize!
                    }
                    if self.physicalFileSize != nil {
                        map["PhysicalFileSize"] = self.physicalFileSize!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    if self.tableRows != nil {
                        map["TableRows"] = self.tableRows!
                    }
                    if self.tableType != nil {
                        map["TableType"] = self.tableType!
                    }
                    if self.totalSize != nil {
                        map["TotalSize"] = self.totalSize!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AvgRowLength"] as? Int64 {
                        self.avgRowLength = value
                    }
                    if let value = dict["DataFree"] as? Int64 {
                        self.dataFree = value
                    }
                    if let value = dict["DataSize"] as? Int64 {
                        self.dataSize = value
                    }
                    if let value = dict["DbName"] as? String {
                        self.dbName = value
                    }
                    if let value = dict["Engine"] as? String {
                        self.engine = value
                    }
                    if let value = dict["FragmentSize"] as? Int64 {
                        self.fragmentSize = value
                    }
                    if let value = dict["IndexSize"] as? Int64 {
                        self.indexSize = value
                    }
                    if let value = dict["PhyTotalSize"] as? Int64 {
                        self.phyTotalSize = value
                    }
                    if let value = dict["PhysicalFileSize"] as? Int64 {
                        self.physicalFileSize = value
                    }
                    if let value = dict["TableName"] as? String {
                        self.tableName = value
                    }
                    if let value = dict["TableRows"] as? Int64 {
                        self.tableRows = value
                    }
                    if let value = dict["TableType"] as? String {
                        self.tableType = value
                    }
                    if let value = dict["TotalSize"] as? Int64 {
                        self.totalSize = value
                    }
                }
            }
            public var analysisErrorType: String?

            public var analysisSuccess: Bool?

            public var dailyIncrement: Int64?

            public var estimateAvailableDays: Int64?

            public var needOptimizeItemList: [GetStorageAnalysisResultResponseBody.Data.StorageAnalysisResult.NeedOptimizeItemList]?

            public var tableStats: [GetStorageAnalysisResultResponseBody.Data.StorageAnalysisResult.TableStats]?

            public var totalFreeStorageSize: Int64?

            public var totalStorageSize: Int64?

            public var totalUsedStorageSize: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.analysisErrorType != nil {
                    map["AnalysisErrorType"] = self.analysisErrorType!
                }
                if self.analysisSuccess != nil {
                    map["AnalysisSuccess"] = self.analysisSuccess!
                }
                if self.dailyIncrement != nil {
                    map["DailyIncrement"] = self.dailyIncrement!
                }
                if self.estimateAvailableDays != nil {
                    map["EstimateAvailableDays"] = self.estimateAvailableDays!
                }
                if self.needOptimizeItemList != nil {
                    var tmp : [Any] = []
                    for k in self.needOptimizeItemList! {
                        tmp.append(k.toMap())
                    }
                    map["NeedOptimizeItemList"] = tmp
                }
                if self.tableStats != nil {
                    var tmp : [Any] = []
                    for k in self.tableStats! {
                        tmp.append(k.toMap())
                    }
                    map["TableStats"] = tmp
                }
                if self.totalFreeStorageSize != nil {
                    map["TotalFreeStorageSize"] = self.totalFreeStorageSize!
                }
                if self.totalStorageSize != nil {
                    map["TotalStorageSize"] = self.totalStorageSize!
                }
                if self.totalUsedStorageSize != nil {
                    map["TotalUsedStorageSize"] = self.totalUsedStorageSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AnalysisErrorType"] as? String {
                    self.analysisErrorType = value
                }
                if let value = dict["AnalysisSuccess"] as? Bool {
                    self.analysisSuccess = value
                }
                if let value = dict["DailyIncrement"] as? Int64 {
                    self.dailyIncrement = value
                }
                if let value = dict["EstimateAvailableDays"] as? Int64 {
                    self.estimateAvailableDays = value
                }
                if let value = dict["NeedOptimizeItemList"] as? [Any?] {
                    var tmp : [GetStorageAnalysisResultResponseBody.Data.StorageAnalysisResult.NeedOptimizeItemList] = []
                    for v in value {
                        if v != nil {
                            var model = GetStorageAnalysisResultResponseBody.Data.StorageAnalysisResult.NeedOptimizeItemList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.needOptimizeItemList = tmp
                }
                if let value = dict["TableStats"] as? [Any?] {
                    var tmp : [GetStorageAnalysisResultResponseBody.Data.StorageAnalysisResult.TableStats] = []
                    for v in value {
                        if v != nil {
                            var model = GetStorageAnalysisResultResponseBody.Data.StorageAnalysisResult.TableStats()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.tableStats = tmp
                }
                if let value = dict["TotalFreeStorageSize"] as? Int64 {
                    self.totalFreeStorageSize = value
                }
                if let value = dict["TotalStorageSize"] as? Int64 {
                    self.totalStorageSize = value
                }
                if let value = dict["TotalUsedStorageSize"] as? Int64 {
                    self.totalUsedStorageSize = value
                }
            }
        }
        public var analyzedDbCount: Int64?

        public var storageAnalysisResult: GetStorageAnalysisResultResponseBody.Data.StorageAnalysisResult?

        public var taskFinish: Bool?

        public var taskId: String?

        public var taskProgress: Int64?

        public var taskState: String?

        public var taskSuccess: Bool?

        public var totalDbCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.storageAnalysisResult?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analyzedDbCount != nil {
                map["AnalyzedDbCount"] = self.analyzedDbCount!
            }
            if self.storageAnalysisResult != nil {
                map["StorageAnalysisResult"] = self.storageAnalysisResult?.toMap()
            }
            if self.taskFinish != nil {
                map["TaskFinish"] = self.taskFinish!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskProgress != nil {
                map["TaskProgress"] = self.taskProgress!
            }
            if self.taskState != nil {
                map["TaskState"] = self.taskState!
            }
            if self.taskSuccess != nil {
                map["TaskSuccess"] = self.taskSuccess!
            }
            if self.totalDbCount != nil {
                map["TotalDbCount"] = self.totalDbCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AnalyzedDbCount"] as? Int64 {
                self.analyzedDbCount = value
            }
            if let value = dict["StorageAnalysisResult"] as? [String: Any?] {
                var model = GetStorageAnalysisResultResponseBody.Data.StorageAnalysisResult()
                model.fromMap(value)
                self.storageAnalysisResult = model
            }
            if let value = dict["TaskFinish"] as? Bool {
                self.taskFinish = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
            if let value = dict["TaskProgress"] as? Int64 {
                self.taskProgress = value
            }
            if let value = dict["TaskState"] as? String {
                self.taskState = value
            }
            if let value = dict["TaskSuccess"] as? Bool {
                self.taskSuccess = value
            }
            if let value = dict["TotalDbCount"] as? Int64 {
                self.totalDbCount = value
            }
        }
    }
    public var code: Int64?

    public var data: GetStorageAnalysisResultResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetStorageAnalysisResultResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetStorageAnalysisResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetStorageAnalysisResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetStorageAnalysisResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class KillInstanceAllSessionRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class KillInstanceAllSessionResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class KillInstanceAllSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: KillInstanceAllSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = KillInstanceAllSessionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyAutoScalingConfigRequest : Tea.TeaModel {
    public class Bandwidth : Tea.TeaModel {
        public var apply: Bool?

        public var bandwidthUsageLowerThreshold: Int32?

        public var bandwidthUsageUpperThreshold: Int32?

        public var downgrade: Bool?

        public var observationWindowSize: String?

        public var upgrade: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apply != nil {
                map["Apply"] = self.apply!
            }
            if self.bandwidthUsageLowerThreshold != nil {
                map["BandwidthUsageLowerThreshold"] = self.bandwidthUsageLowerThreshold!
            }
            if self.bandwidthUsageUpperThreshold != nil {
                map["BandwidthUsageUpperThreshold"] = self.bandwidthUsageUpperThreshold!
            }
            if self.downgrade != nil {
                map["Downgrade"] = self.downgrade!
            }
            if self.observationWindowSize != nil {
                map["ObservationWindowSize"] = self.observationWindowSize!
            }
            if self.upgrade != nil {
                map["Upgrade"] = self.upgrade!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Apply"] as? Bool {
                self.apply = value
            }
            if let value = dict["BandwidthUsageLowerThreshold"] as? Int32 {
                self.bandwidthUsageLowerThreshold = value
            }
            if let value = dict["BandwidthUsageUpperThreshold"] as? Int32 {
                self.bandwidthUsageUpperThreshold = value
            }
            if let value = dict["Downgrade"] as? Bool {
                self.downgrade = value
            }
            if let value = dict["ObservationWindowSize"] as? String {
                self.observationWindowSize = value
            }
            if let value = dict["Upgrade"] as? Bool {
                self.upgrade = value
            }
        }
    }
    public class Resource : Tea.TeaModel {
        public var apply: Bool?

        public var cpuUsageUpperThreshold: Int32?

        public var downgradeObservationWindowSize: String?

        public var enable: Bool?

        public var upgradeObservationWindowSize: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apply != nil {
                map["Apply"] = self.apply!
            }
            if self.cpuUsageUpperThreshold != nil {
                map["CpuUsageUpperThreshold"] = self.cpuUsageUpperThreshold!
            }
            if self.downgradeObservationWindowSize != nil {
                map["DowngradeObservationWindowSize"] = self.downgradeObservationWindowSize!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.upgradeObservationWindowSize != nil {
                map["UpgradeObservationWindowSize"] = self.upgradeObservationWindowSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Apply"] as? Bool {
                self.apply = value
            }
            if let value = dict["CpuUsageUpperThreshold"] as? Int32 {
                self.cpuUsageUpperThreshold = value
            }
            if let value = dict["DowngradeObservationWindowSize"] as? String {
                self.downgradeObservationWindowSize = value
            }
            if let value = dict["Enable"] as? Bool {
                self.enable = value
            }
            if let value = dict["UpgradeObservationWindowSize"] as? String {
                self.upgradeObservationWindowSize = value
            }
        }
    }
    public class Shard : Tea.TeaModel {
        public var apply: Bool?

        public var downgrade: Bool?

        public var downgradeObservationWindowSize: String?

        public var maxShards: Int32?

        public var memUsageLowerThreshold: Int32?

        public var memUsageUpperThreshold: Int32?

        public var minShards: Int32?

        public var upgrade: Bool?

        public var upgradeObservationWindowSize: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apply != nil {
                map["Apply"] = self.apply!
            }
            if self.downgrade != nil {
                map["Downgrade"] = self.downgrade!
            }
            if self.downgradeObservationWindowSize != nil {
                map["DowngradeObservationWindowSize"] = self.downgradeObservationWindowSize!
            }
            if self.maxShards != nil {
                map["MaxShards"] = self.maxShards!
            }
            if self.memUsageLowerThreshold != nil {
                map["MemUsageLowerThreshold"] = self.memUsageLowerThreshold!
            }
            if self.memUsageUpperThreshold != nil {
                map["MemUsageUpperThreshold"] = self.memUsageUpperThreshold!
            }
            if self.minShards != nil {
                map["MinShards"] = self.minShards!
            }
            if self.upgrade != nil {
                map["Upgrade"] = self.upgrade!
            }
            if self.upgradeObservationWindowSize != nil {
                map["UpgradeObservationWindowSize"] = self.upgradeObservationWindowSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Apply"] as? Bool {
                self.apply = value
            }
            if let value = dict["Downgrade"] as? Bool {
                self.downgrade = value
            }
            if let value = dict["DowngradeObservationWindowSize"] as? String {
                self.downgradeObservationWindowSize = value
            }
            if let value = dict["MaxShards"] as? Int32 {
                self.maxShards = value
            }
            if let value = dict["MemUsageLowerThreshold"] as? Int32 {
                self.memUsageLowerThreshold = value
            }
            if let value = dict["MemUsageUpperThreshold"] as? Int32 {
                self.memUsageUpperThreshold = value
            }
            if let value = dict["MinShards"] as? Int32 {
                self.minShards = value
            }
            if let value = dict["Upgrade"] as? Bool {
                self.upgrade = value
            }
            if let value = dict["UpgradeObservationWindowSize"] as? String {
                self.upgradeObservationWindowSize = value
            }
        }
    }
    public class Spec : Tea.TeaModel {
        public var apply: Bool?

        public var coolDownTime: String?

        public var cpuUsageUpperThreshold: Int32?

        public var downgrade: Bool?

        public var maxReadOnlyNodes: Int32?

        public var maxSpec: String?

        public var memUsageUpperThreshold: Int32?

        public var observationWindowSize: String?

        public var upgrade: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apply != nil {
                map["Apply"] = self.apply!
            }
            if self.coolDownTime != nil {
                map["CoolDownTime"] = self.coolDownTime!
            }
            if self.cpuUsageUpperThreshold != nil {
                map["CpuUsageUpperThreshold"] = self.cpuUsageUpperThreshold!
            }
            if self.downgrade != nil {
                map["Downgrade"] = self.downgrade!
            }
            if self.maxReadOnlyNodes != nil {
                map["MaxReadOnlyNodes"] = self.maxReadOnlyNodes!
            }
            if self.maxSpec != nil {
                map["MaxSpec"] = self.maxSpec!
            }
            if self.memUsageUpperThreshold != nil {
                map["MemUsageUpperThreshold"] = self.memUsageUpperThreshold!
            }
            if self.observationWindowSize != nil {
                map["ObservationWindowSize"] = self.observationWindowSize!
            }
            if self.upgrade != nil {
                map["Upgrade"] = self.upgrade!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Apply"] as? Bool {
                self.apply = value
            }
            if let value = dict["CoolDownTime"] as? String {
                self.coolDownTime = value
            }
            if let value = dict["CpuUsageUpperThreshold"] as? Int32 {
                self.cpuUsageUpperThreshold = value
            }
            if let value = dict["Downgrade"] as? Bool {
                self.downgrade = value
            }
            if let value = dict["MaxReadOnlyNodes"] as? Int32 {
                self.maxReadOnlyNodes = value
            }
            if let value = dict["MaxSpec"] as? String {
                self.maxSpec = value
            }
            if let value = dict["MemUsageUpperThreshold"] as? Int32 {
                self.memUsageUpperThreshold = value
            }
            if let value = dict["ObservationWindowSize"] as? String {
                self.observationWindowSize = value
            }
            if let value = dict["Upgrade"] as? Bool {
                self.upgrade = value
            }
        }
    }
    public class Storage : Tea.TeaModel {
        public var apply: Bool?

        public var diskUsageUpperThreshold: Int32?

        public var maxStorage: Int32?

        public var upgrade: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apply != nil {
                map["Apply"] = self.apply!
            }
            if self.diskUsageUpperThreshold != nil {
                map["DiskUsageUpperThreshold"] = self.diskUsageUpperThreshold!
            }
            if self.maxStorage != nil {
                map["MaxStorage"] = self.maxStorage!
            }
            if self.upgrade != nil {
                map["Upgrade"] = self.upgrade!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Apply"] as? Bool {
                self.apply = value
            }
            if let value = dict["DiskUsageUpperThreshold"] as? Int32 {
                self.diskUsageUpperThreshold = value
            }
            if let value = dict["MaxStorage"] as? Int32 {
                self.maxStorage = value
            }
            if let value = dict["Upgrade"] as? Bool {
                self.upgrade = value
            }
        }
    }
    public var bandwidth: ModifyAutoScalingConfigRequest.Bandwidth?

    public var instanceId: String?

    public var resource: ModifyAutoScalingConfigRequest.Resource?

    public var shard: ModifyAutoScalingConfigRequest.Shard?

    public var spec: ModifyAutoScalingConfigRequest.Spec?

    public var storage: ModifyAutoScalingConfigRequest.Storage?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bandwidth?.validate()
        try self.resource?.validate()
        try self.shard?.validate()
        try self.spec?.validate()
        try self.storage?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth?.toMap()
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource?.toMap()
        }
        if self.shard != nil {
            map["Shard"] = self.shard?.toMap()
        }
        if self.spec != nil {
            map["Spec"] = self.spec?.toMap()
        }
        if self.storage != nil {
            map["Storage"] = self.storage?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidth"] as? [String: Any?] {
            var model = ModifyAutoScalingConfigRequest.Bandwidth()
            model.fromMap(value)
            self.bandwidth = model
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Resource"] as? [String: Any?] {
            var model = ModifyAutoScalingConfigRequest.Resource()
            model.fromMap(value)
            self.resource = model
        }
        if let value = dict["Shard"] as? [String: Any?] {
            var model = ModifyAutoScalingConfigRequest.Shard()
            model.fromMap(value)
            self.shard = model
        }
        if let value = dict["Spec"] as? [String: Any?] {
            var model = ModifyAutoScalingConfigRequest.Spec()
            model.fromMap(value)
            self.spec = model
        }
        if let value = dict["Storage"] as? [String: Any?] {
            var model = ModifyAutoScalingConfigRequest.Storage()
            model.fromMap(value)
            self.storage = model
        }
    }
}

public class ModifyAutoScalingConfigResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class ModifyAutoScalingConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAutoScalingConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyAutoScalingConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifySqlLogConfigRequest : Tea.TeaModel {
    public class Filters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var enable: Bool?

    public var enableAudit: Bool?

    public var filters: [ModifySqlLogConfigRequest.Filters]?

    public var hotRetention: Int32?

    public var instanceId: String?

    public var requestEnable: Bool?

    public var retention: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.enableAudit != nil {
            map["EnableAudit"] = self.enableAudit!
        }
        if self.filters != nil {
            var tmp : [Any] = []
            for k in self.filters! {
                tmp.append(k.toMap())
            }
            map["Filters"] = tmp
        }
        if self.hotRetention != nil {
            map["HotRetention"] = self.hotRetention!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestEnable != nil {
            map["RequestEnable"] = self.requestEnable!
        }
        if self.retention != nil {
            map["Retention"] = self.retention!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Enable"] as? Bool {
            self.enable = value
        }
        if let value = dict["EnableAudit"] as? Bool {
            self.enableAudit = value
        }
        if let value = dict["Filters"] as? [Any?] {
            var tmp : [ModifySqlLogConfigRequest.Filters] = []
            for v in value {
                if v != nil {
                    var model = ModifySqlLogConfigRequest.Filters()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filters = tmp
        }
        if let value = dict["HotRetention"] as? Int32 {
            self.hotRetention = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RequestEnable"] as? Bool {
            self.requestEnable = value
        }
        if let value = dict["Retention"] as? Int32 {
            self.retention = value
        }
    }
}

public class ModifySqlLogConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var coldEnable: Bool?

        public var coldRetention: Int32?

        public var coldStartTime: Int64?

        public var collectorVersion: String?

        public var hotEnable: Bool?

        public var hotRetention: Int32?

        public var hotStartTime: Int64?

        public var logFilter: String?

        public var requestEnable: Bool?

        public var requestStartTime: Int64?

        public var requestStopTime: Int64?

        public var retention: Int32?

        public var sqlLogEnable: Bool?

        public var sqlLogState: String?

        public var sqlLogVisibleTime: Int64?

        public var supportVersion: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coldEnable != nil {
                map["ColdEnable"] = self.coldEnable!
            }
            if self.coldRetention != nil {
                map["ColdRetention"] = self.coldRetention!
            }
            if self.coldStartTime != nil {
                map["ColdStartTime"] = self.coldStartTime!
            }
            if self.collectorVersion != nil {
                map["CollectorVersion"] = self.collectorVersion!
            }
            if self.hotEnable != nil {
                map["HotEnable"] = self.hotEnable!
            }
            if self.hotRetention != nil {
                map["HotRetention"] = self.hotRetention!
            }
            if self.hotStartTime != nil {
                map["HotStartTime"] = self.hotStartTime!
            }
            if self.logFilter != nil {
                map["LogFilter"] = self.logFilter!
            }
            if self.requestEnable != nil {
                map["RequestEnable"] = self.requestEnable!
            }
            if self.requestStartTime != nil {
                map["RequestStartTime"] = self.requestStartTime!
            }
            if self.requestStopTime != nil {
                map["RequestStopTime"] = self.requestStopTime!
            }
            if self.retention != nil {
                map["Retention"] = self.retention!
            }
            if self.sqlLogEnable != nil {
                map["SqlLogEnable"] = self.sqlLogEnable!
            }
            if self.sqlLogState != nil {
                map["SqlLogState"] = self.sqlLogState!
            }
            if self.sqlLogVisibleTime != nil {
                map["SqlLogVisibleTime"] = self.sqlLogVisibleTime!
            }
            if self.supportVersion != nil {
                map["SupportVersion"] = self.supportVersion!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ColdEnable"] as? Bool {
                self.coldEnable = value
            }
            if let value = dict["ColdRetention"] as? Int32 {
                self.coldRetention = value
            }
            if let value = dict["ColdStartTime"] as? Int64 {
                self.coldStartTime = value
            }
            if let value = dict["CollectorVersion"] as? String {
                self.collectorVersion = value
            }
            if let value = dict["HotEnable"] as? Bool {
                self.hotEnable = value
            }
            if let value = dict["HotRetention"] as? Int32 {
                self.hotRetention = value
            }
            if let value = dict["HotStartTime"] as? Int64 {
                self.hotStartTime = value
            }
            if let value = dict["LogFilter"] as? String {
                self.logFilter = value
            }
            if let value = dict["RequestEnable"] as? Bool {
                self.requestEnable = value
            }
            if let value = dict["RequestStartTime"] as? Int64 {
                self.requestStartTime = value
            }
            if let value = dict["RequestStopTime"] as? Int64 {
                self.requestStopTime = value
            }
            if let value = dict["Retention"] as? Int32 {
                self.retention = value
            }
            if let value = dict["SqlLogEnable"] as? Bool {
                self.sqlLogEnable = value
            }
            if let value = dict["SqlLogState"] as? String {
                self.sqlLogState = value
            }
            if let value = dict["SqlLogVisibleTime"] as? Int64 {
                self.sqlLogVisibleTime = value
            }
            if let value = dict["SupportVersion"] as? String {
                self.supportVersion = value
            }
            if let value = dict["Version"] as? String {
                self.version = value
            }
        }
    }
    public var code: String?

    public var data: ModifySqlLogConfigResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ModifySqlLogConfigResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class ModifySqlLogConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySqlLogConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifySqlLogConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RunCloudBenchTaskRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class RunCloudBenchTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class PreCheckItem : Tea.TeaModel {
            public var code: Int32?

            public var details: String?

            public var message: String?

            public var name: String?

            public var order: Int32?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.details != nil {
                    map["Details"] = self.details!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.order != nil {
                    map["Order"] = self.order!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? Int32 {
                    self.code = value
                }
                if let value = dict["Details"] as? String {
                    self.details = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Order"] as? Int32 {
                    self.order = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var preCheckItem: [RunCloudBenchTaskResponseBody.Data.PreCheckItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.preCheckItem != nil {
                var tmp : [Any] = []
                for k in self.preCheckItem! {
                    tmp.append(k.toMap())
                }
                map["PreCheckItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PreCheckItem"] as? [Any?] {
                var tmp : [RunCloudBenchTaskResponseBody.Data.PreCheckItem] = []
                for v in value {
                    if v != nil {
                        var model = RunCloudBenchTaskResponseBody.Data.PreCheckItem()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.preCheckItem = tmp
            }
        }
    }
    public var code: String?

    public var data: RunCloudBenchTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = RunCloudBenchTaskResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class RunCloudBenchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunCloudBenchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RunCloudBenchTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetEventSubscriptionRequest : Tea.TeaModel {
    public var active: String?

    public var channelType: String?

    public var contactGroupName: String?

    public var contactName: String?

    public var dispatchRule: String?

    public var eventContext: String?

    public var instanceId: String?

    public var lang: String?

    public var level: String?

    public var minInterval: String?

    public var severity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.active != nil {
            map["Active"] = self.active!
        }
        if self.channelType != nil {
            map["ChannelType"] = self.channelType!
        }
        if self.contactGroupName != nil {
            map["ContactGroupName"] = self.contactGroupName!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.dispatchRule != nil {
            map["DispatchRule"] = self.dispatchRule!
        }
        if self.eventContext != nil {
            map["EventContext"] = self.eventContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.minInterval != nil {
            map["MinInterval"] = self.minInterval!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Active"] as? String {
            self.active = value
        }
        if let value = dict["ChannelType"] as? String {
            self.channelType = value
        }
        if let value = dict["ContactGroupName"] as? String {
            self.contactGroupName = value
        }
        if let value = dict["ContactName"] as? String {
            self.contactName = value
        }
        if let value = dict["DispatchRule"] as? String {
            self.dispatchRule = value
        }
        if let value = dict["EventContext"] as? String {
            self.eventContext = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Level"] as? String {
            self.level = value
        }
        if let value = dict["MinInterval"] as? String {
            self.minInterval = value
        }
        if let value = dict["Severity"] as? String {
            self.severity = value
        }
    }
}

public class SetEventSubscriptionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var active: Int32?

        public var channelType: String?

        public var contactGroupName: String?

        public var contactName: String?

        public var eventContext: String?

        public var instanceId: String?

        public var lang: String?

        public var level: String?

        public var minInterval: Int32?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.active != nil {
                map["active"] = self.active!
            }
            if self.channelType != nil {
                map["channelType"] = self.channelType!
            }
            if self.contactGroupName != nil {
                map["contactGroupName"] = self.contactGroupName!
            }
            if self.contactName != nil {
                map["contactName"] = self.contactName!
            }
            if self.eventContext != nil {
                map["eventContext"] = self.eventContext!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.lang != nil {
                map["lang"] = self.lang!
            }
            if self.level != nil {
                map["level"] = self.level!
            }
            if self.minInterval != nil {
                map["minInterval"] = self.minInterval!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["active"] as? Int32 {
                self.active = value
            }
            if let value = dict["channelType"] as? String {
                self.channelType = value
            }
            if let value = dict["contactGroupName"] as? String {
                self.contactGroupName = value
            }
            if let value = dict["contactName"] as? String {
                self.contactName = value
            }
            if let value = dict["eventContext"] as? String {
                self.eventContext = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["lang"] as? String {
                self.lang = value
            }
            if let value = dict["level"] as? String {
                self.level = value
            }
            if let value = dict["minInterval"] as? Int32 {
                self.minInterval = value
            }
            if let value = dict["userId"] as? String {
                self.userId = value
            }
        }
    }
    public var code: String?

    public var data: SetEventSubscriptionResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = SetEventSubscriptionResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class SetEventSubscriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetEventSubscriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetEventSubscriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAutoResourceOptimizeRulesAsyncRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceIds: String?

    public var resultId: String?

    public var tableFragmentationRatio: Double?

    public var tableSpaceSize: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.resultId != nil {
            map["ResultId"] = self.resultId!
        }
        if self.tableFragmentationRatio != nil {
            map["TableFragmentationRatio"] = self.tableFragmentationRatio!
        }
        if self.tableSpaceSize != nil {
            map["TableSpaceSize"] = self.tableSpaceSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["ResultId"] as? String {
            self.resultId = value
        }
        if let value = dict["TableFragmentationRatio"] as? Double {
            self.tableFragmentationRatio = value
        }
        if let value = dict["TableSpaceSize"] as? Double {
            self.tableSpaceSize = value
        }
    }
}

public class UpdateAutoResourceOptimizeRulesAsyncResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ConfigResponse : Tea.TeaModel {
            public class ConfigFailInstanceList : Tea.TeaModel {
                public var configSuccess: Bool?

                public var errorMessage: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configSuccess != nil {
                        map["ConfigSuccess"] = self.configSuccess!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ConfigSuccess"] as? Bool {
                        self.configSuccess = value
                    }
                    if let value = dict["ErrorMessage"] as? String {
                        self.errorMessage = value
                    }
                    if let value = dict["InstanceId"] as? String {
                        self.instanceId = value
                    }
                }
            }
            public class ConfigSuccessInstanceList : Tea.TeaModel {
                public var configSuccess: Bool?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configSuccess != nil {
                        map["ConfigSuccess"] = self.configSuccess!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ConfigSuccess"] as? Bool {
                        self.configSuccess = value
                    }
                    if let value = dict["InstanceId"] as? String {
                        self.instanceId = value
                    }
                }
            }
            public var configFailInstanceCount: Int64?

            public var configFailInstanceList: [UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data.ConfigResponse.ConfigFailInstanceList]?

            public var configSuccessInstanceCount: Int64?

            public var configSuccessInstanceList: [UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data.ConfigResponse.ConfigSuccessInstanceList]?

            public var totalInstanceCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configFailInstanceCount != nil {
                    map["ConfigFailInstanceCount"] = self.configFailInstanceCount!
                }
                if self.configFailInstanceList != nil {
                    var tmp : [Any] = []
                    for k in self.configFailInstanceList! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigFailInstanceList"] = tmp
                }
                if self.configSuccessInstanceCount != nil {
                    map["ConfigSuccessInstanceCount"] = self.configSuccessInstanceCount!
                }
                if self.configSuccessInstanceList != nil {
                    var tmp : [Any] = []
                    for k in self.configSuccessInstanceList! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigSuccessInstanceList"] = tmp
                }
                if self.totalInstanceCount != nil {
                    map["TotalInstanceCount"] = self.totalInstanceCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigFailInstanceCount"] as? Int64 {
                    self.configFailInstanceCount = value
                }
                if let value = dict["ConfigFailInstanceList"] as? [Any?] {
                    var tmp : [UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data.ConfigResponse.ConfigFailInstanceList] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data.ConfigResponse.ConfigFailInstanceList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.configFailInstanceList = tmp
                }
                if let value = dict["ConfigSuccessInstanceCount"] as? Int64 {
                    self.configSuccessInstanceCount = value
                }
                if let value = dict["ConfigSuccessInstanceList"] as? [Any?] {
                    var tmp : [UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data.ConfigResponse.ConfigSuccessInstanceList] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data.ConfigResponse.ConfigSuccessInstanceList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.configSuccessInstanceList = tmp
                }
                if let value = dict["TotalInstanceCount"] as? Int64 {
                    self.totalInstanceCount = value
                }
            }
        }
        public var complete: Bool?

        public var configResponse: UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data.ConfigResponse?

        public var fail: Bool?

        public var isFinish: Bool?

        public var resultId: String?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.configResponse?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complete != nil {
                map["Complete"] = self.complete!
            }
            if self.configResponse != nil {
                map["ConfigResponse"] = self.configResponse?.toMap()
            }
            if self.fail != nil {
                map["Fail"] = self.fail!
            }
            if self.isFinish != nil {
                map["IsFinish"] = self.isFinish!
            }
            if self.resultId != nil {
                map["ResultId"] = self.resultId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Complete"] as? Bool {
                self.complete = value
            }
            if let value = dict["ConfigResponse"] as? [String: Any?] {
                var model = UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data.ConfigResponse()
                model.fromMap(value)
                self.configResponse = model
            }
            if let value = dict["Fail"] as? Bool {
                self.fail = value
            }
            if let value = dict["IsFinish"] as? Bool {
                self.isFinish = value
            }
            if let value = dict["ResultId"] as? String {
                self.resultId = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
        }
    }
    public var code: Int64?

    public var data: UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateAutoResourceOptimizeRulesAsyncResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAutoResourceOptimizeRulesAsyncResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateAutoResourceOptimizeRulesAsyncResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAutoSqlOptimizeStatusRequest : Tea.TeaModel {
    public var instances: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Instances"] as? String {
            self.instances = value
        }
        if let value = dict["Status"] as? Int32 {
            self.status = value
        }
    }
}

public class UpdateAutoSqlOptimizeStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var errorCode: String?

        public var errorMsg: String?

        public var success: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMsg != nil {
                map["ErrorMsg"] = self.errorMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ErrorCode"] as? String {
                self.errorCode = value
            }
            if let value = dict["ErrorMsg"] as? String {
                self.errorMsg = value
            }
            if let value = dict["Success"] as? String {
                self.success = value
            }
        }
    }
    public var code: String?

    public var data: UpdateAutoSqlOptimizeStatusResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateAutoSqlOptimizeStatusResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class UpdateAutoSqlOptimizeStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAutoSqlOptimizeStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateAutoSqlOptimizeStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAutoThrottleRulesAsyncRequest : Tea.TeaModel {
    public var abnormalDuration: Double?

    public var activeSessions: Int64?

    public var allowThrottleEndTime: String?

    public var allowThrottleStartTime: String?

    public var autoKillSession: Bool?

    public var consoleContext: String?

    public var cpuSessionRelation: String?

    public var cpuUsage: Double?

    public var instanceIds: String?

    public var maxThrottleTime: Double?

    public var resultId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.abnormalDuration != nil {
            map["AbnormalDuration"] = self.abnormalDuration!
        }
        if self.activeSessions != nil {
            map["ActiveSessions"] = self.activeSessions!
        }
        if self.allowThrottleEndTime != nil {
            map["AllowThrottleEndTime"] = self.allowThrottleEndTime!
        }
        if self.allowThrottleStartTime != nil {
            map["AllowThrottleStartTime"] = self.allowThrottleStartTime!
        }
        if self.autoKillSession != nil {
            map["AutoKillSession"] = self.autoKillSession!
        }
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.cpuSessionRelation != nil {
            map["CpuSessionRelation"] = self.cpuSessionRelation!
        }
        if self.cpuUsage != nil {
            map["CpuUsage"] = self.cpuUsage!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.maxThrottleTime != nil {
            map["MaxThrottleTime"] = self.maxThrottleTime!
        }
        if self.resultId != nil {
            map["ResultId"] = self.resultId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AbnormalDuration"] as? Double {
            self.abnormalDuration = value
        }
        if let value = dict["ActiveSessions"] as? Int64 {
            self.activeSessions = value
        }
        if let value = dict["AllowThrottleEndTime"] as? String {
            self.allowThrottleEndTime = value
        }
        if let value = dict["AllowThrottleStartTime"] as? String {
            self.allowThrottleStartTime = value
        }
        if let value = dict["AutoKillSession"] as? Bool {
            self.autoKillSession = value
        }
        if let value = dict["ConsoleContext"] as? String {
            self.consoleContext = value
        }
        if let value = dict["CpuSessionRelation"] as? String {
            self.cpuSessionRelation = value
        }
        if let value = dict["CpuUsage"] as? Double {
            self.cpuUsage = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["MaxThrottleTime"] as? Double {
            self.maxThrottleTime = value
        }
        if let value = dict["ResultId"] as? String {
            self.resultId = value
        }
    }
}

public class UpdateAutoThrottleRulesAsyncResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ConfigResponse : Tea.TeaModel {
            public class ConfigFailInstanceList : Tea.TeaModel {
                public var configSuccess: Bool?

                public var errorMessage: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configSuccess != nil {
                        map["ConfigSuccess"] = self.configSuccess!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ConfigSuccess"] as? Bool {
                        self.configSuccess = value
                    }
                    if let value = dict["ErrorMessage"] as? String {
                        self.errorMessage = value
                    }
                    if let value = dict["InstanceId"] as? String {
                        self.instanceId = value
                    }
                }
            }
            public class ConfigSuccessInstanceList : Tea.TeaModel {
                public var configSuccess: Bool?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configSuccess != nil {
                        map["ConfigSuccess"] = self.configSuccess!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ConfigSuccess"] as? Bool {
                        self.configSuccess = value
                    }
                    if let value = dict["InstanceId"] as? String {
                        self.instanceId = value
                    }
                }
            }
            public var configFailInstanceCount: Int64?

            public var configFailInstanceList: [UpdateAutoThrottleRulesAsyncResponseBody.Data.ConfigResponse.ConfigFailInstanceList]?

            public var configSuccessInstanceCount: Int64?

            public var configSuccessInstanceList: [UpdateAutoThrottleRulesAsyncResponseBody.Data.ConfigResponse.ConfigSuccessInstanceList]?

            public var totalInstanceCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configFailInstanceCount != nil {
                    map["ConfigFailInstanceCount"] = self.configFailInstanceCount!
                }
                if self.configFailInstanceList != nil {
                    var tmp : [Any] = []
                    for k in self.configFailInstanceList! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigFailInstanceList"] = tmp
                }
                if self.configSuccessInstanceCount != nil {
                    map["ConfigSuccessInstanceCount"] = self.configSuccessInstanceCount!
                }
                if self.configSuccessInstanceList != nil {
                    var tmp : [Any] = []
                    for k in self.configSuccessInstanceList! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigSuccessInstanceList"] = tmp
                }
                if self.totalInstanceCount != nil {
                    map["TotalInstanceCount"] = self.totalInstanceCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigFailInstanceCount"] as? Int64 {
                    self.configFailInstanceCount = value
                }
                if let value = dict["ConfigFailInstanceList"] as? [Any?] {
                    var tmp : [UpdateAutoThrottleRulesAsyncResponseBody.Data.ConfigResponse.ConfigFailInstanceList] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateAutoThrottleRulesAsyncResponseBody.Data.ConfigResponse.ConfigFailInstanceList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.configFailInstanceList = tmp
                }
                if let value = dict["ConfigSuccessInstanceCount"] as? Int64 {
                    self.configSuccessInstanceCount = value
                }
                if let value = dict["ConfigSuccessInstanceList"] as? [Any?] {
                    var tmp : [UpdateAutoThrottleRulesAsyncResponseBody.Data.ConfigResponse.ConfigSuccessInstanceList] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateAutoThrottleRulesAsyncResponseBody.Data.ConfigResponse.ConfigSuccessInstanceList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.configSuccessInstanceList = tmp
                }
                if let value = dict["TotalInstanceCount"] as? Int64 {
                    self.totalInstanceCount = value
                }
            }
        }
        public var complete: Bool?

        public var configResponse: UpdateAutoThrottleRulesAsyncResponseBody.Data.ConfigResponse?

        public var fail: Bool?

        public var isFinish: Bool?

        public var resultId: String?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.configResponse?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complete != nil {
                map["Complete"] = self.complete!
            }
            if self.configResponse != nil {
                map["ConfigResponse"] = self.configResponse?.toMap()
            }
            if self.fail != nil {
                map["Fail"] = self.fail!
            }
            if self.isFinish != nil {
                map["IsFinish"] = self.isFinish!
            }
            if self.resultId != nil {
                map["ResultId"] = self.resultId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Complete"] as? Bool {
                self.complete = value
            }
            if let value = dict["ConfigResponse"] as? [String: Any?] {
                var model = UpdateAutoThrottleRulesAsyncResponseBody.Data.ConfigResponse()
                model.fromMap(value)
                self.configResponse = model
            }
            if let value = dict["Fail"] as? Bool {
                self.fail = value
            }
            if let value = dict["IsFinish"] as? Bool {
                self.isFinish = value
            }
            if let value = dict["ResultId"] as? String {
                self.resultId = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
        }
    }
    public var code: Int64?

    public var data: UpdateAutoThrottleRulesAsyncResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateAutoThrottleRulesAsyncResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateAutoThrottleRulesAsyncResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAutoThrottleRulesAsyncResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateAutoThrottleRulesAsyncResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}
