import Foundation
import Tea
import TeaUtils
import AlibabaCloudOssSdk
import AlibabacloudOpenPlatform20191219
import AlibabaCloudOSSUtil
import TeaFileForm
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class Cluster : Tea.TeaModel {
    public var clusterBizId: String?

    public var clusterId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterBizId != nil {
            map["ClusterBizId"] = self.clusterBizId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterBizId") {
            self.clusterBizId = dict["ClusterBizId"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! Int64
        }
    }
}

public class ClusterConfig : Tea.TeaModel {
    public var configValue: String?

    public var enableOverwrite: Bool?

    public var moduleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configValue != nil {
            map["ConfigValue"] = self.configValue!
        }
        if self.enableOverwrite != nil {
            map["EnableOverwrite"] = self.enableOverwrite!
        }
        if self.moduleName != nil {
            map["ModuleName"] = self.moduleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigValue") {
            self.configValue = dict["ConfigValue"] as! String
        }
        if dict.keys.contains("EnableOverwrite") {
            self.enableOverwrite = dict["EnableOverwrite"] as! Bool
        }
        if dict.keys.contains("ModuleName") {
            self.moduleName = dict["ModuleName"] as! String
        }
    }
}

public class Collection : Tea.TeaModel {
    public var collectionType: String?

    public var comment: String?

    public var createTime: Int64?

    public var level: Int32?

    public var name: String?

    public var ownerId: String?

    public var ownerName: String?

    public var qualifiedName: String?

    public var updateTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectionType != nil {
            map["CollectionType"] = self.collectionType!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ownerName != nil {
            map["OwnerName"] = self.ownerName!
        }
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CollectionType") {
            self.collectionType = dict["CollectionType"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("OwnerName") {
            self.ownerName = dict["OwnerName"] as! String
        }
        if dict.keys.contains("QualifiedName") {
            self.qualifiedName = dict["QualifiedName"] as! String
        }
        if dict.keys.contains("UpdateTime") {
            self.updateTime = dict["UpdateTime"] as! Int64
        }
    }
}

public class Entity : Tea.TeaModel {
    public var entityContent: [String: Any]?

    public var qualifiedName: String?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityContent != nil {
            map["EntityContent"] = self.entityContent!
        }
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityContent") {
            self.entityContent = dict["EntityContent"] as! [String: Any]
        }
        if dict.keys.contains("QualifiedName") {
            self.qualifiedName = dict["QualifiedName"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class LineageEntityVO : Tea.TeaModel {
    public var attributes: [String: String]?

    public var detailUrl: String?

    public var entityType: String?

    public var name: String?

    public var owner: String?

    public var parentName: String?

    public var qualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributes != nil {
            map["Attributes"] = self.attributes!
        }
        if self.detailUrl != nil {
            map["DetailUrl"] = self.detailUrl!
        }
        if self.entityType != nil {
            map["EntityType"] = self.entityType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.parentName != nil {
            map["ParentName"] = self.parentName!
        }
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attributes") {
            self.attributes = dict["Attributes"] as! [String: String]
        }
        if dict.keys.contains("DetailUrl") {
            self.detailUrl = dict["DetailUrl"] as! String
        }
        if dict.keys.contains("EntityType") {
            self.entityType = dict["EntityType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("ParentName") {
            self.parentName = dict["ParentName"] as! String
        }
        if dict.keys.contains("QualifiedName") {
            self.qualifiedName = dict["QualifiedName"] as! String
        }
    }
}

public class LineageRelationRegisterBulkVO : Tea.TeaModel {
    public var createTimestamp: Int64?

    public var destEntities: [LineageEntityVO]?

    public var relationship: RelationshipVO?

    public var srcEntities: [LineageEntityVO]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.relationship?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.destEntities != nil {
            var tmp : [Any] = []
            for k in self.destEntities! {
                tmp.append(k.toMap())
            }
            map["DestEntities"] = tmp
        }
        if self.relationship != nil {
            map["Relationship"] = self.relationship?.toMap()
        }
        if self.srcEntities != nil {
            var tmp : [Any] = []
            for k in self.srcEntities! {
                tmp.append(k.toMap())
            }
            map["SrcEntities"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("DestEntities") {
            var tmp : [LineageEntityVO] = []
            for v in dict["DestEntities"] as! [Any] {
                var model = LineageEntityVO()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.destEntities = tmp
        }
        if dict.keys.contains("Relationship") {
            var model = RelationshipVO()
            model.fromMap(dict["Relationship"] as! [String: Any])
            self.relationship = model
        }
        if dict.keys.contains("SrcEntities") {
            var tmp : [LineageEntityVO] = []
            for v in dict["SrcEntities"] as! [Any] {
                var model = LineageEntityVO()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.srcEntities = tmp
        }
    }
}

public class LineageRelationRegisterTaskVO : Tea.TeaModel {
    public var attributes: [String: String]?

    public var createTimestamp: Int64?

    public var inputEntities: [LineageEntityVO]?

    public var name: String?

    public var outputEntities: [LineageEntityVO]?

    public var qualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributes != nil {
            map["Attributes"] = self.attributes!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.inputEntities != nil {
            var tmp : [Any] = []
            for k in self.inputEntities! {
                tmp.append(k.toMap())
            }
            map["InputEntities"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputEntities != nil {
            var tmp : [Any] = []
            for k in self.outputEntities! {
                tmp.append(k.toMap())
            }
            map["OutputEntities"] = tmp
        }
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attributes") {
            self.attributes = dict["Attributes"] as! [String: String]
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("InputEntities") {
            var tmp : [LineageEntityVO] = []
            for v in dict["InputEntities"] as! [Any] {
                var model = LineageEntityVO()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inputEntities = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OutputEntities") {
            var tmp : [LineageEntityVO] = []
            for v in dict["OutputEntities"] as! [Any] {
                var model = LineageEntityVO()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.outputEntities = tmp
        }
        if dict.keys.contains("QualifiedName") {
            self.qualifiedName = dict["QualifiedName"] as! String
        }
    }
}

public class LineageRelationRegisterVO : Tea.TeaModel {
    public var createTimestamp: Int64?

    public var destEntity: LineageEntityVO?

    public var relationship: RelationshipVO?

    public var srcEntity: LineageEntityVO?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.destEntity?.validate()
        try self.relationship?.validate()
        try self.srcEntity?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.destEntity != nil {
            map["DestEntity"] = self.destEntity?.toMap()
        }
        if self.relationship != nil {
            map["Relationship"] = self.relationship?.toMap()
        }
        if self.srcEntity != nil {
            map["SrcEntity"] = self.srcEntity?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("DestEntity") {
            var model = LineageEntityVO()
            model.fromMap(dict["DestEntity"] as! [String: Any])
            self.destEntity = model
        }
        if dict.keys.contains("Relationship") {
            var model = RelationshipVO()
            model.fromMap(dict["Relationship"] as! [String: Any])
            self.relationship = model
        }
        if dict.keys.contains("SrcEntity") {
            var model = LineageEntityVO()
            model.fromMap(dict["SrcEntity"] as! [String: Any])
            self.srcEntity = model
        }
    }
}

public class RelationshipVO : Tea.TeaModel {
    public var attributes: [String: String]?

    public var relationshipGuid: String?

    public var relationshipType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributes != nil {
            map["Attributes"] = self.attributes!
        }
        if self.relationshipGuid != nil {
            map["RelationshipGuid"] = self.relationshipGuid!
        }
        if self.relationshipType != nil {
            map["RelationshipType"] = self.relationshipType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attributes") {
            self.attributes = dict["Attributes"] as! [String: String]
        }
        if dict.keys.contains("RelationshipGuid") {
            self.relationshipGuid = dict["RelationshipGuid"] as! String
        }
        if dict.keys.contains("RelationshipType") {
            self.relationshipType = dict["RelationshipType"] as! String
        }
    }
}

public class UserEntityTag : Tea.TeaModel {
    public var tagKey: String?

    public var tagValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        if self.tagValue != nil {
            map["TagValue"] = self.tagValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! String
        }
        if dict.keys.contains("TagValue") {
            self.tagValue = dict["TagValue"] as! String
        }
    }
}

public class DataDesensPlanTemplateValue : Tea.TeaModel {
    public var name: String?

    public var supportWaterMark: Bool?

    public var extParamTemplate: [Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.supportWaterMark != nil {
            map["SupportWaterMark"] = self.supportWaterMark!
        }
        if self.extParamTemplate != nil {
            map["ExtParamTemplate"] = self.extParamTemplate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SupportWaterMark") {
            self.supportWaterMark = dict["SupportWaterMark"] as! Bool
        }
        if dict.keys.contains("ExtParamTemplate") {
            self.extParamTemplate = dict["ExtParamTemplate"] as! [Any]
        }
    }
}

public class AbolishDataServiceApiRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class AbolishDataServiceApiResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AbolishDataServiceApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AbolishDataServiceApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AbolishDataServiceApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMetaCollectionEntityRequest : Tea.TeaModel {
    public var collectionQualifiedName: String?

    public var entityQualifiedName: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectionQualifiedName != nil {
            map["CollectionQualifiedName"] = self.collectionQualifiedName!
        }
        if self.entityQualifiedName != nil {
            map["EntityQualifiedName"] = self.entityQualifiedName!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CollectionQualifiedName") {
            self.collectionQualifiedName = dict["CollectionQualifiedName"] as! String
        }
        if dict.keys.contains("EntityQualifiedName") {
            self.entityQualifiedName = dict["EntityQualifiedName"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class AddMetaCollectionEntityResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var status: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddMetaCollectionEntityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMetaCollectionEntityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMetaCollectionEntityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddProjectMemberToRoleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var projectId: Int64?

    public var roleCode: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCode != nil {
            map["RoleCode"] = self.roleCode!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RoleCode") {
            self.roleCode = dict["RoleCode"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class AddProjectMemberToRoleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddProjectMemberToRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddProjectMemberToRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddProjectMemberToRoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddRecognizeRuleRequest : Tea.TeaModel {
    public var accountName: String?

    public var colExclude: String?

    public var colScan: String?

    public var commentScan: String?

    public var contentScan: String?

    public var hitThreshold: Int32?

    public var level: String?

    public var levelName: String?

    public var nodeId: String?

    public var nodeParent: String?

    public var operationType: Int32?

    public var recognizeRules: String?

    public var recognizeRulesType: String?

    public var sensitiveDescription: String?

    public var sensitiveName: String?

    public var status: Int32?

    public var templateId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.colExclude != nil {
            map["ColExclude"] = self.colExclude!
        }
        if self.colScan != nil {
            map["ColScan"] = self.colScan!
        }
        if self.commentScan != nil {
            map["CommentScan"] = self.commentScan!
        }
        if self.contentScan != nil {
            map["ContentScan"] = self.contentScan!
        }
        if self.hitThreshold != nil {
            map["HitThreshold"] = self.hitThreshold!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.levelName != nil {
            map["LevelName"] = self.levelName!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeParent != nil {
            map["NodeParent"] = self.nodeParent!
        }
        if self.operationType != nil {
            map["OperationType"] = self.operationType!
        }
        if self.recognizeRules != nil {
            map["RecognizeRules"] = self.recognizeRules!
        }
        if self.recognizeRulesType != nil {
            map["RecognizeRulesType"] = self.recognizeRulesType!
        }
        if self.sensitiveDescription != nil {
            map["SensitiveDescription"] = self.sensitiveDescription!
        }
        if self.sensitiveName != nil {
            map["SensitiveName"] = self.sensitiveName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountName") {
            self.accountName = dict["AccountName"] as! String
        }
        if dict.keys.contains("ColExclude") {
            self.colExclude = dict["ColExclude"] as! String
        }
        if dict.keys.contains("ColScan") {
            self.colScan = dict["ColScan"] as! String
        }
        if dict.keys.contains("CommentScan") {
            self.commentScan = dict["CommentScan"] as! String
        }
        if dict.keys.contains("ContentScan") {
            self.contentScan = dict["ContentScan"] as! String
        }
        if dict.keys.contains("HitThreshold") {
            self.hitThreshold = dict["HitThreshold"] as! Int32
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("LevelName") {
            self.levelName = dict["LevelName"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("NodeParent") {
            self.nodeParent = dict["NodeParent"] as! String
        }
        if dict.keys.contains("OperationType") {
            self.operationType = dict["OperationType"] as! Int32
        }
        if dict.keys.contains("RecognizeRules") {
            self.recognizeRules = dict["RecognizeRules"] as! String
        }
        if dict.keys.contains("RecognizeRulesType") {
            self.recognizeRulesType = dict["RecognizeRulesType"] as! String
        }
        if dict.keys.contains("SensitiveDescription") {
            self.sensitiveDescription = dict["SensitiveDescription"] as! String
        }
        if dict.keys.contains("SensitiveName") {
            self.sensitiveName = dict["SensitiveName"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class AddRecognizeRuleResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddRecognizeRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddRecognizeRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddRecognizeRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddToMetaCategoryRequest : Tea.TeaModel {
    public var categoryId: Int64?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryId") {
            self.categoryId = dict["CategoryId"] as! Int64
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
    }
}

public class AddToMetaCategoryResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddToMetaCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddToMetaCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddToMetaCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApprovePermissionApplyOrderRequest : Tea.TeaModel {
    public var approveAction: Int32?

    public var approveComment: String?

    public var flowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.approveAction != nil {
            map["ApproveAction"] = self.approveAction!
        }
        if self.approveComment != nil {
            map["ApproveComment"] = self.approveComment!
        }
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApproveAction") {
            self.approveAction = dict["ApproveAction"] as! Int32
        }
        if dict.keys.contains("ApproveComment") {
            self.approveComment = dict["ApproveComment"] as! String
        }
        if dict.keys.contains("FlowId") {
            self.flowId = dict["FlowId"] as! String
        }
    }
}

public class ApprovePermissionApplyOrderResponseBody : Tea.TeaModel {
    public var approveSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.approveSuccess != nil {
            map["ApproveSuccess"] = self.approveSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApproveSuccess") {
            self.approveSuccess = dict["ApproveSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ApprovePermissionApplyOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApprovePermissionApplyOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApprovePermissionApplyOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CallbackExtensionRequest : Tea.TeaModel {
    public var checkMessage: String?

    public var checkResult: String?

    public var extensionCode: String?

    public var messageId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkMessage != nil {
            map["CheckMessage"] = self.checkMessage!
        }
        if self.checkResult != nil {
            map["CheckResult"] = self.checkResult!
        }
        if self.extensionCode != nil {
            map["ExtensionCode"] = self.extensionCode!
        }
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckMessage") {
            self.checkMessage = dict["CheckMessage"] as! String
        }
        if dict.keys.contains("CheckResult") {
            self.checkResult = dict["CheckResult"] as! String
        }
        if dict.keys.contains("ExtensionCode") {
            self.extensionCode = dict["ExtensionCode"] as! String
        }
        if dict.keys.contains("MessageId") {
            self.messageId = dict["MessageId"] as! String
        }
    }
}

public class CallbackExtensionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CallbackExtensionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CallbackExtensionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CallbackExtensionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeResourceManagerResourceGroupRequest : Tea.TeaModel {
    public var resourceId: String?

    public var resourceManagerResourceGroupId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceManagerResourceGroupId != nil {
            map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceManagerResourceGroupId") {
            self.resourceManagerResourceGroupId = dict["ResourceManagerResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ChangeResourceManagerResourceGroupResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ChangeResourceManagerResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeResourceManagerResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ChangeResourceManagerResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckFileDeploymentRequest : Tea.TeaModel {
    public var checkDetailUrl: String?

    public var checkerInstanceId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkDetailUrl != nil {
            map["CheckDetailUrl"] = self.checkDetailUrl!
        }
        if self.checkerInstanceId != nil {
            map["CheckerInstanceId"] = self.checkerInstanceId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckDetailUrl") {
            self.checkDetailUrl = dict["CheckDetailUrl"] as! String
        }
        if dict.keys.contains("CheckerInstanceId") {
            self.checkerInstanceId = dict["CheckerInstanceId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class CheckFileDeploymentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CheckFileDeploymentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckFileDeploymentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckFileDeploymentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckMetaPartitionRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var partition: String?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.partition != nil {
            map["Partition"] = self.partition!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("Partition") {
            self.partition = dict["Partition"] as! String
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class CheckMetaPartitionResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CheckMetaPartitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckMetaPartitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckMetaPartitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckMetaTableRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class CheckMetaTableResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CheckMetaTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckMetaTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckMetaTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBaselineRequest : Tea.TeaModel {
    public class OvertimeSettings : Tea.TeaModel {
        public var cycle: Int32?

        public var time: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycle != nil {
                map["Cycle"] = self.cycle!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cycle") {
                self.cycle = dict["Cycle"] as! Int32
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! String
            }
        }
    }
    public var alertMarginThreshold: Int32?

    public var baselineName: String?

    public var baselineType: String?

    public var nodeIds: String?

    public var overtimeSettings: [CreateBaselineRequest.OvertimeSettings]?

    public var owner: String?

    public var priority: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertMarginThreshold != nil {
            map["AlertMarginThreshold"] = self.alertMarginThreshold!
        }
        if self.baselineName != nil {
            map["BaselineName"] = self.baselineName!
        }
        if self.baselineType != nil {
            map["BaselineType"] = self.baselineType!
        }
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.overtimeSettings != nil {
            var tmp : [Any] = []
            for k in self.overtimeSettings! {
                tmp.append(k.toMap())
            }
            map["OvertimeSettings"] = tmp
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertMarginThreshold") {
            self.alertMarginThreshold = dict["AlertMarginThreshold"] as! Int32
        }
        if dict.keys.contains("BaselineName") {
            self.baselineName = dict["BaselineName"] as! String
        }
        if dict.keys.contains("BaselineType") {
            self.baselineType = dict["BaselineType"] as! String
        }
        if dict.keys.contains("NodeIds") {
            self.nodeIds = dict["NodeIds"] as! String
        }
        if dict.keys.contains("OvertimeSettings") {
            var tmp : [CreateBaselineRequest.OvertimeSettings] = []
            for v in dict["OvertimeSettings"] as! [Any] {
                var model = CreateBaselineRequest.OvertimeSettings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.overtimeSettings = tmp
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class CreateBaselineResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateBaselineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBaselineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateBaselineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBusinessRequest : Tea.TeaModel {
    public var businessName: String?

    public var description_: String?

    public var owner: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var useType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessName != nil {
            map["BusinessName"] = self.businessName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.useType != nil {
            map["UseType"] = self.useType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessName") {
            self.businessName = dict["BusinessName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
        if dict.keys.contains("UseType") {
            self.useType = dict["UseType"] as! String
        }
    }
}

public class CreateBusinessResponseBody : Tea.TeaModel {
    public var businessId: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessId != nil {
            map["BusinessId"] = self.businessId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessId") {
            self.businessId = dict["BusinessId"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateBusinessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBusinessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateBusinessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateConnectionRequest : Tea.TeaModel {
    public var connectionType: String?

    public var content: String?

    public var description_: String?

    public var envType: Int32?

    public var name: String?

    public var projectId: Int64?

    public var subType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionType != nil {
            map["ConnectionType"] = self.connectionType!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.subType != nil {
            map["SubType"] = self.subType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConnectionType") {
            self.connectionType = dict["ConnectionType"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SubType") {
            self.subType = dict["SubType"] as! String
        }
    }
}

public class CreateConnectionResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDIAlarmRuleRequest : Tea.TeaModel {
    public class NotificationSettings : Tea.TeaModel {
        public class NotificationChannels : Tea.TeaModel {
            public var channels: [String]?

            public var severity: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! [String]
                }
                if dict.keys.contains("Severity") {
                    self.severity = dict["Severity"] as! String
                }
            }
        }
        public class NotificationReceivers : Tea.TeaModel {
            public var receiverType: String?

            public var receiverValues: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.receiverType != nil {
                    map["ReceiverType"] = self.receiverType!
                }
                if self.receiverValues != nil {
                    map["ReceiverValues"] = self.receiverValues!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReceiverType") {
                    self.receiverType = dict["ReceiverType"] as! String
                }
                if dict.keys.contains("ReceiverValues") {
                    self.receiverValues = dict["ReceiverValues"] as! [String]
                }
            }
        }
        public var inhibitionInterval: Int32?

        public var notificationChannels: [CreateDIAlarmRuleRequest.NotificationSettings.NotificationChannels]?

        public var notificationReceivers: [CreateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inhibitionInterval != nil {
                map["InhibitionInterval"] = self.inhibitionInterval!
            }
            if self.notificationChannels != nil {
                var tmp : [Any] = []
                for k in self.notificationChannels! {
                    tmp.append(k.toMap())
                }
                map["NotificationChannels"] = tmp
            }
            if self.notificationReceivers != nil {
                var tmp : [Any] = []
                for k in self.notificationReceivers! {
                    tmp.append(k.toMap())
                }
                map["NotificationReceivers"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InhibitionInterval") {
                self.inhibitionInterval = dict["InhibitionInterval"] as! Int32
            }
            if dict.keys.contains("NotificationChannels") {
                var tmp : [CreateDIAlarmRuleRequest.NotificationSettings.NotificationChannels] = []
                for v in dict["NotificationChannels"] as! [Any] {
                    var model = CreateDIAlarmRuleRequest.NotificationSettings.NotificationChannels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notificationChannels = tmp
            }
            if dict.keys.contains("NotificationReceivers") {
                var tmp : [CreateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers] = []
                for v in dict["NotificationReceivers"] as! [Any] {
                    var model = CreateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notificationReceivers = tmp
            }
        }
    }
    public class TriggerConditions : Tea.TeaModel {
        public var duration: Int64?

        public var severity: String?

        public var threshold: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Severity") {
                self.severity = dict["Severity"] as! String
            }
            if dict.keys.contains("Threshold") {
                self.threshold = dict["Threshold"] as! Int64
            }
        }
    }
    public var DIJobId: Int64?

    public var description_: String?

    public var enabled: Bool?

    public var metricType: String?

    public var notificationSettings: CreateDIAlarmRuleRequest.NotificationSettings?

    public var triggerConditions: [CreateDIAlarmRuleRequest.TriggerConditions]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notificationSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.notificationSettings != nil {
            map["NotificationSettings"] = self.notificationSettings?.toMap()
        }
        if self.triggerConditions != nil {
            var tmp : [Any] = []
            for k in self.triggerConditions! {
                tmp.append(k.toMap())
            }
            map["TriggerConditions"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("NotificationSettings") {
            var model = CreateDIAlarmRuleRequest.NotificationSettings()
            model.fromMap(dict["NotificationSettings"] as! [String: Any])
            self.notificationSettings = model
        }
        if dict.keys.contains("TriggerConditions") {
            var tmp : [CreateDIAlarmRuleRequest.TriggerConditions] = []
            for v in dict["TriggerConditions"] as! [Any] {
                var model = CreateDIAlarmRuleRequest.TriggerConditions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.triggerConditions = tmp
        }
    }
}

public class CreateDIAlarmRuleShrinkRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var description_: String?

    public var enabled: Bool?

    public var metricType: String?

    public var notificationSettingsShrink: String?

    public var triggerConditionsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.notificationSettingsShrink != nil {
            map["NotificationSettings"] = self.notificationSettingsShrink!
        }
        if self.triggerConditionsShrink != nil {
            map["TriggerConditions"] = self.triggerConditionsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("NotificationSettings") {
            self.notificationSettingsShrink = dict["NotificationSettings"] as! String
        }
        if dict.keys.contains("TriggerConditions") {
            self.triggerConditionsShrink = dict["TriggerConditions"] as! String
        }
    }
}

public class CreateDIAlarmRuleResponseBody : Tea.TeaModel {
    public var DIAlarmRuleId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIAlarmRuleId") {
            self.DIAlarmRuleId = dict["DIAlarmRuleId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDIAlarmRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDIAlarmRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDIAlarmRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDIJobRequest : Tea.TeaModel {
    public class DestinationDataSourceSettings : Tea.TeaModel {
        public var dataSourceName: String?

        public var dataSourceProperties: [String: String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceName != nil {
                map["DataSourceName"] = self.dataSourceName!
            }
            if self.dataSourceProperties != nil {
                map["DataSourceProperties"] = self.dataSourceProperties!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataSourceName") {
                self.dataSourceName = dict["DataSourceName"] as! String
            }
            if dict.keys.contains("DataSourceProperties") {
                self.dataSourceProperties = dict["DataSourceProperties"] as! [String: String]
            }
        }
    }
    public class JobSettings : Tea.TeaModel {
        public class ColumnDataTypeSettings : Tea.TeaModel {
            public var destinationDataType: String?

            public var sourceDataType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.destinationDataType != nil {
                    map["DestinationDataType"] = self.destinationDataType!
                }
                if self.sourceDataType != nil {
                    map["SourceDataType"] = self.sourceDataType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DestinationDataType") {
                    self.destinationDataType = dict["DestinationDataType"] as! String
                }
                if dict.keys.contains("SourceDataType") {
                    self.sourceDataType = dict["SourceDataType"] as! String
                }
            }
        }
        public class CycleScheduleSettings : Tea.TeaModel {
            public var cycleMigrationType: String?

            public var scheduleParameters: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleMigrationType != nil {
                    map["CycleMigrationType"] = self.cycleMigrationType!
                }
                if self.scheduleParameters != nil {
                    map["ScheduleParameters"] = self.scheduleParameters!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CycleMigrationType") {
                    self.cycleMigrationType = dict["CycleMigrationType"] as! String
                }
                if dict.keys.contains("ScheduleParameters") {
                    self.scheduleParameters = dict["ScheduleParameters"] as! String
                }
            }
        }
        public class DdlHandlingSettings : Tea.TeaModel {
            public var action: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class ImportRuleSettings : Tea.TeaModel {
            public var fileId: String?

            public var source: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileId") {
                    self.fileId = dict["FileId"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
            }
        }
        public class RuntimeSettings : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var channelSettings: String?

        public var columnDataTypeSettings: [CreateDIJobRequest.JobSettings.ColumnDataTypeSettings]?

        public var cycleScheduleSettings: CreateDIJobRequest.JobSettings.CycleScheduleSettings?

        public var ddlHandlingSettings: [CreateDIJobRequest.JobSettings.DdlHandlingSettings]?

        public var importRuleSettings: CreateDIJobRequest.JobSettings.ImportRuleSettings?

        public var runtimeSettings: [CreateDIJobRequest.JobSettings.RuntimeSettings]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cycleScheduleSettings?.validate()
            try self.importRuleSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelSettings != nil {
                map["ChannelSettings"] = self.channelSettings!
            }
            if self.columnDataTypeSettings != nil {
                var tmp : [Any] = []
                for k in self.columnDataTypeSettings! {
                    tmp.append(k.toMap())
                }
                map["ColumnDataTypeSettings"] = tmp
            }
            if self.cycleScheduleSettings != nil {
                map["CycleScheduleSettings"] = self.cycleScheduleSettings?.toMap()
            }
            if self.ddlHandlingSettings != nil {
                var tmp : [Any] = []
                for k in self.ddlHandlingSettings! {
                    tmp.append(k.toMap())
                }
                map["DdlHandlingSettings"] = tmp
            }
            if self.importRuleSettings != nil {
                map["ImportRuleSettings"] = self.importRuleSettings?.toMap()
            }
            if self.runtimeSettings != nil {
                var tmp : [Any] = []
                for k in self.runtimeSettings! {
                    tmp.append(k.toMap())
                }
                map["RuntimeSettings"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelSettings") {
                self.channelSettings = dict["ChannelSettings"] as! String
            }
            if dict.keys.contains("ColumnDataTypeSettings") {
                var tmp : [CreateDIJobRequest.JobSettings.ColumnDataTypeSettings] = []
                for v in dict["ColumnDataTypeSettings"] as! [Any] {
                    var model = CreateDIJobRequest.JobSettings.ColumnDataTypeSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.columnDataTypeSettings = tmp
            }
            if dict.keys.contains("CycleScheduleSettings") {
                var model = CreateDIJobRequest.JobSettings.CycleScheduleSettings()
                model.fromMap(dict["CycleScheduleSettings"] as! [String: Any])
                self.cycleScheduleSettings = model
            }
            if dict.keys.contains("DdlHandlingSettings") {
                var tmp : [CreateDIJobRequest.JobSettings.DdlHandlingSettings] = []
                for v in dict["DdlHandlingSettings"] as! [Any] {
                    var model = CreateDIJobRequest.JobSettings.DdlHandlingSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ddlHandlingSettings = tmp
            }
            if dict.keys.contains("ImportRuleSettings") {
                var model = CreateDIJobRequest.JobSettings.ImportRuleSettings()
                model.fromMap(dict["ImportRuleSettings"] as! [String: Any])
                self.importRuleSettings = model
            }
            if dict.keys.contains("RuntimeSettings") {
                var tmp : [CreateDIJobRequest.JobSettings.RuntimeSettings] = []
                for v in dict["RuntimeSettings"] as! [Any] {
                    var model = CreateDIJobRequest.JobSettings.RuntimeSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.runtimeSettings = tmp
            }
        }
    }
    public class ResourceSettings : Tea.TeaModel {
        public class OfflineResourceSettings : Tea.TeaModel {
            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceGroupIdentifier") {
                    self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
                }
            }
        }
        public class RealtimeResourceSettings : Tea.TeaModel {
            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceGroupIdentifier") {
                    self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
                }
            }
        }
        public var offlineResourceSettings: CreateDIJobRequest.ResourceSettings.OfflineResourceSettings?

        public var realtimeResourceSettings: CreateDIJobRequest.ResourceSettings.RealtimeResourceSettings?

        public var requestedCu: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.offlineResourceSettings?.validate()
            try self.realtimeResourceSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.offlineResourceSettings != nil {
                map["OfflineResourceSettings"] = self.offlineResourceSettings?.toMap()
            }
            if self.realtimeResourceSettings != nil {
                map["RealtimeResourceSettings"] = self.realtimeResourceSettings?.toMap()
            }
            if self.requestedCu != nil {
                map["RequestedCu"] = self.requestedCu!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OfflineResourceSettings") {
                var model = CreateDIJobRequest.ResourceSettings.OfflineResourceSettings()
                model.fromMap(dict["OfflineResourceSettings"] as! [String: Any])
                self.offlineResourceSettings = model
            }
            if dict.keys.contains("RealtimeResourceSettings") {
                var model = CreateDIJobRequest.ResourceSettings.RealtimeResourceSettings()
                model.fromMap(dict["RealtimeResourceSettings"] as! [String: Any])
                self.realtimeResourceSettings = model
            }
            if dict.keys.contains("RequestedCu") {
                self.requestedCu = dict["RequestedCu"] as! Double
            }
        }
    }
    public class SourceDataSourceSettings : Tea.TeaModel {
        public var dataSourceName: String?

        public var dataSourceProperties: [String: String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceName != nil {
                map["DataSourceName"] = self.dataSourceName!
            }
            if self.dataSourceProperties != nil {
                map["DataSourceProperties"] = self.dataSourceProperties!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataSourceName") {
                self.dataSourceName = dict["DataSourceName"] as! String
            }
            if dict.keys.contains("DataSourceProperties") {
                self.dataSourceProperties = dict["DataSourceProperties"] as! [String: String]
            }
        }
    }
    public class TableMappings : Tea.TeaModel {
        public class SourceObjectSelectionRules : Tea.TeaModel {
            public var expression: String?

            public var objectType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.objectType != nil {
                    map["ObjectType"] = self.objectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Expression") {
                    self.expression = dict["Expression"] as! String
                }
                if dict.keys.contains("ObjectType") {
                    self.objectType = dict["ObjectType"] as! String
                }
            }
        }
        public class TransformationRules : Tea.TeaModel {
            public var ruleActionType: String?

            public var ruleName: String?

            public var ruleTargetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ruleActionType != nil {
                    map["RuleActionType"] = self.ruleActionType!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.ruleTargetType != nil {
                    map["RuleTargetType"] = self.ruleTargetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RuleActionType") {
                    self.ruleActionType = dict["RuleActionType"] as! String
                }
                if dict.keys.contains("RuleName") {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("RuleTargetType") {
                    self.ruleTargetType = dict["RuleTargetType"] as! String
                }
            }
        }
        public var sourceObjectSelectionRules: [CreateDIJobRequest.TableMappings.SourceObjectSelectionRules]?

        public var transformationRules: [CreateDIJobRequest.TableMappings.TransformationRules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sourceObjectSelectionRules != nil {
                var tmp : [Any] = []
                for k in self.sourceObjectSelectionRules! {
                    tmp.append(k.toMap())
                }
                map["SourceObjectSelectionRules"] = tmp
            }
            if self.transformationRules != nil {
                var tmp : [Any] = []
                for k in self.transformationRules! {
                    tmp.append(k.toMap())
                }
                map["TransformationRules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SourceObjectSelectionRules") {
                var tmp : [CreateDIJobRequest.TableMappings.SourceObjectSelectionRules] = []
                for v in dict["SourceObjectSelectionRules"] as! [Any] {
                    var model = CreateDIJobRequest.TableMappings.SourceObjectSelectionRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sourceObjectSelectionRules = tmp
            }
            if dict.keys.contains("TransformationRules") {
                var tmp : [CreateDIJobRequest.TableMappings.TransformationRules] = []
                for v in dict["TransformationRules"] as! [Any] {
                    var model = CreateDIJobRequest.TableMappings.TransformationRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transformationRules = tmp
            }
        }
    }
    public class TransformationRules : Tea.TeaModel {
        public var ruleActionType: String?

        public var ruleExpression: String?

        public var ruleName: String?

        public var ruleTargetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleActionType != nil {
                map["RuleActionType"] = self.ruleActionType!
            }
            if self.ruleExpression != nil {
                map["RuleExpression"] = self.ruleExpression!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.ruleTargetType != nil {
                map["RuleTargetType"] = self.ruleTargetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RuleActionType") {
                self.ruleActionType = dict["RuleActionType"] as! String
            }
            if dict.keys.contains("RuleExpression") {
                self.ruleExpression = dict["RuleExpression"] as! String
            }
            if dict.keys.contains("RuleName") {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("RuleTargetType") {
                self.ruleTargetType = dict["RuleTargetType"] as! String
            }
        }
    }
    public var description_: String?

    public var destinationDataSourceSettings: [CreateDIJobRequest.DestinationDataSourceSettings]?

    public var destinationDataSourceType: String?

    public var jobName: String?

    public var jobSettings: CreateDIJobRequest.JobSettings?

    public var migrationType: String?

    public var projectId: Int64?

    public var resourceSettings: CreateDIJobRequest.ResourceSettings?

    public var sourceDataSourceSettings: [CreateDIJobRequest.SourceDataSourceSettings]?

    public var sourceDataSourceType: String?

    public var systemDebug: String?

    public var tableMappings: [CreateDIJobRequest.TableMappings]?

    public var transformationRules: [CreateDIJobRequest.TransformationRules]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobSettings?.validate()
        try self.resourceSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationDataSourceSettings != nil {
            var tmp : [Any] = []
            for k in self.destinationDataSourceSettings! {
                tmp.append(k.toMap())
            }
            map["DestinationDataSourceSettings"] = tmp
        }
        if self.destinationDataSourceType != nil {
            map["DestinationDataSourceType"] = self.destinationDataSourceType!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.jobSettings != nil {
            map["JobSettings"] = self.jobSettings?.toMap()
        }
        if self.migrationType != nil {
            map["MigrationType"] = self.migrationType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceSettings != nil {
            map["ResourceSettings"] = self.resourceSettings?.toMap()
        }
        if self.sourceDataSourceSettings != nil {
            var tmp : [Any] = []
            for k in self.sourceDataSourceSettings! {
                tmp.append(k.toMap())
            }
            map["SourceDataSourceSettings"] = tmp
        }
        if self.sourceDataSourceType != nil {
            map["SourceDataSourceType"] = self.sourceDataSourceType!
        }
        if self.systemDebug != nil {
            map["SystemDebug"] = self.systemDebug!
        }
        if self.tableMappings != nil {
            var tmp : [Any] = []
            for k in self.tableMappings! {
                tmp.append(k.toMap())
            }
            map["TableMappings"] = tmp
        }
        if self.transformationRules != nil {
            var tmp : [Any] = []
            for k in self.transformationRules! {
                tmp.append(k.toMap())
            }
            map["TransformationRules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationDataSourceSettings") {
            var tmp : [CreateDIJobRequest.DestinationDataSourceSettings] = []
            for v in dict["DestinationDataSourceSettings"] as! [Any] {
                var model = CreateDIJobRequest.DestinationDataSourceSettings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.destinationDataSourceSettings = tmp
        }
        if dict.keys.contains("DestinationDataSourceType") {
            self.destinationDataSourceType = dict["DestinationDataSourceType"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("JobSettings") {
            var model = CreateDIJobRequest.JobSettings()
            model.fromMap(dict["JobSettings"] as! [String: Any])
            self.jobSettings = model
        }
        if dict.keys.contains("MigrationType") {
            self.migrationType = dict["MigrationType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ResourceSettings") {
            var model = CreateDIJobRequest.ResourceSettings()
            model.fromMap(dict["ResourceSettings"] as! [String: Any])
            self.resourceSettings = model
        }
        if dict.keys.contains("SourceDataSourceSettings") {
            var tmp : [CreateDIJobRequest.SourceDataSourceSettings] = []
            for v in dict["SourceDataSourceSettings"] as! [Any] {
                var model = CreateDIJobRequest.SourceDataSourceSettings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sourceDataSourceSettings = tmp
        }
        if dict.keys.contains("SourceDataSourceType") {
            self.sourceDataSourceType = dict["SourceDataSourceType"] as! String
        }
        if dict.keys.contains("SystemDebug") {
            self.systemDebug = dict["SystemDebug"] as! String
        }
        if dict.keys.contains("TableMappings") {
            var tmp : [CreateDIJobRequest.TableMappings] = []
            for v in dict["TableMappings"] as! [Any] {
                var model = CreateDIJobRequest.TableMappings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tableMappings = tmp
        }
        if dict.keys.contains("TransformationRules") {
            var tmp : [CreateDIJobRequest.TransformationRules] = []
            for v in dict["TransformationRules"] as! [Any] {
                var model = CreateDIJobRequest.TransformationRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.transformationRules = tmp
        }
    }
}

public class CreateDIJobShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var destinationDataSourceSettingsShrink: String?

    public var destinationDataSourceType: String?

    public var jobName: String?

    public var jobSettingsShrink: String?

    public var migrationType: String?

    public var projectId: Int64?

    public var resourceSettingsShrink: String?

    public var sourceDataSourceSettingsShrink: String?

    public var sourceDataSourceType: String?

    public var systemDebug: String?

    public var tableMappingsShrink: String?

    public var transformationRulesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationDataSourceSettingsShrink != nil {
            map["DestinationDataSourceSettings"] = self.destinationDataSourceSettingsShrink!
        }
        if self.destinationDataSourceType != nil {
            map["DestinationDataSourceType"] = self.destinationDataSourceType!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.jobSettingsShrink != nil {
            map["JobSettings"] = self.jobSettingsShrink!
        }
        if self.migrationType != nil {
            map["MigrationType"] = self.migrationType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceSettingsShrink != nil {
            map["ResourceSettings"] = self.resourceSettingsShrink!
        }
        if self.sourceDataSourceSettingsShrink != nil {
            map["SourceDataSourceSettings"] = self.sourceDataSourceSettingsShrink!
        }
        if self.sourceDataSourceType != nil {
            map["SourceDataSourceType"] = self.sourceDataSourceType!
        }
        if self.systemDebug != nil {
            map["SystemDebug"] = self.systemDebug!
        }
        if self.tableMappingsShrink != nil {
            map["TableMappings"] = self.tableMappingsShrink!
        }
        if self.transformationRulesShrink != nil {
            map["TransformationRules"] = self.transformationRulesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationDataSourceSettings") {
            self.destinationDataSourceSettingsShrink = dict["DestinationDataSourceSettings"] as! String
        }
        if dict.keys.contains("DestinationDataSourceType") {
            self.destinationDataSourceType = dict["DestinationDataSourceType"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("JobSettings") {
            self.jobSettingsShrink = dict["JobSettings"] as! String
        }
        if dict.keys.contains("MigrationType") {
            self.migrationType = dict["MigrationType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ResourceSettings") {
            self.resourceSettingsShrink = dict["ResourceSettings"] as! String
        }
        if dict.keys.contains("SourceDataSourceSettings") {
            self.sourceDataSourceSettingsShrink = dict["SourceDataSourceSettings"] as! String
        }
        if dict.keys.contains("SourceDataSourceType") {
            self.sourceDataSourceType = dict["SourceDataSourceType"] as! String
        }
        if dict.keys.contains("SystemDebug") {
            self.systemDebug = dict["SystemDebug"] as! String
        }
        if dict.keys.contains("TableMappings") {
            self.tableMappingsShrink = dict["TableMappings"] as! String
        }
        if dict.keys.contains("TransformationRules") {
            self.transformationRulesShrink = dict["TransformationRules"] as! String
        }
    }
}

public class CreateDIJobResponseBody : Tea.TeaModel {
    public var DIJobId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDIJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDISyncTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public var projectId: Int64?

    public var taskContent: String?

    public var taskName: String?

    public var taskParam: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskContent != nil {
            map["TaskContent"] = self.taskContent!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskParam != nil {
            map["TaskParam"] = self.taskParam!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TaskContent") {
            self.taskContent = dict["TaskContent"] as! String
        }
        if dict.keys.contains("TaskName") {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskParam") {
            self.taskParam = dict["TaskParam"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class CreateDISyncTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var fileId: Int64?

        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileId != nil {
                map["FileId"] = self.fileId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileId") {
                self.fileId = dict["FileId"] as! Int64
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: CreateDISyncTaskResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = CreateDISyncTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDISyncTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDISyncTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDISyncTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDagComplementRequest : Tea.TeaModel {
    public var bizBeginTime: String?

    public var bizEndTime: String?

    public var endBizDate: String?

    public var excludeNodeIds: String?

    public var includeNodeIds: String?

    public var name: String?

    public var nodeParams: String?

    public var parallelism: Bool?

    public var projectEnv: String?

    public var rootNodeId: Int64?

    public var startBizDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizBeginTime != nil {
            map["BizBeginTime"] = self.bizBeginTime!
        }
        if self.bizEndTime != nil {
            map["BizEndTime"] = self.bizEndTime!
        }
        if self.endBizDate != nil {
            map["EndBizDate"] = self.endBizDate!
        }
        if self.excludeNodeIds != nil {
            map["ExcludeNodeIds"] = self.excludeNodeIds!
        }
        if self.includeNodeIds != nil {
            map["IncludeNodeIds"] = self.includeNodeIds!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nodeParams != nil {
            map["NodeParams"] = self.nodeParams!
        }
        if self.parallelism != nil {
            map["Parallelism"] = self.parallelism!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.rootNodeId != nil {
            map["RootNodeId"] = self.rootNodeId!
        }
        if self.startBizDate != nil {
            map["StartBizDate"] = self.startBizDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizBeginTime") {
            self.bizBeginTime = dict["BizBeginTime"] as! String
        }
        if dict.keys.contains("BizEndTime") {
            self.bizEndTime = dict["BizEndTime"] as! String
        }
        if dict.keys.contains("EndBizDate") {
            self.endBizDate = dict["EndBizDate"] as! String
        }
        if dict.keys.contains("ExcludeNodeIds") {
            self.excludeNodeIds = dict["ExcludeNodeIds"] as! String
        }
        if dict.keys.contains("IncludeNodeIds") {
            self.includeNodeIds = dict["IncludeNodeIds"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NodeParams") {
            self.nodeParams = dict["NodeParams"] as! String
        }
        if dict.keys.contains("Parallelism") {
            self.parallelism = dict["Parallelism"] as! Bool
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("RootNodeId") {
            self.rootNodeId = dict["RootNodeId"] as! Int64
        }
        if dict.keys.contains("StartBizDate") {
            self.startBizDate = dict["StartBizDate"] as! String
        }
    }
}

public class CreateDagComplementResponseBody : Tea.TeaModel {
    public var data: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDagComplementResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDagComplementResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDagComplementResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDagTestRequest : Tea.TeaModel {
    public var bizdate: String?

    public var name: String?

    public var nodeId: Int64?

    public var nodeParams: String?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeParams != nil {
            map["NodeParams"] = self.nodeParams!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizdate") {
            self.bizdate = dict["Bizdate"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("NodeParams") {
            self.nodeParams = dict["NodeParams"] as! String
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class CreateDagTestResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDagTestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDagTestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDagTestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataServiceApiRequest : Tea.TeaModel {
    public var apiDescription: String?

    public var apiMode: Int32?

    public var apiName: String?

    public var apiPath: String?

    public var folderId: Int64?

    public var groupId: String?

    public var projectId: Int64?

    public var protocols: String?

    public var registrationDetails: String?

    public var requestContentType: Int32?

    public var requestMethod: Int32?

    public var resourceGroupId: Int64?

    public var responseContentType: Int32?

    public var scriptDetails: String?

    public var sqlMode: Int64?

    public var tenantId: Int64?

    public var timeout: Int32?

    public var visibleRange: Int32?

    public var wizardDetails: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiDescription != nil {
            map["ApiDescription"] = self.apiDescription!
        }
        if self.apiMode != nil {
            map["ApiMode"] = self.apiMode!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.apiPath != nil {
            map["ApiPath"] = self.apiPath!
        }
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.protocols != nil {
            map["Protocols"] = self.protocols!
        }
        if self.registrationDetails != nil {
            map["RegistrationDetails"] = self.registrationDetails!
        }
        if self.requestContentType != nil {
            map["RequestContentType"] = self.requestContentType!
        }
        if self.requestMethod != nil {
            map["RequestMethod"] = self.requestMethod!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.responseContentType != nil {
            map["ResponseContentType"] = self.responseContentType!
        }
        if self.scriptDetails != nil {
            map["ScriptDetails"] = self.scriptDetails!
        }
        if self.sqlMode != nil {
            map["SqlMode"] = self.sqlMode!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.visibleRange != nil {
            map["VisibleRange"] = self.visibleRange!
        }
        if self.wizardDetails != nil {
            map["WizardDetails"] = self.wizardDetails!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiDescription") {
            self.apiDescription = dict["ApiDescription"] as! String
        }
        if dict.keys.contains("ApiMode") {
            self.apiMode = dict["ApiMode"] as! Int32
        }
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("ApiPath") {
            self.apiPath = dict["ApiPath"] as! String
        }
        if dict.keys.contains("FolderId") {
            self.folderId = dict["FolderId"] as! Int64
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("Protocols") {
            self.protocols = dict["Protocols"] as! String
        }
        if dict.keys.contains("RegistrationDetails") {
            self.registrationDetails = dict["RegistrationDetails"] as! String
        }
        if dict.keys.contains("RequestContentType") {
            self.requestContentType = dict["RequestContentType"] as! Int32
        }
        if dict.keys.contains("RequestMethod") {
            self.requestMethod = dict["RequestMethod"] as! Int32
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! Int64
        }
        if dict.keys.contains("ResponseContentType") {
            self.responseContentType = dict["ResponseContentType"] as! Int32
        }
        if dict.keys.contains("ScriptDetails") {
            self.scriptDetails = dict["ScriptDetails"] as! String
        }
        if dict.keys.contains("SqlMode") {
            self.sqlMode = dict["SqlMode"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("VisibleRange") {
            self.visibleRange = dict["VisibleRange"] as! Int32
        }
        if dict.keys.contains("WizardDetails") {
            self.wizardDetails = dict["WizardDetails"] as! String
        }
    }
}

public class CreateDataServiceApiResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataServiceApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataServiceApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataServiceApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataServiceApiAuthorityRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var authorizedProjectId: Int64?

    public var endTime: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.authorizedProjectId != nil {
            map["AuthorizedProjectId"] = self.authorizedProjectId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! Int64
        }
        if dict.keys.contains("AuthorizedProjectId") {
            self.authorizedProjectId = dict["AuthorizedProjectId"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class CreateDataServiceApiAuthorityResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataServiceApiAuthorityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataServiceApiAuthorityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataServiceApiAuthorityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataServiceFolderRequest : Tea.TeaModel {
    public var folderName: String?

    public var groupId: String?

    public var parentId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderName != nil {
            map["FolderName"] = self.folderName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FolderName") {
            self.folderName = dict["FolderName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class CreateDataServiceFolderResponseBody : Tea.TeaModel {
    public var folderId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FolderId") {
            self.folderId = dict["FolderId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDataServiceFolderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataServiceFolderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataServiceFolderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataServiceGroupRequest : Tea.TeaModel {
    public var apiGatewayGroupId: String?

    public var description_: String?

    public var groupName: String?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiGatewayGroupId != nil {
            map["ApiGatewayGroupId"] = self.apiGatewayGroupId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiGatewayGroupId") {
            self.apiGatewayGroupId = dict["ApiGatewayGroupId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class CreateDataServiceGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDataServiceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataServiceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataServiceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataSourceRequest : Tea.TeaModel {
    public var content: String?

    public var dataSourceType: String?

    public var description_: String?

    public var envType: Int32?

    public var name: String?

    public var projectId: Int64?

    public var subType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.subType != nil {
            map["SubType"] = self.subType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SubType") {
            self.subType = dict["SubType"] as! String
        }
    }
}

public class CreateDataSourceResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateExportMigrationRequest : Tea.TeaModel {
    public var description_: String?

    public var exportMode: String?

    public var exportObjectStatus: String?

    public var incrementalSince: Int64?

    public var name: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.exportMode != nil {
            map["ExportMode"] = self.exportMode!
        }
        if self.exportObjectStatus != nil {
            map["ExportObjectStatus"] = self.exportObjectStatus!
        }
        if self.incrementalSince != nil {
            map["IncrementalSince"] = self.incrementalSince!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ExportMode") {
            self.exportMode = dict["ExportMode"] as! String
        }
        if dict.keys.contains("ExportObjectStatus") {
            self.exportObjectStatus = dict["ExportObjectStatus"] as! String
        }
        if dict.keys.contains("IncrementalSince") {
            self.incrementalSince = dict["IncrementalSince"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class CreateExportMigrationResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateExportMigrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateExportMigrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateExportMigrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFileRequest : Tea.TeaModel {
    public var advancedSettings: String?

    public var applyScheduleImmediately: Bool?

    public var autoParsing: Bool?

    public var autoRerunIntervalMillis: Int32?

    public var autoRerunTimes: Int32?

    public var connectionName: String?

    public var content: String?

    public var createFolderIfNotExists: Bool?

    public var cronExpress: String?

    public var cycleType: String?

    public var dependentNodeIdList: String?

    public var dependentType: String?

    public var endEffectDate: Int64?

    public var fileDescription: String?

    public var fileFolderPath: String?

    public var fileName: String?

    public var fileType: Int32?

    public var ignoreParentSkipRunningProperty: Bool?

    public var imageId: String?

    public var inputList: String?

    public var inputParameters: String?

    public var outputParameters: String?

    public var owner: String?

    public var paraValue: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var rerunMode: String?

    public var resourceGroupId: Int64?

    public var resourceGroupIdentifier: String?

    public var schedulerType: String?

    public var startEffectDate: Int64?

    public var startImmediately: Bool?

    public var stop: Bool?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advancedSettings != nil {
            map["AdvancedSettings"] = self.advancedSettings!
        }
        if self.applyScheduleImmediately != nil {
            map["ApplyScheduleImmediately"] = self.applyScheduleImmediately!
        }
        if self.autoParsing != nil {
            map["AutoParsing"] = self.autoParsing!
        }
        if self.autoRerunIntervalMillis != nil {
            map["AutoRerunIntervalMillis"] = self.autoRerunIntervalMillis!
        }
        if self.autoRerunTimes != nil {
            map["AutoRerunTimes"] = self.autoRerunTimes!
        }
        if self.connectionName != nil {
            map["ConnectionName"] = self.connectionName!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.createFolderIfNotExists != nil {
            map["CreateFolderIfNotExists"] = self.createFolderIfNotExists!
        }
        if self.cronExpress != nil {
            map["CronExpress"] = self.cronExpress!
        }
        if self.cycleType != nil {
            map["CycleType"] = self.cycleType!
        }
        if self.dependentNodeIdList != nil {
            map["DependentNodeIdList"] = self.dependentNodeIdList!
        }
        if self.dependentType != nil {
            map["DependentType"] = self.dependentType!
        }
        if self.endEffectDate != nil {
            map["EndEffectDate"] = self.endEffectDate!
        }
        if self.fileDescription != nil {
            map["FileDescription"] = self.fileDescription!
        }
        if self.fileFolderPath != nil {
            map["FileFolderPath"] = self.fileFolderPath!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileType != nil {
            map["FileType"] = self.fileType!
        }
        if self.ignoreParentSkipRunningProperty != nil {
            map["IgnoreParentSkipRunningProperty"] = self.ignoreParentSkipRunningProperty!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.inputList != nil {
            map["InputList"] = self.inputList!
        }
        if self.inputParameters != nil {
            map["InputParameters"] = self.inputParameters!
        }
        if self.outputParameters != nil {
            map["OutputParameters"] = self.outputParameters!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.paraValue != nil {
            map["ParaValue"] = self.paraValue!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.rerunMode != nil {
            map["RerunMode"] = self.rerunMode!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceGroupIdentifier != nil {
            map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
        }
        if self.schedulerType != nil {
            map["SchedulerType"] = self.schedulerType!
        }
        if self.startEffectDate != nil {
            map["StartEffectDate"] = self.startEffectDate!
        }
        if self.startImmediately != nil {
            map["StartImmediately"] = self.startImmediately!
        }
        if self.stop != nil {
            map["Stop"] = self.stop!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdvancedSettings") {
            self.advancedSettings = dict["AdvancedSettings"] as! String
        }
        if dict.keys.contains("ApplyScheduleImmediately") {
            self.applyScheduleImmediately = dict["ApplyScheduleImmediately"] as! Bool
        }
        if dict.keys.contains("AutoParsing") {
            self.autoParsing = dict["AutoParsing"] as! Bool
        }
        if dict.keys.contains("AutoRerunIntervalMillis") {
            self.autoRerunIntervalMillis = dict["AutoRerunIntervalMillis"] as! Int32
        }
        if dict.keys.contains("AutoRerunTimes") {
            self.autoRerunTimes = dict["AutoRerunTimes"] as! Int32
        }
        if dict.keys.contains("ConnectionName") {
            self.connectionName = dict["ConnectionName"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("CreateFolderIfNotExists") {
            self.createFolderIfNotExists = dict["CreateFolderIfNotExists"] as! Bool
        }
        if dict.keys.contains("CronExpress") {
            self.cronExpress = dict["CronExpress"] as! String
        }
        if dict.keys.contains("CycleType") {
            self.cycleType = dict["CycleType"] as! String
        }
        if dict.keys.contains("DependentNodeIdList") {
            self.dependentNodeIdList = dict["DependentNodeIdList"] as! String
        }
        if dict.keys.contains("DependentType") {
            self.dependentType = dict["DependentType"] as! String
        }
        if dict.keys.contains("EndEffectDate") {
            self.endEffectDate = dict["EndEffectDate"] as! Int64
        }
        if dict.keys.contains("FileDescription") {
            self.fileDescription = dict["FileDescription"] as! String
        }
        if dict.keys.contains("FileFolderPath") {
            self.fileFolderPath = dict["FileFolderPath"] as! String
        }
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileType") {
            self.fileType = dict["FileType"] as! Int32
        }
        if dict.keys.contains("IgnoreParentSkipRunningProperty") {
            self.ignoreParentSkipRunningProperty = dict["IgnoreParentSkipRunningProperty"] as! Bool
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InputList") {
            self.inputList = dict["InputList"] as! String
        }
        if dict.keys.contains("InputParameters") {
            self.inputParameters = dict["InputParameters"] as! String
        }
        if dict.keys.contains("OutputParameters") {
            self.outputParameters = dict["OutputParameters"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("ParaValue") {
            self.paraValue = dict["ParaValue"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
        if dict.keys.contains("RerunMode") {
            self.rerunMode = dict["RerunMode"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! Int64
        }
        if dict.keys.contains("ResourceGroupIdentifier") {
            self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
        }
        if dict.keys.contains("SchedulerType") {
            self.schedulerType = dict["SchedulerType"] as! String
        }
        if dict.keys.contains("StartEffectDate") {
            self.startEffectDate = dict["StartEffectDate"] as! Int64
        }
        if dict.keys.contains("StartImmediately") {
            self.startImmediately = dict["StartImmediately"] as! Bool
        }
        if dict.keys.contains("Stop") {
            self.stop = dict["Stop"] as! Bool
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class CreateFileResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFolderRequest : Tea.TeaModel {
    public var folderPath: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderPath != nil {
            map["FolderPath"] = self.folderPath!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FolderPath") {
            self.folderPath = dict["FolderPath"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class CreateFolderResponseBody : Tea.TeaModel {
    public var data: String?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateFolderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFolderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateFolderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateImportMigrationRequest : Tea.TeaModel {
    public var calculateEngineMap: String?

    public var commitRule: String?

    public var description_: String?

    public var name: String?

    public var packageFile: String?

    public var packageType: String?

    public var projectId: Int64?

    public var resourceGroupMap: String?

    public var workspaceMap: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calculateEngineMap != nil {
            map["CalculateEngineMap"] = self.calculateEngineMap!
        }
        if self.commitRule != nil {
            map["CommitRule"] = self.commitRule!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.packageFile != nil {
            map["PackageFile"] = self.packageFile!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceGroupMap != nil {
            map["ResourceGroupMap"] = self.resourceGroupMap!
        }
        if self.workspaceMap != nil {
            map["WorkspaceMap"] = self.workspaceMap!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalculateEngineMap") {
            self.calculateEngineMap = dict["CalculateEngineMap"] as! String
        }
        if dict.keys.contains("CommitRule") {
            self.commitRule = dict["CommitRule"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PackageFile") {
            self.packageFile = dict["PackageFile"] as! String
        }
        if dict.keys.contains("PackageType") {
            self.packageType = dict["PackageType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ResourceGroupMap") {
            self.resourceGroupMap = dict["ResourceGroupMap"] as! String
        }
        if dict.keys.contains("WorkspaceMap") {
            self.workspaceMap = dict["WorkspaceMap"] as! String
        }
    }
}

public class CreateImportMigrationAdvanceRequest : Tea.TeaModel {
    public var calculateEngineMap: String?

    public var commitRule: String?

    public var description_: String?

    public var name: String?

    public var packageFileObject: InputStream?

    public var packageType: String?

    public var projectId: Int64?

    public var resourceGroupMap: String?

    public var workspaceMap: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calculateEngineMap != nil {
            map["CalculateEngineMap"] = self.calculateEngineMap!
        }
        if self.commitRule != nil {
            map["CommitRule"] = self.commitRule!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.packageFileObject != nil {
            map["PackageFile"] = self.packageFileObject!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceGroupMap != nil {
            map["ResourceGroupMap"] = self.resourceGroupMap!
        }
        if self.workspaceMap != nil {
            map["WorkspaceMap"] = self.workspaceMap!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalculateEngineMap") {
            self.calculateEngineMap = dict["CalculateEngineMap"] as! String
        }
        if dict.keys.contains("CommitRule") {
            self.commitRule = dict["CommitRule"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PackageFile") {
            self.packageFileObject = dict["PackageFile"] as! InputStream
        }
        if dict.keys.contains("PackageType") {
            self.packageType = dict["PackageType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ResourceGroupMap") {
            self.resourceGroupMap = dict["ResourceGroupMap"] as! String
        }
        if dict.keys.contains("WorkspaceMap") {
            self.workspaceMap = dict["WorkspaceMap"] as! String
        }
    }
}

public class CreateImportMigrationResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateImportMigrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateImportMigrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateImportMigrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateManualDagRequest : Tea.TeaModel {
    public var bizDate: String?

    public var dagParameters: String?

    public var excludeNodeIds: String?

    public var flowName: String?

    public var includeNodeIds: String?

    public var nodeParameters: String?

    public var projectEnv: String?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizDate != nil {
            map["BizDate"] = self.bizDate!
        }
        if self.dagParameters != nil {
            map["DagParameters"] = self.dagParameters!
        }
        if self.excludeNodeIds != nil {
            map["ExcludeNodeIds"] = self.excludeNodeIds!
        }
        if self.flowName != nil {
            map["FlowName"] = self.flowName!
        }
        if self.includeNodeIds != nil {
            map["IncludeNodeIds"] = self.includeNodeIds!
        }
        if self.nodeParameters != nil {
            map["NodeParameters"] = self.nodeParameters!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizDate") {
            self.bizDate = dict["BizDate"] as! String
        }
        if dict.keys.contains("DagParameters") {
            self.dagParameters = dict["DagParameters"] as! String
        }
        if dict.keys.contains("ExcludeNodeIds") {
            self.excludeNodeIds = dict["ExcludeNodeIds"] as! String
        }
        if dict.keys.contains("FlowName") {
            self.flowName = dict["FlowName"] as! String
        }
        if dict.keys.contains("IncludeNodeIds") {
            self.includeNodeIds = dict["IncludeNodeIds"] as! String
        }
        if dict.keys.contains("NodeParameters") {
            self.nodeParameters = dict["NodeParameters"] as! String
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
    }
}

public class CreateManualDagResponseBody : Tea.TeaModel {
    public var dagId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateManualDagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateManualDagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateManualDagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMetaCategoryRequest : Tea.TeaModel {
    public var comment: String?

    public var name: String?

    public var parentId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! Int64
        }
    }
}

public class CreateMetaCategoryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var categoryId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.categoryId != nil {
                map["CategoryId"] = self.categoryId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CategoryId") {
                self.categoryId = dict["CategoryId"] as! Int64
            }
        }
    }
    public var data: CreateMetaCategoryResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = CreateMetaCategoryResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateMetaCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMetaCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMetaCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMetaCollectionRequest : Tea.TeaModel {
    public var collectionType: String?

    public var comment: String?

    public var name: String?

    public var parentQualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectionType != nil {
            map["CollectionType"] = self.collectionType!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentQualifiedName != nil {
            map["ParentQualifiedName"] = self.parentQualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CollectionType") {
            self.collectionType = dict["CollectionType"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ParentQualifiedName") {
            self.parentQualifiedName = dict["ParentQualifiedName"] as! String
        }
    }
}

public class CreateMetaCollectionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: String?

    public var qualifiedName: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("QualifiedName") {
            self.qualifiedName = dict["QualifiedName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateMetaCollectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMetaCollectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMetaCollectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePermissionApplyOrderRequest : Tea.TeaModel {
    public class ApplyObject : Tea.TeaModel {
        public class ColumnMetaList : Tea.TeaModel {
            public var actions: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actions != nil {
                    map["Actions"] = self.actions!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Actions") {
                    self.actions = dict["Actions"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var actions: String?

        public var columnMetaList: [CreatePermissionApplyOrderRequest.ApplyObject.ColumnMetaList]?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actions != nil {
                map["Actions"] = self.actions!
            }
            if self.columnMetaList != nil {
                var tmp : [Any] = []
                for k in self.columnMetaList! {
                    tmp.append(k.toMap())
                }
                map["ColumnMetaList"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Actions") {
                self.actions = dict["Actions"] as! String
            }
            if dict.keys.contains("ColumnMetaList") {
                var tmp : [CreatePermissionApplyOrderRequest.ApplyObject.ColumnMetaList] = []
                for v in dict["ColumnMetaList"] as! [Any] {
                    var model = CreatePermissionApplyOrderRequest.ApplyObject.ColumnMetaList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.columnMetaList = tmp
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var applyObject: [CreatePermissionApplyOrderRequest.ApplyObject]?

    public var applyReason: String?

    public var applyType: String?

    public var applyUserIds: String?

    public var catalogName: String?

    public var deadline: Int64?

    public var engineType: String?

    public var maxComputeProjectName: String?

    public var orderType: Int32?

    public var workspaceId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applyObject != nil {
            var tmp : [Any] = []
            for k in self.applyObject! {
                tmp.append(k.toMap())
            }
            map["ApplyObject"] = tmp
        }
        if self.applyReason != nil {
            map["ApplyReason"] = self.applyReason!
        }
        if self.applyType != nil {
            map["ApplyType"] = self.applyType!
        }
        if self.applyUserIds != nil {
            map["ApplyUserIds"] = self.applyUserIds!
        }
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.deadline != nil {
            map["Deadline"] = self.deadline!
        }
        if self.engineType != nil {
            map["EngineType"] = self.engineType!
        }
        if self.maxComputeProjectName != nil {
            map["MaxComputeProjectName"] = self.maxComputeProjectName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplyObject") {
            var tmp : [CreatePermissionApplyOrderRequest.ApplyObject] = []
            for v in dict["ApplyObject"] as! [Any] {
                var model = CreatePermissionApplyOrderRequest.ApplyObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.applyObject = tmp
        }
        if dict.keys.contains("ApplyReason") {
            self.applyReason = dict["ApplyReason"] as! String
        }
        if dict.keys.contains("ApplyType") {
            self.applyType = dict["ApplyType"] as! String
        }
        if dict.keys.contains("ApplyUserIds") {
            self.applyUserIds = dict["ApplyUserIds"] as! String
        }
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("Deadline") {
            self.deadline = dict["Deadline"] as! Int64
        }
        if dict.keys.contains("EngineType") {
            self.engineType = dict["EngineType"] as! String
        }
        if dict.keys.contains("MaxComputeProjectName") {
            self.maxComputeProjectName = dict["MaxComputeProjectName"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! Int32
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! Int32
        }
    }
}

public class CreatePermissionApplyOrderResponseBody : Tea.TeaModel {
    public var flowId: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowId") {
            self.flowId = dict["FlowId"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePermissionApplyOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePermissionApplyOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePermissionApplyOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProjectRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var disableDevelopment: Bool?

    public var isAllowDownload: Int32?

    public var projectDescription: String?

    public var projectIdentifier: String?

    public var projectMode: Int32?

    public var projectName: String?

    public var resourceManagerResourceGroupId: String?

    public var tags: [CreateProjectRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.disableDevelopment != nil {
            map["DisableDevelopment"] = self.disableDevelopment!
        }
        if self.isAllowDownload != nil {
            map["IsAllowDownload"] = self.isAllowDownload!
        }
        if self.projectDescription != nil {
            map["ProjectDescription"] = self.projectDescription!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.projectMode != nil {
            map["ProjectMode"] = self.projectMode!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.resourceManagerResourceGroupId != nil {
            map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DisableDevelopment") {
            self.disableDevelopment = dict["DisableDevelopment"] as! Bool
        }
        if dict.keys.contains("IsAllowDownload") {
            self.isAllowDownload = dict["IsAllowDownload"] as! Int32
        }
        if dict.keys.contains("ProjectDescription") {
            self.projectDescription = dict["ProjectDescription"] as! String
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
        if dict.keys.contains("ProjectMode") {
            self.projectMode = dict["ProjectMode"] as! Int32
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("ResourceManagerResourceGroupId") {
            self.resourceManagerResourceGroupId = dict["ResourceManagerResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [CreateProjectRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateProjectRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class CreateProjectShrinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var disableDevelopment: Bool?

    public var isAllowDownload: Int32?

    public var projectDescription: String?

    public var projectIdentifier: String?

    public var projectMode: Int32?

    public var projectName: String?

    public var resourceManagerResourceGroupId: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.disableDevelopment != nil {
            map["DisableDevelopment"] = self.disableDevelopment!
        }
        if self.isAllowDownload != nil {
            map["IsAllowDownload"] = self.isAllowDownload!
        }
        if self.projectDescription != nil {
            map["ProjectDescription"] = self.projectDescription!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.projectMode != nil {
            map["ProjectMode"] = self.projectMode!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.resourceManagerResourceGroupId != nil {
            map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DisableDevelopment") {
            self.disableDevelopment = dict["DisableDevelopment"] as! Bool
        }
        if dict.keys.contains("IsAllowDownload") {
            self.isAllowDownload = dict["IsAllowDownload"] as! Int32
        }
        if dict.keys.contains("ProjectDescription") {
            self.projectDescription = dict["ProjectDescription"] as! String
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
        if dict.keys.contains("ProjectMode") {
            self.projectMode = dict["ProjectMode"] as! Int32
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("ResourceManagerResourceGroupId") {
            self.resourceManagerResourceGroupId = dict["ResourceManagerResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tagsShrink = dict["Tags"] as! String
        }
    }
}

public class CreateProjectResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProjectMemberRequest : Tea.TeaModel {
    public var clientToken: String?

    public var projectId: Int64?

    public var roleCode: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCode != nil {
            map["RoleCode"] = self.roleCode!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RoleCode") {
            self.roleCode = dict["RoleCode"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class CreateProjectMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateProjectMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProjectMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateProjectMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateQualityEntityRequest : Tea.TeaModel {
    public var entityLevel: Int32?

    public var envType: String?

    public var matchExpression: String?

    public var projectId: Int64?

    public var projectName: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityLevel != nil {
            map["EntityLevel"] = self.entityLevel!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.matchExpression != nil {
            map["MatchExpression"] = self.matchExpression!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityLevel") {
            self.entityLevel = dict["EntityLevel"] as! Int32
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("MatchExpression") {
            self.matchExpression = dict["MatchExpression"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class CreateQualityEntityResponseBody : Tea.TeaModel {
    public var data: Int32?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int32
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateQualityEntityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateQualityEntityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateQualityEntityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateQualityFollowerRequest : Tea.TeaModel {
    public var alarmMode: Int32?

    public var entityId: Int64?

    public var follower: String?

    public var projectId: Int64?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmMode != nil {
            map["AlarmMode"] = self.alarmMode!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.follower != nil {
            map["Follower"] = self.follower!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmMode") {
            self.alarmMode = dict["AlarmMode"] as! Int32
        }
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! Int64
        }
        if dict.keys.contains("Follower") {
            self.follower = dict["Follower"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
    }
}

public class CreateQualityFollowerResponseBody : Tea.TeaModel {
    public var data: Int32?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int32
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateQualityFollowerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateQualityFollowerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateQualityFollowerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateQualityRelativeNodeRequest : Tea.TeaModel {
    public var envType: String?

    public var matchExpression: String?

    public var nodeId: Int64?

    public var projectId: Int64?

    public var projectName: String?

    public var tableName: String?

    public var targetNodeProjectId: Int64?

    public var targetNodeProjectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.matchExpression != nil {
            map["MatchExpression"] = self.matchExpression!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.targetNodeProjectId != nil {
            map["TargetNodeProjectId"] = self.targetNodeProjectId!
        }
        if self.targetNodeProjectName != nil {
            map["TargetNodeProjectName"] = self.targetNodeProjectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("MatchExpression") {
            self.matchExpression = dict["MatchExpression"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("TargetNodeProjectId") {
            self.targetNodeProjectId = dict["TargetNodeProjectId"] as! Int64
        }
        if dict.keys.contains("TargetNodeProjectName") {
            self.targetNodeProjectName = dict["TargetNodeProjectName"] as! String
        }
    }
}

public class CreateQualityRelativeNodeResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateQualityRelativeNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateQualityRelativeNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateQualityRelativeNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateQualityRuleRequest : Tea.TeaModel {
    public var blockType: Int32?

    public var checker: Int32?

    public var comment: String?

    public var criticalThreshold: String?

    public var entityId: Int64?

    public var expectValue: String?

    public var methodName: String?

    public var operator_: String?

    public var predictType: Int32?

    public var projectId: Int64?

    public var projectName: String?

    public var property: String?

    public var propertyType: String?

    public var ruleName: String?

    public var ruleType: Int32?

    public var taskSetting: String?

    public var templateId: Int32?

    public var trend: String?

    public var warningThreshold: String?

    public var whereCondition: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.blockType != nil {
            map["BlockType"] = self.blockType!
        }
        if self.checker != nil {
            map["Checker"] = self.checker!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.criticalThreshold != nil {
            map["CriticalThreshold"] = self.criticalThreshold!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.expectValue != nil {
            map["ExpectValue"] = self.expectValue!
        }
        if self.methodName != nil {
            map["MethodName"] = self.methodName!
        }
        if self.operator_ != nil {
            map["Operator"] = self.operator_!
        }
        if self.predictType != nil {
            map["PredictType"] = self.predictType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.property != nil {
            map["Property"] = self.property!
        }
        if self.propertyType != nil {
            map["PropertyType"] = self.propertyType!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        if self.taskSetting != nil {
            map["TaskSetting"] = self.taskSetting!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.trend != nil {
            map["Trend"] = self.trend!
        }
        if self.warningThreshold != nil {
            map["WarningThreshold"] = self.warningThreshold!
        }
        if self.whereCondition != nil {
            map["WhereCondition"] = self.whereCondition!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BlockType") {
            self.blockType = dict["BlockType"] as! Int32
        }
        if dict.keys.contains("Checker") {
            self.checker = dict["Checker"] as! Int32
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("CriticalThreshold") {
            self.criticalThreshold = dict["CriticalThreshold"] as! String
        }
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! Int64
        }
        if dict.keys.contains("ExpectValue") {
            self.expectValue = dict["ExpectValue"] as! String
        }
        if dict.keys.contains("MethodName") {
            self.methodName = dict["MethodName"] as! String
        }
        if dict.keys.contains("Operator") {
            self.operator_ = dict["Operator"] as! String
        }
        if dict.keys.contains("PredictType") {
            self.predictType = dict["PredictType"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("Property") {
            self.property = dict["Property"] as! String
        }
        if dict.keys.contains("PropertyType") {
            self.propertyType = dict["PropertyType"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("RuleType") {
            self.ruleType = dict["RuleType"] as! Int32
        }
        if dict.keys.contains("TaskSetting") {
            self.taskSetting = dict["TaskSetting"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! Int32
        }
        if dict.keys.contains("Trend") {
            self.trend = dict["Trend"] as! String
        }
        if dict.keys.contains("WarningThreshold") {
            self.warningThreshold = dict["WarningThreshold"] as! String
        }
        if dict.keys.contains("WhereCondition") {
            self.whereCondition = dict["WhereCondition"] as! String
        }
    }
}

public class CreateQualityRuleResponseBody : Tea.TeaModel {
    public var data: String?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateQualityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateQualityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateQualityRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRemindRequest : Tea.TeaModel {
    public var alertInterval: Int32?

    public var alertMethods: String?

    public var alertTargets: String?

    public var alertUnit: String?

    public var baselineIds: String?

    public var bizProcessIds: String?

    public var detail: String?

    public var dndEnd: String?

    public var maxAlertTimes: Int32?

    public var nodeIds: String?

    public var projectId: Int64?

    public var remindName: String?

    public var remindType: String?

    public var remindUnit: String?

    public var robotUrls: String?

    public var webhooks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertInterval != nil {
            map["AlertInterval"] = self.alertInterval!
        }
        if self.alertMethods != nil {
            map["AlertMethods"] = self.alertMethods!
        }
        if self.alertTargets != nil {
            map["AlertTargets"] = self.alertTargets!
        }
        if self.alertUnit != nil {
            map["AlertUnit"] = self.alertUnit!
        }
        if self.baselineIds != nil {
            map["BaselineIds"] = self.baselineIds!
        }
        if self.bizProcessIds != nil {
            map["BizProcessIds"] = self.bizProcessIds!
        }
        if self.detail != nil {
            map["Detail"] = self.detail!
        }
        if self.dndEnd != nil {
            map["DndEnd"] = self.dndEnd!
        }
        if self.maxAlertTimes != nil {
            map["MaxAlertTimes"] = self.maxAlertTimes!
        }
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.remindName != nil {
            map["RemindName"] = self.remindName!
        }
        if self.remindType != nil {
            map["RemindType"] = self.remindType!
        }
        if self.remindUnit != nil {
            map["RemindUnit"] = self.remindUnit!
        }
        if self.robotUrls != nil {
            map["RobotUrls"] = self.robotUrls!
        }
        if self.webhooks != nil {
            map["Webhooks"] = self.webhooks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertInterval") {
            self.alertInterval = dict["AlertInterval"] as! Int32
        }
        if dict.keys.contains("AlertMethods") {
            self.alertMethods = dict["AlertMethods"] as! String
        }
        if dict.keys.contains("AlertTargets") {
            self.alertTargets = dict["AlertTargets"] as! String
        }
        if dict.keys.contains("AlertUnit") {
            self.alertUnit = dict["AlertUnit"] as! String
        }
        if dict.keys.contains("BaselineIds") {
            self.baselineIds = dict["BaselineIds"] as! String
        }
        if dict.keys.contains("BizProcessIds") {
            self.bizProcessIds = dict["BizProcessIds"] as! String
        }
        if dict.keys.contains("Detail") {
            self.detail = dict["Detail"] as! String
        }
        if dict.keys.contains("DndEnd") {
            self.dndEnd = dict["DndEnd"] as! String
        }
        if dict.keys.contains("MaxAlertTimes") {
            self.maxAlertTimes = dict["MaxAlertTimes"] as! Int32
        }
        if dict.keys.contains("NodeIds") {
            self.nodeIds = dict["NodeIds"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RemindName") {
            self.remindName = dict["RemindName"] as! String
        }
        if dict.keys.contains("RemindType") {
            self.remindType = dict["RemindType"] as! String
        }
        if dict.keys.contains("RemindUnit") {
            self.remindUnit = dict["RemindUnit"] as! String
        }
        if dict.keys.contains("RobotUrls") {
            self.robotUrls = dict["RobotUrls"] as! String
        }
        if dict.keys.contains("Webhooks") {
            self.webhooks = dict["Webhooks"] as! String
        }
    }
}

public class CreateRemindResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateRemindResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRemindResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRemindResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateResourceFileRequest : Tea.TeaModel {
    public var content: String?

    public var fileDescription: String?

    public var fileFolderPath: String?

    public var fileName: String?

    public var fileType: Int32?

    public var originResourceName: String?

    public var owner: String?

    public var projectId: Int64?

    public var registerToCalcEngine: Bool?

    public var resourceFile: String?

    public var storageURL: String?

    public var uploadMode: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.fileDescription != nil {
            map["FileDescription"] = self.fileDescription!
        }
        if self.fileFolderPath != nil {
            map["FileFolderPath"] = self.fileFolderPath!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileType != nil {
            map["FileType"] = self.fileType!
        }
        if self.originResourceName != nil {
            map["OriginResourceName"] = self.originResourceName!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.registerToCalcEngine != nil {
            map["RegisterToCalcEngine"] = self.registerToCalcEngine!
        }
        if self.resourceFile != nil {
            map["ResourceFile"] = self.resourceFile!
        }
        if self.storageURL != nil {
            map["StorageURL"] = self.storageURL!
        }
        if self.uploadMode != nil {
            map["UploadMode"] = self.uploadMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("FileDescription") {
            self.fileDescription = dict["FileDescription"] as! String
        }
        if dict.keys.contains("FileFolderPath") {
            self.fileFolderPath = dict["FileFolderPath"] as! String
        }
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileType") {
            self.fileType = dict["FileType"] as! Int32
        }
        if dict.keys.contains("OriginResourceName") {
            self.originResourceName = dict["OriginResourceName"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RegisterToCalcEngine") {
            self.registerToCalcEngine = dict["RegisterToCalcEngine"] as! Bool
        }
        if dict.keys.contains("ResourceFile") {
            self.resourceFile = dict["ResourceFile"] as! String
        }
        if dict.keys.contains("StorageURL") {
            self.storageURL = dict["StorageURL"] as! String
        }
        if dict.keys.contains("UploadMode") {
            self.uploadMode = dict["UploadMode"] as! Bool
        }
    }
}

public class CreateResourceFileAdvanceRequest : Tea.TeaModel {
    public var content: String?

    public var fileDescription: String?

    public var fileFolderPath: String?

    public var fileName: String?

    public var fileType: Int32?

    public var originResourceName: String?

    public var owner: String?

    public var projectId: Int64?

    public var registerToCalcEngine: Bool?

    public var resourceFileObject: InputStream?

    public var storageURL: String?

    public var uploadMode: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.fileDescription != nil {
            map["FileDescription"] = self.fileDescription!
        }
        if self.fileFolderPath != nil {
            map["FileFolderPath"] = self.fileFolderPath!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileType != nil {
            map["FileType"] = self.fileType!
        }
        if self.originResourceName != nil {
            map["OriginResourceName"] = self.originResourceName!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.registerToCalcEngine != nil {
            map["RegisterToCalcEngine"] = self.registerToCalcEngine!
        }
        if self.resourceFileObject != nil {
            map["ResourceFile"] = self.resourceFileObject!
        }
        if self.storageURL != nil {
            map["StorageURL"] = self.storageURL!
        }
        if self.uploadMode != nil {
            map["UploadMode"] = self.uploadMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("FileDescription") {
            self.fileDescription = dict["FileDescription"] as! String
        }
        if dict.keys.contains("FileFolderPath") {
            self.fileFolderPath = dict["FileFolderPath"] as! String
        }
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileType") {
            self.fileType = dict["FileType"] as! Int32
        }
        if dict.keys.contains("OriginResourceName") {
            self.originResourceName = dict["OriginResourceName"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RegisterToCalcEngine") {
            self.registerToCalcEngine = dict["RegisterToCalcEngine"] as! Bool
        }
        if dict.keys.contains("ResourceFile") {
            self.resourceFileObject = dict["ResourceFile"] as! InputStream
        }
        if dict.keys.contains("StorageURL") {
            self.storageURL = dict["StorageURL"] as! String
        }
        if dict.keys.contains("UploadMode") {
            self.uploadMode = dict["UploadMode"] as! Bool
        }
    }
}

public class CreateResourceFileResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateResourceFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateResourceFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateResourceFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTableRequest : Tea.TeaModel {
    public class Columns : Tea.TeaModel {
        public var columnName: String?

        public var columnNameCn: String?

        public var columnType: String?

        public var comment: String?

        public var isPartitionCol: Bool?

        public var length: Int32?

        public var seqNumber: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columnName != nil {
                map["ColumnName"] = self.columnName!
            }
            if self.columnNameCn != nil {
                map["ColumnNameCn"] = self.columnNameCn!
            }
            if self.columnType != nil {
                map["ColumnType"] = self.columnType!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.isPartitionCol != nil {
                map["IsPartitionCol"] = self.isPartitionCol!
            }
            if self.length != nil {
                map["Length"] = self.length!
            }
            if self.seqNumber != nil {
                map["SeqNumber"] = self.seqNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ColumnName") {
                self.columnName = dict["ColumnName"] as! String
            }
            if dict.keys.contains("ColumnNameCn") {
                self.columnNameCn = dict["ColumnNameCn"] as! String
            }
            if dict.keys.contains("ColumnType") {
                self.columnType = dict["ColumnType"] as! String
            }
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("IsPartitionCol") {
                self.isPartitionCol = dict["IsPartitionCol"] as! Bool
            }
            if dict.keys.contains("Length") {
                self.length = dict["Length"] as! Int32
            }
            if dict.keys.contains("SeqNumber") {
                self.seqNumber = dict["SeqNumber"] as! Int32
            }
        }
    }
    public class Themes : Tea.TeaModel {
        public var themeId: Int64?

        public var themeLevel: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.themeId != nil {
                map["ThemeId"] = self.themeId!
            }
            if self.themeLevel != nil {
                map["ThemeLevel"] = self.themeLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ThemeId") {
                self.themeId = dict["ThemeId"] as! Int64
            }
            if dict.keys.contains("ThemeLevel") {
                self.themeLevel = dict["ThemeLevel"] as! Int32
            }
        }
    }
    public var appGuid: String?

    public var categoryId: Int64?

    public var clientToken: String?

    public var columns: [CreateTableRequest.Columns]?

    public var comment: String?

    public var endpoint: String?

    public var envType: Int32?

    public var externalTableType: String?

    public var hasPart: Int32?

    public var isView: Int32?

    public var lifeCycle: Int32?

    public var location: String?

    public var logicalLevelId: Int64?

    public var ownerId: String?

    public var physicsLevelId: Int64?

    public var projectId: Int64?

    public var schema: String?

    public var tableName: String?

    public var themes: [CreateTableRequest.Themes]?

    public var visibility: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGuid != nil {
            map["AppGuid"] = self.appGuid!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.columns != nil {
            var tmp : [Any] = []
            for k in self.columns! {
                tmp.append(k.toMap())
            }
            map["Columns"] = tmp
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.endpoint != nil {
            map["Endpoint"] = self.endpoint!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.externalTableType != nil {
            map["ExternalTableType"] = self.externalTableType!
        }
        if self.hasPart != nil {
            map["HasPart"] = self.hasPart!
        }
        if self.isView != nil {
            map["IsView"] = self.isView!
        }
        if self.lifeCycle != nil {
            map["LifeCycle"] = self.lifeCycle!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.logicalLevelId != nil {
            map["LogicalLevelId"] = self.logicalLevelId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicsLevelId != nil {
            map["PhysicsLevelId"] = self.physicsLevelId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.themes != nil {
            var tmp : [Any] = []
            for k in self.themes! {
                tmp.append(k.toMap())
            }
            map["Themes"] = tmp
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppGuid") {
            self.appGuid = dict["AppGuid"] as! String
        }
        if dict.keys.contains("CategoryId") {
            self.categoryId = dict["CategoryId"] as! Int64
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Columns") {
            var tmp : [CreateTableRequest.Columns] = []
            for v in dict["Columns"] as! [Any] {
                var model = CreateTableRequest.Columns()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.columns = tmp
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Endpoint") {
            self.endpoint = dict["Endpoint"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! Int32
        }
        if dict.keys.contains("ExternalTableType") {
            self.externalTableType = dict["ExternalTableType"] as! String
        }
        if dict.keys.contains("HasPart") {
            self.hasPart = dict["HasPart"] as! Int32
        }
        if dict.keys.contains("IsView") {
            self.isView = dict["IsView"] as! Int32
        }
        if dict.keys.contains("LifeCycle") {
            self.lifeCycle = dict["LifeCycle"] as! Int32
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("LogicalLevelId") {
            self.logicalLevelId = dict["LogicalLevelId"] as! Int64
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PhysicsLevelId") {
            self.physicsLevelId = dict["PhysicsLevelId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("Schema") {
            self.schema = dict["Schema"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Themes") {
            var tmp : [CreateTableRequest.Themes] = []
            for v in dict["Themes"] as! [Any] {
                var model = CreateTableRequest.Themes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.themes = tmp
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! Int32
        }
    }
}

public class CreateTableResponseBody : Tea.TeaModel {
    public class TaskInfo : Tea.TeaModel {
        public var content: String?

        public var nextTaskId: String?

        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.nextTaskId != nil {
                map["NextTaskId"] = self.nextTaskId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("NextTaskId") {
                self.nextTaskId = dict["NextTaskId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
        }
    }
    public var requestId: String?

    public var taskInfo: CreateTableResponseBody.TaskInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskInfo != nil {
            map["TaskInfo"] = self.taskInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskInfo") {
            var model = CreateTableResponseBody.TaskInfo()
            model.fromMap(dict["TaskInfo"] as! [String: Any])
            self.taskInfo = model
        }
    }
}

public class CreateTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTableLevelRequest : Tea.TeaModel {
    public var description_: String?

    public var levelType: Int32?

    public var name: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.levelType != nil {
            map["LevelType"] = self.levelType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("LevelType") {
            self.levelType = dict["LevelType"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class CreateTableLevelResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var levelId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.levelId != nil {
            map["LevelId"] = self.levelId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("LevelId") {
            self.levelId = dict["LevelId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateTableLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTableLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTableLevelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTableThemeRequest : Tea.TeaModel {
    public var level: Int32?

    public var name: String?

    public var parentId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class CreateTableThemeResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public var themeId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.themeId != nil {
            map["ThemeId"] = self.themeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("ThemeId") {
            self.themeId = dict["ThemeId"] as! Int64
        }
    }
}

public class CreateTableThemeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTableThemeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTableThemeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUdfFileRequest : Tea.TeaModel {
    public var className: String?

    public var cmdDescription: String?

    public var createFolderIfNotExists: Bool?

    public var example: String?

    public var fileFolderPath: String?

    public var fileName: String?

    public var functionType: String?

    public var parameterDescription: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var resources: String?

    public var returnValue: String?

    public var udfDescription: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.className != nil {
            map["ClassName"] = self.className!
        }
        if self.cmdDescription != nil {
            map["CmdDescription"] = self.cmdDescription!
        }
        if self.createFolderIfNotExists != nil {
            map["CreateFolderIfNotExists"] = self.createFolderIfNotExists!
        }
        if self.example != nil {
            map["Example"] = self.example!
        }
        if self.fileFolderPath != nil {
            map["FileFolderPath"] = self.fileFolderPath!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.functionType != nil {
            map["FunctionType"] = self.functionType!
        }
        if self.parameterDescription != nil {
            map["ParameterDescription"] = self.parameterDescription!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.resources != nil {
            map["Resources"] = self.resources!
        }
        if self.returnValue != nil {
            map["ReturnValue"] = self.returnValue!
        }
        if self.udfDescription != nil {
            map["UdfDescription"] = self.udfDescription!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClassName") {
            self.className = dict["ClassName"] as! String
        }
        if dict.keys.contains("CmdDescription") {
            self.cmdDescription = dict["CmdDescription"] as! String
        }
        if dict.keys.contains("CreateFolderIfNotExists") {
            self.createFolderIfNotExists = dict["CreateFolderIfNotExists"] as! Bool
        }
        if dict.keys.contains("Example") {
            self.example = dict["Example"] as! String
        }
        if dict.keys.contains("FileFolderPath") {
            self.fileFolderPath = dict["FileFolderPath"] as! String
        }
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FunctionType") {
            self.functionType = dict["FunctionType"] as! String
        }
        if dict.keys.contains("ParameterDescription") {
            self.parameterDescription = dict["ParameterDescription"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
        if dict.keys.contains("Resources") {
            self.resources = dict["Resources"] as! String
        }
        if dict.keys.contains("ReturnValue") {
            self.returnValue = dict["ReturnValue"] as! String
        }
        if dict.keys.contains("UdfDescription") {
            self.udfDescription = dict["UdfDescription"] as! String
        }
    }
}

public class CreateUdfFileResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateUdfFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUdfFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUdfFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBaselineRequest : Tea.TeaModel {
    public var baselineId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineId") {
            self.baselineId = dict["BaselineId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class DeleteBaselineResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteBaselineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBaselineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteBaselineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBusinessRequest : Tea.TeaModel {
    public var businessId: Int64?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessId != nil {
            map["BusinessId"] = self.businessId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessId") {
            self.businessId = dict["BusinessId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class DeleteBusinessResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteBusinessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBusinessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteBusinessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteConnectionRequest : Tea.TeaModel {
    public var connectionId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionId != nil {
            map["ConnectionId"] = self.connectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConnectionId") {
            self.connectionId = dict["ConnectionId"] as! Int64
        }
    }
}

public class DeleteConnectionResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDIAlarmRuleRequest : Tea.TeaModel {
    public var DIAlarmRuleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIAlarmRuleId") {
            self.DIAlarmRuleId = dict["DIAlarmRuleId"] as! Int64
        }
    }
}

public class DeleteDIAlarmRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDIAlarmRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDIAlarmRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDIAlarmRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDIJobRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
    }
}

public class DeleteDIJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDIJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDISyncTaskRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class DeleteDISyncTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: DeleteDISyncTaskResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DeleteDISyncTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDISyncTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDISyncTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDISyncTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataServiceApiRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class DeleteDataServiceApiResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDataServiceApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataServiceApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataServiceApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataServiceApiAuthorityRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var authorizedProjectId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.authorizedProjectId != nil {
            map["AuthorizedProjectId"] = self.authorizedProjectId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! Int64
        }
        if dict.keys.contains("AuthorizedProjectId") {
            self.authorizedProjectId = dict["AuthorizedProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class DeleteDataServiceApiAuthorityResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDataServiceApiAuthorityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataServiceApiAuthorityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataServiceApiAuthorityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataSourceRequest : Tea.TeaModel {
    public var dataSourceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! Int64
        }
    }
}

public class DeleteDataSourceResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFileRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class DeleteFileResponseBody : Tea.TeaModel {
    public var deploymentId: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentId != nil {
            map["DeploymentId"] = self.deploymentId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeploymentId") {
            self.deploymentId = dict["DeploymentId"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFolderRequest : Tea.TeaModel {
    public var folderId: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FolderId") {
            self.folderId = dict["FolderId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class DeleteFolderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteFolderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFolderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteFolderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFromMetaCategoryRequest : Tea.TeaModel {
    public var categoryId: Int64?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryId") {
            self.categoryId = dict["CategoryId"] as! Int64
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
    }
}

public class DeleteFromMetaCategoryResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteFromMetaCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFromMetaCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteFromMetaCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLineageRelationRequest : Tea.TeaModel {
    public var destEntityQualifiedName: String?

    public var relationshipGuid: String?

    public var relationshipType: String?

    public var srcEntityQualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destEntityQualifiedName != nil {
            map["DestEntityQualifiedName"] = self.destEntityQualifiedName!
        }
        if self.relationshipGuid != nil {
            map["RelationshipGuid"] = self.relationshipGuid!
        }
        if self.relationshipType != nil {
            map["RelationshipType"] = self.relationshipType!
        }
        if self.srcEntityQualifiedName != nil {
            map["SrcEntityQualifiedName"] = self.srcEntityQualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestEntityQualifiedName") {
            self.destEntityQualifiedName = dict["DestEntityQualifiedName"] as! String
        }
        if dict.keys.contains("RelationshipGuid") {
            self.relationshipGuid = dict["RelationshipGuid"] as! String
        }
        if dict.keys.contains("RelationshipType") {
            self.relationshipType = dict["RelationshipType"] as! String
        }
        if dict.keys.contains("SrcEntityQualifiedName") {
            self.srcEntityQualifiedName = dict["SrcEntityQualifiedName"] as! String
        }
    }
}

public class DeleteLineageRelationResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var status: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteLineageRelationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLineageRelationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLineageRelationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMetaCategoryRequest : Tea.TeaModel {
    public var categoryId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryId") {
            self.categoryId = dict["CategoryId"] as! Int64
        }
    }
}

public class DeleteMetaCategoryResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteMetaCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMetaCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMetaCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMetaCollectionRequest : Tea.TeaModel {
    public var qualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QualifiedName") {
            self.qualifiedName = dict["QualifiedName"] as! String
        }
    }
}

public class DeleteMetaCollectionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var status: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteMetaCollectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMetaCollectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMetaCollectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMetaCollectionEntityRequest : Tea.TeaModel {
    public var collectionQualifiedName: String?

    public var entityQualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectionQualifiedName != nil {
            map["CollectionQualifiedName"] = self.collectionQualifiedName!
        }
        if self.entityQualifiedName != nil {
            map["EntityQualifiedName"] = self.entityQualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CollectionQualifiedName") {
            self.collectionQualifiedName = dict["CollectionQualifiedName"] as! String
        }
        if dict.keys.contains("EntityQualifiedName") {
            self.entityQualifiedName = dict["EntityQualifiedName"] as! String
        }
    }
}

public class DeleteMetaCollectionEntityResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var status: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteMetaCollectionEntityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMetaCollectionEntityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMetaCollectionEntityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProjectMemberRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class DeleteProjectMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteProjectMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProjectMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteProjectMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteQualityEntityRequest : Tea.TeaModel {
    public var entityId: Int64?

    public var envType: String?

    public var projectId: Int64?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! Int64
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
    }
}

public class DeleteQualityEntityResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteQualityEntityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteQualityEntityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteQualityEntityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteQualityFollowerRequest : Tea.TeaModel {
    public var followerId: Int64?

    public var projectId: Int64?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.followerId != nil {
            map["FollowerId"] = self.followerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FollowerId") {
            self.followerId = dict["FollowerId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
    }
}

public class DeleteQualityFollowerResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteQualityFollowerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteQualityFollowerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteQualityFollowerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteQualityRelativeNodeRequest : Tea.TeaModel {
    public var envType: String?

    public var matchExpression: String?

    public var nodeId: Int64?

    public var projectId: Int64?

    public var projectName: String?

    public var tableName: String?

    public var targetNodeProjectId: Int64?

    public var targetNodeProjectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.matchExpression != nil {
            map["MatchExpression"] = self.matchExpression!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.targetNodeProjectId != nil {
            map["TargetNodeProjectId"] = self.targetNodeProjectId!
        }
        if self.targetNodeProjectName != nil {
            map["TargetNodeProjectName"] = self.targetNodeProjectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("MatchExpression") {
            self.matchExpression = dict["MatchExpression"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("TargetNodeProjectId") {
            self.targetNodeProjectId = dict["TargetNodeProjectId"] as! Int64
        }
        if dict.keys.contains("TargetNodeProjectName") {
            self.targetNodeProjectName = dict["TargetNodeProjectName"] as! String
        }
    }
}

public class DeleteQualityRelativeNodeResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteQualityRelativeNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteQualityRelativeNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteQualityRelativeNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteQualityRuleRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var projectName: String?

    public var ruleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! Int64
        }
    }
}

public class DeleteQualityRuleResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteQualityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteQualityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteQualityRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRecognizeRuleRequest : Tea.TeaModel {
    public var sensitiveId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sensitiveId != nil {
            map["SensitiveId"] = self.sensitiveId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SensitiveId") {
            self.sensitiveId = dict["SensitiveId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DeleteRecognizeRuleResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteRecognizeRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRecognizeRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRecognizeRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRemindRequest : Tea.TeaModel {
    public var remindId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remindId != nil {
            map["RemindId"] = self.remindId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RemindId") {
            self.remindId = dict["RemindId"] as! Int64
        }
    }
}

public class DeleteRemindResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteRemindResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRemindResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRemindResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTableRequest : Tea.TeaModel {
    public var appGuid: String?

    public var envType: Int32?

    public var projectId: Int64?

    public var schema: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGuid != nil {
            map["AppGuid"] = self.appGuid!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppGuid") {
            self.appGuid = dict["AppGuid"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("Schema") {
            self.schema = dict["Schema"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class DeleteTableResponseBody : Tea.TeaModel {
    public class TaskInfo : Tea.TeaModel {
        public var content: String?

        public var nextTaskId: String?

        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.nextTaskId != nil {
                map["NextTaskId"] = self.nextTaskId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("NextTaskId") {
                self.nextTaskId = dict["NextTaskId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
        }
    }
    public var requestId: String?

    public var taskInfo: DeleteTableResponseBody.TaskInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskInfo != nil {
            map["TaskInfo"] = self.taskInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskInfo") {
            var model = DeleteTableResponseBody.TaskInfo()
            model.fromMap(dict["TaskInfo"] as! [String: Any])
            self.taskInfo = model
        }
    }
}

public class DeleteTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTableLevelRequest : Tea.TeaModel {
    public var levelId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.levelId != nil {
            map["LevelId"] = self.levelId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LevelId") {
            self.levelId = dict["LevelId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class DeleteTableLevelResponseBody : Tea.TeaModel {
    public var deleteResult: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteResult != nil {
            map["DeleteResult"] = self.deleteResult!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteResult") {
            self.deleteResult = dict["DeleteResult"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTableLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTableLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTableLevelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTableThemeRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var themeId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.themeId != nil {
            map["ThemeId"] = self.themeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ThemeId") {
            self.themeId = dict["ThemeId"] as! Int64
        }
    }
}

public class DeleteTableThemeResponseBody : Tea.TeaModel {
    public var deleteResult: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteResult != nil {
            map["DeleteResult"] = self.deleteResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteResult") {
            self.deleteResult = dict["DeleteResult"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteTableThemeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTableThemeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTableThemeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeployDISyncTaskRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class DeployDISyncTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: DeployDISyncTaskResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DeployDISyncTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeployDISyncTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeployDISyncTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeployDISyncTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeployFileRequest : Tea.TeaModel {
    public var comment: String?

    public var fileId: Int64?

    public var nodeId: Int64?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! Int64
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class DeployFileResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeployFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeployFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeployFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DesensitizeDataRequest : Tea.TeaModel {
    public var data: String?

    public var sceneCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.sceneCode != nil {
            map["SceneCode"] = self.sceneCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("SceneCode") {
            self.sceneCode = dict["SceneCode"] as! String
        }
    }
}

public class DesensitizeDataResponseBody : Tea.TeaModel {
    public var desensitizeData: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desensitizeData != nil {
            map["DesensitizeData"] = self.desensitizeData!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesensitizeData") {
            self.desensitizeData = dict["DesensitizeData"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DesensitizeDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DesensitizeDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DesensitizeDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgDesensPlanAddOrUpdateRequest : Tea.TeaModel {
    public class DesensRules : Tea.TeaModel {
        public class DesensPlan : Tea.TeaModel {
            public var desensPlanType: String?

            public var extParam: [String: Any]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.desensPlanType != nil {
                    map["DesensPlanType"] = self.desensPlanType!
                }
                if self.extParam != nil {
                    map["ExtParam"] = self.extParam!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DesensPlanType") {
                    self.desensPlanType = dict["DesensPlanType"] as! String
                }
                if dict.keys.contains("ExtParam") {
                    self.extParam = dict["ExtParam"] as! [String: Any]
                }
            }
        }
        public var checkWatermark: Bool?

        public var dataType: String?

        public var desensPlan: DsgDesensPlanAddOrUpdateRequest.DesensRules.DesensPlan?

        public var id: Int32?

        public var owner: String?

        public var ruleName: String?

        public var sceneIds: [Int32]?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.desensPlan?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkWatermark != nil {
                map["CheckWatermark"] = self.checkWatermark!
            }
            if self.dataType != nil {
                map["DataType"] = self.dataType!
            }
            if self.desensPlan != nil {
                map["DesensPlan"] = self.desensPlan?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.sceneIds != nil {
                map["SceneIds"] = self.sceneIds!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckWatermark") {
                self.checkWatermark = dict["CheckWatermark"] as! Bool
            }
            if dict.keys.contains("DataType") {
                self.dataType = dict["DataType"] as! String
            }
            if dict.keys.contains("DesensPlan") {
                var model = DsgDesensPlanAddOrUpdateRequest.DesensRules.DesensPlan()
                model.fromMap(dict["DesensPlan"] as! [String: Any])
                self.desensPlan = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("RuleName") {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("SceneIds") {
                self.sceneIds = dict["SceneIds"] as! [Int32]
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
        }
    }
    public var desensRules: [DsgDesensPlanAddOrUpdateRequest.DesensRules]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desensRules != nil {
            var tmp : [Any] = []
            for k in self.desensRules! {
                tmp.append(k.toMap())
            }
            map["DesensRules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesensRules") {
            var tmp : [DsgDesensPlanAddOrUpdateRequest.DesensRules] = []
            for v in dict["DesensRules"] as! [Any] {
                var model = DsgDesensPlanAddOrUpdateRequest.DesensRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.desensRules = tmp
        }
    }
}

public class DsgDesensPlanAddOrUpdateShrinkRequest : Tea.TeaModel {
    public var desensRulesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desensRulesShrink != nil {
            map["DesensRules"] = self.desensRulesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesensRules") {
            self.desensRulesShrink = dict["DesensRules"] as! String
        }
    }
}

public class DsgDesensPlanAddOrUpdateResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgDesensPlanAddOrUpdateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgDesensPlanAddOrUpdateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgDesensPlanAddOrUpdateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgDesensPlanDeleteRequest : Tea.TeaModel {
    public var ids: [Int32]?

    public var sceneCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.sceneCode != nil {
            map["SceneCode"] = self.sceneCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! [Int32]
        }
        if dict.keys.contains("SceneCode") {
            self.sceneCode = dict["SceneCode"] as! String
        }
    }
}

public class DsgDesensPlanDeleteShrinkRequest : Tea.TeaModel {
    public var idsShrink: String?

    public var sceneCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        if self.sceneCode != nil {
            map["SceneCode"] = self.sceneCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ids") {
            self.idsShrink = dict["Ids"] as! String
        }
        if dict.keys.contains("SceneCode") {
            self.sceneCode = dict["SceneCode"] as! String
        }
    }
}

public class DsgDesensPlanDeleteResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgDesensPlanDeleteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgDesensPlanDeleteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgDesensPlanDeleteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgDesensPlanQueryListRequest : Tea.TeaModel {
    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var ruleName: String?

    public var sceneId: Int32?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("SceneId") {
            self.sceneId = dict["SceneId"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class DsgDesensPlanQueryListResponseBody : Tea.TeaModel {
    public class PageData : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class DesensPlan : Tea.TeaModel {
                public var desensPlanType: String?

                public var extParam: [String: Any]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.desensPlanType != nil {
                        map["DesensPlanType"] = self.desensPlanType!
                    }
                    if self.extParam != nil {
                        map["ExtParam"] = self.extParam!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DesensPlanType") {
                        self.desensPlanType = dict["DesensPlanType"] as! String
                    }
                    if dict.keys.contains("ExtParam") {
                        self.extParam = dict["ExtParam"] as! [String: Any]
                    }
                }
            }
            public var checkWatermark: Bool?

            public var dataType: String?

            public var desenMode: String?

            public var desensPlan: DsgDesensPlanQueryListResponseBody.PageData.Data.DesensPlan?

            public var desensRule: String?

            public var desensWay: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var owner: String?

            public var ruleName: String?

            public var sceneCode: String?

            public var sceneName: String?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.desensPlan?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkWatermark != nil {
                    map["CheckWatermark"] = self.checkWatermark!
                }
                if self.dataType != nil {
                    map["DataType"] = self.dataType!
                }
                if self.desenMode != nil {
                    map["DesenMode"] = self.desenMode!
                }
                if self.desensPlan != nil {
                    map["DesensPlan"] = self.desensPlan?.toMap()
                }
                if self.desensRule != nil {
                    map["DesensRule"] = self.desensRule!
                }
                if self.desensWay != nil {
                    map["DesensWay"] = self.desensWay!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.sceneCode != nil {
                    map["SceneCode"] = self.sceneCode!
                }
                if self.sceneName != nil {
                    map["SceneName"] = self.sceneName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CheckWatermark") {
                    self.checkWatermark = dict["CheckWatermark"] as! Bool
                }
                if dict.keys.contains("DataType") {
                    self.dataType = dict["DataType"] as! String
                }
                if dict.keys.contains("DesenMode") {
                    self.desenMode = dict["DesenMode"] as! String
                }
                if dict.keys.contains("DesensPlan") {
                    var model = DsgDesensPlanQueryListResponseBody.PageData.Data.DesensPlan()
                    model.fromMap(dict["DesensPlan"] as! [String: Any])
                    self.desensPlan = model
                }
                if dict.keys.contains("DesensRule") {
                    self.desensRule = dict["DesensRule"] as! String
                }
                if dict.keys.contains("DesensWay") {
                    self.desensWay = dict["DesensWay"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("RuleName") {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("SceneCode") {
                    self.sceneCode = dict["SceneCode"] as! String
                }
                if dict.keys.contains("SceneName") {
                    self.sceneName = dict["SceneName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var data: [DsgDesensPlanQueryListResponseBody.PageData.Data]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                var tmp : [Any] = []
                for k in self.data! {
                    tmp.append(k.toMap())
                }
                map["Data"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                var tmp : [DsgDesensPlanQueryListResponseBody.PageData.Data] = []
                for v in dict["Data"] as! [Any] {
                    var model = DsgDesensPlanQueryListResponseBody.PageData.Data()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.data = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var pageData: DsgDesensPlanQueryListResponseBody.PageData?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.pageData != nil {
            map["PageData"] = self.pageData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("PageData") {
            var model = DsgDesensPlanQueryListResponseBody.PageData()
            model.fromMap(dict["PageData"] as! [String: Any])
            self.pageData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgDesensPlanQueryListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgDesensPlanQueryListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgDesensPlanQueryListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgDesensPlanUpdateStatusRequest : Tea.TeaModel {
    public var ids: [Int32]?

    public var sceneCode: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.sceneCode != nil {
            map["SceneCode"] = self.sceneCode!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! [Int32]
        }
        if dict.keys.contains("SceneCode") {
            self.sceneCode = dict["SceneCode"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class DsgDesensPlanUpdateStatusShrinkRequest : Tea.TeaModel {
    public var idsShrink: String?

    public var sceneCode: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        if self.sceneCode != nil {
            map["SceneCode"] = self.sceneCode!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ids") {
            self.idsShrink = dict["Ids"] as! String
        }
        if dict.keys.contains("SceneCode") {
            self.sceneCode = dict["SceneCode"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class DsgDesensPlanUpdateStatusResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgDesensPlanUpdateStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgDesensPlanUpdateStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgDesensPlanUpdateStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgPlatformQueryProjectsAndSchemaFromMetaRequest : Tea.TeaModel {
    public var engineName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engineName != nil {
            map["EngineName"] = self.engineName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EngineName") {
            self.engineName = dict["EngineName"] as! String
        }
    }
}

public class DsgPlatformQueryProjectsAndSchemaFromMetaResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterId: String?

        public var project: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.project != nil {
                map["Project"] = self.project!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("Project") {
                self.project = dict["Project"] as! String
            }
        }
    }
    public var data: [DsgPlatformQueryProjectsAndSchemaFromMetaResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DsgPlatformQueryProjectsAndSchemaFromMetaResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DsgPlatformQueryProjectsAndSchemaFromMetaResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgPlatformQueryProjectsAndSchemaFromMetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgPlatformQueryProjectsAndSchemaFromMetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgPlatformQueryProjectsAndSchemaFromMetaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgQueryDefaultTemplatesRequest : Tea.TeaModel {
    public var sceneId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SceneId") {
            self.sceneId = dict["SceneId"] as! Int32
        }
    }
}

public class DsgQueryDefaultTemplatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dataType: String?

        public var desensPlanTemplate: [String: [DataDesensPlanTemplateValue]]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataType != nil {
                map["DataType"] = self.dataType!
            }
            if self.desensPlanTemplate != nil {
                var tmp : [String: Any] = [:]
                for (k, v) in self.desensPlanTemplate! {
                    var l1 : [Any] = []
                    for k1 in v {
                        l1.append(k1.toMap())
                    }
                    tmp[k] = l1
                }
                map["DesensPlanTemplate"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataType") {
                self.dataType = dict["DataType"] as! String
            }
            if dict.keys.contains("DesensPlanTemplate") {
                var tmp : [String: [DataDesensPlanTemplateValue]] = [:]
                for (k, v) in dict["DesensPlanTemplate"] as! [String: Any] {
                    var l1 : [DataDesensPlanTemplateValue] = []
                    for v1 in v as! [Any] {
                        var model = DataDesensPlanTemplateValue()
                        if v1 != nil {
                            model.fromMap(v1 as! [String: Any])
                        }
                        l1.append(model)
                    }
                    tmp[k] = l1
                }
                self.desensPlanTemplate = tmp
            }
        }
    }
    public var data: [DsgQueryDefaultTemplatesResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DsgQueryDefaultTemplatesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DsgQueryDefaultTemplatesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgQueryDefaultTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgQueryDefaultTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgQueryDefaultTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgQuerySensResultRequest : Tea.TeaModel {
    public var col: String?

    public var dbType: String?

    public var level: String?

    public var nodeName: String?

    public var order: String?

    public var orderField: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var projectName: String?

    public var schemaName: String?

    public var sensStatus: String?

    public var sensitiveId: String?

    public var sensitiveName: String?

    public var table: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.col != nil {
            map["Col"] = self.col!
        }
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.orderField != nil {
            map["OrderField"] = self.orderField!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.sensStatus != nil {
            map["SensStatus"] = self.sensStatus!
        }
        if self.sensitiveId != nil {
            map["SensitiveId"] = self.sensitiveId!
        }
        if self.sensitiveName != nil {
            map["SensitiveName"] = self.sensitiveName!
        }
        if self.table != nil {
            map["Table"] = self.table!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Col") {
            self.col = dict["Col"] as! String
        }
        if dict.keys.contains("DbType") {
            self.dbType = dict["DbType"] as! String
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("NodeName") {
            self.nodeName = dict["NodeName"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("OrderField") {
            self.orderField = dict["OrderField"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("SchemaName") {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("SensStatus") {
            self.sensStatus = dict["SensStatus"] as! String
        }
        if dict.keys.contains("SensitiveId") {
            self.sensitiveId = dict["SensitiveId"] as! String
        }
        if dict.keys.contains("SensitiveName") {
            self.sensitiveName = dict["SensitiveName"] as! String
        }
        if dict.keys.contains("Table") {
            self.table = dict["Table"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DsgQuerySensResultResponseBody : Tea.TeaModel {
    public var data: Any?

    public var dynamicErrorCode: String?

    public var dynamicErrorMessage: String?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicErrorCode != nil {
            map["DynamicErrorCode"] = self.dynamicErrorCode!
        }
        if self.dynamicErrorMessage != nil {
            map["DynamicErrorMessage"] = self.dynamicErrorMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("DynamicErrorCode") {
            self.dynamicErrorCode = dict["DynamicErrorCode"] as! String
        }
        if dict.keys.contains("DynamicErrorMessage") {
            self.dynamicErrorMessage = dict["DynamicErrorMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgQuerySensResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgQuerySensResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgQuerySensResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgRunSensIdentifyRequest : Tea.TeaModel {
    public class EsMetaParams : Tea.TeaModel {
        public var clusterId: String?

        public var dbType: String?

        public var instanceId: Int64?

        public var projectName: String?

        public var schemaName: String?

        public var tableName: String?

        public var tableNameList: [String]?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.tableNameList != nil {
                map["TableNameList"] = self.tableNameList!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("DbType") {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
            if dict.keys.contains("SchemaName") {
                self.schemaName = dict["SchemaName"] as! String
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
            if dict.keys.contains("TableNameList") {
                self.tableNameList = dict["TableNameList"] as! [String]
            }
            if dict.keys.contains("User") {
                self.user = dict["User"] as! String
            }
        }
    }
    public var esMetaParams: [DsgRunSensIdentifyRequest.EsMetaParams]?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.esMetaParams != nil {
            var tmp : [Any] = []
            for k in self.esMetaParams! {
                tmp.append(k.toMap())
            }
            map["EsMetaParams"] = tmp
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EsMetaParams") {
            var tmp : [DsgRunSensIdentifyRequest.EsMetaParams] = []
            for v in dict["EsMetaParams"] as! [Any] {
                var model = DsgRunSensIdentifyRequest.EsMetaParams()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.esMetaParams = tmp
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DsgRunSensIdentifyShrinkRequest : Tea.TeaModel {
    public var esMetaParamsShrink: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.esMetaParamsShrink != nil {
            map["EsMetaParams"] = self.esMetaParamsShrink!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EsMetaParams") {
            self.esMetaParamsShrink = dict["EsMetaParams"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DsgRunSensIdentifyResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgRunSensIdentifyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgRunSensIdentifyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgRunSensIdentifyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgSceneAddOrUpdateSceneRequest : Tea.TeaModel {
    public class Scenes : Tea.TeaModel {
        public class Projects : Tea.TeaModel {
            public var clusterId: String?

            public var dbType: String?

            public var projectName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["clusterId"] = self.clusterId!
                }
                if self.dbType != nil {
                    map["dbType"] = self.dbType!
                }
                if self.projectName != nil {
                    map["projectName"] = self.projectName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("clusterId") {
                    self.clusterId = dict["clusterId"] as! String
                }
                if dict.keys.contains("dbType") {
                    self.dbType = dict["dbType"] as! String
                }
                if dict.keys.contains("projectName") {
                    self.projectName = dict["projectName"] as! String
                }
            }
        }
        public var desc: String?

        public var id: String?

        public var projects: [DsgSceneAddOrUpdateSceneRequest.Scenes.Projects]?

        public var sceneCode: String?

        public var sceneName: String?

        public var userGroupIds: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desc != nil {
                map["desc"] = self.desc!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.projects != nil {
                var tmp : [Any] = []
                for k in self.projects! {
                    tmp.append(k.toMap())
                }
                map["projects"] = tmp
            }
            if self.sceneCode != nil {
                map["sceneCode"] = self.sceneCode!
            }
            if self.sceneName != nil {
                map["sceneName"] = self.sceneName!
            }
            if self.userGroupIds != nil {
                map["userGroupIds"] = self.userGroupIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("desc") {
                self.desc = dict["desc"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("projects") {
                var tmp : [DsgSceneAddOrUpdateSceneRequest.Scenes.Projects] = []
                for v in dict["projects"] as! [Any] {
                    var model = DsgSceneAddOrUpdateSceneRequest.Scenes.Projects()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.projects = tmp
            }
            if dict.keys.contains("sceneCode") {
                self.sceneCode = dict["sceneCode"] as! String
            }
            if dict.keys.contains("sceneName") {
                self.sceneName = dict["sceneName"] as! String
            }
            if dict.keys.contains("userGroupIds") {
                self.userGroupIds = dict["userGroupIds"] as! [Int64]
            }
        }
    }
    public var scenes: [DsgSceneAddOrUpdateSceneRequest.Scenes]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scenes != nil {
            var tmp : [Any] = []
            for k in self.scenes! {
                tmp.append(k.toMap())
            }
            map["scenes"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("scenes") {
            var tmp : [DsgSceneAddOrUpdateSceneRequest.Scenes] = []
            for v in dict["scenes"] as! [Any] {
                var model = DsgSceneAddOrUpdateSceneRequest.Scenes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scenes = tmp
        }
    }
}

public class DsgSceneAddOrUpdateSceneShrinkRequest : Tea.TeaModel {
    public var scenesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scenesShrink != nil {
            map["scenes"] = self.scenesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("scenes") {
            self.scenesShrink = dict["scenes"] as! String
        }
    }
}

public class DsgSceneAddOrUpdateSceneResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgSceneAddOrUpdateSceneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgSceneAddOrUpdateSceneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgSceneAddOrUpdateSceneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgSceneQuerySceneListByNameRequest : Tea.TeaModel {
    public var sceneName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sceneName != nil {
            map["SceneName"] = self.sceneName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SceneName") {
            self.sceneName = dict["SceneName"] as! String
        }
    }
}

public class DsgSceneQuerySceneListByNameResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Projects : Tea.TeaModel {
            public var clusterId: String?

            public var dbType: String?

            public var projectName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("DbType") {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("ProjectName") {
                    self.projectName = dict["ProjectName"] as! String
                }
            }
        }
        public var children: [Any]?

        public var desc: String?

        public var id: Int64?

        public var projects: [DsgSceneQuerySceneListByNameResponseBody.Data.Projects]?

        public var sceneCode: String?

        public var sceneLevel: Int32?

        public var sceneName: String?

        public var userGroups: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.children != nil {
                map["Children"] = self.children!
            }
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.projects != nil {
                var tmp : [Any] = []
                for k in self.projects! {
                    tmp.append(k.toMap())
                }
                map["Projects"] = tmp
            }
            if self.sceneCode != nil {
                map["SceneCode"] = self.sceneCode!
            }
            if self.sceneLevel != nil {
                map["SceneLevel"] = self.sceneLevel!
            }
            if self.sceneName != nil {
                map["SceneName"] = self.sceneName!
            }
            if self.userGroups != nil {
                map["UserGroups"] = self.userGroups!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Children") {
                self.children = dict["Children"] as! [Any]
            }
            if dict.keys.contains("Desc") {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Projects") {
                var tmp : [DsgSceneQuerySceneListByNameResponseBody.Data.Projects] = []
                for v in dict["Projects"] as! [Any] {
                    var model = DsgSceneQuerySceneListByNameResponseBody.Data.Projects()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.projects = tmp
            }
            if dict.keys.contains("SceneCode") {
                self.sceneCode = dict["SceneCode"] as! String
            }
            if dict.keys.contains("SceneLevel") {
                self.sceneLevel = dict["SceneLevel"] as! Int32
            }
            if dict.keys.contains("SceneName") {
                self.sceneName = dict["SceneName"] as! String
            }
            if dict.keys.contains("UserGroups") {
                self.userGroups = dict["UserGroups"] as! String
            }
        }
    }
    public var data: [DsgSceneQuerySceneListByNameResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DsgSceneQuerySceneListByNameResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DsgSceneQuerySceneListByNameResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgSceneQuerySceneListByNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgSceneQuerySceneListByNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgSceneQuerySceneListByNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgScenedDeleteSceneRequest : Tea.TeaModel {
    public var ids: [Int32]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! [Int32]
        }
    }
}

public class DsgScenedDeleteSceneShrinkRequest : Tea.TeaModel {
    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ids") {
            self.idsShrink = dict["Ids"] as! String
        }
    }
}

public class DsgScenedDeleteSceneResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgScenedDeleteSceneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgScenedDeleteSceneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgScenedDeleteSceneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgStopSensIdentifyRequest : Tea.TeaModel {
    public var jobId: Int64?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DsgStopSensIdentifyResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgStopSensIdentifyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgStopSensIdentifyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgStopSensIdentifyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgUserGroupAddOrUpdateRequest : Tea.TeaModel {
    public class UserGroups : Tea.TeaModel {
        public var accounts: [String]?

        public var id: Int64?

        public var name: String?

        public var owner: String?

        public var projectName: String?

        public var userGroupType: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accounts != nil {
                map["Accounts"] = self.accounts!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.userGroupType != nil {
                map["UserGroupType"] = self.userGroupType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Accounts") {
                self.accounts = dict["Accounts"] as! [String]
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
            if dict.keys.contains("UserGroupType") {
                self.userGroupType = dict["UserGroupType"] as! Int32
            }
        }
    }
    public var userGroups: [DsgUserGroupAddOrUpdateRequest.UserGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.userGroups != nil {
            var tmp : [Any] = []
            for k in self.userGroups! {
                tmp.append(k.toMap())
            }
            map["UserGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("UserGroups") {
            var tmp : [DsgUserGroupAddOrUpdateRequest.UserGroups] = []
            for v in dict["UserGroups"] as! [Any] {
                var model = DsgUserGroupAddOrUpdateRequest.UserGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.userGroups = tmp
        }
    }
}

public class DsgUserGroupAddOrUpdateShrinkRequest : Tea.TeaModel {
    public var userGroupsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.userGroupsShrink != nil {
            map["UserGroups"] = self.userGroupsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("UserGroups") {
            self.userGroupsShrink = dict["UserGroups"] as! String
        }
    }
}

public class DsgUserGroupAddOrUpdateResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgUserGroupAddOrUpdateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgUserGroupAddOrUpdateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgUserGroupAddOrUpdateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgUserGroupDeleteRequest : Tea.TeaModel {
    public var ids: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! [Int64]
        }
    }
}

public class DsgUserGroupDeleteShrinkRequest : Tea.TeaModel {
    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ids") {
            self.idsShrink = dict["Ids"] as! String
        }
    }
}

public class DsgUserGroupDeleteResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgUserGroupDeleteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgUserGroupDeleteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgUserGroupDeleteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgUserGroupGetOdpsRoleGroupsRequest : Tea.TeaModel {
    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
    }
}

public class DsgUserGroupGetOdpsRoleGroupsResponseBody : Tea.TeaModel {
    public var data: [String]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgUserGroupGetOdpsRoleGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgUserGroupGetOdpsRoleGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgUserGroupGetOdpsRoleGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgUserGroupQueryListRequest : Tea.TeaModel {
    public var name: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
    }
}

public class DsgUserGroupQueryListResponseBody : Tea.TeaModel {
    public class PageData : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public var accounts: [String]?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int32?

            public var name: String?

            public var owner: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accounts != nil {
                    map["Accounts"] = self.accounts!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Accounts") {
                    self.accounts = dict["Accounts"] as! [String]
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
            }
        }
        public var data: [DsgUserGroupQueryListResponseBody.PageData.Data]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                var tmp : [Any] = []
                for k in self.data! {
                    tmp.append(k.toMap())
                }
                map["Data"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                var tmp : [DsgUserGroupQueryListResponseBody.PageData.Data] = []
                for v in dict["Data"] as! [Any] {
                    var model = DsgUserGroupQueryListResponseBody.PageData.Data()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.data = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var pageData: DsgUserGroupQueryListResponseBody.PageData?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.pageData != nil {
            map["PageData"] = self.pageData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("PageData") {
            var model = DsgUserGroupQueryListResponseBody.PageData()
            model.fromMap(dict["PageData"] as! [String: Any])
            self.pageData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgUserGroupQueryListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgUserGroupQueryListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgUserGroupQueryListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgUserGroupQueryUserListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accountName: String?

        public var accountType: Int32?

        public var baseId: String?

        public var parentAccountId: String?

        public var yunAccount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountName != nil {
                map["AccountName"] = self.accountName!
            }
            if self.accountType != nil {
                map["AccountType"] = self.accountType!
            }
            if self.baseId != nil {
                map["BaseId"] = self.baseId!
            }
            if self.parentAccountId != nil {
                map["ParentAccountId"] = self.parentAccountId!
            }
            if self.yunAccount != nil {
                map["YunAccount"] = self.yunAccount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountName") {
                self.accountName = dict["AccountName"] as! String
            }
            if dict.keys.contains("AccountType") {
                self.accountType = dict["AccountType"] as! Int32
            }
            if dict.keys.contains("BaseId") {
                self.baseId = dict["BaseId"] as! String
            }
            if dict.keys.contains("ParentAccountId") {
                self.parentAccountId = dict["ParentAccountId"] as! String
            }
            if dict.keys.contains("YunAccount") {
                self.yunAccount = dict["YunAccount"] as! String
            }
        }
    }
    public var data: [DsgUserGroupQueryUserListResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DsgUserGroupQueryUserListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DsgUserGroupQueryUserListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgUserGroupQueryUserListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgUserGroupQueryUserListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgUserGroupQueryUserListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgWhiteListAddOrUpdateRequest : Tea.TeaModel {
    public class WhiteLists : Tea.TeaModel {
        public var endTime: String?

        public var id: Int32?

        public var ruleId: Int32?

        public var startTime: String?

        public var userGroupIds: [Int32]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.userGroupIds != nil {
                map["UserGroupIds"] = self.userGroupIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("RuleId") {
                self.ruleId = dict["RuleId"] as! Int32
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("UserGroupIds") {
                self.userGroupIds = dict["UserGroupIds"] as! [Int32]
            }
        }
    }
    public var whiteLists: [DsgWhiteListAddOrUpdateRequest.WhiteLists]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.whiteLists != nil {
            var tmp : [Any] = []
            for k in self.whiteLists! {
                tmp.append(k.toMap())
            }
            map["WhiteLists"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WhiteLists") {
            var tmp : [DsgWhiteListAddOrUpdateRequest.WhiteLists] = []
            for v in dict["WhiteLists"] as! [Any] {
                var model = DsgWhiteListAddOrUpdateRequest.WhiteLists()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.whiteLists = tmp
        }
    }
}

public class DsgWhiteListAddOrUpdateShrinkRequest : Tea.TeaModel {
    public var whiteListsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.whiteListsShrink != nil {
            map["WhiteLists"] = self.whiteListsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WhiteLists") {
            self.whiteListsShrink = dict["WhiteLists"] as! String
        }
    }
}

public class DsgWhiteListAddOrUpdateResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgWhiteListAddOrUpdateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgWhiteListAddOrUpdateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgWhiteListAddOrUpdateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgWhiteListDeleteListRequest : Tea.TeaModel {
    public var ids: [Int32]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! [Int32]
        }
    }
}

public class DsgWhiteListDeleteListShrinkRequest : Tea.TeaModel {
    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ids") {
            self.idsShrink = dict["Ids"] as! String
        }
    }
}

public class DsgWhiteListDeleteListResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgWhiteListDeleteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgWhiteListDeleteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgWhiteListDeleteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DsgWhiteListQueryListRequest : Tea.TeaModel {
    public var dataType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var sceneId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataType != nil {
            map["DataType"] = self.dataType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataType") {
            self.dataType = dict["DataType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SceneId") {
            self.sceneId = dict["SceneId"] as! Int64
        }
    }
}

public class DsgWhiteListQueryListResponseBody : Tea.TeaModel {
    public class PageData : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public var endTime: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var ruleId: Int64?

            public var sceneId: Int64?

            public var startTime: String?

            public var type: String?

            public var userGroups: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.sceneId != nil {
                    map["SceneId"] = self.sceneId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.userGroups != nil {
                    map["UserGroups"] = self.userGroups!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("RuleId") {
                    self.ruleId = dict["RuleId"] as! Int64
                }
                if dict.keys.contains("SceneId") {
                    self.sceneId = dict["SceneId"] as! Int64
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UserGroups") {
                    self.userGroups = dict["UserGroups"] as! [String]
                }
            }
        }
        public var data: [DsgWhiteListQueryListResponseBody.PageData.Data]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                var tmp : [Any] = []
                for k in self.data! {
                    tmp.append(k.toMap())
                }
                map["Data"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                var tmp : [DsgWhiteListQueryListResponseBody.PageData.Data] = []
                for v in dict["Data"] as! [Any] {
                    var model = DsgWhiteListQueryListResponseBody.PageData.Data()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.data = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var pageData: DsgWhiteListQueryListResponseBody.PageData?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.pageData != nil {
            map["PageData"] = self.pageData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("PageData") {
            var model = DsgWhiteListQueryListResponseBody.PageData()
            model.fromMap(dict["PageData"] as! [String: Any])
            self.pageData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DsgWhiteListQueryListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgWhiteListQueryListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DsgWhiteListQueryListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EditRecognizeRuleRequest : Tea.TeaModel {
    public var accountName: String?

    public var colExclude: String?

    public var colScan: String?

    public var commentScan: String?

    public var contentScan: String?

    public var hitThreshold: Int32?

    public var levelName: String?

    public var nodeId: String?

    public var nodeParent: String?

    public var operationType: Int32?

    public var recognizeRules: String?

    public var recognizeRulesType: String?

    public var sensitiveDescription: String?

    public var sensitiveId: String?

    public var sensitiveName: String?

    public var status: Int32?

    public var templateId: String?

    public var tenantId: String?

    public var level: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.colExclude != nil {
            map["ColExclude"] = self.colExclude!
        }
        if self.colScan != nil {
            map["ColScan"] = self.colScan!
        }
        if self.commentScan != nil {
            map["CommentScan"] = self.commentScan!
        }
        if self.contentScan != nil {
            map["ContentScan"] = self.contentScan!
        }
        if self.hitThreshold != nil {
            map["HitThreshold"] = self.hitThreshold!
        }
        if self.levelName != nil {
            map["LevelName"] = self.levelName!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeParent != nil {
            map["NodeParent"] = self.nodeParent!
        }
        if self.operationType != nil {
            map["OperationType"] = self.operationType!
        }
        if self.recognizeRules != nil {
            map["RecognizeRules"] = self.recognizeRules!
        }
        if self.recognizeRulesType != nil {
            map["RecognizeRulesType"] = self.recognizeRulesType!
        }
        if self.sensitiveDescription != nil {
            map["SensitiveDescription"] = self.sensitiveDescription!
        }
        if self.sensitiveId != nil {
            map["SensitiveId"] = self.sensitiveId!
        }
        if self.sensitiveName != nil {
            map["SensitiveName"] = self.sensitiveName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.level != nil {
            map["level"] = self.level!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountName") {
            self.accountName = dict["AccountName"] as! String
        }
        if dict.keys.contains("ColExclude") {
            self.colExclude = dict["ColExclude"] as! String
        }
        if dict.keys.contains("ColScan") {
            self.colScan = dict["ColScan"] as! String
        }
        if dict.keys.contains("CommentScan") {
            self.commentScan = dict["CommentScan"] as! String
        }
        if dict.keys.contains("ContentScan") {
            self.contentScan = dict["ContentScan"] as! String
        }
        if dict.keys.contains("HitThreshold") {
            self.hitThreshold = dict["HitThreshold"] as! Int32
        }
        if dict.keys.contains("LevelName") {
            self.levelName = dict["LevelName"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("NodeParent") {
            self.nodeParent = dict["NodeParent"] as! String
        }
        if dict.keys.contains("OperationType") {
            self.operationType = dict["OperationType"] as! Int32
        }
        if dict.keys.contains("RecognizeRules") {
            self.recognizeRules = dict["RecognizeRules"] as! String
        }
        if dict.keys.contains("RecognizeRulesType") {
            self.recognizeRulesType = dict["RecognizeRulesType"] as! String
        }
        if dict.keys.contains("SensitiveDescription") {
            self.sensitiveDescription = dict["SensitiveDescription"] as! String
        }
        if dict.keys.contains("SensitiveId") {
            self.sensitiveId = dict["SensitiveId"] as! String
        }
        if dict.keys.contains("SensitiveName") {
            self.sensitiveName = dict["SensitiveName"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("level") {
            self.level = dict["level"] as! String
        }
    }
}

public class EditRecognizeRuleResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EditRecognizeRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EditRecognizeRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EditRecognizeRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EstablishRelationTableToBusinessRequest : Tea.TeaModel {
    public var businessId: String?

    public var folderId: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessId != nil {
            map["BusinessId"] = self.businessId!
        }
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessId") {
            self.businessId = dict["BusinessId"] as! String
        }
        if dict.keys.contains("FolderId") {
            self.folderId = dict["FolderId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
    }
}

public class EstablishRelationTableToBusinessResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EstablishRelationTableToBusinessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EstablishRelationTableToBusinessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EstablishRelationTableToBusinessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportDataSourcesRequest : Tea.TeaModel {
    public var dataSourceType: String?

    public var envType: Int32?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var subType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.subType != nil {
            map["SubType"] = self.subType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SubType") {
            self.subType = dict["SubType"] as! String
        }
    }
}

public class ExportDataSourcesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataSources : Tea.TeaModel {
            public var bindingCalcEngineId: Int32?

            public var connectStatus: Int32?

            public var content: String?

            public var dataSourceType: String?

            public var defaultEngine: Bool?

            public var description_: String?

            public var envType: Int32?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int32?

            public var name: String?

            public var operator_: String?

            public var projectId: Int32?

            public var sequence: Int32?

            public var shared: Bool?

            public var status: Int32?

            public var subType: String?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindingCalcEngineId != nil {
                    map["BindingCalcEngineId"] = self.bindingCalcEngineId!
                }
                if self.connectStatus != nil {
                    map["ConnectStatus"] = self.connectStatus!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.dataSourceType != nil {
                    map["DataSourceType"] = self.dataSourceType!
                }
                if self.defaultEngine != nil {
                    map["DefaultEngine"] = self.defaultEngine!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.sequence != nil {
                    map["Sequence"] = self.sequence!
                }
                if self.shared != nil {
                    map["Shared"] = self.shared!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.subType != nil {
                    map["SubType"] = self.subType!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BindingCalcEngineId") {
                    self.bindingCalcEngineId = dict["BindingCalcEngineId"] as! Int32
                }
                if dict.keys.contains("ConnectStatus") {
                    self.connectStatus = dict["ConnectStatus"] as! Int32
                }
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("DataSourceType") {
                    self.dataSourceType = dict["DataSourceType"] as! String
                }
                if dict.keys.contains("DefaultEngine") {
                    self.defaultEngine = dict["DefaultEngine"] as! Bool
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! Int32
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Operator") {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int32
                }
                if dict.keys.contains("Sequence") {
                    self.sequence = dict["Sequence"] as! Int32
                }
                if dict.keys.contains("Shared") {
                    self.shared = dict["Shared"] as! Bool
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("SubType") {
                    self.subType = dict["SubType"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
            }
        }
        public var dataSources: [ExportDataSourcesResponseBody.Data.DataSources]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSources != nil {
                var tmp : [Any] = []
                for k in self.dataSources! {
                    tmp.append(k.toMap())
                }
                map["DataSources"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataSources") {
                var tmp : [ExportDataSourcesResponseBody.Data.DataSources] = []
                for v in dict["DataSources"] as! [Any] {
                    var model = ExportDataSourcesResponseBody.Data.DataSources()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataSources = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ExportDataSourcesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ExportDataSourcesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ExportDataSourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportDataSourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportDataSourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GenerateDISyncTaskConfigForCreatingRequest : Tea.TeaModel {
    public var clientToken: String?

    public var projectId: Int64?

    public var taskParam: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskParam != nil {
            map["TaskParam"] = self.taskParam!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TaskParam") {
            self.taskParam = dict["TaskParam"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class GenerateDISyncTaskConfigForCreatingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var processId: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.processId != nil {
                map["ProcessId"] = self.processId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ProcessId") {
                self.processId = dict["ProcessId"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: GenerateDISyncTaskConfigForCreatingResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GenerateDISyncTaskConfigForCreatingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GenerateDISyncTaskConfigForCreatingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateDISyncTaskConfigForCreatingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GenerateDISyncTaskConfigForCreatingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GenerateDISyncTaskConfigForUpdatingRequest : Tea.TeaModel {
    public var clientToken: String?

    public var projectId: Int64?

    public var taskId: Int64?

    public var taskParam: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskParam != nil {
            map["TaskParam"] = self.taskParam!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
        if dict.keys.contains("TaskParam") {
            self.taskParam = dict["TaskParam"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class GenerateDISyncTaskConfigForUpdatingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var processId: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.processId != nil {
                map["ProcessId"] = self.processId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ProcessId") {
                self.processId = dict["ProcessId"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: GenerateDISyncTaskConfigForUpdatingResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GenerateDISyncTaskConfigForUpdatingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GenerateDISyncTaskConfigForUpdatingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateDISyncTaskConfigForUpdatingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GenerateDISyncTaskConfigForUpdatingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAlertMessageRequest : Tea.TeaModel {
    public var alertId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") {
            self.alertId = dict["AlertId"] as! String
        }
    }
}

public class GetAlertMessageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Instances : Tea.TeaModel {
            public var instanceId: Int64?

            public var nodeId: Int64?

            public var nodeName: String?

            public var projectId: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Nodes : Tea.TeaModel {
            public var nodeId: Int64?

            public var nodeName: String?

            public var owner: String?

            public var projectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
            }
        }
        public class SlaAlert : Tea.TeaModel {
            public var baselineId: Int64?

            public var baselineName: String?

            public var baselineOwner: String?

            public var bizdate: Int64?

            public var inGroupId: Int32?

            public var projectId: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.baselineName != nil {
                    map["BaselineName"] = self.baselineName!
                }
                if self.baselineOwner != nil {
                    map["BaselineOwner"] = self.baselineOwner!
                }
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.inGroupId != nil {
                    map["InGroupId"] = self.inGroupId!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("BaselineName") {
                    self.baselineName = dict["BaselineName"] as! String
                }
                if dict.keys.contains("BaselineOwner") {
                    self.baselineOwner = dict["BaselineOwner"] as! String
                }
                if dict.keys.contains("Bizdate") {
                    self.bizdate = dict["Bizdate"] as! Int64
                }
                if dict.keys.contains("InGroupId") {
                    self.inGroupId = dict["InGroupId"] as! Int32
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Topics : Tea.TeaModel {
            public var instanceId: Int64?

            public var nodeId: Int64?

            public var topicId: Int64?

            public var topicName: String?

            public var topicOwner: String?

            public var topicStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.topicId != nil {
                    map["TopicId"] = self.topicId!
                }
                if self.topicName != nil {
                    map["TopicName"] = self.topicName!
                }
                if self.topicOwner != nil {
                    map["TopicOwner"] = self.topicOwner!
                }
                if self.topicStatus != nil {
                    map["TopicStatus"] = self.topicStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("TopicId") {
                    self.topicId = dict["TopicId"] as! Int64
                }
                if dict.keys.contains("TopicName") {
                    self.topicName = dict["TopicName"] as! String
                }
                if dict.keys.contains("TopicOwner") {
                    self.topicOwner = dict["TopicOwner"] as! String
                }
                if dict.keys.contains("TopicStatus") {
                    self.topicStatus = dict["TopicStatus"] as! String
                }
            }
        }
        public var alertId: Int64?

        public var alertMessageStatus: String?

        public var alertMethod: String?

        public var alertTime: Int64?

        public var alertUser: String?

        public var content: String?

        public var instances: [GetAlertMessageResponseBody.Data.Instances]?

        public var nodes: [GetAlertMessageResponseBody.Data.Nodes]?

        public var remindId: Int64?

        public var remindName: String?

        public var slaAlert: GetAlertMessageResponseBody.Data.SlaAlert?

        public var source: String?

        public var topics: [GetAlertMessageResponseBody.Data.Topics]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.slaAlert?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertId != nil {
                map["AlertId"] = self.alertId!
            }
            if self.alertMessageStatus != nil {
                map["AlertMessageStatus"] = self.alertMessageStatus!
            }
            if self.alertMethod != nil {
                map["AlertMethod"] = self.alertMethod!
            }
            if self.alertTime != nil {
                map["AlertTime"] = self.alertTime!
            }
            if self.alertUser != nil {
                map["AlertUser"] = self.alertUser!
            }
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.instances != nil {
                var tmp : [Any] = []
                for k in self.instances! {
                    tmp.append(k.toMap())
                }
                map["Instances"] = tmp
            }
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            if self.remindId != nil {
                map["RemindId"] = self.remindId!
            }
            if self.remindName != nil {
                map["RemindName"] = self.remindName!
            }
            if self.slaAlert != nil {
                map["SlaAlert"] = self.slaAlert?.toMap()
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.topics != nil {
                var tmp : [Any] = []
                for k in self.topics! {
                    tmp.append(k.toMap())
                }
                map["Topics"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertId") {
                self.alertId = dict["AlertId"] as! Int64
            }
            if dict.keys.contains("AlertMessageStatus") {
                self.alertMessageStatus = dict["AlertMessageStatus"] as! String
            }
            if dict.keys.contains("AlertMethod") {
                self.alertMethod = dict["AlertMethod"] as! String
            }
            if dict.keys.contains("AlertTime") {
                self.alertTime = dict["AlertTime"] as! Int64
            }
            if dict.keys.contains("AlertUser") {
                self.alertUser = dict["AlertUser"] as! String
            }
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("Instances") {
                var tmp : [GetAlertMessageResponseBody.Data.Instances] = []
                for v in dict["Instances"] as! [Any] {
                    var model = GetAlertMessageResponseBody.Data.Instances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instances = tmp
            }
            if dict.keys.contains("Nodes") {
                var tmp : [GetAlertMessageResponseBody.Data.Nodes] = []
                for v in dict["Nodes"] as! [Any] {
                    var model = GetAlertMessageResponseBody.Data.Nodes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodes = tmp
            }
            if dict.keys.contains("RemindId") {
                self.remindId = dict["RemindId"] as! Int64
            }
            if dict.keys.contains("RemindName") {
                self.remindName = dict["RemindName"] as! String
            }
            if dict.keys.contains("SlaAlert") {
                var model = GetAlertMessageResponseBody.Data.SlaAlert()
                model.fromMap(dict["SlaAlert"] as! [String: Any])
                self.slaAlert = model
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Topics") {
                var tmp : [GetAlertMessageResponseBody.Data.Topics] = []
                for v in dict["Topics"] as! [Any] {
                    var model = GetAlertMessageResponseBody.Data.Topics()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.topics = tmp
            }
        }
    }
    public var data: GetAlertMessageResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetAlertMessageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAlertMessageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAlertMessageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAlertMessageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBaselineRequest : Tea.TeaModel {
    public var baselineId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineId") {
            self.baselineId = dict["BaselineId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class GetBaselineResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AlertSettings : Tea.TeaModel {
            public class DingRobots : Tea.TeaModel {
                public var atAll: Bool?

                public var webUrl: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.atAll != nil {
                        map["AtAll"] = self.atAll!
                    }
                    if self.webUrl != nil {
                        map["WebUrl"] = self.webUrl!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AtAll") {
                        self.atAll = dict["AtAll"] as! Bool
                    }
                    if dict.keys.contains("WebUrl") {
                        self.webUrl = dict["WebUrl"] as! String
                    }
                }
            }
            public var alertInterval: Int32?

            public var alertMaximum: Int32?

            public var alertMethods: [String]?

            public var alertRecipient: String?

            public var alertRecipientType: String?

            public var alertType: String?

            public var baselineAlertEnabled: Bool?

            public var dingRobots: [GetBaselineResponseBody.Data.AlertSettings.DingRobots]?

            public var silenceEndTime: String?

            public var silenceStartTime: String?

            public var topicTypes: [String]?

            public var webhooks: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertInterval != nil {
                    map["AlertInterval"] = self.alertInterval!
                }
                if self.alertMaximum != nil {
                    map["AlertMaximum"] = self.alertMaximum!
                }
                if self.alertMethods != nil {
                    map["AlertMethods"] = self.alertMethods!
                }
                if self.alertRecipient != nil {
                    map["AlertRecipient"] = self.alertRecipient!
                }
                if self.alertRecipientType != nil {
                    map["AlertRecipientType"] = self.alertRecipientType!
                }
                if self.alertType != nil {
                    map["AlertType"] = self.alertType!
                }
                if self.baselineAlertEnabled != nil {
                    map["BaselineAlertEnabled"] = self.baselineAlertEnabled!
                }
                if self.dingRobots != nil {
                    var tmp : [Any] = []
                    for k in self.dingRobots! {
                        tmp.append(k.toMap())
                    }
                    map["DingRobots"] = tmp
                }
                if self.silenceEndTime != nil {
                    map["SilenceEndTime"] = self.silenceEndTime!
                }
                if self.silenceStartTime != nil {
                    map["SilenceStartTime"] = self.silenceStartTime!
                }
                if self.topicTypes != nil {
                    map["TopicTypes"] = self.topicTypes!
                }
                if self.webhooks != nil {
                    map["Webhooks"] = self.webhooks!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertInterval") {
                    self.alertInterval = dict["AlertInterval"] as! Int32
                }
                if dict.keys.contains("AlertMaximum") {
                    self.alertMaximum = dict["AlertMaximum"] as! Int32
                }
                if dict.keys.contains("AlertMethods") {
                    self.alertMethods = dict["AlertMethods"] as! [String]
                }
                if dict.keys.contains("AlertRecipient") {
                    self.alertRecipient = dict["AlertRecipient"] as! String
                }
                if dict.keys.contains("AlertRecipientType") {
                    self.alertRecipientType = dict["AlertRecipientType"] as! String
                }
                if dict.keys.contains("AlertType") {
                    self.alertType = dict["AlertType"] as! String
                }
                if dict.keys.contains("BaselineAlertEnabled") {
                    self.baselineAlertEnabled = dict["BaselineAlertEnabled"] as! Bool
                }
                if dict.keys.contains("DingRobots") {
                    var tmp : [GetBaselineResponseBody.Data.AlertSettings.DingRobots] = []
                    for v in dict["DingRobots"] as! [Any] {
                        var model = GetBaselineResponseBody.Data.AlertSettings.DingRobots()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.dingRobots = tmp
                }
                if dict.keys.contains("SilenceEndTime") {
                    self.silenceEndTime = dict["SilenceEndTime"] as! String
                }
                if dict.keys.contains("SilenceStartTime") {
                    self.silenceStartTime = dict["SilenceStartTime"] as! String
                }
                if dict.keys.contains("TopicTypes") {
                    self.topicTypes = dict["TopicTypes"] as! [String]
                }
                if dict.keys.contains("Webhooks") {
                    self.webhooks = dict["Webhooks"] as! [String]
                }
            }
        }
        public class OverTimeSettings : Tea.TeaModel {
            public var cycle: Int32?

            public var time: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycle != nil {
                    map["Cycle"] = self.cycle!
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cycle") {
                    self.cycle = dict["Cycle"] as! Int32
                }
                if dict.keys.contains("Time") {
                    self.time = dict["Time"] as! String
                }
            }
        }
        public var alertEnabled: Bool?

        public var alertMarginThreshold: Int32?

        public var alertSettings: [GetBaselineResponseBody.Data.AlertSettings]?

        public var baselineId: Int64?

        public var baselineName: String?

        public var baselineType: String?

        public var enabled: Bool?

        public var nodeIds: [Int64]?

        public var overTimeSettings: [GetBaselineResponseBody.Data.OverTimeSettings]?

        public var owner: String?

        public var priority: Int32?

        public var projectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertEnabled != nil {
                map["AlertEnabled"] = self.alertEnabled!
            }
            if self.alertMarginThreshold != nil {
                map["AlertMarginThreshold"] = self.alertMarginThreshold!
            }
            if self.alertSettings != nil {
                var tmp : [Any] = []
                for k in self.alertSettings! {
                    tmp.append(k.toMap())
                }
                map["AlertSettings"] = tmp
            }
            if self.baselineId != nil {
                map["BaselineId"] = self.baselineId!
            }
            if self.baselineName != nil {
                map["BaselineName"] = self.baselineName!
            }
            if self.baselineType != nil {
                map["BaselineType"] = self.baselineType!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.nodeIds != nil {
                map["NodeIds"] = self.nodeIds!
            }
            if self.overTimeSettings != nil {
                var tmp : [Any] = []
                for k in self.overTimeSettings! {
                    tmp.append(k.toMap())
                }
                map["OverTimeSettings"] = tmp
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertEnabled") {
                self.alertEnabled = dict["AlertEnabled"] as! Bool
            }
            if dict.keys.contains("AlertMarginThreshold") {
                self.alertMarginThreshold = dict["AlertMarginThreshold"] as! Int32
            }
            if dict.keys.contains("AlertSettings") {
                var tmp : [GetBaselineResponseBody.Data.AlertSettings] = []
                for v in dict["AlertSettings"] as! [Any] {
                    var model = GetBaselineResponseBody.Data.AlertSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertSettings = tmp
            }
            if dict.keys.contains("BaselineId") {
                self.baselineId = dict["BaselineId"] as! Int64
            }
            if dict.keys.contains("BaselineName") {
                self.baselineName = dict["BaselineName"] as! String
            }
            if dict.keys.contains("BaselineType") {
                self.baselineType = dict["BaselineType"] as! String
            }
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
            if dict.keys.contains("NodeIds") {
                self.nodeIds = dict["NodeIds"] as! [Int64]
            }
            if dict.keys.contains("OverTimeSettings") {
                var tmp : [GetBaselineResponseBody.Data.OverTimeSettings] = []
                for v in dict["OverTimeSettings"] as! [Any] {
                    var model = GetBaselineResponseBody.Data.OverTimeSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.overTimeSettings = tmp
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
        }
    }
    public var data: GetBaselineResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetBaselineResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetBaselineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBaselineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBaselineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBaselineConfigRequest : Tea.TeaModel {
    public var baselineId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineId") {
            self.baselineId = dict["BaselineId"] as! Int64
        }
    }
}

public class GetBaselineConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var baselineId: Int64?

        public var baselineName: String?

        public var baselineType: String?

        public var expHour: Int32?

        public var expMinu: Int32?

        public var hourExpDetail: String?

        public var hourSlaDetail: String?

        public var isDefault: Bool?

        public var owner: String?

        public var priority: Int32?

        public var projectId: Int64?

        public var slaHour: Int32?

        public var slaMinu: Int32?

        public var useFlag: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineId != nil {
                map["BaselineId"] = self.baselineId!
            }
            if self.baselineName != nil {
                map["BaselineName"] = self.baselineName!
            }
            if self.baselineType != nil {
                map["BaselineType"] = self.baselineType!
            }
            if self.expHour != nil {
                map["ExpHour"] = self.expHour!
            }
            if self.expMinu != nil {
                map["ExpMinu"] = self.expMinu!
            }
            if self.hourExpDetail != nil {
                map["HourExpDetail"] = self.hourExpDetail!
            }
            if self.hourSlaDetail != nil {
                map["HourSlaDetail"] = self.hourSlaDetail!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.slaHour != nil {
                map["SlaHour"] = self.slaHour!
            }
            if self.slaMinu != nil {
                map["SlaMinu"] = self.slaMinu!
            }
            if self.useFlag != nil {
                map["UseFlag"] = self.useFlag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BaselineId") {
                self.baselineId = dict["BaselineId"] as! Int64
            }
            if dict.keys.contains("BaselineName") {
                self.baselineName = dict["BaselineName"] as! String
            }
            if dict.keys.contains("BaselineType") {
                self.baselineType = dict["BaselineType"] as! String
            }
            if dict.keys.contains("ExpHour") {
                self.expHour = dict["ExpHour"] as! Int32
            }
            if dict.keys.contains("ExpMinu") {
                self.expMinu = dict["ExpMinu"] as! Int32
            }
            if dict.keys.contains("HourExpDetail") {
                self.hourExpDetail = dict["HourExpDetail"] as! String
            }
            if dict.keys.contains("HourSlaDetail") {
                self.hourSlaDetail = dict["HourSlaDetail"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("SlaHour") {
                self.slaHour = dict["SlaHour"] as! Int32
            }
            if dict.keys.contains("SlaMinu") {
                self.slaMinu = dict["SlaMinu"] as! Int32
            }
            if dict.keys.contains("UseFlag") {
                self.useFlag = dict["UseFlag"] as! Bool
            }
        }
    }
    public var data: GetBaselineConfigResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetBaselineConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetBaselineConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBaselineConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBaselineConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBaselineKeyPathRequest : Tea.TeaModel {
    public var baselineId: Int64?

    public var bizdate: String?

    public var inGroupId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.inGroupId != nil {
            map["InGroupId"] = self.inGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineId") {
            self.baselineId = dict["BaselineId"] as! Int64
        }
        if dict.keys.contains("Bizdate") {
            self.bizdate = dict["Bizdate"] as! String
        }
        if dict.keys.contains("InGroupId") {
            self.inGroupId = dict["InGroupId"] as! Int32
        }
    }
}

public class GetBaselineKeyPathResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Runs : Tea.TeaModel {
            public var absTime: Int64?

            public var beginCast: Int64?

            public var beginRunningTime: Int64?

            public var beginWaitResTime: Int64?

            public var beginWaitTimeTime: Int64?

            public var endCast: Int64?

            public var finishTime: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.absTime != nil {
                    map["AbsTime"] = self.absTime!
                }
                if self.beginCast != nil {
                    map["BeginCast"] = self.beginCast!
                }
                if self.beginRunningTime != nil {
                    map["BeginRunningTime"] = self.beginRunningTime!
                }
                if self.beginWaitResTime != nil {
                    map["BeginWaitResTime"] = self.beginWaitResTime!
                }
                if self.beginWaitTimeTime != nil {
                    map["BeginWaitTimeTime"] = self.beginWaitTimeTime!
                }
                if self.endCast != nil {
                    map["EndCast"] = self.endCast!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbsTime") {
                    self.absTime = dict["AbsTime"] as! Int64
                }
                if dict.keys.contains("BeginCast") {
                    self.beginCast = dict["BeginCast"] as! Int64
                }
                if dict.keys.contains("BeginRunningTime") {
                    self.beginRunningTime = dict["BeginRunningTime"] as! Int64
                }
                if dict.keys.contains("BeginWaitResTime") {
                    self.beginWaitResTime = dict["BeginWaitResTime"] as! Int64
                }
                if dict.keys.contains("BeginWaitTimeTime") {
                    self.beginWaitTimeTime = dict["BeginWaitTimeTime"] as! Int64
                }
                if dict.keys.contains("EndCast") {
                    self.endCast = dict["EndCast"] as! Int64
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Topics : Tea.TeaModel {
            public var addTime: Int64?

            public var instanceId: Int64?

            public var topicId: Int64?

            public var topicName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addTime != nil {
                    map["AddTime"] = self.addTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.topicId != nil {
                    map["TopicId"] = self.topicId!
                }
                if self.topicName != nil {
                    map["TopicName"] = self.topicName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddTime") {
                    self.addTime = dict["AddTime"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("TopicId") {
                    self.topicId = dict["TopicId"] as! Int64
                }
                if dict.keys.contains("TopicName") {
                    self.topicName = dict["TopicName"] as! String
                }
            }
        }
        public var bizdate: Int64?

        public var inGroupId: Int32?

        public var instanceId: Int64?

        public var nodeId: Int64?

        public var nodeName: String?

        public var owner: String?

        public var prgType: Int32?

        public var projectId: Int64?

        public var runs: [GetBaselineKeyPathResponseBody.Data.Runs]?

        public var topics: [GetBaselineKeyPathResponseBody.Data.Topics]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizdate != nil {
                map["Bizdate"] = self.bizdate!
            }
            if self.inGroupId != nil {
                map["InGroupId"] = self.inGroupId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.prgType != nil {
                map["PrgType"] = self.prgType!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.runs != nil {
                var tmp : [Any] = []
                for k in self.runs! {
                    tmp.append(k.toMap())
                }
                map["Runs"] = tmp
            }
            if self.topics != nil {
                var tmp : [Any] = []
                for k in self.topics! {
                    tmp.append(k.toMap())
                }
                map["Topics"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bizdate") {
                self.bizdate = dict["Bizdate"] as! Int64
            }
            if dict.keys.contains("InGroupId") {
                self.inGroupId = dict["InGroupId"] as! Int32
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! Int64
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("PrgType") {
                self.prgType = dict["PrgType"] as! Int32
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("Runs") {
                var tmp : [GetBaselineKeyPathResponseBody.Data.Runs] = []
                for v in dict["Runs"] as! [Any] {
                    var model = GetBaselineKeyPathResponseBody.Data.Runs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.runs = tmp
            }
            if dict.keys.contains("Topics") {
                var tmp : [GetBaselineKeyPathResponseBody.Data.Topics] = []
                for v in dict["Topics"] as! [Any] {
                    var model = GetBaselineKeyPathResponseBody.Data.Topics()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.topics = tmp
            }
        }
    }
    public var data: [GetBaselineKeyPathResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [GetBaselineKeyPathResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetBaselineKeyPathResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetBaselineKeyPathResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBaselineKeyPathResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBaselineKeyPathResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBaselineStatusRequest : Tea.TeaModel {
    public var baselineId: Int64?

    public var bizdate: String?

    public var inGroupId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.inGroupId != nil {
            map["InGroupId"] = self.inGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineId") {
            self.baselineId = dict["BaselineId"] as! Int64
        }
        if dict.keys.contains("Bizdate") {
            self.bizdate = dict["Bizdate"] as! String
        }
        if dict.keys.contains("InGroupId") {
            self.inGroupId = dict["InGroupId"] as! Int32
        }
    }
}

public class GetBaselineStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BlockInstance : Tea.TeaModel {
            public var endCast: Int64?

            public var finishTime: Int64?

            public var instanceId: Int64?

            public var nodeId: Int64?

            public var nodeName: String?

            public var owner: String?

            public var projectId: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endCast != nil {
                    map["EndCast"] = self.endCast!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndCast") {
                    self.endCast = dict["EndCast"] as! Int64
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class LastInstance : Tea.TeaModel {
            public var endCast: Int64?

            public var finishTime: Int64?

            public var instanceId: Int64?

            public var nodeId: Int64?

            public var nodeName: String?

            public var owner: String?

            public var projectId: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endCast != nil {
                    map["EndCast"] = self.endCast!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndCast") {
                    self.endCast = dict["EndCast"] as! Int64
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var baselineId: Int64?

        public var baselineName: String?

        public var bizdate: Int64?

        public var blockInstance: GetBaselineStatusResponseBody.Data.BlockInstance?

        public var buffer: Double?

        public var endCast: Int64?

        public var expTime: Int64?

        public var finishStatus: String?

        public var finishTime: Int64?

        public var inGroupId: Int32?

        public var lastInstance: GetBaselineStatusResponseBody.Data.LastInstance?

        public var owner: String?

        public var priority: Int32?

        public var projectId: Int64?

        public var slaTime: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.blockInstance?.validate()
            try self.lastInstance?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineId != nil {
                map["BaselineId"] = self.baselineId!
            }
            if self.baselineName != nil {
                map["BaselineName"] = self.baselineName!
            }
            if self.bizdate != nil {
                map["Bizdate"] = self.bizdate!
            }
            if self.blockInstance != nil {
                map["BlockInstance"] = self.blockInstance?.toMap()
            }
            if self.buffer != nil {
                map["Buffer"] = self.buffer!
            }
            if self.endCast != nil {
                map["EndCast"] = self.endCast!
            }
            if self.expTime != nil {
                map["ExpTime"] = self.expTime!
            }
            if self.finishStatus != nil {
                map["FinishStatus"] = self.finishStatus!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inGroupId != nil {
                map["InGroupId"] = self.inGroupId!
            }
            if self.lastInstance != nil {
                map["LastInstance"] = self.lastInstance?.toMap()
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.slaTime != nil {
                map["SlaTime"] = self.slaTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BaselineId") {
                self.baselineId = dict["BaselineId"] as! Int64
            }
            if dict.keys.contains("BaselineName") {
                self.baselineName = dict["BaselineName"] as! String
            }
            if dict.keys.contains("Bizdate") {
                self.bizdate = dict["Bizdate"] as! Int64
            }
            if dict.keys.contains("BlockInstance") {
                var model = GetBaselineStatusResponseBody.Data.BlockInstance()
                model.fromMap(dict["BlockInstance"] as! [String: Any])
                self.blockInstance = model
            }
            if dict.keys.contains("Buffer") {
                self.buffer = dict["Buffer"] as! Double
            }
            if dict.keys.contains("EndCast") {
                self.endCast = dict["EndCast"] as! Int64
            }
            if dict.keys.contains("ExpTime") {
                self.expTime = dict["ExpTime"] as! Int64
            }
            if dict.keys.contains("FinishStatus") {
                self.finishStatus = dict["FinishStatus"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! Int64
            }
            if dict.keys.contains("InGroupId") {
                self.inGroupId = dict["InGroupId"] as! Int32
            }
            if dict.keys.contains("LastInstance") {
                var model = GetBaselineStatusResponseBody.Data.LastInstance()
                model.fromMap(dict["LastInstance"] as! [String: Any])
                self.lastInstance = model
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("SlaTime") {
                self.slaTime = dict["SlaTime"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: GetBaselineStatusResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetBaselineStatusResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetBaselineStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBaselineStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBaselineStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBusinessRequest : Tea.TeaModel {
    public var businessId: Int64?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessId != nil {
            map["BusinessId"] = self.businessId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessId") {
            self.businessId = dict["BusinessId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class GetBusinessResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var businessId: Int64?

        public var businessName: String?

        public var description_: String?

        public var owner: String?

        public var projectId: String?

        public var useType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessId != nil {
                map["BusinessId"] = self.businessId!
            }
            if self.businessName != nil {
                map["BusinessName"] = self.businessName!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.useType != nil {
                map["UseType"] = self.useType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BusinessId") {
                self.businessId = dict["BusinessId"] as! Int64
            }
            if dict.keys.contains("BusinessName") {
                self.businessName = dict["BusinessName"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("UseType") {
                self.useType = dict["UseType"] as! String
            }
        }
    }
    public var data: GetBusinessResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetBusinessResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetBusinessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBusinessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBusinessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDDLJobStatusRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetDDLJobStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var content: String?

        public var nextTaskId: String?

        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.nextTaskId != nil {
                map["NextTaskId"] = self.nextTaskId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("NextTaskId") {
                self.nextTaskId = dict["NextTaskId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
        }
    }
    public var data: GetDDLJobStatusResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDDLJobStatusResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDDLJobStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDDLJobStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDDLJobStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDIAlarmRuleRequest : Tea.TeaModel {
    public var DIAlarmRuleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIAlarmRuleId") {
            self.DIAlarmRuleId = dict["DIAlarmRuleId"] as! Int64
        }
    }
}

public class GetDIAlarmRuleResponseBody : Tea.TeaModel {
    public class DIAlarmRule : Tea.TeaModel {
        public class NotificationSettings : Tea.TeaModel {
            public class NotificationChannels : Tea.TeaModel {
                public var channels: [String]?

                public var severity: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.severity != nil {
                        map["Severity"] = self.severity!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! [String]
                    }
                    if dict.keys.contains("Severity") {
                        self.severity = dict["Severity"] as! String
                    }
                }
            }
            public class NotificationReceivers : Tea.TeaModel {
                public var receiverType: String?

                public var receiverValues: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.receiverType != nil {
                        map["ReceiverType"] = self.receiverType!
                    }
                    if self.receiverValues != nil {
                        map["ReceiverValues"] = self.receiverValues!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ReceiverType") {
                        self.receiverType = dict["ReceiverType"] as! String
                    }
                    if dict.keys.contains("ReceiverValues") {
                        self.receiverValues = dict["ReceiverValues"] as! [String]
                    }
                }
            }
            public var inhibitionInterval: Int32?

            public var notificationChannels: [GetDIAlarmRuleResponseBody.DIAlarmRule.NotificationSettings.NotificationChannels]?

            public var notificationReceivers: [GetDIAlarmRuleResponseBody.DIAlarmRule.NotificationSettings.NotificationReceivers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inhibitionInterval != nil {
                    map["InhibitionInterval"] = self.inhibitionInterval!
                }
                if self.notificationChannels != nil {
                    var tmp : [Any] = []
                    for k in self.notificationChannels! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationChannels"] = tmp
                }
                if self.notificationReceivers != nil {
                    var tmp : [Any] = []
                    for k in self.notificationReceivers! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationReceivers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InhibitionInterval") {
                    self.inhibitionInterval = dict["InhibitionInterval"] as! Int32
                }
                if dict.keys.contains("NotificationChannels") {
                    var tmp : [GetDIAlarmRuleResponseBody.DIAlarmRule.NotificationSettings.NotificationChannels] = []
                    for v in dict["NotificationChannels"] as! [Any] {
                        var model = GetDIAlarmRuleResponseBody.DIAlarmRule.NotificationSettings.NotificationChannels()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.notificationChannels = tmp
                }
                if dict.keys.contains("NotificationReceivers") {
                    var tmp : [GetDIAlarmRuleResponseBody.DIAlarmRule.NotificationSettings.NotificationReceivers] = []
                    for v in dict["NotificationReceivers"] as! [Any] {
                        var model = GetDIAlarmRuleResponseBody.DIAlarmRule.NotificationSettings.NotificationReceivers()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.notificationReceivers = tmp
                }
            }
        }
        public class TriggerConditions : Tea.TeaModel {
            public var duration: Int64?

            public var severity: String?

            public var threshold: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int64
                }
                if dict.keys.contains("Severity") {
                    self.severity = dict["Severity"] as! String
                }
                if dict.keys.contains("Threshold") {
                    self.threshold = dict["Threshold"] as! Int64
                }
            }
        }
        public var createdTime: Int64?

        public var createdUid: String?

        public var DIAlarmRuleId: Int64?

        public var DIJobId: Int64?

        public var description_: String?

        public var enabled: Bool?

        public var metricType: String?

        public var notificationSettings: GetDIAlarmRuleResponseBody.DIAlarmRule.NotificationSettings?

        public var triggerConditions: [GetDIAlarmRuleResponseBody.DIAlarmRule.TriggerConditions]?

        public var updatedTime: Int64?

        public var updatedUid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.notificationSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.createdUid != nil {
                map["CreatedUid"] = self.createdUid!
            }
            if self.DIAlarmRuleId != nil {
                map["DIAlarmRuleId"] = self.DIAlarmRuleId!
            }
            if self.DIJobId != nil {
                map["DIJobId"] = self.DIJobId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.metricType != nil {
                map["MetricType"] = self.metricType!
            }
            if self.notificationSettings != nil {
                map["NotificationSettings"] = self.notificationSettings?.toMap()
            }
            if self.triggerConditions != nil {
                var tmp : [Any] = []
                for k in self.triggerConditions! {
                    tmp.append(k.toMap())
                }
                map["TriggerConditions"] = tmp
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            if self.updatedUid != nil {
                map["UpdatedUid"] = self.updatedUid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! Int64
            }
            if dict.keys.contains("CreatedUid") {
                self.createdUid = dict["CreatedUid"] as! String
            }
            if dict.keys.contains("DIAlarmRuleId") {
                self.DIAlarmRuleId = dict["DIAlarmRuleId"] as! Int64
            }
            if dict.keys.contains("DIJobId") {
                self.DIJobId = dict["DIJobId"] as! Int64
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
            if dict.keys.contains("MetricType") {
                self.metricType = dict["MetricType"] as! String
            }
            if dict.keys.contains("NotificationSettings") {
                var model = GetDIAlarmRuleResponseBody.DIAlarmRule.NotificationSettings()
                model.fromMap(dict["NotificationSettings"] as! [String: Any])
                self.notificationSettings = model
            }
            if dict.keys.contains("TriggerConditions") {
                var tmp : [GetDIAlarmRuleResponseBody.DIAlarmRule.TriggerConditions] = []
                for v in dict["TriggerConditions"] as! [Any] {
                    var model = GetDIAlarmRuleResponseBody.DIAlarmRule.TriggerConditions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.triggerConditions = tmp
            }
            if dict.keys.contains("UpdatedTime") {
                self.updatedTime = dict["UpdatedTime"] as! Int64
            }
            if dict.keys.contains("UpdatedUid") {
                self.updatedUid = dict["UpdatedUid"] as! String
            }
        }
    }
    public var DIAlarmRule: GetDIAlarmRuleResponseBody.DIAlarmRule?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DIAlarmRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRule != nil {
            map["DIAlarmRule"] = self.DIAlarmRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIAlarmRule") {
            var model = GetDIAlarmRuleResponseBody.DIAlarmRule()
            model.fromMap(dict["DIAlarmRule"] as! [String: Any])
            self.DIAlarmRule = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDIAlarmRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDIAlarmRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDIAlarmRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDIJobRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var withDetails: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.withDetails != nil {
            map["WithDetails"] = self.withDetails!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("WithDetails") {
            self.withDetails = dict["WithDetails"] as! Bool
        }
    }
}

public class GetDIJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DestinationDataSourceSettings : Tea.TeaModel {
            public var dataSourceName: String?

            public var dataSourceProperties: [String: String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSourceName != nil {
                    map["DataSourceName"] = self.dataSourceName!
                }
                if self.dataSourceProperties != nil {
                    map["DataSourceProperties"] = self.dataSourceProperties!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataSourceName") {
                    self.dataSourceName = dict["DataSourceName"] as! String
                }
                if dict.keys.contains("DataSourceProperties") {
                    self.dataSourceProperties = dict["DataSourceProperties"] as! [String: String]
                }
            }
        }
        public class JobSettings : Tea.TeaModel {
            public class ColumnDataTypeSettings : Tea.TeaModel {
                public var destinationDataType: String?

                public var sourceDataType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.destinationDataType != nil {
                        map["DestinationDataType"] = self.destinationDataType!
                    }
                    if self.sourceDataType != nil {
                        map["SourceDataType"] = self.sourceDataType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DestinationDataType") {
                        self.destinationDataType = dict["DestinationDataType"] as! String
                    }
                    if dict.keys.contains("SourceDataType") {
                        self.sourceDataType = dict["SourceDataType"] as! String
                    }
                }
            }
            public class CycleScheduleSettings : Tea.TeaModel {
                public var cycleMigrationType: String?

                public var scheduleParameters: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cycleMigrationType != nil {
                        map["CycleMigrationType"] = self.cycleMigrationType!
                    }
                    if self.scheduleParameters != nil {
                        map["ScheduleParameters"] = self.scheduleParameters!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CycleMigrationType") {
                        self.cycleMigrationType = dict["CycleMigrationType"] as! String
                    }
                    if dict.keys.contains("ScheduleParameters") {
                        self.scheduleParameters = dict["ScheduleParameters"] as! String
                    }
                }
            }
            public class DdlHandlingSettings : Tea.TeaModel {
                public var action: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.action != nil {
                        map["Action"] = self.action!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Action") {
                        self.action = dict["Action"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class RuntimeSettings : Tea.TeaModel {
                public var name: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var channelSettings: String?

            public var columnDataTypeSettings: [GetDIJobResponseBody.Data.JobSettings.ColumnDataTypeSettings]?

            public var cycleScheduleSettings: GetDIJobResponseBody.Data.JobSettings.CycleScheduleSettings?

            public var ddlHandlingSettings: [GetDIJobResponseBody.Data.JobSettings.DdlHandlingSettings]?

            public var runtimeSettings: [GetDIJobResponseBody.Data.JobSettings.RuntimeSettings]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cycleScheduleSettings?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelSettings != nil {
                    map["ChannelSettings"] = self.channelSettings!
                }
                if self.columnDataTypeSettings != nil {
                    var tmp : [Any] = []
                    for k in self.columnDataTypeSettings! {
                        tmp.append(k.toMap())
                    }
                    map["ColumnDataTypeSettings"] = tmp
                }
                if self.cycleScheduleSettings != nil {
                    map["CycleScheduleSettings"] = self.cycleScheduleSettings?.toMap()
                }
                if self.ddlHandlingSettings != nil {
                    var tmp : [Any] = []
                    for k in self.ddlHandlingSettings! {
                        tmp.append(k.toMap())
                    }
                    map["DdlHandlingSettings"] = tmp
                }
                if self.runtimeSettings != nil {
                    var tmp : [Any] = []
                    for k in self.runtimeSettings! {
                        tmp.append(k.toMap())
                    }
                    map["RuntimeSettings"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelSettings") {
                    self.channelSettings = dict["ChannelSettings"] as! String
                }
                if dict.keys.contains("ColumnDataTypeSettings") {
                    var tmp : [GetDIJobResponseBody.Data.JobSettings.ColumnDataTypeSettings] = []
                    for v in dict["ColumnDataTypeSettings"] as! [Any] {
                        var model = GetDIJobResponseBody.Data.JobSettings.ColumnDataTypeSettings()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.columnDataTypeSettings = tmp
                }
                if dict.keys.contains("CycleScheduleSettings") {
                    var model = GetDIJobResponseBody.Data.JobSettings.CycleScheduleSettings()
                    model.fromMap(dict["CycleScheduleSettings"] as! [String: Any])
                    self.cycleScheduleSettings = model
                }
                if dict.keys.contains("DdlHandlingSettings") {
                    var tmp : [GetDIJobResponseBody.Data.JobSettings.DdlHandlingSettings] = []
                    for v in dict["DdlHandlingSettings"] as! [Any] {
                        var model = GetDIJobResponseBody.Data.JobSettings.DdlHandlingSettings()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ddlHandlingSettings = tmp
                }
                if dict.keys.contains("RuntimeSettings") {
                    var tmp : [GetDIJobResponseBody.Data.JobSettings.RuntimeSettings] = []
                    for v in dict["RuntimeSettings"] as! [Any] {
                        var model = GetDIJobResponseBody.Data.JobSettings.RuntimeSettings()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.runtimeSettings = tmp
                }
            }
        }
        public class ResourceSettings : Tea.TeaModel {
            public class OfflineResourceSettings : Tea.TeaModel {
                public var resourceGroupIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceGroupIdentifier != nil {
                        map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ResourceGroupIdentifier") {
                        self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
                    }
                }
            }
            public class RealtimeResourceSettings : Tea.TeaModel {
                public var resourceGroupIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceGroupIdentifier != nil {
                        map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ResourceGroupIdentifier") {
                        self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
                    }
                }
            }
            public var offlineResourceSettings: GetDIJobResponseBody.Data.ResourceSettings.OfflineResourceSettings?

            public var realtimeResourceSettings: GetDIJobResponseBody.Data.ResourceSettings.RealtimeResourceSettings?

            public var requestedCu: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.offlineResourceSettings?.validate()
                try self.realtimeResourceSettings?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.offlineResourceSettings != nil {
                    map["OfflineResourceSettings"] = self.offlineResourceSettings?.toMap()
                }
                if self.realtimeResourceSettings != nil {
                    map["RealtimeResourceSettings"] = self.realtimeResourceSettings?.toMap()
                }
                if self.requestedCu != nil {
                    map["RequestedCu"] = self.requestedCu!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OfflineResourceSettings") {
                    var model = GetDIJobResponseBody.Data.ResourceSettings.OfflineResourceSettings()
                    model.fromMap(dict["OfflineResourceSettings"] as! [String: Any])
                    self.offlineResourceSettings = model
                }
                if dict.keys.contains("RealtimeResourceSettings") {
                    var model = GetDIJobResponseBody.Data.ResourceSettings.RealtimeResourceSettings()
                    model.fromMap(dict["RealtimeResourceSettings"] as! [String: Any])
                    self.realtimeResourceSettings = model
                }
                if dict.keys.contains("RequestedCu") {
                    self.requestedCu = dict["RequestedCu"] as! Double
                }
            }
        }
        public class SourceDataSourceSettings : Tea.TeaModel {
            public var dataSourceName: String?

            public var dataSourceProperties: [String: String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSourceName != nil {
                    map["DataSourceName"] = self.dataSourceName!
                }
                if self.dataSourceProperties != nil {
                    map["DataSourceProperties"] = self.dataSourceProperties!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataSourceName") {
                    self.dataSourceName = dict["DataSourceName"] as! String
                }
                if dict.keys.contains("DataSourceProperties") {
                    self.dataSourceProperties = dict["DataSourceProperties"] as! [String: String]
                }
            }
        }
        public class TableMappings : Tea.TeaModel {
            public class SourceObjectSelectionRules : Tea.TeaModel {
                public var expression: String?

                public var objectType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.objectType != nil {
                        map["ObjectType"] = self.objectType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Expression") {
                        self.expression = dict["Expression"] as! String
                    }
                    if dict.keys.contains("ObjectType") {
                        self.objectType = dict["ObjectType"] as! String
                    }
                }
            }
            public class TransformationRules : Tea.TeaModel {
                public var ruleActionType: String?

                public var ruleName: String?

                public var ruleTargetType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ruleActionType != nil {
                        map["RuleActionType"] = self.ruleActionType!
                    }
                    if self.ruleName != nil {
                        map["RuleName"] = self.ruleName!
                    }
                    if self.ruleTargetType != nil {
                        map["RuleTargetType"] = self.ruleTargetType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RuleActionType") {
                        self.ruleActionType = dict["RuleActionType"] as! String
                    }
                    if dict.keys.contains("RuleName") {
                        self.ruleName = dict["RuleName"] as! String
                    }
                    if dict.keys.contains("RuleTargetType") {
                        self.ruleTargetType = dict["RuleTargetType"] as! String
                    }
                }
            }
            public var sourceObjectSelectionRules: [GetDIJobResponseBody.Data.TableMappings.SourceObjectSelectionRules]?

            public var transformationRules: [GetDIJobResponseBody.Data.TableMappings.TransformationRules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sourceObjectSelectionRules != nil {
                    var tmp : [Any] = []
                    for k in self.sourceObjectSelectionRules! {
                        tmp.append(k.toMap())
                    }
                    map["SourceObjectSelectionRules"] = tmp
                }
                if self.transformationRules != nil {
                    var tmp : [Any] = []
                    for k in self.transformationRules! {
                        tmp.append(k.toMap())
                    }
                    map["TransformationRules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SourceObjectSelectionRules") {
                    var tmp : [GetDIJobResponseBody.Data.TableMappings.SourceObjectSelectionRules] = []
                    for v in dict["SourceObjectSelectionRules"] as! [Any] {
                        var model = GetDIJobResponseBody.Data.TableMappings.SourceObjectSelectionRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.sourceObjectSelectionRules = tmp
                }
                if dict.keys.contains("TransformationRules") {
                    var tmp : [GetDIJobResponseBody.Data.TableMappings.TransformationRules] = []
                    for v in dict["TransformationRules"] as! [Any] {
                        var model = GetDIJobResponseBody.Data.TableMappings.TransformationRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.transformationRules = tmp
                }
            }
        }
        public class TransformationRules : Tea.TeaModel {
            public var ruleActionType: String?

            public var ruleExpression: String?

            public var ruleName: String?

            public var ruleTargetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ruleActionType != nil {
                    map["RuleActionType"] = self.ruleActionType!
                }
                if self.ruleExpression != nil {
                    map["RuleExpression"] = self.ruleExpression!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.ruleTargetType != nil {
                    map["RuleTargetType"] = self.ruleTargetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RuleActionType") {
                    self.ruleActionType = dict["RuleActionType"] as! String
                }
                if dict.keys.contains("RuleExpression") {
                    self.ruleExpression = dict["RuleExpression"] as! String
                }
                if dict.keys.contains("RuleName") {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("RuleTargetType") {
                    self.ruleTargetType = dict["RuleTargetType"] as! String
                }
            }
        }
        public var createdTime: Int64?

        public var createdUid: String?

        public var DIJobId: Int64?

        public var description_: String?

        public var destinationDataSourceSettings: [GetDIJobResponseBody.Data.DestinationDataSourceSettings]?

        public var destinationDataSourceType: String?

        public var errorMessage: String?

        public var jobName: String?

        public var jobSettings: GetDIJobResponseBody.Data.JobSettings?

        public var jobStatus: String?

        public var migrationType: String?

        public var projectId: Int64?

        public var resourceSettings: GetDIJobResponseBody.Data.ResourceSettings?

        public var runStats: [String: String]?

        public var sourceDataSourceSettings: [GetDIJobResponseBody.Data.SourceDataSourceSettings]?

        public var sourceDataSourceType: String?

        public var startedTime: Int64?

        public var startedUid: String?

        public var tableMappings: [GetDIJobResponseBody.Data.TableMappings]?

        public var transformationRules: [GetDIJobResponseBody.Data.TransformationRules]?

        public var updatedTime: Int64?

        public var updatedUid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.jobSettings?.validate()
            try self.resourceSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.createdUid != nil {
                map["CreatedUid"] = self.createdUid!
            }
            if self.DIJobId != nil {
                map["DIJobId"] = self.DIJobId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destinationDataSourceSettings != nil {
                var tmp : [Any] = []
                for k in self.destinationDataSourceSettings! {
                    tmp.append(k.toMap())
                }
                map["DestinationDataSourceSettings"] = tmp
            }
            if self.destinationDataSourceType != nil {
                map["DestinationDataSourceType"] = self.destinationDataSourceType!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.jobName != nil {
                map["JobName"] = self.jobName!
            }
            if self.jobSettings != nil {
                map["JobSettings"] = self.jobSettings?.toMap()
            }
            if self.jobStatus != nil {
                map["JobStatus"] = self.jobStatus!
            }
            if self.migrationType != nil {
                map["MigrationType"] = self.migrationType!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.resourceSettings != nil {
                map["ResourceSettings"] = self.resourceSettings?.toMap()
            }
            if self.runStats != nil {
                map["RunStats"] = self.runStats!
            }
            if self.sourceDataSourceSettings != nil {
                var tmp : [Any] = []
                for k in self.sourceDataSourceSettings! {
                    tmp.append(k.toMap())
                }
                map["SourceDataSourceSettings"] = tmp
            }
            if self.sourceDataSourceType != nil {
                map["SourceDataSourceType"] = self.sourceDataSourceType!
            }
            if self.startedTime != nil {
                map["StartedTime"] = self.startedTime!
            }
            if self.startedUid != nil {
                map["StartedUid"] = self.startedUid!
            }
            if self.tableMappings != nil {
                var tmp : [Any] = []
                for k in self.tableMappings! {
                    tmp.append(k.toMap())
                }
                map["TableMappings"] = tmp
            }
            if self.transformationRules != nil {
                var tmp : [Any] = []
                for k in self.transformationRules! {
                    tmp.append(k.toMap())
                }
                map["TransformationRules"] = tmp
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            if self.updatedUid != nil {
                map["UpdatedUid"] = self.updatedUid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! Int64
            }
            if dict.keys.contains("CreatedUid") {
                self.createdUid = dict["CreatedUid"] as! String
            }
            if dict.keys.contains("DIJobId") {
                self.DIJobId = dict["DIJobId"] as! Int64
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestinationDataSourceSettings") {
                var tmp : [GetDIJobResponseBody.Data.DestinationDataSourceSettings] = []
                for v in dict["DestinationDataSourceSettings"] as! [Any] {
                    var model = GetDIJobResponseBody.Data.DestinationDataSourceSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.destinationDataSourceSettings = tmp
            }
            if dict.keys.contains("DestinationDataSourceType") {
                self.destinationDataSourceType = dict["DestinationDataSourceType"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("JobName") {
                self.jobName = dict["JobName"] as! String
            }
            if dict.keys.contains("JobSettings") {
                var model = GetDIJobResponseBody.Data.JobSettings()
                model.fromMap(dict["JobSettings"] as! [String: Any])
                self.jobSettings = model
            }
            if dict.keys.contains("JobStatus") {
                self.jobStatus = dict["JobStatus"] as! String
            }
            if dict.keys.contains("MigrationType") {
                self.migrationType = dict["MigrationType"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("ResourceSettings") {
                var model = GetDIJobResponseBody.Data.ResourceSettings()
                model.fromMap(dict["ResourceSettings"] as! [String: Any])
                self.resourceSettings = model
            }
            if dict.keys.contains("RunStats") {
                self.runStats = dict["RunStats"] as! [String: String]
            }
            if dict.keys.contains("SourceDataSourceSettings") {
                var tmp : [GetDIJobResponseBody.Data.SourceDataSourceSettings] = []
                for v in dict["SourceDataSourceSettings"] as! [Any] {
                    var model = GetDIJobResponseBody.Data.SourceDataSourceSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sourceDataSourceSettings = tmp
            }
            if dict.keys.contains("SourceDataSourceType") {
                self.sourceDataSourceType = dict["SourceDataSourceType"] as! String
            }
            if dict.keys.contains("StartedTime") {
                self.startedTime = dict["StartedTime"] as! Int64
            }
            if dict.keys.contains("StartedUid") {
                self.startedUid = dict["StartedUid"] as! String
            }
            if dict.keys.contains("TableMappings") {
                var tmp : [GetDIJobResponseBody.Data.TableMappings] = []
                for v in dict["TableMappings"] as! [Any] {
                    var model = GetDIJobResponseBody.Data.TableMappings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableMappings = tmp
            }
            if dict.keys.contains("TransformationRules") {
                var tmp : [GetDIJobResponseBody.Data.TransformationRules] = []
                for v in dict["TransformationRules"] as! [Any] {
                    var model = GetDIJobResponseBody.Data.TransformationRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transformationRules = tmp
            }
            if dict.keys.contains("UpdatedTime") {
                self.updatedTime = dict["UpdatedTime"] as! Int64
            }
            if dict.keys.contains("UpdatedUid") {
                self.updatedUid = dict["UpdatedUid"] as! String
            }
        }
    }
    public var data: GetDIJobResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDIJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDIJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDISyncInstanceInfoRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class GetDISyncInstanceInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SolutionInfo : Tea.TeaModel {
            public class StepDetail : Tea.TeaModel {
                public var info: String?

                public var status: String?

                public var stepId: Int64?

                public var stepName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.info != nil {
                        map["Info"] = self.info!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.stepId != nil {
                        map["StepId"] = self.stepId!
                    }
                    if self.stepName != nil {
                        map["StepName"] = self.stepName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Info") {
                        self.info = dict["Info"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("StepId") {
                        self.stepId = dict["StepId"] as! Int64
                    }
                    if dict.keys.contains("StepName") {
                        self.stepName = dict["StepName"] as! String
                    }
                }
            }
            public var creatorName: String?

            public var id: Int64?

            public var status: String?

            public var stepDetail: [GetDISyncInstanceInfoResponseBody.Data.SolutionInfo.StepDetail]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creatorName != nil {
                    map["CreatorName"] = self.creatorName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.stepDetail != nil {
                    var tmp : [Any] = []
                    for k in self.stepDetail! {
                        tmp.append(k.toMap())
                    }
                    map["StepDetail"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatorName") {
                    self.creatorName = dict["CreatorName"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StepDetail") {
                    var tmp : [GetDISyncInstanceInfoResponseBody.Data.SolutionInfo.StepDetail] = []
                    for v in dict["StepDetail"] as! [Any] {
                        var model = GetDISyncInstanceInfoResponseBody.Data.SolutionInfo.StepDetail()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.stepDetail = tmp
                }
            }
        }
        public var message: String?

        public var name: String?

        public var solutionInfo: GetDISyncInstanceInfoResponseBody.Data.SolutionInfo?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.solutionInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.solutionInfo != nil {
                map["SolutionInfo"] = self.solutionInfo?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("SolutionInfo") {
                var model = GetDISyncInstanceInfoResponseBody.Data.SolutionInfo()
                model.fromMap(dict["SolutionInfo"] as! [String: Any])
                self.solutionInfo = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: GetDISyncInstanceInfoResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDISyncInstanceInfoResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDISyncInstanceInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDISyncInstanceInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDISyncInstanceInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDISyncTaskRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class GetDISyncTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AlarmList : Tea.TeaModel {
            public class AlarmRuleList : Tea.TeaModel {
                public var aggregator: String?

                public var comparator: String?

                public var duration: Int64?

                public var level: String?

                public var threshold: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aggregator != nil {
                        map["Aggregator"] = self.aggregator!
                    }
                    if self.comparator != nil {
                        map["Comparator"] = self.comparator!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Aggregator") {
                        self.aggregator = dict["Aggregator"] as! String
                    }
                    if dict.keys.contains("Comparator") {
                        self.comparator = dict["Comparator"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! Int64
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Threshold") {
                        self.threshold = dict["Threshold"] as! Int64
                    }
                }
            }
            public class NotifyRule : Tea.TeaModel {
                public var critical: [String]?

                public var interval: Int64?

                public var warning: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.critical != nil {
                        map["Critical"] = self.critical!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.warning != nil {
                        map["Warning"] = self.warning!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Critical") {
                        self.critical = dict["Critical"] as! [String]
                    }
                    if dict.keys.contains("Interval") {
                        self.interval = dict["Interval"] as! Int64
                    }
                    if dict.keys.contains("Warning") {
                        self.warning = dict["Warning"] as! [String]
                    }
                }
            }
            public var alarmRuleList: [GetDISyncTaskResponseBody.Data.AlarmList.AlarmRuleList]?

            public var description_: String?

            public var enabled: Bool?

            public var id: Int64?

            public var metric: String?

            public var notifyRule: GetDISyncTaskResponseBody.Data.AlarmList.NotifyRule?

            public var ruleName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.notifyRule?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alarmRuleList != nil {
                    var tmp : [Any] = []
                    for k in self.alarmRuleList! {
                        tmp.append(k.toMap())
                    }
                    map["AlarmRuleList"] = tmp
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.metric != nil {
                    map["Metric"] = self.metric!
                }
                if self.notifyRule != nil {
                    map["NotifyRule"] = self.notifyRule?.toMap()
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlarmRuleList") {
                    var tmp : [GetDISyncTaskResponseBody.Data.AlarmList.AlarmRuleList] = []
                    for v in dict["AlarmRuleList"] as! [Any] {
                        var model = GetDISyncTaskResponseBody.Data.AlarmList.AlarmRuleList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.alarmRuleList = tmp
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Enabled") {
                    self.enabled = dict["Enabled"] as! Bool
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Metric") {
                    self.metric = dict["Metric"] as! String
                }
                if dict.keys.contains("NotifyRule") {
                    var model = GetDISyncTaskResponseBody.Data.AlarmList.NotifyRule()
                    model.fromMap(dict["NotifyRule"] as! [String: Any])
                    self.notifyRule = model
                }
                if dict.keys.contains("RuleName") {
                    self.ruleName = dict["RuleName"] as! String
                }
            }
        }
        public class SolutionDetail : Tea.TeaModel {
            public var creatorName: String?

            public var id: Int64?

            public var name: String?

            public var processContent: String?

            public var processExtra: String?

            public var projectId: Int64?

            public var sourceType: String?

            public var startTime: String?

            public var status: String?

            public var submitTime: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creatorName != nil {
                    map["CreatorName"] = self.creatorName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.processContent != nil {
                    map["ProcessContent"] = self.processContent!
                }
                if self.processExtra != nil {
                    map["ProcessExtra"] = self.processExtra!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatorName") {
                    self.creatorName = dict["CreatorName"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ProcessContent") {
                    self.processContent = dict["ProcessContent"] as! String
                }
                if dict.keys.contains("ProcessExtra") {
                    self.processExtra = dict["ProcessExtra"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SubmitTime") {
                    self.submitTime = dict["SubmitTime"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var alarmList: [GetDISyncTaskResponseBody.Data.AlarmList]?

        public var code: String?

        public var message: String?

        public var solutionDetail: GetDISyncTaskResponseBody.Data.SolutionDetail?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.solutionDetail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmList != nil {
                var tmp : [Any] = []
                for k in self.alarmList! {
                    tmp.append(k.toMap())
                }
                map["AlarmList"] = tmp
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.solutionDetail != nil {
                map["SolutionDetail"] = self.solutionDetail?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmList") {
                var tmp : [GetDISyncTaskResponseBody.Data.AlarmList] = []
                for v in dict["AlarmList"] as! [Any] {
                    var model = GetDISyncTaskResponseBody.Data.AlarmList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alarmList = tmp
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("SolutionDetail") {
                var model = GetDISyncTaskResponseBody.Data.SolutionDetail()
                model.fromMap(dict["SolutionDetail"] as! [String: Any])
                self.solutionDetail = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: GetDISyncTaskResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDISyncTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDISyncTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDISyncTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDISyncTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDagRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class GetDagResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var bizdate: Int64?

        public var createTime: Int64?

        public var createUser: String?

        public var dagId: Int64?

        public var finishTime: Int64?

        public var gmtdate: Int64?

        public var modifyTime: Int64?

        public var name: String?

        public var opSeq: Int64?

        public var projectId: Int64?

        public var startTime: Int64?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizdate != nil {
                map["Bizdate"] = self.bizdate!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.dagId != nil {
                map["DagId"] = self.dagId!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.gmtdate != nil {
                map["Gmtdate"] = self.gmtdate!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.opSeq != nil {
                map["OpSeq"] = self.opSeq!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bizdate") {
                self.bizdate = dict["Bizdate"] as! Int64
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreateUser") {
                self.createUser = dict["CreateUser"] as! String
            }
            if dict.keys.contains("DagId") {
                self.dagId = dict["DagId"] as! Int64
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! Int64
            }
            if dict.keys.contains("Gmtdate") {
                self.gmtdate = dict["Gmtdate"] as! Int64
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OpSeq") {
                self.opSeq = dict["OpSeq"] as! Int64
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var data: GetDagResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDagResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataServiceApiRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class GetDataServiceApiResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RegistrationDetails : Tea.TeaModel {
            public class RegistrationErrorCodes : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var errorSolution: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.errorSolution != nil {
                        map["ErrorSolution"] = self.errorSolution!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("ErrorSolution") {
                        self.errorSolution = dict["ErrorSolution"] as! String
                    }
                }
            }
            public class RegistrationRequestParameters : Tea.TeaModel {
                public var columnName: String?

                public var defaultValue: String?

                public var exampleValue: String?

                public var isRequiredParameter: Bool?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public var parameterOperator: Int32?

                public var parameterPosition: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columnName != nil {
                        map["ColumnName"] = self.columnName!
                    }
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.isRequiredParameter != nil {
                        map["IsRequiredParameter"] = self.isRequiredParameter!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.parameterOperator != nil {
                        map["ParameterOperator"] = self.parameterOperator!
                    }
                    if self.parameterPosition != nil {
                        map["ParameterPosition"] = self.parameterPosition!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ColumnName") {
                        self.columnName = dict["ColumnName"] as! String
                    }
                    if dict.keys.contains("DefaultValue") {
                        self.defaultValue = dict["DefaultValue"] as! String
                    }
                    if dict.keys.contains("ExampleValue") {
                        self.exampleValue = dict["ExampleValue"] as! String
                    }
                    if dict.keys.contains("IsRequiredParameter") {
                        self.isRequiredParameter = dict["IsRequiredParameter"] as! Bool
                    }
                    if dict.keys.contains("ParameterDataType") {
                        self.parameterDataType = dict["ParameterDataType"] as! Int32
                    }
                    if dict.keys.contains("ParameterDescription") {
                        self.parameterDescription = dict["ParameterDescription"] as! String
                    }
                    if dict.keys.contains("ParameterName") {
                        self.parameterName = dict["ParameterName"] as! String
                    }
                    if dict.keys.contains("ParameterOperator") {
                        self.parameterOperator = dict["ParameterOperator"] as! Int32
                    }
                    if dict.keys.contains("ParameterPosition") {
                        self.parameterPosition = dict["ParameterPosition"] as! Int32
                    }
                }
            }
            public var failedResultSample: String?

            public var registrationErrorCodes: [GetDataServiceApiResponseBody.Data.RegistrationDetails.RegistrationErrorCodes]?

            public var registrationRequestParameters: [GetDataServiceApiResponseBody.Data.RegistrationDetails.RegistrationRequestParameters]?

            public var serviceContentType: Int32?

            public var serviceHost: String?

            public var servicePath: String?

            public var serviceRequestBodyDescription: String?

            public var successfulResultSample: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedResultSample != nil {
                    map["FailedResultSample"] = self.failedResultSample!
                }
                if self.registrationErrorCodes != nil {
                    var tmp : [Any] = []
                    for k in self.registrationErrorCodes! {
                        tmp.append(k.toMap())
                    }
                    map["RegistrationErrorCodes"] = tmp
                }
                if self.registrationRequestParameters != nil {
                    var tmp : [Any] = []
                    for k in self.registrationRequestParameters! {
                        tmp.append(k.toMap())
                    }
                    map["RegistrationRequestParameters"] = tmp
                }
                if self.serviceContentType != nil {
                    map["ServiceContentType"] = self.serviceContentType!
                }
                if self.serviceHost != nil {
                    map["ServiceHost"] = self.serviceHost!
                }
                if self.servicePath != nil {
                    map["ServicePath"] = self.servicePath!
                }
                if self.serviceRequestBodyDescription != nil {
                    map["ServiceRequestBodyDescription"] = self.serviceRequestBodyDescription!
                }
                if self.successfulResultSample != nil {
                    map["SuccessfulResultSample"] = self.successfulResultSample!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedResultSample") {
                    self.failedResultSample = dict["FailedResultSample"] as! String
                }
                if dict.keys.contains("RegistrationErrorCodes") {
                    var tmp : [GetDataServiceApiResponseBody.Data.RegistrationDetails.RegistrationErrorCodes] = []
                    for v in dict["RegistrationErrorCodes"] as! [Any] {
                        var model = GetDataServiceApiResponseBody.Data.RegistrationDetails.RegistrationErrorCodes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.registrationErrorCodes = tmp
                }
                if dict.keys.contains("RegistrationRequestParameters") {
                    var tmp : [GetDataServiceApiResponseBody.Data.RegistrationDetails.RegistrationRequestParameters] = []
                    for v in dict["RegistrationRequestParameters"] as! [Any] {
                        var model = GetDataServiceApiResponseBody.Data.RegistrationDetails.RegistrationRequestParameters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.registrationRequestParameters = tmp
                }
                if dict.keys.contains("ServiceContentType") {
                    self.serviceContentType = dict["ServiceContentType"] as! Int32
                }
                if dict.keys.contains("ServiceHost") {
                    self.serviceHost = dict["ServiceHost"] as! String
                }
                if dict.keys.contains("ServicePath") {
                    self.servicePath = dict["ServicePath"] as! String
                }
                if dict.keys.contains("ServiceRequestBodyDescription") {
                    self.serviceRequestBodyDescription = dict["ServiceRequestBodyDescription"] as! String
                }
                if dict.keys.contains("SuccessfulResultSample") {
                    self.successfulResultSample = dict["SuccessfulResultSample"] as! String
                }
            }
        }
        public class ScriptDetails : Tea.TeaModel {
            public class ScriptConnection : Tea.TeaModel {
                public var connectionId: Int64?

                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connectionId != nil {
                        map["ConnectionId"] = self.connectionId!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConnectionId") {
                        self.connectionId = dict["ConnectionId"] as! Int64
                    }
                    if dict.keys.contains("TableName") {
                        self.tableName = dict["TableName"] as! String
                    }
                }
            }
            public class ScriptRequestParameters : Tea.TeaModel {
                public var columnName: String?

                public var defaultValue: String?

                public var exampleValue: String?

                public var isRequiredParameter: Bool?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public var parameterOperator: Int32?

                public var parameterPosition: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columnName != nil {
                        map["ColumnName"] = self.columnName!
                    }
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.isRequiredParameter != nil {
                        map["IsRequiredParameter"] = self.isRequiredParameter!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.parameterOperator != nil {
                        map["ParameterOperator"] = self.parameterOperator!
                    }
                    if self.parameterPosition != nil {
                        map["ParameterPosition"] = self.parameterPosition!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ColumnName") {
                        self.columnName = dict["ColumnName"] as! String
                    }
                    if dict.keys.contains("DefaultValue") {
                        self.defaultValue = dict["DefaultValue"] as! String
                    }
                    if dict.keys.contains("ExampleValue") {
                        self.exampleValue = dict["ExampleValue"] as! String
                    }
                    if dict.keys.contains("IsRequiredParameter") {
                        self.isRequiredParameter = dict["IsRequiredParameter"] as! Bool
                    }
                    if dict.keys.contains("ParameterDataType") {
                        self.parameterDataType = dict["ParameterDataType"] as! Int32
                    }
                    if dict.keys.contains("ParameterDescription") {
                        self.parameterDescription = dict["ParameterDescription"] as! String
                    }
                    if dict.keys.contains("ParameterName") {
                        self.parameterName = dict["ParameterName"] as! String
                    }
                    if dict.keys.contains("ParameterOperator") {
                        self.parameterOperator = dict["ParameterOperator"] as! Int32
                    }
                    if dict.keys.contains("ParameterPosition") {
                        self.parameterPosition = dict["ParameterPosition"] as! Int32
                    }
                }
            }
            public class ScriptResponseParameters : Tea.TeaModel {
                public var columnName: String?

                public var exampleValue: String?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columnName != nil {
                        map["ColumnName"] = self.columnName!
                    }
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ColumnName") {
                        self.columnName = dict["ColumnName"] as! String
                    }
                    if dict.keys.contains("ExampleValue") {
                        self.exampleValue = dict["ExampleValue"] as! String
                    }
                    if dict.keys.contains("ParameterDataType") {
                        self.parameterDataType = dict["ParameterDataType"] as! Int32
                    }
                    if dict.keys.contains("ParameterDescription") {
                        self.parameterDescription = dict["ParameterDescription"] as! String
                    }
                    if dict.keys.contains("ParameterName") {
                        self.parameterName = dict["ParameterName"] as! String
                    }
                }
            }
            public var isPagedResponse: Bool?

            public var script: String?

            public var scriptConnection: GetDataServiceApiResponseBody.Data.ScriptDetails.ScriptConnection?

            public var scriptRequestParameters: [GetDataServiceApiResponseBody.Data.ScriptDetails.ScriptRequestParameters]?

            public var scriptResponseParameters: [GetDataServiceApiResponseBody.Data.ScriptDetails.ScriptResponseParameters]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.scriptConnection?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isPagedResponse != nil {
                    map["IsPagedResponse"] = self.isPagedResponse!
                }
                if self.script != nil {
                    map["Script"] = self.script!
                }
                if self.scriptConnection != nil {
                    map["ScriptConnection"] = self.scriptConnection?.toMap()
                }
                if self.scriptRequestParameters != nil {
                    var tmp : [Any] = []
                    for k in self.scriptRequestParameters! {
                        tmp.append(k.toMap())
                    }
                    map["ScriptRequestParameters"] = tmp
                }
                if self.scriptResponseParameters != nil {
                    var tmp : [Any] = []
                    for k in self.scriptResponseParameters! {
                        tmp.append(k.toMap())
                    }
                    map["ScriptResponseParameters"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IsPagedResponse") {
                    self.isPagedResponse = dict["IsPagedResponse"] as! Bool
                }
                if dict.keys.contains("Script") {
                    self.script = dict["Script"] as! String
                }
                if dict.keys.contains("ScriptConnection") {
                    var model = GetDataServiceApiResponseBody.Data.ScriptDetails.ScriptConnection()
                    model.fromMap(dict["ScriptConnection"] as! [String: Any])
                    self.scriptConnection = model
                }
                if dict.keys.contains("ScriptRequestParameters") {
                    var tmp : [GetDataServiceApiResponseBody.Data.ScriptDetails.ScriptRequestParameters] = []
                    for v in dict["ScriptRequestParameters"] as! [Any] {
                        var model = GetDataServiceApiResponseBody.Data.ScriptDetails.ScriptRequestParameters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.scriptRequestParameters = tmp
                }
                if dict.keys.contains("ScriptResponseParameters") {
                    var tmp : [GetDataServiceApiResponseBody.Data.ScriptDetails.ScriptResponseParameters] = []
                    for v in dict["ScriptResponseParameters"] as! [Any] {
                        var model = GetDataServiceApiResponseBody.Data.ScriptDetails.ScriptResponseParameters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.scriptResponseParameters = tmp
                }
            }
        }
        public class WizardDetails : Tea.TeaModel {
            public class WizardConnection : Tea.TeaModel {
                public var connectionId: Int64?

                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connectionId != nil {
                        map["ConnectionId"] = self.connectionId!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConnectionId") {
                        self.connectionId = dict["ConnectionId"] as! Int64
                    }
                    if dict.keys.contains("TableName") {
                        self.tableName = dict["TableName"] as! String
                    }
                }
            }
            public class WizardRequestParameters : Tea.TeaModel {
                public var columnName: String?

                public var defaultValue: String?

                public var exampleValue: String?

                public var isRequiredParameter: Bool?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public var parameterOperator: Int32?

                public var parameterPosition: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columnName != nil {
                        map["ColumnName"] = self.columnName!
                    }
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.isRequiredParameter != nil {
                        map["IsRequiredParameter"] = self.isRequiredParameter!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.parameterOperator != nil {
                        map["ParameterOperator"] = self.parameterOperator!
                    }
                    if self.parameterPosition != nil {
                        map["ParameterPosition"] = self.parameterPosition!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ColumnName") {
                        self.columnName = dict["ColumnName"] as! String
                    }
                    if dict.keys.contains("DefaultValue") {
                        self.defaultValue = dict["DefaultValue"] as! String
                    }
                    if dict.keys.contains("ExampleValue") {
                        self.exampleValue = dict["ExampleValue"] as! String
                    }
                    if dict.keys.contains("IsRequiredParameter") {
                        self.isRequiredParameter = dict["IsRequiredParameter"] as! Bool
                    }
                    if dict.keys.contains("ParameterDataType") {
                        self.parameterDataType = dict["ParameterDataType"] as! Int32
                    }
                    if dict.keys.contains("ParameterDescription") {
                        self.parameterDescription = dict["ParameterDescription"] as! String
                    }
                    if dict.keys.contains("ParameterName") {
                        self.parameterName = dict["ParameterName"] as! String
                    }
                    if dict.keys.contains("ParameterOperator") {
                        self.parameterOperator = dict["ParameterOperator"] as! Int32
                    }
                    if dict.keys.contains("ParameterPosition") {
                        self.parameterPosition = dict["ParameterPosition"] as! Int32
                    }
                }
            }
            public class WizardResponseParameters : Tea.TeaModel {
                public var columnName: String?

                public var exampleValue: String?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columnName != nil {
                        map["ColumnName"] = self.columnName!
                    }
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ColumnName") {
                        self.columnName = dict["ColumnName"] as! String
                    }
                    if dict.keys.contains("ExampleValue") {
                        self.exampleValue = dict["ExampleValue"] as! String
                    }
                    if dict.keys.contains("ParameterDataType") {
                        self.parameterDataType = dict["ParameterDataType"] as! Int32
                    }
                    if dict.keys.contains("ParameterDescription") {
                        self.parameterDescription = dict["ParameterDescription"] as! String
                    }
                    if dict.keys.contains("ParameterName") {
                        self.parameterName = dict["ParameterName"] as! String
                    }
                }
            }
            public var isPagedResponse: Bool?

            public var wizardConnection: GetDataServiceApiResponseBody.Data.WizardDetails.WizardConnection?

            public var wizardRequestParameters: [GetDataServiceApiResponseBody.Data.WizardDetails.WizardRequestParameters]?

            public var wizardResponseParameters: [GetDataServiceApiResponseBody.Data.WizardDetails.WizardResponseParameters]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.wizardConnection?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isPagedResponse != nil {
                    map["IsPagedResponse"] = self.isPagedResponse!
                }
                if self.wizardConnection != nil {
                    map["WizardConnection"] = self.wizardConnection?.toMap()
                }
                if self.wizardRequestParameters != nil {
                    var tmp : [Any] = []
                    for k in self.wizardRequestParameters! {
                        tmp.append(k.toMap())
                    }
                    map["WizardRequestParameters"] = tmp
                }
                if self.wizardResponseParameters != nil {
                    var tmp : [Any] = []
                    for k in self.wizardResponseParameters! {
                        tmp.append(k.toMap())
                    }
                    map["WizardResponseParameters"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IsPagedResponse") {
                    self.isPagedResponse = dict["IsPagedResponse"] as! Bool
                }
                if dict.keys.contains("WizardConnection") {
                    var model = GetDataServiceApiResponseBody.Data.WizardDetails.WizardConnection()
                    model.fromMap(dict["WizardConnection"] as! [String: Any])
                    self.wizardConnection = model
                }
                if dict.keys.contains("WizardRequestParameters") {
                    var tmp : [GetDataServiceApiResponseBody.Data.WizardDetails.WizardRequestParameters] = []
                    for v in dict["WizardRequestParameters"] as! [Any] {
                        var model = GetDataServiceApiResponseBody.Data.WizardDetails.WizardRequestParameters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.wizardRequestParameters = tmp
                }
                if dict.keys.contains("WizardResponseParameters") {
                    var tmp : [GetDataServiceApiResponseBody.Data.WizardDetails.WizardResponseParameters] = []
                    for v in dict["WizardResponseParameters"] as! [Any] {
                        var model = GetDataServiceApiResponseBody.Data.WizardDetails.WizardResponseParameters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.wizardResponseParameters = tmp
                }
            }
        }
        public var apiId: Int64?

        public var apiMode: Int32?

        public var apiName: String?

        public var apiPath: String?

        public var createdTime: String?

        public var creatorId: String?

        public var description_: String?

        public var folderId: Int64?

        public var groupId: String?

        public var modifiedTime: String?

        public var operatorId: String?

        public var projectId: Int64?

        public var protocols: [Int32]?

        public var registrationDetails: GetDataServiceApiResponseBody.Data.RegistrationDetails?

        public var requestMethod: Int32?

        public var responseContentType: Int32?

        public var scriptDetails: GetDataServiceApiResponseBody.Data.ScriptDetails?

        public var status: Int32?

        public var tenantId: Int64?

        public var timeout: Int32?

        public var visibleRange: Int32?

        public var wizardDetails: GetDataServiceApiResponseBody.Data.WizardDetails?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.registrationDetails?.validate()
            try self.scriptDetails?.validate()
            try self.wizardDetails?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiId != nil {
                map["ApiId"] = self.apiId!
            }
            if self.apiMode != nil {
                map["ApiMode"] = self.apiMode!
            }
            if self.apiName != nil {
                map["ApiName"] = self.apiName!
            }
            if self.apiPath != nil {
                map["ApiPath"] = self.apiPath!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.folderId != nil {
                map["FolderId"] = self.folderId!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.operatorId != nil {
                map["OperatorId"] = self.operatorId!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.protocols != nil {
                map["Protocols"] = self.protocols!
            }
            if self.registrationDetails != nil {
                map["RegistrationDetails"] = self.registrationDetails?.toMap()
            }
            if self.requestMethod != nil {
                map["RequestMethod"] = self.requestMethod!
            }
            if self.responseContentType != nil {
                map["ResponseContentType"] = self.responseContentType!
            }
            if self.scriptDetails != nil {
                map["ScriptDetails"] = self.scriptDetails?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout!
            }
            if self.visibleRange != nil {
                map["VisibleRange"] = self.visibleRange!
            }
            if self.wizardDetails != nil {
                map["WizardDetails"] = self.wizardDetails?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiId") {
                self.apiId = dict["ApiId"] as! Int64
            }
            if dict.keys.contains("ApiMode") {
                self.apiMode = dict["ApiMode"] as! Int32
            }
            if dict.keys.contains("ApiName") {
                self.apiName = dict["ApiName"] as! String
            }
            if dict.keys.contains("ApiPath") {
                self.apiPath = dict["ApiPath"] as! String
            }
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("FolderId") {
                self.folderId = dict["FolderId"] as! Int64
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OperatorId") {
                self.operatorId = dict["OperatorId"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("Protocols") {
                self.protocols = dict["Protocols"] as! [Int32]
            }
            if dict.keys.contains("RegistrationDetails") {
                var model = GetDataServiceApiResponseBody.Data.RegistrationDetails()
                model.fromMap(dict["RegistrationDetails"] as! [String: Any])
                self.registrationDetails = model
            }
            if dict.keys.contains("RequestMethod") {
                self.requestMethod = dict["RequestMethod"] as! Int32
            }
            if dict.keys.contains("ResponseContentType") {
                self.responseContentType = dict["ResponseContentType"] as! Int32
            }
            if dict.keys.contains("ScriptDetails") {
                var model = GetDataServiceApiResponseBody.Data.ScriptDetails()
                model.fromMap(dict["ScriptDetails"] as! [String: Any])
                self.scriptDetails = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
            if dict.keys.contains("Timeout") {
                self.timeout = dict["Timeout"] as! Int32
            }
            if dict.keys.contains("VisibleRange") {
                self.visibleRange = dict["VisibleRange"] as! Int32
            }
            if dict.keys.contains("WizardDetails") {
                var model = GetDataServiceApiResponseBody.Data.WizardDetails()
                model.fromMap(dict["WizardDetails"] as! [String: Any])
                self.wizardDetails = model
            }
        }
    }
    public var data: GetDataServiceApiResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDataServiceApiResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataServiceApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataServiceApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataServiceApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataServiceApiTestRequest : Tea.TeaModel {
    public var testId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.testId != nil {
            map["TestId"] = self.testId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TestId") {
            self.testId = dict["TestId"] as! Int64
        }
    }
}

public class GetDataServiceApiTestResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var apiId: Int64?

        public var costTime: String?

        public var debugInfo: String?

        public var nodesDebugInfo: String?

        public var paramMap: String?

        public var retCode: Int64?

        public var retResult: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiId != nil {
                map["ApiId"] = self.apiId!
            }
            if self.costTime != nil {
                map["CostTime"] = self.costTime!
            }
            if self.debugInfo != nil {
                map["DebugInfo"] = self.debugInfo!
            }
            if self.nodesDebugInfo != nil {
                map["NodesDebugInfo"] = self.nodesDebugInfo!
            }
            if self.paramMap != nil {
                map["ParamMap"] = self.paramMap!
            }
            if self.retCode != nil {
                map["RetCode"] = self.retCode!
            }
            if self.retResult != nil {
                map["RetResult"] = self.retResult!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiId") {
                self.apiId = dict["ApiId"] as! Int64
            }
            if dict.keys.contains("CostTime") {
                self.costTime = dict["CostTime"] as! String
            }
            if dict.keys.contains("DebugInfo") {
                self.debugInfo = dict["DebugInfo"] as! String
            }
            if dict.keys.contains("NodesDebugInfo") {
                self.nodesDebugInfo = dict["NodesDebugInfo"] as! String
            }
            if dict.keys.contains("ParamMap") {
                self.paramMap = dict["ParamMap"] as! String
            }
            if dict.keys.contains("RetCode") {
                self.retCode = dict["RetCode"] as! Int64
            }
            if dict.keys.contains("RetResult") {
                self.retResult = dict["RetResult"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: GetDataServiceApiTestResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDataServiceApiTestResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDataServiceApiTestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataServiceApiTestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataServiceApiTestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataServiceApplicationRequest : Tea.TeaModel {
    public var applicationId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationId") {
            self.applicationId = dict["ApplicationId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class GetDataServiceApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var applicationCode: String?

        public var applicationId: Int64?

        public var applicationKey: String?

        public var applicationName: String?

        public var applicationSecret: String?

        public var projectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationCode != nil {
                map["ApplicationCode"] = self.applicationCode!
            }
            if self.applicationId != nil {
                map["ApplicationId"] = self.applicationId!
            }
            if self.applicationKey != nil {
                map["ApplicationKey"] = self.applicationKey!
            }
            if self.applicationName != nil {
                map["ApplicationName"] = self.applicationName!
            }
            if self.applicationSecret != nil {
                map["ApplicationSecret"] = self.applicationSecret!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplicationCode") {
                self.applicationCode = dict["ApplicationCode"] as! String
            }
            if dict.keys.contains("ApplicationId") {
                self.applicationId = dict["ApplicationId"] as! Int64
            }
            if dict.keys.contains("ApplicationKey") {
                self.applicationKey = dict["ApplicationKey"] as! String
            }
            if dict.keys.contains("ApplicationName") {
                self.applicationName = dict["ApplicationName"] as! String
            }
            if dict.keys.contains("ApplicationSecret") {
                self.applicationSecret = dict["ApplicationSecret"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
        }
    }
    public var data: GetDataServiceApplicationResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDataServiceApplicationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataServiceApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataServiceApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataServiceApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataServiceFolderRequest : Tea.TeaModel {
    public var folderId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FolderId") {
            self.folderId = dict["FolderId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class GetDataServiceFolderResponseBody : Tea.TeaModel {
    public class Folder : Tea.TeaModel {
        public var createdTime: String?

        public var folderId: Int64?

        public var folderName: String?

        public var groupId: String?

        public var modifiedTime: String?

        public var parentId: Int64?

        public var projectId: Int64?

        public var tenantId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.folderId != nil {
                map["FolderId"] = self.folderId!
            }
            if self.folderName != nil {
                map["FolderName"] = self.folderName!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("FolderId") {
                self.folderId = dict["FolderId"] as! Int64
            }
            if dict.keys.contains("FolderName") {
                self.folderName = dict["FolderName"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ParentId") {
                self.parentId = dict["ParentId"] as! Int64
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
        }
    }
    public var folder: GetDataServiceFolderResponseBody.Folder?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.folder?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folder != nil {
            map["Folder"] = self.folder?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Folder") {
            var model = GetDataServiceFolderResponseBody.Folder()
            model.fromMap(dict["Folder"] as! [String: Any])
            self.folder = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDataServiceFolderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataServiceFolderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataServiceFolderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataServiceGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class GetDataServiceGroupResponseBody : Tea.TeaModel {
    public class Group : Tea.TeaModel {
        public var apiGatewayGroupId: String?

        public var createdTime: String?

        public var creatorId: String?

        public var description_: String?

        public var groupId: String?

        public var groupName: String?

        public var modifiedTime: String?

        public var projectId: Int64?

        public var tenantId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiGatewayGroupId != nil {
                map["ApiGatewayGroupId"] = self.apiGatewayGroupId!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiGatewayGroupId") {
                self.apiGatewayGroupId = dict["ApiGatewayGroupId"] as! String
            }
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
        }
    }
    public var group: GetDataServiceGroupResponseBody.Group?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.group?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.group != nil {
            map["Group"] = self.group?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Group") {
            var model = GetDataServiceGroupResponseBody.Group()
            model.fromMap(dict["Group"] as! [String: Any])
            self.group = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDataServiceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataServiceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataServiceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataServicePublishedApiRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class GetDataServicePublishedApiResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RegistrationDetails : Tea.TeaModel {
            public class RegistrationErrorCodes : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var errorSolution: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.errorSolution != nil {
                        map["ErrorSolution"] = self.errorSolution!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("ErrorSolution") {
                        self.errorSolution = dict["ErrorSolution"] as! String
                    }
                }
            }
            public class RegistrationRequestParameters : Tea.TeaModel {
                public var defaultValue: String?

                public var exampleValue: String?

                public var isRequiredParameter: Bool?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public var parameterOperator: Int32?

                public var parameterPosition: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.isRequiredParameter != nil {
                        map["IsRequiredParameter"] = self.isRequiredParameter!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.parameterOperator != nil {
                        map["ParameterOperator"] = self.parameterOperator!
                    }
                    if self.parameterPosition != nil {
                        map["ParameterPosition"] = self.parameterPosition!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DefaultValue") {
                        self.defaultValue = dict["DefaultValue"] as! String
                    }
                    if dict.keys.contains("ExampleValue") {
                        self.exampleValue = dict["ExampleValue"] as! String
                    }
                    if dict.keys.contains("IsRequiredParameter") {
                        self.isRequiredParameter = dict["IsRequiredParameter"] as! Bool
                    }
                    if dict.keys.contains("ParameterDataType") {
                        self.parameterDataType = dict["ParameterDataType"] as! Int32
                    }
                    if dict.keys.contains("ParameterDescription") {
                        self.parameterDescription = dict["ParameterDescription"] as! String
                    }
                    if dict.keys.contains("ParameterName") {
                        self.parameterName = dict["ParameterName"] as! String
                    }
                    if dict.keys.contains("ParameterOperator") {
                        self.parameterOperator = dict["ParameterOperator"] as! Int32
                    }
                    if dict.keys.contains("ParameterPosition") {
                        self.parameterPosition = dict["ParameterPosition"] as! Int32
                    }
                }
            }
            public var failedResultSample: String?

            public var registrationErrorCodes: [GetDataServicePublishedApiResponseBody.Data.RegistrationDetails.RegistrationErrorCodes]?

            public var registrationRequestParameters: [GetDataServicePublishedApiResponseBody.Data.RegistrationDetails.RegistrationRequestParameters]?

            public var serviceContentType: Int32?

            public var serviceHost: String?

            public var servicePath: String?

            public var serviceRequestBodyDescription: String?

            public var successfulResultSample: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedResultSample != nil {
                    map["FailedResultSample"] = self.failedResultSample!
                }
                if self.registrationErrorCodes != nil {
                    var tmp : [Any] = []
                    for k in self.registrationErrorCodes! {
                        tmp.append(k.toMap())
                    }
                    map["RegistrationErrorCodes"] = tmp
                }
                if self.registrationRequestParameters != nil {
                    var tmp : [Any] = []
                    for k in self.registrationRequestParameters! {
                        tmp.append(k.toMap())
                    }
                    map["RegistrationRequestParameters"] = tmp
                }
                if self.serviceContentType != nil {
                    map["ServiceContentType"] = self.serviceContentType!
                }
                if self.serviceHost != nil {
                    map["ServiceHost"] = self.serviceHost!
                }
                if self.servicePath != nil {
                    map["ServicePath"] = self.servicePath!
                }
                if self.serviceRequestBodyDescription != nil {
                    map["ServiceRequestBodyDescription"] = self.serviceRequestBodyDescription!
                }
                if self.successfulResultSample != nil {
                    map["SuccessfulResultSample"] = self.successfulResultSample!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedResultSample") {
                    self.failedResultSample = dict["FailedResultSample"] as! String
                }
                if dict.keys.contains("RegistrationErrorCodes") {
                    var tmp : [GetDataServicePublishedApiResponseBody.Data.RegistrationDetails.RegistrationErrorCodes] = []
                    for v in dict["RegistrationErrorCodes"] as! [Any] {
                        var model = GetDataServicePublishedApiResponseBody.Data.RegistrationDetails.RegistrationErrorCodes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.registrationErrorCodes = tmp
                }
                if dict.keys.contains("RegistrationRequestParameters") {
                    var tmp : [GetDataServicePublishedApiResponseBody.Data.RegistrationDetails.RegistrationRequestParameters] = []
                    for v in dict["RegistrationRequestParameters"] as! [Any] {
                        var model = GetDataServicePublishedApiResponseBody.Data.RegistrationDetails.RegistrationRequestParameters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.registrationRequestParameters = tmp
                }
                if dict.keys.contains("ServiceContentType") {
                    self.serviceContentType = dict["ServiceContentType"] as! Int32
                }
                if dict.keys.contains("ServiceHost") {
                    self.serviceHost = dict["ServiceHost"] as! String
                }
                if dict.keys.contains("ServicePath") {
                    self.servicePath = dict["ServicePath"] as! String
                }
                if dict.keys.contains("ServiceRequestBodyDescription") {
                    self.serviceRequestBodyDescription = dict["ServiceRequestBodyDescription"] as! String
                }
                if dict.keys.contains("SuccessfulResultSample") {
                    self.successfulResultSample = dict["SuccessfulResultSample"] as! String
                }
            }
        }
        public class ScriptDetails : Tea.TeaModel {
            public class ScriptConnection : Tea.TeaModel {
                public var connectionId: Int64?

                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connectionId != nil {
                        map["ConnectionId"] = self.connectionId!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConnectionId") {
                        self.connectionId = dict["ConnectionId"] as! Int64
                    }
                    if dict.keys.contains("TableName") {
                        self.tableName = dict["TableName"] as! String
                    }
                }
            }
            public class ScriptErrorCodes : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var errorSolution: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.errorSolution != nil {
                        map["ErrorSolution"] = self.errorSolution!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("ErrorSolution") {
                        self.errorSolution = dict["ErrorSolution"] as! String
                    }
                }
            }
            public class ScriptRequestParameters : Tea.TeaModel {
                public var defaultValue: String?

                public var exampleValue: String?

                public var isRequiredParameter: Bool?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public var parameterOperator: Int32?

                public var parameterPosition: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.isRequiredParameter != nil {
                        map["IsRequiredParameter"] = self.isRequiredParameter!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.parameterOperator != nil {
                        map["ParameterOperator"] = self.parameterOperator!
                    }
                    if self.parameterPosition != nil {
                        map["ParameterPosition"] = self.parameterPosition!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DefaultValue") {
                        self.defaultValue = dict["DefaultValue"] as! String
                    }
                    if dict.keys.contains("ExampleValue") {
                        self.exampleValue = dict["ExampleValue"] as! String
                    }
                    if dict.keys.contains("IsRequiredParameter") {
                        self.isRequiredParameter = dict["IsRequiredParameter"] as! Bool
                    }
                    if dict.keys.contains("ParameterDataType") {
                        self.parameterDataType = dict["ParameterDataType"] as! Int32
                    }
                    if dict.keys.contains("ParameterDescription") {
                        self.parameterDescription = dict["ParameterDescription"] as! String
                    }
                    if dict.keys.contains("ParameterName") {
                        self.parameterName = dict["ParameterName"] as! String
                    }
                    if dict.keys.contains("ParameterOperator") {
                        self.parameterOperator = dict["ParameterOperator"] as! Int32
                    }
                    if dict.keys.contains("ParameterPosition") {
                        self.parameterPosition = dict["ParameterPosition"] as! Int32
                    }
                }
            }
            public class ScriptResponseParameters : Tea.TeaModel {
                public var exampleValue: String?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ExampleValue") {
                        self.exampleValue = dict["ExampleValue"] as! String
                    }
                    if dict.keys.contains("ParameterDataType") {
                        self.parameterDataType = dict["ParameterDataType"] as! Int32
                    }
                    if dict.keys.contains("ParameterDescription") {
                        self.parameterDescription = dict["ParameterDescription"] as! String
                    }
                    if dict.keys.contains("ParameterName") {
                        self.parameterName = dict["ParameterName"] as! String
                    }
                }
            }
            public var failedResultSample: String?

            public var isPagedResponse: Bool?

            public var script: String?

            public var scriptConnection: GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptConnection?

            public var scriptErrorCodes: [GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptErrorCodes]?

            public var scriptRequestParameters: [GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptRequestParameters]?

            public var scriptResponseParameters: [GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptResponseParameters]?

            public var successfulResultSample: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.scriptConnection?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedResultSample != nil {
                    map["FailedResultSample"] = self.failedResultSample!
                }
                if self.isPagedResponse != nil {
                    map["IsPagedResponse"] = self.isPagedResponse!
                }
                if self.script != nil {
                    map["Script"] = self.script!
                }
                if self.scriptConnection != nil {
                    map["ScriptConnection"] = self.scriptConnection?.toMap()
                }
                if self.scriptErrorCodes != nil {
                    var tmp : [Any] = []
                    for k in self.scriptErrorCodes! {
                        tmp.append(k.toMap())
                    }
                    map["ScriptErrorCodes"] = tmp
                }
                if self.scriptRequestParameters != nil {
                    var tmp : [Any] = []
                    for k in self.scriptRequestParameters! {
                        tmp.append(k.toMap())
                    }
                    map["ScriptRequestParameters"] = tmp
                }
                if self.scriptResponseParameters != nil {
                    var tmp : [Any] = []
                    for k in self.scriptResponseParameters! {
                        tmp.append(k.toMap())
                    }
                    map["ScriptResponseParameters"] = tmp
                }
                if self.successfulResultSample != nil {
                    map["SuccessfulResultSample"] = self.successfulResultSample!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedResultSample") {
                    self.failedResultSample = dict["FailedResultSample"] as! String
                }
                if dict.keys.contains("IsPagedResponse") {
                    self.isPagedResponse = dict["IsPagedResponse"] as! Bool
                }
                if dict.keys.contains("Script") {
                    self.script = dict["Script"] as! String
                }
                if dict.keys.contains("ScriptConnection") {
                    var model = GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptConnection()
                    model.fromMap(dict["ScriptConnection"] as! [String: Any])
                    self.scriptConnection = model
                }
                if dict.keys.contains("ScriptErrorCodes") {
                    var tmp : [GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptErrorCodes] = []
                    for v in dict["ScriptErrorCodes"] as! [Any] {
                        var model = GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptErrorCodes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.scriptErrorCodes = tmp
                }
                if dict.keys.contains("ScriptRequestParameters") {
                    var tmp : [GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptRequestParameters] = []
                    for v in dict["ScriptRequestParameters"] as! [Any] {
                        var model = GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptRequestParameters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.scriptRequestParameters = tmp
                }
                if dict.keys.contains("ScriptResponseParameters") {
                    var tmp : [GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptResponseParameters] = []
                    for v in dict["ScriptResponseParameters"] as! [Any] {
                        var model = GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptResponseParameters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.scriptResponseParameters = tmp
                }
                if dict.keys.contains("SuccessfulResultSample") {
                    self.successfulResultSample = dict["SuccessfulResultSample"] as! String
                }
            }
        }
        public class WizardDetails : Tea.TeaModel {
            public class WizardConnection : Tea.TeaModel {
                public var connectionId: Int64?

                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connectionId != nil {
                        map["ConnectionId"] = self.connectionId!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConnectionId") {
                        self.connectionId = dict["ConnectionId"] as! Int64
                    }
                    if dict.keys.contains("TableName") {
                        self.tableName = dict["TableName"] as! String
                    }
                }
            }
            public class WizardErrorCodes : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var errorSolution: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.errorSolution != nil {
                        map["ErrorSolution"] = self.errorSolution!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("ErrorSolution") {
                        self.errorSolution = dict["ErrorSolution"] as! String
                    }
                }
            }
            public class WizardRequestParameters : Tea.TeaModel {
                public var defaultValue: String?

                public var exampleValue: String?

                public var isRequiredParameter: Bool?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public var parameterOperator: Int32?

                public var parameterPosition: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.isRequiredParameter != nil {
                        map["IsRequiredParameter"] = self.isRequiredParameter!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.parameterOperator != nil {
                        map["ParameterOperator"] = self.parameterOperator!
                    }
                    if self.parameterPosition != nil {
                        map["ParameterPosition"] = self.parameterPosition!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DefaultValue") {
                        self.defaultValue = dict["DefaultValue"] as! String
                    }
                    if dict.keys.contains("ExampleValue") {
                        self.exampleValue = dict["ExampleValue"] as! String
                    }
                    if dict.keys.contains("IsRequiredParameter") {
                        self.isRequiredParameter = dict["IsRequiredParameter"] as! Bool
                    }
                    if dict.keys.contains("ParameterDataType") {
                        self.parameterDataType = dict["ParameterDataType"] as! Int32
                    }
                    if dict.keys.contains("ParameterDescription") {
                        self.parameterDescription = dict["ParameterDescription"] as! String
                    }
                    if dict.keys.contains("ParameterName") {
                        self.parameterName = dict["ParameterName"] as! String
                    }
                    if dict.keys.contains("ParameterOperator") {
                        self.parameterOperator = dict["ParameterOperator"] as! Int32
                    }
                    if dict.keys.contains("ParameterPosition") {
                        self.parameterPosition = dict["ParameterPosition"] as! Int32
                    }
                }
            }
            public class WizardResponseParameters : Tea.TeaModel {
                public var exampleValue: String?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ExampleValue") {
                        self.exampleValue = dict["ExampleValue"] as! String
                    }
                    if dict.keys.contains("ParameterDataType") {
                        self.parameterDataType = dict["ParameterDataType"] as! Int32
                    }
                    if dict.keys.contains("ParameterDescription") {
                        self.parameterDescription = dict["ParameterDescription"] as! String
                    }
                    if dict.keys.contains("ParameterName") {
                        self.parameterName = dict["ParameterName"] as! String
                    }
                }
            }
            public var failedResultSample: String?

            public var isPagedResponse: Bool?

            public var successfulResultSample: String?

            public var wizardConnection: GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardConnection?

            public var wizardErrorCodes: [GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardErrorCodes]?

            public var wizardRequestParameters: [GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardRequestParameters]?

            public var wizardResponseParameters: [GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardResponseParameters]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.wizardConnection?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedResultSample != nil {
                    map["FailedResultSample"] = self.failedResultSample!
                }
                if self.isPagedResponse != nil {
                    map["IsPagedResponse"] = self.isPagedResponse!
                }
                if self.successfulResultSample != nil {
                    map["SuccessfulResultSample"] = self.successfulResultSample!
                }
                if self.wizardConnection != nil {
                    map["WizardConnection"] = self.wizardConnection?.toMap()
                }
                if self.wizardErrorCodes != nil {
                    var tmp : [Any] = []
                    for k in self.wizardErrorCodes! {
                        tmp.append(k.toMap())
                    }
                    map["WizardErrorCodes"] = tmp
                }
                if self.wizardRequestParameters != nil {
                    var tmp : [Any] = []
                    for k in self.wizardRequestParameters! {
                        tmp.append(k.toMap())
                    }
                    map["WizardRequestParameters"] = tmp
                }
                if self.wizardResponseParameters != nil {
                    var tmp : [Any] = []
                    for k in self.wizardResponseParameters! {
                        tmp.append(k.toMap())
                    }
                    map["WizardResponseParameters"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedResultSample") {
                    self.failedResultSample = dict["FailedResultSample"] as! String
                }
                if dict.keys.contains("IsPagedResponse") {
                    self.isPagedResponse = dict["IsPagedResponse"] as! Bool
                }
                if dict.keys.contains("SuccessfulResultSample") {
                    self.successfulResultSample = dict["SuccessfulResultSample"] as! String
                }
                if dict.keys.contains("WizardConnection") {
                    var model = GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardConnection()
                    model.fromMap(dict["WizardConnection"] as! [String: Any])
                    self.wizardConnection = model
                }
                if dict.keys.contains("WizardErrorCodes") {
                    var tmp : [GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardErrorCodes] = []
                    for v in dict["WizardErrorCodes"] as! [Any] {
                        var model = GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardErrorCodes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.wizardErrorCodes = tmp
                }
                if dict.keys.contains("WizardRequestParameters") {
                    var tmp : [GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardRequestParameters] = []
                    for v in dict["WizardRequestParameters"] as! [Any] {
                        var model = GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardRequestParameters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.wizardRequestParameters = tmp
                }
                if dict.keys.contains("WizardResponseParameters") {
                    var tmp : [GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardResponseParameters] = []
                    for v in dict["WizardResponseParameters"] as! [Any] {
                        var model = GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardResponseParameters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.wizardResponseParameters = tmp
                }
            }
        }
        public var apiId: Int64?

        public var apiMode: Int32?

        public var apiName: String?

        public var apiPath: String?

        public var createdTime: String?

        public var creatorId: String?

        public var description_: String?

        public var groupId: String?

        public var modifiedTime: String?

        public var operatorId: String?

        public var projectId: Int64?

        public var protocols: [Int32]?

        public var registrationDetails: GetDataServicePublishedApiResponseBody.Data.RegistrationDetails?

        public var requestMethod: Int32?

        public var responseContentType: Int32?

        public var scriptDetails: GetDataServicePublishedApiResponseBody.Data.ScriptDetails?

        public var status: Int32?

        public var tenantId: Int64?

        public var timeout: Int32?

        public var visibleRange: Int32?

        public var wizardDetails: GetDataServicePublishedApiResponseBody.Data.WizardDetails?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.registrationDetails?.validate()
            try self.scriptDetails?.validate()
            try self.wizardDetails?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiId != nil {
                map["ApiId"] = self.apiId!
            }
            if self.apiMode != nil {
                map["ApiMode"] = self.apiMode!
            }
            if self.apiName != nil {
                map["ApiName"] = self.apiName!
            }
            if self.apiPath != nil {
                map["ApiPath"] = self.apiPath!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.operatorId != nil {
                map["OperatorId"] = self.operatorId!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.protocols != nil {
                map["Protocols"] = self.protocols!
            }
            if self.registrationDetails != nil {
                map["RegistrationDetails"] = self.registrationDetails?.toMap()
            }
            if self.requestMethod != nil {
                map["RequestMethod"] = self.requestMethod!
            }
            if self.responseContentType != nil {
                map["ResponseContentType"] = self.responseContentType!
            }
            if self.scriptDetails != nil {
                map["ScriptDetails"] = self.scriptDetails?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout!
            }
            if self.visibleRange != nil {
                map["VisibleRange"] = self.visibleRange!
            }
            if self.wizardDetails != nil {
                map["WizardDetails"] = self.wizardDetails?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiId") {
                self.apiId = dict["ApiId"] as! Int64
            }
            if dict.keys.contains("ApiMode") {
                self.apiMode = dict["ApiMode"] as! Int32
            }
            if dict.keys.contains("ApiName") {
                self.apiName = dict["ApiName"] as! String
            }
            if dict.keys.contains("ApiPath") {
                self.apiPath = dict["ApiPath"] as! String
            }
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("OperatorId") {
                self.operatorId = dict["OperatorId"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("Protocols") {
                self.protocols = dict["Protocols"] as! [Int32]
            }
            if dict.keys.contains("RegistrationDetails") {
                var model = GetDataServicePublishedApiResponseBody.Data.RegistrationDetails()
                model.fromMap(dict["RegistrationDetails"] as! [String: Any])
                self.registrationDetails = model
            }
            if dict.keys.contains("RequestMethod") {
                self.requestMethod = dict["RequestMethod"] as! Int32
            }
            if dict.keys.contains("ResponseContentType") {
                self.responseContentType = dict["ResponseContentType"] as! Int32
            }
            if dict.keys.contains("ScriptDetails") {
                var model = GetDataServicePublishedApiResponseBody.Data.ScriptDetails()
                model.fromMap(dict["ScriptDetails"] as! [String: Any])
                self.scriptDetails = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
            if dict.keys.contains("Timeout") {
                self.timeout = dict["Timeout"] as! Int32
            }
            if dict.keys.contains("VisibleRange") {
                self.visibleRange = dict["VisibleRange"] as! Int32
            }
            if dict.keys.contains("WizardDetails") {
                var model = GetDataServicePublishedApiResponseBody.Data.WizardDetails()
                model.fromMap(dict["WizardDetails"] as! [String: Any])
                self.wizardDetails = model
            }
        }
    }
    public var data: GetDataServicePublishedApiResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDataServicePublishedApiResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataServicePublishedApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataServicePublishedApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataServicePublishedApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataSourceMetaRequest : Tea.TeaModel {
    public var datasourceName: String?

    public var envType: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasourceName != nil {
            map["DatasourceName"] = self.datasourceName!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasourceName") {
            self.datasourceName = dict["DatasourceName"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class GetDataSourceMetaResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var meta: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.meta != nil {
                map["Meta"] = self.meta!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Meta") {
                self.meta = dict["Meta"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: GetDataSourceMetaResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDataSourceMetaResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataSourceMetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataSourceMetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataSourceMetaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDeploymentRequest : Tea.TeaModel {
    public var deploymentId: Int64?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentId != nil {
            map["DeploymentId"] = self.deploymentId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeploymentId") {
            self.deploymentId = dict["DeploymentId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class GetDeploymentResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DeployedItems : Tea.TeaModel {
            public var fileId: Int64?

            public var fileVersion: Int64?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.fileVersion != nil {
                    map["FileVersion"] = self.fileVersion!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileId") {
                    self.fileId = dict["FileId"] as! Int64
                }
                if dict.keys.contains("FileVersion") {
                    self.fileVersion = dict["FileVersion"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public class Deployment : Tea.TeaModel {
            public var checkingStatus: Int32?

            public var createTime: Int64?

            public var creatorId: String?

            public var errorMessage: String?

            public var executeTime: Int64?

            public var fromEnvironment: Int32?

            public var handlerId: String?

            public var name: String?

            public var status: Int32?

            public var toEnvironment: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkingStatus != nil {
                    map["CheckingStatus"] = self.checkingStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.executeTime != nil {
                    map["ExecuteTime"] = self.executeTime!
                }
                if self.fromEnvironment != nil {
                    map["FromEnvironment"] = self.fromEnvironment!
                }
                if self.handlerId != nil {
                    map["HandlerId"] = self.handlerId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.toEnvironment != nil {
                    map["ToEnvironment"] = self.toEnvironment!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CheckingStatus") {
                    self.checkingStatus = dict["CheckingStatus"] as! Int32
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CreatorId") {
                    self.creatorId = dict["CreatorId"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("ExecuteTime") {
                    self.executeTime = dict["ExecuteTime"] as! Int64
                }
                if dict.keys.contains("FromEnvironment") {
                    self.fromEnvironment = dict["FromEnvironment"] as! Int32
                }
                if dict.keys.contains("HandlerId") {
                    self.handlerId = dict["HandlerId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("ToEnvironment") {
                    self.toEnvironment = dict["ToEnvironment"] as! Int32
                }
            }
        }
        public var deployedItems: [GetDeploymentResponseBody.Data.DeployedItems]?

        public var deployment: GetDeploymentResponseBody.Data.Deployment?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.deployment?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deployedItems != nil {
                var tmp : [Any] = []
                for k in self.deployedItems! {
                    tmp.append(k.toMap())
                }
                map["DeployedItems"] = tmp
            }
            if self.deployment != nil {
                map["Deployment"] = self.deployment?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeployedItems") {
                var tmp : [GetDeploymentResponseBody.Data.DeployedItems] = []
                for v in dict["DeployedItems"] as! [Any] {
                    var model = GetDeploymentResponseBody.Data.DeployedItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deployedItems = tmp
            }
            if dict.keys.contains("Deployment") {
                var model = GetDeploymentResponseBody.Data.Deployment()
                model.fromMap(dict["Deployment"] as! [String: Any])
                self.deployment = model
            }
        }
    }
    public var data: GetDeploymentResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDeploymentResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDeploymentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeploymentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDeploymentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetExtensionRequest : Tea.TeaModel {
    public var extensionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extensionCode != nil {
            map["ExtensionCode"] = self.extensionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExtensionCode") {
            self.extensionCode = dict["ExtensionCode"] as! String
        }
    }
}

public class GetExtensionResponseBody : Tea.TeaModel {
    public class Extension_ : Tea.TeaModel {
        public class BindEventList : Tea.TeaModel {
            public var eventCode: String?

            public var eventName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventCode != nil {
                    map["EventCode"] = self.eventCode!
                }
                if self.eventName != nil {
                    map["EventName"] = self.eventName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EventCode") {
                    self.eventCode = dict["EventCode"] as! String
                }
                if dict.keys.contains("EventName") {
                    self.eventName = dict["EventName"] as! String
                }
            }
        }
        public class EventCategoryList : Tea.TeaModel {
            public var categoryCode: String?

            public var categoryName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.categoryCode != nil {
                    map["CategoryCode"] = self.categoryCode!
                }
                if self.categoryName != nil {
                    map["CategoryName"] = self.categoryName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CategoryCode") {
                    self.categoryCode = dict["CategoryCode"] as! String
                }
                if dict.keys.contains("CategoryName") {
                    self.categoryName = dict["CategoryName"] as! String
                }
            }
        }
        public var bindEventList: [GetExtensionResponseBody.Extension_.BindEventList]?

        public var detailUrl: String?

        public var eventCategoryList: [GetExtensionResponseBody.Extension_.EventCategoryList]?

        public var extensionCode: String?

        public var extensionDesc: String?

        public var extensionName: String?

        public var helpDocUrl: String?

        public var optionSetting: String?

        public var parameterSetting: String?

        public var projectTesting: Int64?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bindEventList != nil {
                var tmp : [Any] = []
                for k in self.bindEventList! {
                    tmp.append(k.toMap())
                }
                map["BindEventList"] = tmp
            }
            if self.detailUrl != nil {
                map["DetailUrl"] = self.detailUrl!
            }
            if self.eventCategoryList != nil {
                var tmp : [Any] = []
                for k in self.eventCategoryList! {
                    tmp.append(k.toMap())
                }
                map["EventCategoryList"] = tmp
            }
            if self.extensionCode != nil {
                map["ExtensionCode"] = self.extensionCode!
            }
            if self.extensionDesc != nil {
                map["ExtensionDesc"] = self.extensionDesc!
            }
            if self.extensionName != nil {
                map["ExtensionName"] = self.extensionName!
            }
            if self.helpDocUrl != nil {
                map["HelpDocUrl"] = self.helpDocUrl!
            }
            if self.optionSetting != nil {
                map["OptionSetting"] = self.optionSetting!
            }
            if self.parameterSetting != nil {
                map["ParameterSetting"] = self.parameterSetting!
            }
            if self.projectTesting != nil {
                map["ProjectTesting"] = self.projectTesting!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BindEventList") {
                var tmp : [GetExtensionResponseBody.Extension_.BindEventList] = []
                for v in dict["BindEventList"] as! [Any] {
                    var model = GetExtensionResponseBody.Extension_.BindEventList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.bindEventList = tmp
            }
            if dict.keys.contains("DetailUrl") {
                self.detailUrl = dict["DetailUrl"] as! String
            }
            if dict.keys.contains("EventCategoryList") {
                var tmp : [GetExtensionResponseBody.Extension_.EventCategoryList] = []
                for v in dict["EventCategoryList"] as! [Any] {
                    var model = GetExtensionResponseBody.Extension_.EventCategoryList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eventCategoryList = tmp
            }
            if dict.keys.contains("ExtensionCode") {
                self.extensionCode = dict["ExtensionCode"] as! String
            }
            if dict.keys.contains("ExtensionDesc") {
                self.extensionDesc = dict["ExtensionDesc"] as! String
            }
            if dict.keys.contains("ExtensionName") {
                self.extensionName = dict["ExtensionName"] as! String
            }
            if dict.keys.contains("HelpDocUrl") {
                self.helpDocUrl = dict["HelpDocUrl"] as! String
            }
            if dict.keys.contains("OptionSetting") {
                self.optionSetting = dict["OptionSetting"] as! String
            }
            if dict.keys.contains("ParameterSetting") {
                self.parameterSetting = dict["ParameterSetting"] as! String
            }
            if dict.keys.contains("ProjectTesting") {
                self.projectTesting = dict["ProjectTesting"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
        }
    }
    public var extension_: GetExtensionResponseBody.Extension_?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.extension_?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extension_ != nil {
            map["Extension"] = self.extension_?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Extension") {
            var model = GetExtensionResponseBody.Extension_()
            model.fromMap(dict["Extension"] as! [String: Any])
            self.extension_ = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetExtensionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetExtensionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetExtensionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFileRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var nodeId: Int64?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! Int64
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class GetFileResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class File : Tea.TeaModel {
            public var advancedSettings: String?

            public var autoParsing: Bool?

            public var bizId: Int64?

            public var businessId: Int64?

            public var commitStatus: Int32?

            public var connectionName: String?

            public var content: String?

            public var createTime: Int64?

            public var createUser: String?

            public var currentVersion: Int32?

            public var deletedStatus: String?

            public var fileDescription: String?

            public var fileFolderId: String?

            public var fileId: Int64?

            public var fileName: String?

            public var fileType: Int32?

            public var isMaxCompute: Bool?

            public var lastEditTime: Int64?

            public var lastEditUser: String?

            public var nodeId: Int64?

            public var owner: String?

            public var parentId: Int64?

            public var useType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.advancedSettings != nil {
                    map["AdvancedSettings"] = self.advancedSettings!
                }
                if self.autoParsing != nil {
                    map["AutoParsing"] = self.autoParsing!
                }
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.businessId != nil {
                    map["BusinessId"] = self.businessId!
                }
                if self.commitStatus != nil {
                    map["CommitStatus"] = self.commitStatus!
                }
                if self.connectionName != nil {
                    map["ConnectionName"] = self.connectionName!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.currentVersion != nil {
                    map["CurrentVersion"] = self.currentVersion!
                }
                if self.deletedStatus != nil {
                    map["DeletedStatus"] = self.deletedStatus!
                }
                if self.fileDescription != nil {
                    map["FileDescription"] = self.fileDescription!
                }
                if self.fileFolderId != nil {
                    map["FileFolderId"] = self.fileFolderId!
                }
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.fileType != nil {
                    map["FileType"] = self.fileType!
                }
                if self.isMaxCompute != nil {
                    map["IsMaxCompute"] = self.isMaxCompute!
                }
                if self.lastEditTime != nil {
                    map["LastEditTime"] = self.lastEditTime!
                }
                if self.lastEditUser != nil {
                    map["LastEditUser"] = self.lastEditUser!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.useType != nil {
                    map["UseType"] = self.useType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdvancedSettings") {
                    self.advancedSettings = dict["AdvancedSettings"] as! String
                }
                if dict.keys.contains("AutoParsing") {
                    self.autoParsing = dict["AutoParsing"] as! Bool
                }
                if dict.keys.contains("BizId") {
                    self.bizId = dict["BizId"] as! Int64
                }
                if dict.keys.contains("BusinessId") {
                    self.businessId = dict["BusinessId"] as! Int64
                }
                if dict.keys.contains("CommitStatus") {
                    self.commitStatus = dict["CommitStatus"] as! Int32
                }
                if dict.keys.contains("ConnectionName") {
                    self.connectionName = dict["ConnectionName"] as! String
                }
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CreateUser") {
                    self.createUser = dict["CreateUser"] as! String
                }
                if dict.keys.contains("CurrentVersion") {
                    self.currentVersion = dict["CurrentVersion"] as! Int32
                }
                if dict.keys.contains("DeletedStatus") {
                    self.deletedStatus = dict["DeletedStatus"] as! String
                }
                if dict.keys.contains("FileDescription") {
                    self.fileDescription = dict["FileDescription"] as! String
                }
                if dict.keys.contains("FileFolderId") {
                    self.fileFolderId = dict["FileFolderId"] as! String
                }
                if dict.keys.contains("FileId") {
                    self.fileId = dict["FileId"] as! Int64
                }
                if dict.keys.contains("FileName") {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("FileType") {
                    self.fileType = dict["FileType"] as! Int32
                }
                if dict.keys.contains("IsMaxCompute") {
                    self.isMaxCompute = dict["IsMaxCompute"] as! Bool
                }
                if dict.keys.contains("LastEditTime") {
                    self.lastEditTime = dict["LastEditTime"] as! Int64
                }
                if dict.keys.contains("LastEditUser") {
                    self.lastEditUser = dict["LastEditUser"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("ParentId") {
                    self.parentId = dict["ParentId"] as! Int64
                }
                if dict.keys.contains("UseType") {
                    self.useType = dict["UseType"] as! String
                }
            }
        }
        public class NodeConfiguration : Tea.TeaModel {
            public class InputList : Tea.TeaModel {
                public var input: String?

                public var parseType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.input != nil {
                        map["Input"] = self.input!
                    }
                    if self.parseType != nil {
                        map["ParseType"] = self.parseType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Input") {
                        self.input = dict["Input"] as! String
                    }
                    if dict.keys.contains("ParseType") {
                        self.parseType = dict["ParseType"] as! String
                    }
                }
            }
            public class InputParameters : Tea.TeaModel {
                public var parameterName: String?

                public var valueSource: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.valueSource != nil {
                        map["ValueSource"] = self.valueSource!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ParameterName") {
                        self.parameterName = dict["ParameterName"] as! String
                    }
                    if dict.keys.contains("ValueSource") {
                        self.valueSource = dict["ValueSource"] as! String
                    }
                }
            }
            public class OutputList : Tea.TeaModel {
                public var output: String?

                public var refTableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.output != nil {
                        map["Output"] = self.output!
                    }
                    if self.refTableName != nil {
                        map["RefTableName"] = self.refTableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Output") {
                        self.output = dict["Output"] as! String
                    }
                    if dict.keys.contains("RefTableName") {
                        self.refTableName = dict["RefTableName"] as! String
                    }
                }
            }
            public class OutputParameters : Tea.TeaModel {
                public var description_: String?

                public var parameterName: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("ParameterName") {
                        self.parameterName = dict["ParameterName"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var applyScheduleImmediately: String?

            public var autoRerunIntervalMillis: Int32?

            public var autoRerunTimes: Int32?

            public var cronExpress: String?

            public var cycleType: String?

            public var dependentNodeIdList: String?

            public var dependentType: String?

            public var endEffectDate: Int64?

            public var ignoreParentSkipRunningProperty: String?

            public var imageId: String?

            public var inputList: [GetFileResponseBody.Data.NodeConfiguration.InputList]?

            public var inputParameters: [GetFileResponseBody.Data.NodeConfiguration.InputParameters]?

            public var outputList: [GetFileResponseBody.Data.NodeConfiguration.OutputList]?

            public var outputParameters: [GetFileResponseBody.Data.NodeConfiguration.OutputParameters]?

            public var paraValue: String?

            public var rerunMode: String?

            public var resourceGroupId: Int64?

            public var schedulerType: String?

            public var startEffectDate: Int64?

            public var startImmediately: Bool?

            public var stop: Bool?

            public var timeout: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applyScheduleImmediately != nil {
                    map["ApplyScheduleImmediately"] = self.applyScheduleImmediately!
                }
                if self.autoRerunIntervalMillis != nil {
                    map["AutoRerunIntervalMillis"] = self.autoRerunIntervalMillis!
                }
                if self.autoRerunTimes != nil {
                    map["AutoRerunTimes"] = self.autoRerunTimes!
                }
                if self.cronExpress != nil {
                    map["CronExpress"] = self.cronExpress!
                }
                if self.cycleType != nil {
                    map["CycleType"] = self.cycleType!
                }
                if self.dependentNodeIdList != nil {
                    map["DependentNodeIdList"] = self.dependentNodeIdList!
                }
                if self.dependentType != nil {
                    map["DependentType"] = self.dependentType!
                }
                if self.endEffectDate != nil {
                    map["EndEffectDate"] = self.endEffectDate!
                }
                if self.ignoreParentSkipRunningProperty != nil {
                    map["IgnoreParentSkipRunningProperty"] = self.ignoreParentSkipRunningProperty!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.inputList != nil {
                    var tmp : [Any] = []
                    for k in self.inputList! {
                        tmp.append(k.toMap())
                    }
                    map["InputList"] = tmp
                }
                if self.inputParameters != nil {
                    var tmp : [Any] = []
                    for k in self.inputParameters! {
                        tmp.append(k.toMap())
                    }
                    map["InputParameters"] = tmp
                }
                if self.outputList != nil {
                    var tmp : [Any] = []
                    for k in self.outputList! {
                        tmp.append(k.toMap())
                    }
                    map["OutputList"] = tmp
                }
                if self.outputParameters != nil {
                    var tmp : [Any] = []
                    for k in self.outputParameters! {
                        tmp.append(k.toMap())
                    }
                    map["OutputParameters"] = tmp
                }
                if self.paraValue != nil {
                    map["ParaValue"] = self.paraValue!
                }
                if self.rerunMode != nil {
                    map["RerunMode"] = self.rerunMode!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.schedulerType != nil {
                    map["SchedulerType"] = self.schedulerType!
                }
                if self.startEffectDate != nil {
                    map["StartEffectDate"] = self.startEffectDate!
                }
                if self.startImmediately != nil {
                    map["StartImmediately"] = self.startImmediately!
                }
                if self.stop != nil {
                    map["Stop"] = self.stop!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApplyScheduleImmediately") {
                    self.applyScheduleImmediately = dict["ApplyScheduleImmediately"] as! String
                }
                if dict.keys.contains("AutoRerunIntervalMillis") {
                    self.autoRerunIntervalMillis = dict["AutoRerunIntervalMillis"] as! Int32
                }
                if dict.keys.contains("AutoRerunTimes") {
                    self.autoRerunTimes = dict["AutoRerunTimes"] as! Int32
                }
                if dict.keys.contains("CronExpress") {
                    self.cronExpress = dict["CronExpress"] as! String
                }
                if dict.keys.contains("CycleType") {
                    self.cycleType = dict["CycleType"] as! String
                }
                if dict.keys.contains("DependentNodeIdList") {
                    self.dependentNodeIdList = dict["DependentNodeIdList"] as! String
                }
                if dict.keys.contains("DependentType") {
                    self.dependentType = dict["DependentType"] as! String
                }
                if dict.keys.contains("EndEffectDate") {
                    self.endEffectDate = dict["EndEffectDate"] as! Int64
                }
                if dict.keys.contains("IgnoreParentSkipRunningProperty") {
                    self.ignoreParentSkipRunningProperty = dict["IgnoreParentSkipRunningProperty"] as! String
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("InputList") {
                    var tmp : [GetFileResponseBody.Data.NodeConfiguration.InputList] = []
                    for v in dict["InputList"] as! [Any] {
                        var model = GetFileResponseBody.Data.NodeConfiguration.InputList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.inputList = tmp
                }
                if dict.keys.contains("InputParameters") {
                    var tmp : [GetFileResponseBody.Data.NodeConfiguration.InputParameters] = []
                    for v in dict["InputParameters"] as! [Any] {
                        var model = GetFileResponseBody.Data.NodeConfiguration.InputParameters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.inputParameters = tmp
                }
                if dict.keys.contains("OutputList") {
                    var tmp : [GetFileResponseBody.Data.NodeConfiguration.OutputList] = []
                    for v in dict["OutputList"] as! [Any] {
                        var model = GetFileResponseBody.Data.NodeConfiguration.OutputList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.outputList = tmp
                }
                if dict.keys.contains("OutputParameters") {
                    var tmp : [GetFileResponseBody.Data.NodeConfiguration.OutputParameters] = []
                    for v in dict["OutputParameters"] as! [Any] {
                        var model = GetFileResponseBody.Data.NodeConfiguration.OutputParameters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.outputParameters = tmp
                }
                if dict.keys.contains("ParaValue") {
                    self.paraValue = dict["ParaValue"] as! String
                }
                if dict.keys.contains("RerunMode") {
                    self.rerunMode = dict["RerunMode"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! Int64
                }
                if dict.keys.contains("SchedulerType") {
                    self.schedulerType = dict["SchedulerType"] as! String
                }
                if dict.keys.contains("StartEffectDate") {
                    self.startEffectDate = dict["StartEffectDate"] as! Int64
                }
                if dict.keys.contains("StartImmediately") {
                    self.startImmediately = dict["StartImmediately"] as! Bool
                }
                if dict.keys.contains("Stop") {
                    self.stop = dict["Stop"] as! Bool
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int32
                }
            }
        }
        public class ResourceDownloadLink : Tea.TeaModel {
            public var downloadLink: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.downloadLink != nil {
                    map["downloadLink"] = self.downloadLink!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("downloadLink") {
                    self.downloadLink = dict["downloadLink"] as! String
                }
            }
        }
        public var file: GetFileResponseBody.Data.File?

        public var nodeConfiguration: GetFileResponseBody.Data.NodeConfiguration?

        public var resourceDownloadLink: GetFileResponseBody.Data.ResourceDownloadLink?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.file?.validate()
            try self.nodeConfiguration?.validate()
            try self.resourceDownloadLink?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.file != nil {
                map["File"] = self.file?.toMap()
            }
            if self.nodeConfiguration != nil {
                map["NodeConfiguration"] = self.nodeConfiguration?.toMap()
            }
            if self.resourceDownloadLink != nil {
                map["ResourceDownloadLink"] = self.resourceDownloadLink?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("File") {
                var model = GetFileResponseBody.Data.File()
                model.fromMap(dict["File"] as! [String: Any])
                self.file = model
            }
            if dict.keys.contains("NodeConfiguration") {
                var model = GetFileResponseBody.Data.NodeConfiguration()
                model.fromMap(dict["NodeConfiguration"] as! [String: Any])
                self.nodeConfiguration = model
            }
            if dict.keys.contains("ResourceDownloadLink") {
                var model = GetFileResponseBody.Data.ResourceDownloadLink()
                model.fromMap(dict["ResourceDownloadLink"] as! [String: Any])
                self.resourceDownloadLink = model
            }
        }
    }
    public var data: GetFileResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetFileResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFileTypeStatisticRequest : Tea.TeaModel {
    public var projectEnv: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class GetFileTypeStatisticResponseBody : Tea.TeaModel {
    public class ProgramTypeAndCounts : Tea.TeaModel {
        public var count: Int32?

        public var programType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.programType != nil {
                map["ProgramType"] = self.programType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("ProgramType") {
                self.programType = dict["ProgramType"] as! String
            }
        }
    }
    public var programTypeAndCounts: [GetFileTypeStatisticResponseBody.ProgramTypeAndCounts]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.programTypeAndCounts != nil {
            var tmp : [Any] = []
            for k in self.programTypeAndCounts! {
                tmp.append(k.toMap())
            }
            map["ProgramTypeAndCounts"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProgramTypeAndCounts") {
            var tmp : [GetFileTypeStatisticResponseBody.ProgramTypeAndCounts] = []
            for v in dict["ProgramTypeAndCounts"] as! [Any] {
                var model = GetFileTypeStatisticResponseBody.ProgramTypeAndCounts()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.programTypeAndCounts = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetFileTypeStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileTypeStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFileTypeStatisticResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFileVersionRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var fileVersion: Int32?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.fileVersion != nil {
            map["FileVersion"] = self.fileVersion!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! Int64
        }
        if dict.keys.contains("FileVersion") {
            self.fileVersion = dict["FileVersion"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class GetFileVersionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeType: String?

        public var comment: String?

        public var commitTime: Int64?

        public var commitUser: String?

        public var fileContent: String?

        public var fileName: String?

        public var filePropertyContent: String?

        public var fileVersion: Int32?

        public var isCurrentProd: Bool?

        public var nodeContent: String?

        public var nodeId: Int64?

        public var status: String?

        public var useType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeType != nil {
                map["ChangeType"] = self.changeType!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.commitTime != nil {
                map["CommitTime"] = self.commitTime!
            }
            if self.commitUser != nil {
                map["CommitUser"] = self.commitUser!
            }
            if self.fileContent != nil {
                map["FileContent"] = self.fileContent!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.filePropertyContent != nil {
                map["FilePropertyContent"] = self.filePropertyContent!
            }
            if self.fileVersion != nil {
                map["FileVersion"] = self.fileVersion!
            }
            if self.isCurrentProd != nil {
                map["IsCurrentProd"] = self.isCurrentProd!
            }
            if self.nodeContent != nil {
                map["NodeContent"] = self.nodeContent!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.useType != nil {
                map["UseType"] = self.useType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeType") {
                self.changeType = dict["ChangeType"] as! String
            }
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CommitTime") {
                self.commitTime = dict["CommitTime"] as! Int64
            }
            if dict.keys.contains("CommitUser") {
                self.commitUser = dict["CommitUser"] as! String
            }
            if dict.keys.contains("FileContent") {
                self.fileContent = dict["FileContent"] as! String
            }
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FilePropertyContent") {
                self.filePropertyContent = dict["FilePropertyContent"] as! String
            }
            if dict.keys.contains("FileVersion") {
                self.fileVersion = dict["FileVersion"] as! Int32
            }
            if dict.keys.contains("IsCurrentProd") {
                self.isCurrentProd = dict["IsCurrentProd"] as! Bool
            }
            if dict.keys.contains("NodeContent") {
                self.nodeContent = dict["NodeContent"] as! String
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UseType") {
                self.useType = dict["UseType"] as! String
            }
        }
    }
    public var data: GetFileVersionResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetFileVersionResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetFileVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFileVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFolderRequest : Tea.TeaModel {
    public var folderId: String?

    public var folderPath: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.folderPath != nil {
            map["FolderPath"] = self.folderPath!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FolderId") {
            self.folderId = dict["FolderId"] as! String
        }
        if dict.keys.contains("FolderPath") {
            self.folderPath = dict["FolderPath"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class GetFolderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var folderId: String?

        public var folderPath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.folderId != nil {
                map["FolderId"] = self.folderId!
            }
            if self.folderPath != nil {
                map["FolderPath"] = self.folderPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FolderId") {
                self.folderId = dict["FolderId"] as! String
            }
            if dict.keys.contains("FolderPath") {
                self.folderPath = dict["FolderPath"] as! String
            }
        }
    }
    public var data: GetFolderResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetFolderResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetFolderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFolderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFolderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetIDEEventDetailRequest : Tea.TeaModel {
    public var messageId: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MessageId") {
            self.messageId = dict["MessageId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class GetIDEEventDetailResponseBody : Tea.TeaModel {
    public class EventDetail : Tea.TeaModel {
        public class CommittedFile : Tea.TeaModel {
            public class FilePropertyContent : Tea.TeaModel {
                public var businessId: Int64?

                public var currentVersion: Int64?

                public var dataSourceName: String?

                public var folderId: String?

                public var owner: String?

                public var parentFileId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.businessId != nil {
                        map["BusinessId"] = self.businessId!
                    }
                    if self.currentVersion != nil {
                        map["CurrentVersion"] = self.currentVersion!
                    }
                    if self.dataSourceName != nil {
                        map["DataSourceName"] = self.dataSourceName!
                    }
                    if self.folderId != nil {
                        map["FolderId"] = self.folderId!
                    }
                    if self.owner != nil {
                        map["Owner"] = self.owner!
                    }
                    if self.parentFileId != nil {
                        map["ParentFileId"] = self.parentFileId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BusinessId") {
                        self.businessId = dict["BusinessId"] as! Int64
                    }
                    if dict.keys.contains("CurrentVersion") {
                        self.currentVersion = dict["CurrentVersion"] as! Int64
                    }
                    if dict.keys.contains("DataSourceName") {
                        self.dataSourceName = dict["DataSourceName"] as! String
                    }
                    if dict.keys.contains("FolderId") {
                        self.folderId = dict["FolderId"] as! String
                    }
                    if dict.keys.contains("Owner") {
                        self.owner = dict["Owner"] as! String
                    }
                    if dict.keys.contains("ParentFileId") {
                        self.parentFileId = dict["ParentFileId"] as! Int64
                    }
                }
            }
            public class NodeConfiguration : Tea.TeaModel {
                public class InputList : Tea.TeaModel {
                    public var input: String?

                    public var parseType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.input != nil {
                            map["Input"] = self.input!
                        }
                        if self.parseType != nil {
                            map["ParseType"] = self.parseType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Input") {
                            self.input = dict["Input"] as! String
                        }
                        if dict.keys.contains("ParseType") {
                            self.parseType = dict["ParseType"] as! String
                        }
                    }
                }
                public class OutputList : Tea.TeaModel {
                    public var output: String?

                    public var refTableName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.output != nil {
                            map["Output"] = self.output!
                        }
                        if self.refTableName != nil {
                            map["RefTableName"] = self.refTableName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Output") {
                            self.output = dict["Output"] as! String
                        }
                        if dict.keys.contains("RefTableName") {
                            self.refTableName = dict["RefTableName"] as! String
                        }
                    }
                }
                public var autoRerunIntervalMillis: Int64?

                public var autoRerunTimes: Int64?

                public var cronExpress: String?

                public var cycleType: String?

                public var dependentNodeIdList: String?

                public var dependentType: String?

                public var inputList: [GetIDEEventDetailResponseBody.EventDetail.CommittedFile.NodeConfiguration.InputList]?

                public var outputList: [GetIDEEventDetailResponseBody.EventDetail.CommittedFile.NodeConfiguration.OutputList]?

                public var paraValue: String?

                public var rerunMode: String?

                public var resourceGroupId: Int64?

                public var schedulerType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.autoRerunIntervalMillis != nil {
                        map["AutoRerunIntervalMillis"] = self.autoRerunIntervalMillis!
                    }
                    if self.autoRerunTimes != nil {
                        map["AutoRerunTimes"] = self.autoRerunTimes!
                    }
                    if self.cronExpress != nil {
                        map["CronExpress"] = self.cronExpress!
                    }
                    if self.cycleType != nil {
                        map["CycleType"] = self.cycleType!
                    }
                    if self.dependentNodeIdList != nil {
                        map["DependentNodeIdList"] = self.dependentNodeIdList!
                    }
                    if self.dependentType != nil {
                        map["DependentType"] = self.dependentType!
                    }
                    if self.inputList != nil {
                        var tmp : [Any] = []
                        for k in self.inputList! {
                            tmp.append(k.toMap())
                        }
                        map["InputList"] = tmp
                    }
                    if self.outputList != nil {
                        var tmp : [Any] = []
                        for k in self.outputList! {
                            tmp.append(k.toMap())
                        }
                        map["OutputList"] = tmp
                    }
                    if self.paraValue != nil {
                        map["ParaValue"] = self.paraValue!
                    }
                    if self.rerunMode != nil {
                        map["RerunMode"] = self.rerunMode!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    if self.schedulerType != nil {
                        map["SchedulerType"] = self.schedulerType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AutoRerunIntervalMillis") {
                        self.autoRerunIntervalMillis = dict["AutoRerunIntervalMillis"] as! Int64
                    }
                    if dict.keys.contains("AutoRerunTimes") {
                        self.autoRerunTimes = dict["AutoRerunTimes"] as! Int64
                    }
                    if dict.keys.contains("CronExpress") {
                        self.cronExpress = dict["CronExpress"] as! String
                    }
                    if dict.keys.contains("CycleType") {
                        self.cycleType = dict["CycleType"] as! String
                    }
                    if dict.keys.contains("DependentNodeIdList") {
                        self.dependentNodeIdList = dict["DependentNodeIdList"] as! String
                    }
                    if dict.keys.contains("DependentType") {
                        self.dependentType = dict["DependentType"] as! String
                    }
                    if dict.keys.contains("InputList") {
                        var tmp : [GetIDEEventDetailResponseBody.EventDetail.CommittedFile.NodeConfiguration.InputList] = []
                        for v in dict["InputList"] as! [Any] {
                            var model = GetIDEEventDetailResponseBody.EventDetail.CommittedFile.NodeConfiguration.InputList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.inputList = tmp
                    }
                    if dict.keys.contains("OutputList") {
                        var tmp : [GetIDEEventDetailResponseBody.EventDetail.CommittedFile.NodeConfiguration.OutputList] = []
                        for v in dict["OutputList"] as! [Any] {
                            var model = GetIDEEventDetailResponseBody.EventDetail.CommittedFile.NodeConfiguration.OutputList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.outputList = tmp
                    }
                    if dict.keys.contains("ParaValue") {
                        self.paraValue = dict["ParaValue"] as! String
                    }
                    if dict.keys.contains("RerunMode") {
                        self.rerunMode = dict["RerunMode"] as! String
                    }
                    if dict.keys.contains("ResourceGroupId") {
                        self.resourceGroupId = dict["ResourceGroupId"] as! Int64
                    }
                    if dict.keys.contains("SchedulerType") {
                        self.schedulerType = dict["SchedulerType"] as! String
                    }
                }
            }
            public var changeType: String?

            public var comment: String?

            public var committor: String?

            public var content: String?

            public var fileId: Int64?

            public var fileName: String?

            public var filePropertyContent: GetIDEEventDetailResponseBody.EventDetail.CommittedFile.FilePropertyContent?

            public var fileType: Int64?

            public var nodeConfiguration: GetIDEEventDetailResponseBody.EventDetail.CommittedFile.NodeConfiguration?

            public var nodeId: Int64?

            public var useType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.filePropertyContent?.validate()
                try self.nodeConfiguration?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.changeType != nil {
                    map["ChangeType"] = self.changeType!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.committor != nil {
                    map["Committor"] = self.committor!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.filePropertyContent != nil {
                    map["FilePropertyContent"] = self.filePropertyContent?.toMap()
                }
                if self.fileType != nil {
                    map["FileType"] = self.fileType!
                }
                if self.nodeConfiguration != nil {
                    map["NodeConfiguration"] = self.nodeConfiguration?.toMap()
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.useType != nil {
                    map["UseType"] = self.useType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChangeType") {
                    self.changeType = dict["ChangeType"] as! String
                }
                if dict.keys.contains("Comment") {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("Committor") {
                    self.committor = dict["Committor"] as! String
                }
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("FileId") {
                    self.fileId = dict["FileId"] as! Int64
                }
                if dict.keys.contains("FileName") {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("FilePropertyContent") {
                    var model = GetIDEEventDetailResponseBody.EventDetail.CommittedFile.FilePropertyContent()
                    model.fromMap(dict["FilePropertyContent"] as! [String: Any])
                    self.filePropertyContent = model
                }
                if dict.keys.contains("FileType") {
                    self.fileType = dict["FileType"] as! Int64
                }
                if dict.keys.contains("NodeConfiguration") {
                    var model = GetIDEEventDetailResponseBody.EventDetail.CommittedFile.NodeConfiguration()
                    model.fromMap(dict["NodeConfiguration"] as! [String: Any])
                    self.nodeConfiguration = model
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("UseType") {
                    self.useType = dict["UseType"] as! String
                }
            }
        }
        public class DeletedFile : Tea.TeaModel {
            public var businessId: Int64?

            public var content: String?

            public var currentVersion: Int64?

            public var dataSourceName: String?

            public var fileId: Int64?

            public var fileName: String?

            public var fileType: Int64?

            public var folderId: String?

            public var nodeId: Int64?

            public var owner: String?

            public var parentFileId: Int64?

            public var useType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessId != nil {
                    map["BusinessId"] = self.businessId!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.currentVersion != nil {
                    map["CurrentVersion"] = self.currentVersion!
                }
                if self.dataSourceName != nil {
                    map["DataSourceName"] = self.dataSourceName!
                }
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.fileType != nil {
                    map["FileType"] = self.fileType!
                }
                if self.folderId != nil {
                    map["FolderId"] = self.folderId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.parentFileId != nil {
                    map["ParentFileId"] = self.parentFileId!
                }
                if self.useType != nil {
                    map["UseType"] = self.useType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessId") {
                    self.businessId = dict["BusinessId"] as! Int64
                }
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("CurrentVersion") {
                    self.currentVersion = dict["CurrentVersion"] as! Int64
                }
                if dict.keys.contains("DataSourceName") {
                    self.dataSourceName = dict["DataSourceName"] as! String
                }
                if dict.keys.contains("FileId") {
                    self.fileId = dict["FileId"] as! Int64
                }
                if dict.keys.contains("FileName") {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("FileType") {
                    self.fileType = dict["FileType"] as! Int64
                }
                if dict.keys.contains("FolderId") {
                    self.folderId = dict["FolderId"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("ParentFileId") {
                    self.parentFileId = dict["ParentFileId"] as! Int64
                }
                if dict.keys.contains("UseType") {
                    self.useType = dict["UseType"] as! String
                }
            }
        }
        public class FileExecutionCommand : Tea.TeaModel {
            public var content: String?

            public var dataSourceName: String?

            public var fileId: Int64?

            public var fileType: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.dataSourceName != nil {
                    map["DataSourceName"] = self.dataSourceName!
                }
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.fileType != nil {
                    map["FileType"] = self.fileType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("DataSourceName") {
                    self.dataSourceName = dict["DataSourceName"] as! String
                }
                if dict.keys.contains("FileId") {
                    self.fileId = dict["FileId"] as! Int64
                }
                if dict.keys.contains("FileType") {
                    self.fileType = dict["FileType"] as! Int64
                }
            }
        }
        public class TableModel : Tea.TeaModel {
            public class Columns : Tea.TeaModel {
                public var columnName: String?

                public var columnType: String?

                public var comment: String?

                public var isPartitionColumn: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columnName != nil {
                        map["ColumnName"] = self.columnName!
                    }
                    if self.columnType != nil {
                        map["ColumnType"] = self.columnType!
                    }
                    if self.comment != nil {
                        map["Comment"] = self.comment!
                    }
                    if self.isPartitionColumn != nil {
                        map["IsPartitionColumn"] = self.isPartitionColumn!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ColumnName") {
                        self.columnName = dict["ColumnName"] as! String
                    }
                    if dict.keys.contains("ColumnType") {
                        self.columnType = dict["ColumnType"] as! String
                    }
                    if dict.keys.contains("Comment") {
                        self.comment = dict["Comment"] as! String
                    }
                    if dict.keys.contains("IsPartitionColumn") {
                        self.isPartitionColumn = dict["IsPartitionColumn"] as! Bool
                    }
                }
            }
            public var columns: [GetIDEEventDetailResponseBody.EventDetail.TableModel.Columns]?

            public var comment: String?

            public var dataSourceName: String?

            public var env: String?

            public var lifeCycle: Int64?

            public var location: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columns != nil {
                    var tmp : [Any] = []
                    for k in self.columns! {
                        tmp.append(k.toMap())
                    }
                    map["Columns"] = tmp
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.dataSourceName != nil {
                    map["DataSourceName"] = self.dataSourceName!
                }
                if self.env != nil {
                    map["Env"] = self.env!
                }
                if self.lifeCycle != nil {
                    map["LifeCycle"] = self.lifeCycle!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Columns") {
                    var tmp : [GetIDEEventDetailResponseBody.EventDetail.TableModel.Columns] = []
                    for v in dict["Columns"] as! [Any] {
                        var model = GetIDEEventDetailResponseBody.EventDetail.TableModel.Columns()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.columns = tmp
                }
                if dict.keys.contains("Comment") {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("DataSourceName") {
                    self.dataSourceName = dict["DataSourceName"] as! String
                }
                if dict.keys.contains("Env") {
                    self.env = dict["Env"] as! String
                }
                if dict.keys.contains("LifeCycle") {
                    self.lifeCycle = dict["LifeCycle"] as! Int64
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var committedFile: GetIDEEventDetailResponseBody.EventDetail.CommittedFile?

        public var deletedFile: GetIDEEventDetailResponseBody.EventDetail.DeletedFile?

        public var fileExecutionCommand: GetIDEEventDetailResponseBody.EventDetail.FileExecutionCommand?

        public var tableModel: GetIDEEventDetailResponseBody.EventDetail.TableModel?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.committedFile?.validate()
            try self.deletedFile?.validate()
            try self.fileExecutionCommand?.validate()
            try self.tableModel?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.committedFile != nil {
                map["CommittedFile"] = self.committedFile?.toMap()
            }
            if self.deletedFile != nil {
                map["DeletedFile"] = self.deletedFile?.toMap()
            }
            if self.fileExecutionCommand != nil {
                map["FileExecutionCommand"] = self.fileExecutionCommand?.toMap()
            }
            if self.tableModel != nil {
                map["TableModel"] = self.tableModel?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommittedFile") {
                var model = GetIDEEventDetailResponseBody.EventDetail.CommittedFile()
                model.fromMap(dict["CommittedFile"] as! [String: Any])
                self.committedFile = model
            }
            if dict.keys.contains("DeletedFile") {
                var model = GetIDEEventDetailResponseBody.EventDetail.DeletedFile()
                model.fromMap(dict["DeletedFile"] as! [String: Any])
                self.deletedFile = model
            }
            if dict.keys.contains("FileExecutionCommand") {
                var model = GetIDEEventDetailResponseBody.EventDetail.FileExecutionCommand()
                model.fromMap(dict["FileExecutionCommand"] as! [String: Any])
                self.fileExecutionCommand = model
            }
            if dict.keys.contains("TableModel") {
                var model = GetIDEEventDetailResponseBody.EventDetail.TableModel()
                model.fromMap(dict["TableModel"] as! [String: Any])
                self.tableModel = model
            }
        }
    }
    public var eventDetail: GetIDEEventDetailResponseBody.EventDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventDetail != nil {
            map["EventDetail"] = self.eventDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventDetail") {
            var model = GetIDEEventDetailResponseBody.EventDetail()
            model.fromMap(dict["EventDetail"] as! [String: Any])
            self.eventDetail = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetIDEEventDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIDEEventDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetIDEEventDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class GetInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var baselineId: Int64?

        public var beginRunningTime: Int64?

        public var beginWaitResTime: Int64?

        public var beginWaitTimeTime: Int64?

        public var bizdate: Int64?

        public var businessId: Int64?

        public var connection: String?

        public var createTime: Int64?

        public var createUser: String?

        public var cycTime: Int64?

        public var dagId: Int64?

        public var dagType: String?

        public var dqcDescription: String?

        public var dqcType: Int32?

        public var finishTime: Int64?

        public var instanceId: Int64?

        public var modifyTime: Int64?

        public var nodeId: Int64?

        public var nodeName: String?

        public var owner: String?

        public var paramValues: String?

        public var periodNumber: Int32?

        public var priority: Int32?

        public var relatedFlowId: Int64?

        public var repeatInterval: Int64?

        public var repeatability: Bool?

        public var status: String?

        public var taskRerunTime: Int32?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineId != nil {
                map["BaselineId"] = self.baselineId!
            }
            if self.beginRunningTime != nil {
                map["BeginRunningTime"] = self.beginRunningTime!
            }
            if self.beginWaitResTime != nil {
                map["BeginWaitResTime"] = self.beginWaitResTime!
            }
            if self.beginWaitTimeTime != nil {
                map["BeginWaitTimeTime"] = self.beginWaitTimeTime!
            }
            if self.bizdate != nil {
                map["Bizdate"] = self.bizdate!
            }
            if self.businessId != nil {
                map["BusinessId"] = self.businessId!
            }
            if self.connection != nil {
                map["Connection"] = self.connection!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.cycTime != nil {
                map["CycTime"] = self.cycTime!
            }
            if self.dagId != nil {
                map["DagId"] = self.dagId!
            }
            if self.dagType != nil {
                map["DagType"] = self.dagType!
            }
            if self.dqcDescription != nil {
                map["DqcDescription"] = self.dqcDescription!
            }
            if self.dqcType != nil {
                map["DqcType"] = self.dqcType!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.paramValues != nil {
                map["ParamValues"] = self.paramValues!
            }
            if self.periodNumber != nil {
                map["PeriodNumber"] = self.periodNumber!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.relatedFlowId != nil {
                map["RelatedFlowId"] = self.relatedFlowId!
            }
            if self.repeatInterval != nil {
                map["RepeatInterval"] = self.repeatInterval!
            }
            if self.repeatability != nil {
                map["Repeatability"] = self.repeatability!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskRerunTime != nil {
                map["TaskRerunTime"] = self.taskRerunTime!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BaselineId") {
                self.baselineId = dict["BaselineId"] as! Int64
            }
            if dict.keys.contains("BeginRunningTime") {
                self.beginRunningTime = dict["BeginRunningTime"] as! Int64
            }
            if dict.keys.contains("BeginWaitResTime") {
                self.beginWaitResTime = dict["BeginWaitResTime"] as! Int64
            }
            if dict.keys.contains("BeginWaitTimeTime") {
                self.beginWaitTimeTime = dict["BeginWaitTimeTime"] as! Int64
            }
            if dict.keys.contains("Bizdate") {
                self.bizdate = dict["Bizdate"] as! Int64
            }
            if dict.keys.contains("BusinessId") {
                self.businessId = dict["BusinessId"] as! Int64
            }
            if dict.keys.contains("Connection") {
                self.connection = dict["Connection"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreateUser") {
                self.createUser = dict["CreateUser"] as! String
            }
            if dict.keys.contains("CycTime") {
                self.cycTime = dict["CycTime"] as! Int64
            }
            if dict.keys.contains("DagId") {
                self.dagId = dict["DagId"] as! Int64
            }
            if dict.keys.contains("DagType") {
                self.dagType = dict["DagType"] as! String
            }
            if dict.keys.contains("DqcDescription") {
                self.dqcDescription = dict["DqcDescription"] as! String
            }
            if dict.keys.contains("DqcType") {
                self.dqcType = dict["DqcType"] as! Int32
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! Int64
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("ParamValues") {
                self.paramValues = dict["ParamValues"] as! String
            }
            if dict.keys.contains("PeriodNumber") {
                self.periodNumber = dict["PeriodNumber"] as! Int32
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("RelatedFlowId") {
                self.relatedFlowId = dict["RelatedFlowId"] as! Int64
            }
            if dict.keys.contains("RepeatInterval") {
                self.repeatInterval = dict["RepeatInterval"] as! Int64
            }
            if dict.keys.contains("Repeatability") {
                self.repeatability = dict["Repeatability"] as! Bool
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskRerunTime") {
                self.taskRerunTime = dict["TaskRerunTime"] as! Int32
            }
            if dict.keys.contains("TaskType") {
                self.taskType = dict["TaskType"] as! String
            }
        }
    }
    public var data: GetInstanceResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceConsumeTimeRankRequest : Tea.TeaModel {
    public var bizdate: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizdate") {
            self.bizdate = dict["Bizdate"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class GetInstanceConsumeTimeRankResponseBody : Tea.TeaModel {
    public class InstanceConsumeTimeRank : Tea.TeaModel {
        public class ConsumeTimeRank : Tea.TeaModel {
            public var bizdate: Int64?

            public var consumed: Int64?

            public var instanceId: Int64?

            public var nodeId: Int64?

            public var nodeName: String?

            public var owner: String?

            public var prgType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.consumed != nil {
                    map["Consumed"] = self.consumed!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.prgType != nil {
                    map["PrgType"] = self.prgType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bizdate") {
                    self.bizdate = dict["Bizdate"] as! Int64
                }
                if dict.keys.contains("Consumed") {
                    self.consumed = dict["Consumed"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("PrgType") {
                    self.prgType = dict["PrgType"] as! Int32
                }
            }
        }
        public var consumeTimeRank: [GetInstanceConsumeTimeRankResponseBody.InstanceConsumeTimeRank.ConsumeTimeRank]?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consumeTimeRank != nil {
                var tmp : [Any] = []
                for k in self.consumeTimeRank! {
                    tmp.append(k.toMap())
                }
                map["ConsumeTimeRank"] = tmp
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsumeTimeRank") {
                var tmp : [GetInstanceConsumeTimeRankResponseBody.InstanceConsumeTimeRank.ConsumeTimeRank] = []
                for v in dict["ConsumeTimeRank"] as! [Any] {
                    var model = GetInstanceConsumeTimeRankResponseBody.InstanceConsumeTimeRank.ConsumeTimeRank()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.consumeTimeRank = tmp
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var instanceConsumeTimeRank: GetInstanceConsumeTimeRankResponseBody.InstanceConsumeTimeRank?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceConsumeTimeRank?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceConsumeTimeRank != nil {
            map["InstanceConsumeTimeRank"] = self.instanceConsumeTimeRank?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceConsumeTimeRank") {
            var model = GetInstanceConsumeTimeRankResponseBody.InstanceConsumeTimeRank()
            model.fromMap(dict["InstanceConsumeTimeRank"] as! [String: Any])
            self.instanceConsumeTimeRank = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetInstanceConsumeTimeRankResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceConsumeTimeRankResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceConsumeTimeRankResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceCountTrendRequest : Tea.TeaModel {
    public var beginDate: String?

    public var endDate: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginDate != nil {
            map["BeginDate"] = self.beginDate!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginDate") {
            self.beginDate = dict["BeginDate"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class GetInstanceCountTrendResponseBody : Tea.TeaModel {
    public class InstanceCounts : Tea.TeaModel {
        public var count: Int32?

        public var date: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.date != nil {
                map["Date"] = self.date!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("Date") {
                self.date = dict["Date"] as! Int64
            }
        }
    }
    public var instanceCounts: [GetInstanceCountTrendResponseBody.InstanceCounts]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceCounts != nil {
            var tmp : [Any] = []
            for k in self.instanceCounts! {
                tmp.append(k.toMap())
            }
            map["InstanceCounts"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceCounts") {
            var tmp : [GetInstanceCountTrendResponseBody.InstanceCounts] = []
            for v in dict["InstanceCounts"] as! [Any] {
                var model = GetInstanceCountTrendResponseBody.InstanceCounts()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceCounts = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetInstanceCountTrendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceCountTrendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceCountTrendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceErrorRankRequest : Tea.TeaModel {
    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class GetInstanceErrorRankResponseBody : Tea.TeaModel {
    public class InstanceErrorRank : Tea.TeaModel {
        public class ErrorRank : Tea.TeaModel {
            public var count: Int32?

            public var nodeId: Int64?

            public var nodeName: String?

            public var owner: String?

            public var prgType: Int32?

            public var projectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.prgType != nil {
                    map["PrgType"] = self.prgType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("PrgType") {
                    self.prgType = dict["PrgType"] as! Int32
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
            }
        }
        public var errorRank: [GetInstanceErrorRankResponseBody.InstanceErrorRank.ErrorRank]?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorRank != nil {
                var tmp : [Any] = []
                for k in self.errorRank! {
                    tmp.append(k.toMap())
                }
                map["ErrorRank"] = tmp
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorRank") {
                var tmp : [GetInstanceErrorRankResponseBody.InstanceErrorRank.ErrorRank] = []
                for v in dict["ErrorRank"] as! [Any] {
                    var model = GetInstanceErrorRankResponseBody.InstanceErrorRank.ErrorRank()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.errorRank = tmp
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var instanceErrorRank: GetInstanceErrorRankResponseBody.InstanceErrorRank?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceErrorRank?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceErrorRank != nil {
            map["InstanceErrorRank"] = self.instanceErrorRank?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceErrorRank") {
            var model = GetInstanceErrorRankResponseBody.InstanceErrorRank()
            model.fromMap(dict["InstanceErrorRank"] as! [String: Any])
            self.instanceErrorRank = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetInstanceErrorRankResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceErrorRankResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceErrorRankResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceLogRequest : Tea.TeaModel {
    public var instanceHistoryId: Int64?

    public var instanceId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceHistoryId != nil {
            map["InstanceHistoryId"] = self.instanceHistoryId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceHistoryId") {
            self.instanceHistoryId = dict["InstanceHistoryId"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class GetInstanceLogResponseBody : Tea.TeaModel {
    public var data: String?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetInstanceLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceStatusCountRequest : Tea.TeaModel {
    public var bizDate: String?

    public var projectEnv: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizDate != nil {
            map["BizDate"] = self.bizDate!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizDate") {
            self.bizDate = dict["BizDate"] as! String
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class GetInstanceStatusCountResponseBody : Tea.TeaModel {
    public class StatusCount : Tea.TeaModel {
        public var failureCount: Int32?

        public var notRunCount: Int32?

        public var runningCount: Int32?

        public var successCount: Int32?

        public var totalCount: Int32?

        public var waitResCount: Int32?

        public var waitTimeCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failureCount != nil {
                map["FailureCount"] = self.failureCount!
            }
            if self.notRunCount != nil {
                map["NotRunCount"] = self.notRunCount!
            }
            if self.runningCount != nil {
                map["RunningCount"] = self.runningCount!
            }
            if self.successCount != nil {
                map["SuccessCount"] = self.successCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.waitResCount != nil {
                map["WaitResCount"] = self.waitResCount!
            }
            if self.waitTimeCount != nil {
                map["WaitTimeCount"] = self.waitTimeCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailureCount") {
                self.failureCount = dict["FailureCount"] as! Int32
            }
            if dict.keys.contains("NotRunCount") {
                self.notRunCount = dict["NotRunCount"] as! Int32
            }
            if dict.keys.contains("RunningCount") {
                self.runningCount = dict["RunningCount"] as! Int32
            }
            if dict.keys.contains("SuccessCount") {
                self.successCount = dict["SuccessCount"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("WaitResCount") {
                self.waitResCount = dict["WaitResCount"] as! Int32
            }
            if dict.keys.contains("WaitTimeCount") {
                self.waitTimeCount = dict["WaitTimeCount"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var statusCount: GetInstanceStatusCountResponseBody.StatusCount?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statusCount?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCount != nil {
            map["StatusCount"] = self.statusCount?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCount") {
            var model = GetInstanceStatusCountResponseBody.StatusCount()
            model.fromMap(dict["StatusCount"] as! [String: Any])
            self.statusCount = model
        }
    }
}

public class GetInstanceStatusCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceStatusCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceStatusCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceStatusStatisticRequest : Tea.TeaModel {
    public var bizDate: String?

    public var dagType: String?

    public var projectEnv: String?

    public var projectId: Int64?

    public var schedulerPeriod: String?

    public var schedulerType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizDate != nil {
            map["BizDate"] = self.bizDate!
        }
        if self.dagType != nil {
            map["DagType"] = self.dagType!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.schedulerPeriod != nil {
            map["SchedulerPeriod"] = self.schedulerPeriod!
        }
        if self.schedulerType != nil {
            map["SchedulerType"] = self.schedulerType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizDate") {
            self.bizDate = dict["BizDate"] as! String
        }
        if dict.keys.contains("DagType") {
            self.dagType = dict["DagType"] as! String
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SchedulerPeriod") {
            self.schedulerPeriod = dict["SchedulerPeriod"] as! String
        }
        if dict.keys.contains("SchedulerType") {
            self.schedulerType = dict["SchedulerType"] as! String
        }
    }
}

public class GetInstanceStatusStatisticResponseBody : Tea.TeaModel {
    public class StatusCount : Tea.TeaModel {
        public var failureCount: Int32?

        public var notRunCount: Int32?

        public var runningCount: Int32?

        public var successCount: Int32?

        public var totalCount: Int32?

        public var waitResCount: Int32?

        public var waitTimeCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failureCount != nil {
                map["FailureCount"] = self.failureCount!
            }
            if self.notRunCount != nil {
                map["NotRunCount"] = self.notRunCount!
            }
            if self.runningCount != nil {
                map["RunningCount"] = self.runningCount!
            }
            if self.successCount != nil {
                map["SuccessCount"] = self.successCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.waitResCount != nil {
                map["WaitResCount"] = self.waitResCount!
            }
            if self.waitTimeCount != nil {
                map["WaitTimeCount"] = self.waitTimeCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailureCount") {
                self.failureCount = dict["FailureCount"] as! Int32
            }
            if dict.keys.contains("NotRunCount") {
                self.notRunCount = dict["NotRunCount"] as! Int32
            }
            if dict.keys.contains("RunningCount") {
                self.runningCount = dict["RunningCount"] as! Int32
            }
            if dict.keys.contains("SuccessCount") {
                self.successCount = dict["SuccessCount"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("WaitResCount") {
                self.waitResCount = dict["WaitResCount"] as! Int32
            }
            if dict.keys.contains("WaitTimeCount") {
                self.waitTimeCount = dict["WaitTimeCount"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var statusCount: GetInstanceStatusStatisticResponseBody.StatusCount?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statusCount?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCount != nil {
            map["StatusCount"] = self.statusCount?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCount") {
            var model = GetInstanceStatusStatisticResponseBody.StatusCount()
            model.fromMap(dict["StatusCount"] as! [String: Any])
            self.statusCount = model
        }
    }
}

public class GetInstanceStatusStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceStatusStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceStatusStatisticResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetManualDagInstancesRequest : Tea.TeaModel {
    public var dagId: String?

    public var projectEnv: String?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! String
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
    }
}

public class GetManualDagInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public var beginRunningTime: Int64?

        public var beginWaitResTime: Int64?

        public var beginWaitTimeTime: Int64?

        public var bizDate: Int64?

        public var createTime: Int64?

        public var createUser: String?

        public var cycTime: Int64?

        public var dagId: Int64?

        public var dagType: String?

        public var finishTime: Int64?

        public var instanceId: Int64?

        public var modifyTime: Int64?

        public var nodeId: Int64?

        public var nodeName: String?

        public var paramValues: String?

        public var status: String?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.beginRunningTime != nil {
                map["BeginRunningTime"] = self.beginRunningTime!
            }
            if self.beginWaitResTime != nil {
                map["BeginWaitResTime"] = self.beginWaitResTime!
            }
            if self.beginWaitTimeTime != nil {
                map["BeginWaitTimeTime"] = self.beginWaitTimeTime!
            }
            if self.bizDate != nil {
                map["BizDate"] = self.bizDate!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.cycTime != nil {
                map["CycTime"] = self.cycTime!
            }
            if self.dagId != nil {
                map["DagId"] = self.dagId!
            }
            if self.dagType != nil {
                map["DagType"] = self.dagType!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.paramValues != nil {
                map["ParamValues"] = self.paramValues!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BeginRunningTime") {
                self.beginRunningTime = dict["BeginRunningTime"] as! Int64
            }
            if dict.keys.contains("BeginWaitResTime") {
                self.beginWaitResTime = dict["BeginWaitResTime"] as! Int64
            }
            if dict.keys.contains("BeginWaitTimeTime") {
                self.beginWaitTimeTime = dict["BeginWaitTimeTime"] as! Int64
            }
            if dict.keys.contains("BizDate") {
                self.bizDate = dict["BizDate"] as! Int64
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreateUser") {
                self.createUser = dict["CreateUser"] as! String
            }
            if dict.keys.contains("CycTime") {
                self.cycTime = dict["CycTime"] as! Int64
            }
            if dict.keys.contains("DagId") {
                self.dagId = dict["DagId"] as! Int64
            }
            if dict.keys.contains("DagType") {
                self.dagType = dict["DagType"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! Int64
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("ParamValues") {
                self.paramValues = dict["ParamValues"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskType") {
                self.taskType = dict["TaskType"] as! String
            }
        }
    }
    public var instances: [GetManualDagInstancesResponseBody.Instances]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            var tmp : [GetManualDagInstancesResponseBody.Instances] = []
            for v in dict["Instances"] as! [Any] {
                var model = GetManualDagInstancesResponseBody.Instances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instances = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetManualDagInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetManualDagInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetManualDagInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaCategoryRequest : Tea.TeaModel {
    public var pageNum: Int32?

    public var pageSize: Int32?

    public var parentCategoryId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentCategoryId != nil {
            map["ParentCategoryId"] = self.parentCategoryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ParentCategoryId") {
            self.parentCategoryId = dict["ParentCategoryId"] as! Int64
        }
    }
}

public class GetMetaCategoryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataEntityList : Tea.TeaModel {
            public var categoryId: Int64?

            public var comment: String?

            public var createTime: Int64?

            public var depth: Int32?

            public var lastOperatorId: String?

            public var modifiedTime: Int64?

            public var name: String?

            public var ownerId: String?

            public var parentCategoryId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.categoryId != nil {
                    map["CategoryId"] = self.categoryId!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.depth != nil {
                    map["Depth"] = self.depth!
                }
                if self.lastOperatorId != nil {
                    map["LastOperatorId"] = self.lastOperatorId!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.parentCategoryId != nil {
                    map["ParentCategoryId"] = self.parentCategoryId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CategoryId") {
                    self.categoryId = dict["CategoryId"] as! Int64
                }
                if dict.keys.contains("Comment") {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Depth") {
                    self.depth = dict["Depth"] as! Int32
                }
                if dict.keys.contains("LastOperatorId") {
                    self.lastOperatorId = dict["LastOperatorId"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OwnerId") {
                    self.ownerId = dict["OwnerId"] as! String
                }
                if dict.keys.contains("ParentCategoryId") {
                    self.parentCategoryId = dict["ParentCategoryId"] as! Int64
                }
            }
        }
        public var dataEntityList: [GetMetaCategoryResponseBody.Data.DataEntityList]?

        public var pageNum: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataEntityList != nil {
                var tmp : [Any] = []
                for k in self.dataEntityList! {
                    tmp.append(k.toMap())
                }
                map["DataEntityList"] = tmp
            }
            if self.pageNum != nil {
                map["PageNum"] = self.pageNum!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataEntityList") {
                var tmp : [GetMetaCategoryResponseBody.Data.DataEntityList] = []
                for v in dict["DataEntityList"] as! [Any] {
                    var model = GetMetaCategoryResponseBody.Data.DataEntityList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataEntityList = tmp
            }
            if dict.keys.contains("PageNum") {
                self.pageNum = dict["PageNum"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: GetMetaCategoryResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetMetaCategoryResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaCollectionDetailRequest : Tea.TeaModel {
    public var qualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QualifiedName") {
            self.qualifiedName = dict["QualifiedName"] as! String
        }
    }
}

public class GetMetaCollectionDetailResponseBody : Tea.TeaModel {
    public var collection: Collection?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.collection?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collection != nil {
            map["Collection"] = self.collection?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Collection") {
            var model = Collection()
            model.fromMap(dict["Collection"] as! [String: Any])
            self.collection = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaCollectionDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaCollectionDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaCollectionDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaColumnLineageRequest : Tea.TeaModel {
    public var clusterId: String?

    public var columnGuid: String?

    public var columnName: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var direction: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.columnGuid != nil {
            map["ColumnGuid"] = self.columnGuid!
        }
        if self.columnName != nil {
            map["ColumnName"] = self.columnName!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ColumnGuid") {
            self.columnGuid = dict["ColumnGuid"] as! String
        }
        if dict.keys.contains("ColumnName") {
            self.columnName = dict["ColumnName"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class GetMetaColumnLineageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataEntityList : Tea.TeaModel {
            public var clusterId: String?

            public var columnGuid: String?

            public var columnName: String?

            public var databaseName: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.columnGuid != nil {
                    map["ColumnGuid"] = self.columnGuid!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("ColumnGuid") {
                    self.columnGuid = dict["ColumnGuid"] as! String
                }
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("DatabaseName") {
                    self.databaseName = dict["DatabaseName"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var dataEntityList: [GetMetaColumnLineageResponseBody.Data.DataEntityList]?

        public var pageNum: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataEntityList != nil {
                var tmp : [Any] = []
                for k in self.dataEntityList! {
                    tmp.append(k.toMap())
                }
                map["DataEntityList"] = tmp
            }
            if self.pageNum != nil {
                map["PageNum"] = self.pageNum!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataEntityList") {
                var tmp : [GetMetaColumnLineageResponseBody.Data.DataEntityList] = []
                for v in dict["DataEntityList"] as! [Any] {
                    var model = GetMetaColumnLineageResponseBody.Data.DataEntityList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataEntityList = tmp
            }
            if dict.keys.contains("PageNum") {
                self.pageNum = dict["PageNum"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: GetMetaColumnLineageResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetMetaColumnLineageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaColumnLineageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaColumnLineageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaColumnLineageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaDBInfoRequest : Tea.TeaModel {
    public var appGuid: String?

    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGuid != nil {
            map["AppGuid"] = self.appGuid!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppGuid") {
            self.appGuid = dict["AppGuid"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
    }
}

public class GetMetaDBInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appGuid: String?

        public var clusterBizId: String?

        public var comment: String?

        public var createTime: Int64?

        public var endpoint: String?

        public var envType: Int32?

        public var location: String?

        public var modifyTime: Int64?

        public var name: String?

        public var ownerId: String?

        public var ownerName: String?

        public var projectId: Int64?

        public var projectName: String?

        public var projectNameCn: String?

        public var tenantId: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appGuid != nil {
                map["AppGuid"] = self.appGuid!
            }
            if self.clusterBizId != nil {
                map["ClusterBizId"] = self.clusterBizId!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.location != nil {
                map["Location"] = self.location!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.projectNameCn != nil {
                map["ProjectNameCn"] = self.projectNameCn!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppGuid") {
                self.appGuid = dict["AppGuid"] as! String
            }
            if dict.keys.contains("ClusterBizId") {
                self.clusterBizId = dict["ClusterBizId"] as! String
            }
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("EnvType") {
                self.envType = dict["EnvType"] as! Int32
            }
            if dict.keys.contains("Location") {
                self.location = dict["Location"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OwnerId") {
                self.ownerId = dict["OwnerId"] as! String
            }
            if dict.keys.contains("OwnerName") {
                self.ownerName = dict["OwnerName"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
            if dict.keys.contains("ProjectNameCn") {
                self.projectNameCn = dict["ProjectNameCn"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var data: GetMetaDBInfoResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetMetaDBInfoResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMetaDBInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaDBInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaDBInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaDBTableListRequest : Tea.TeaModel {
    public var appGuid: String?

    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGuid != nil {
            map["AppGuid"] = self.appGuid!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppGuid") {
            self.appGuid = dict["AppGuid"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class GetMetaDBTableListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TableEntityList : Tea.TeaModel {
            public var databaseName: String?

            public var tableGuid: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseName") {
                    self.databaseName = dict["DatabaseName"] as! String
                }
                if dict.keys.contains("TableGuid") {
                    self.tableGuid = dict["TableGuid"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var tableEntityList: [GetMetaDBTableListResponseBody.Data.TableEntityList]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.tableEntityList != nil {
                var tmp : [Any] = []
                for k in self.tableEntityList! {
                    tmp.append(k.toMap())
                }
                map["TableEntityList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TableEntityList") {
                var tmp : [GetMetaDBTableListResponseBody.Data.TableEntityList] = []
                for v in dict["TableEntityList"] as! [Any] {
                    var model = GetMetaDBTableListResponseBody.Data.TableEntityList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableEntityList = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: GetMetaDBTableListResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetMetaDBTableListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMetaDBTableListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaDBTableListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaDBTableListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaTableBasicInfoRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var extension_: Bool?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.extension_ != nil {
            map["Extension"] = self.extension_!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("Extension") {
            self.extension_ = dict["Extension"] as! Bool
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class GetMetaTableBasicInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var caption: String?

        public var clusterId: String?

        public var columnCount: Int32?

        public var comment: String?

        public var createTime: Int64?

        public var dataSize: Int64?

        public var databaseName: String?

        public var envType: Int32?

        public var favoriteCount: Int64?

        public var isPartitionTable: Bool?

        public var isView: Bool?

        public var isVisible: Int32?

        public var lastAccessTime: Int64?

        public var lastDdlTime: Int64?

        public var lastModifyTime: Int64?

        public var lifeCycle: Int32?

        public var location: String?

        public var ownerId: String?

        public var partitionKeys: String?

        public var projectId: Int64?

        public var projectName: String?

        public var readCount: Int64?

        public var schema: String?

        public var tableGuid: String?

        public var tableName: String?

        public var tenantId: Int64?

        public var viewCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.caption != nil {
                map["Caption"] = self.caption!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.columnCount != nil {
                map["ColumnCount"] = self.columnCount!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dataSize != nil {
                map["DataSize"] = self.dataSize!
            }
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.favoriteCount != nil {
                map["FavoriteCount"] = self.favoriteCount!
            }
            if self.isPartitionTable != nil {
                map["IsPartitionTable"] = self.isPartitionTable!
            }
            if self.isView != nil {
                map["IsView"] = self.isView!
            }
            if self.isVisible != nil {
                map["IsVisible"] = self.isVisible!
            }
            if self.lastAccessTime != nil {
                map["LastAccessTime"] = self.lastAccessTime!
            }
            if self.lastDdlTime != nil {
                map["LastDdlTime"] = self.lastDdlTime!
            }
            if self.lastModifyTime != nil {
                map["LastModifyTime"] = self.lastModifyTime!
            }
            if self.lifeCycle != nil {
                map["LifeCycle"] = self.lifeCycle!
            }
            if self.location != nil {
                map["Location"] = self.location!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.partitionKeys != nil {
                map["PartitionKeys"] = self.partitionKeys!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.readCount != nil {
                map["ReadCount"] = self.readCount!
            }
            if self.schema != nil {
                map["Schema"] = self.schema!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.viewCount != nil {
                map["ViewCount"] = self.viewCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Caption") {
                self.caption = dict["Caption"] as! String
            }
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ColumnCount") {
                self.columnCount = dict["ColumnCount"] as! Int32
            }
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("DataSize") {
                self.dataSize = dict["DataSize"] as! Int64
            }
            if dict.keys.contains("DatabaseName") {
                self.databaseName = dict["DatabaseName"] as! String
            }
            if dict.keys.contains("EnvType") {
                self.envType = dict["EnvType"] as! Int32
            }
            if dict.keys.contains("FavoriteCount") {
                self.favoriteCount = dict["FavoriteCount"] as! Int64
            }
            if dict.keys.contains("IsPartitionTable") {
                self.isPartitionTable = dict["IsPartitionTable"] as! Bool
            }
            if dict.keys.contains("IsView") {
                self.isView = dict["IsView"] as! Bool
            }
            if dict.keys.contains("IsVisible") {
                self.isVisible = dict["IsVisible"] as! Int32
            }
            if dict.keys.contains("LastAccessTime") {
                self.lastAccessTime = dict["LastAccessTime"] as! Int64
            }
            if dict.keys.contains("LastDdlTime") {
                self.lastDdlTime = dict["LastDdlTime"] as! Int64
            }
            if dict.keys.contains("LastModifyTime") {
                self.lastModifyTime = dict["LastModifyTime"] as! Int64
            }
            if dict.keys.contains("LifeCycle") {
                self.lifeCycle = dict["LifeCycle"] as! Int32
            }
            if dict.keys.contains("Location") {
                self.location = dict["Location"] as! String
            }
            if dict.keys.contains("OwnerId") {
                self.ownerId = dict["OwnerId"] as! String
            }
            if dict.keys.contains("PartitionKeys") {
                self.partitionKeys = dict["PartitionKeys"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
            if dict.keys.contains("ReadCount") {
                self.readCount = dict["ReadCount"] as! Int64
            }
            if dict.keys.contains("Schema") {
                self.schema = dict["Schema"] as! String
            }
            if dict.keys.contains("TableGuid") {
                self.tableGuid = dict["TableGuid"] as! String
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
            if dict.keys.contains("ViewCount") {
                self.viewCount = dict["ViewCount"] as! Int64
            }
        }
    }
    public var data: GetMetaTableBasicInfoResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetMetaTableBasicInfoResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaTableBasicInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableBasicInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaTableBasicInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaTableChangeLogRequest : Tea.TeaModel {
    public var changeType: String?

    public var endDate: String?

    public var objectType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startDate: String?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeType != nil {
            map["ChangeType"] = self.changeType!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeType") {
            self.changeType = dict["ChangeType"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("ObjectType") {
            self.objectType = dict["ObjectType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
    }
}

public class GetMetaTableChangeLogResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataEntityList : Tea.TeaModel {
            public var changeContent: String?

            public var changeType: String?

            public var createTime: Int64?

            public var modifiedTime: Int64?

            public var objectType: String?

            public var operator_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.changeContent != nil {
                    map["ChangeContent"] = self.changeContent!
                }
                if self.changeType != nil {
                    map["ChangeType"] = self.changeType!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.objectType != nil {
                    map["ObjectType"] = self.objectType!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChangeContent") {
                    self.changeContent = dict["ChangeContent"] as! String
                }
                if dict.keys.contains("ChangeType") {
                    self.changeType = dict["ChangeType"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! Int64
                }
                if dict.keys.contains("ObjectType") {
                    self.objectType = dict["ObjectType"] as! String
                }
                if dict.keys.contains("Operator") {
                    self.operator_ = dict["Operator"] as! String
                }
            }
        }
        public var dataEntityList: [GetMetaTableChangeLogResponseBody.Data.DataEntityList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataEntityList != nil {
                var tmp : [Any] = []
                for k in self.dataEntityList! {
                    tmp.append(k.toMap())
                }
                map["DataEntityList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataEntityList") {
                var tmp : [GetMetaTableChangeLogResponseBody.Data.DataEntityList] = []
                for v in dict["DataEntityList"] as! [Any] {
                    var model = GetMetaTableChangeLogResponseBody.Data.DataEntityList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataEntityList = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: GetMetaTableChangeLogResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetMetaTableChangeLogResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaTableChangeLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableChangeLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaTableChangeLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaTableColumnRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class GetMetaTableColumnResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ColumnList : Tea.TeaModel {
            public var caption: String?

            public var columnGuid: String?

            public var columnName: String?

            public var columnType: String?

            public var comment: String?

            public var isForeignKey: Bool?

            public var isPartitionColumn: Bool?

            public var isPrimaryKey: Bool?

            public var position: Int32?

            public var relationCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.caption != nil {
                    map["Caption"] = self.caption!
                }
                if self.columnGuid != nil {
                    map["ColumnGuid"] = self.columnGuid!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.columnType != nil {
                    map["ColumnType"] = self.columnType!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.isForeignKey != nil {
                    map["IsForeignKey"] = self.isForeignKey!
                }
                if self.isPartitionColumn != nil {
                    map["IsPartitionColumn"] = self.isPartitionColumn!
                }
                if self.isPrimaryKey != nil {
                    map["IsPrimaryKey"] = self.isPrimaryKey!
                }
                if self.position != nil {
                    map["Position"] = self.position!
                }
                if self.relationCount != nil {
                    map["RelationCount"] = self.relationCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Caption") {
                    self.caption = dict["Caption"] as! String
                }
                if dict.keys.contains("ColumnGuid") {
                    self.columnGuid = dict["ColumnGuid"] as! String
                }
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("ColumnType") {
                    self.columnType = dict["ColumnType"] as! String
                }
                if dict.keys.contains("Comment") {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("IsForeignKey") {
                    self.isForeignKey = dict["IsForeignKey"] as! Bool
                }
                if dict.keys.contains("IsPartitionColumn") {
                    self.isPartitionColumn = dict["IsPartitionColumn"] as! Bool
                }
                if dict.keys.contains("IsPrimaryKey") {
                    self.isPrimaryKey = dict["IsPrimaryKey"] as! Bool
                }
                if dict.keys.contains("Position") {
                    self.position = dict["Position"] as! Int32
                }
                if dict.keys.contains("RelationCount") {
                    self.relationCount = dict["RelationCount"] as! Int64
                }
            }
        }
        public var columnList: [GetMetaTableColumnResponseBody.Data.ColumnList]?

        public var pageNum: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columnList != nil {
                var tmp : [Any] = []
                for k in self.columnList! {
                    tmp.append(k.toMap())
                }
                map["ColumnList"] = tmp
            }
            if self.pageNum != nil {
                map["PageNum"] = self.pageNum!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ColumnList") {
                var tmp : [GetMetaTableColumnResponseBody.Data.ColumnList] = []
                for v in dict["ColumnList"] as! [Any] {
                    var model = GetMetaTableColumnResponseBody.Data.ColumnList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.columnList = tmp
            }
            if dict.keys.contains("PageNum") {
                self.pageNum = dict["PageNum"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: GetMetaTableColumnResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetMetaTableColumnResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaTableColumnResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableColumnResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaTableColumnResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaTableFullInfoRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class GetMetaTableFullInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ColumnList : Tea.TeaModel {
            public var caption: String?

            public var columnGuid: String?

            public var columnName: String?

            public var columnType: String?

            public var comment: String?

            public var isForeignKey: Bool?

            public var isPartitionColumn: Bool?

            public var isPrimaryKey: Bool?

            public var position: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.caption != nil {
                    map["Caption"] = self.caption!
                }
                if self.columnGuid != nil {
                    map["ColumnGuid"] = self.columnGuid!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.columnType != nil {
                    map["ColumnType"] = self.columnType!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.isForeignKey != nil {
                    map["IsForeignKey"] = self.isForeignKey!
                }
                if self.isPartitionColumn != nil {
                    map["IsPartitionColumn"] = self.isPartitionColumn!
                }
                if self.isPrimaryKey != nil {
                    map["IsPrimaryKey"] = self.isPrimaryKey!
                }
                if self.position != nil {
                    map["Position"] = self.position!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Caption") {
                    self.caption = dict["Caption"] as! String
                }
                if dict.keys.contains("ColumnGuid") {
                    self.columnGuid = dict["ColumnGuid"] as! String
                }
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("ColumnType") {
                    self.columnType = dict["ColumnType"] as! String
                }
                if dict.keys.contains("Comment") {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("IsForeignKey") {
                    self.isForeignKey = dict["IsForeignKey"] as! Bool
                }
                if dict.keys.contains("IsPartitionColumn") {
                    self.isPartitionColumn = dict["IsPartitionColumn"] as! Bool
                }
                if dict.keys.contains("IsPrimaryKey") {
                    self.isPrimaryKey = dict["IsPrimaryKey"] as! Bool
                }
                if dict.keys.contains("Position") {
                    self.position = dict["Position"] as! Int32
                }
            }
        }
        public var clusterId: String?

        public var columnList: [GetMetaTableFullInfoResponseBody.Data.ColumnList]?

        public var comment: String?

        public var createTime: Int64?

        public var dataSize: Int64?

        public var databaseName: String?

        public var envType: Int32?

        public var isVisible: Int32?

        public var lastAccessTime: Int64?

        public var lastDdlTime: Int64?

        public var lastModifyTime: Int64?

        public var lifeCycle: Int32?

        public var location: String?

        public var ownerId: String?

        public var partitionKeys: String?

        public var projectId: Int64?

        public var projectName: String?

        public var schema: String?

        public var tableGuid: String?

        public var tableName: String?

        public var tenantId: Int64?

        public var totalColumnCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.columnList != nil {
                var tmp : [Any] = []
                for k in self.columnList! {
                    tmp.append(k.toMap())
                }
                map["ColumnList"] = tmp
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dataSize != nil {
                map["DataSize"] = self.dataSize!
            }
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.isVisible != nil {
                map["IsVisible"] = self.isVisible!
            }
            if self.lastAccessTime != nil {
                map["LastAccessTime"] = self.lastAccessTime!
            }
            if self.lastDdlTime != nil {
                map["LastDdlTime"] = self.lastDdlTime!
            }
            if self.lastModifyTime != nil {
                map["LastModifyTime"] = self.lastModifyTime!
            }
            if self.lifeCycle != nil {
                map["LifeCycle"] = self.lifeCycle!
            }
            if self.location != nil {
                map["Location"] = self.location!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.partitionKeys != nil {
                map["PartitionKeys"] = self.partitionKeys!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.schema != nil {
                map["Schema"] = self.schema!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.totalColumnCount != nil {
                map["TotalColumnCount"] = self.totalColumnCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ColumnList") {
                var tmp : [GetMetaTableFullInfoResponseBody.Data.ColumnList] = []
                for v in dict["ColumnList"] as! [Any] {
                    var model = GetMetaTableFullInfoResponseBody.Data.ColumnList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.columnList = tmp
            }
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("DataSize") {
                self.dataSize = dict["DataSize"] as! Int64
            }
            if dict.keys.contains("DatabaseName") {
                self.databaseName = dict["DatabaseName"] as! String
            }
            if dict.keys.contains("EnvType") {
                self.envType = dict["EnvType"] as! Int32
            }
            if dict.keys.contains("IsVisible") {
                self.isVisible = dict["IsVisible"] as! Int32
            }
            if dict.keys.contains("LastAccessTime") {
                self.lastAccessTime = dict["LastAccessTime"] as! Int64
            }
            if dict.keys.contains("LastDdlTime") {
                self.lastDdlTime = dict["LastDdlTime"] as! Int64
            }
            if dict.keys.contains("LastModifyTime") {
                self.lastModifyTime = dict["LastModifyTime"] as! Int64
            }
            if dict.keys.contains("LifeCycle") {
                self.lifeCycle = dict["LifeCycle"] as! Int32
            }
            if dict.keys.contains("Location") {
                self.location = dict["Location"] as! String
            }
            if dict.keys.contains("OwnerId") {
                self.ownerId = dict["OwnerId"] as! String
            }
            if dict.keys.contains("PartitionKeys") {
                self.partitionKeys = dict["PartitionKeys"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
            if dict.keys.contains("Schema") {
                self.schema = dict["Schema"] as! String
            }
            if dict.keys.contains("TableGuid") {
                self.tableGuid = dict["TableGuid"] as! String
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
            if dict.keys.contains("TotalColumnCount") {
                self.totalColumnCount = dict["TotalColumnCount"] as! Int64
            }
        }
    }
    public var data: GetMetaTableFullInfoResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetMetaTableFullInfoResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaTableFullInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableFullInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaTableFullInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaTableIntroWikiRequest : Tea.TeaModel {
    public var tableGuid: String?

    public var wikiVersion: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.wikiVersion != nil {
            map["WikiVersion"] = self.wikiVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("WikiVersion") {
            self.wikiVersion = dict["WikiVersion"] as! Int64
        }
    }
}

public class GetMetaTableIntroWikiResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var content: String?

        public var createTime: Int64?

        public var creator: String?

        public var creatorName: String?

        public var modifiedTime: Int64?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("CreatorName") {
                self.creatorName = dict["CreatorName"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! Int64
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var data: GetMetaTableIntroWikiResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetMetaTableIntroWikiResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaTableIntroWikiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableIntroWikiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaTableIntroWikiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaTableLineageRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var direction: String?

    public var nextPrimaryKey: String?

    public var pageSize: Int32?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.nextPrimaryKey != nil {
            map["NextPrimaryKey"] = self.nextPrimaryKey!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("NextPrimaryKey") {
            self.nextPrimaryKey = dict["NextPrimaryKey"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class GetMetaTableLineageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataEntityList : Tea.TeaModel {
            public var createTimestamp: Int64?

            public var databaseName: String?

            public var tableGuid: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("DatabaseName") {
                    self.databaseName = dict["DatabaseName"] as! String
                }
                if dict.keys.contains("TableGuid") {
                    self.tableGuid = dict["TableGuid"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var dataEntityList: [GetMetaTableLineageResponseBody.Data.DataEntityList]?

        public var hasNext: Bool?

        public var nextPrimaryKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataEntityList != nil {
                var tmp : [Any] = []
                for k in self.dataEntityList! {
                    tmp.append(k.toMap())
                }
                map["DataEntityList"] = tmp
            }
            if self.hasNext != nil {
                map["HasNext"] = self.hasNext!
            }
            if self.nextPrimaryKey != nil {
                map["NextPrimaryKey"] = self.nextPrimaryKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataEntityList") {
                var tmp : [GetMetaTableLineageResponseBody.Data.DataEntityList] = []
                for v in dict["DataEntityList"] as! [Any] {
                    var model = GetMetaTableLineageResponseBody.Data.DataEntityList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataEntityList = tmp
            }
            if dict.keys.contains("HasNext") {
                self.hasNext = dict["HasNext"] as! Bool
            }
            if dict.keys.contains("NextPrimaryKey") {
                self.nextPrimaryKey = dict["NextPrimaryKey"] as! String
            }
        }
    }
    public var data: GetMetaTableLineageResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetMetaTableLineageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaTableLineageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableLineageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaTableLineageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaTableListByCategoryRequest : Tea.TeaModel {
    public var categoryId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryId") {
            self.categoryId = dict["CategoryId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class GetMetaTableListByCategoryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var tableGuidList: [String]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.tableGuidList != nil {
                map["TableGuidList"] = self.tableGuidList!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TableGuidList") {
                self.tableGuidList = dict["TableGuidList"] as! [String]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: GetMetaTableListByCategoryResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetMetaTableListByCategoryResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaTableListByCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableListByCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaTableListByCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaTableOutputRequest : Tea.TeaModel {
    public var endDate: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startDate: String?

    public var tableGuid: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetMetaTableOutputResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataEntityList : Tea.TeaModel {
            public var endTime: String?

            public var projectId: Int64?

            public var startTime: String?

            public var tableGuid: String?

            public var taskId: String?

            public var taskInstanceId: Int64?

            public var waitTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskInstanceId != nil {
                    map["TaskInstanceId"] = self.taskInstanceId!
                }
                if self.waitTime != nil {
                    map["WaitTime"] = self.waitTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("TableGuid") {
                    self.tableGuid = dict["TableGuid"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("TaskInstanceId") {
                    self.taskInstanceId = dict["TaskInstanceId"] as! Int64
                }
                if dict.keys.contains("WaitTime") {
                    self.waitTime = dict["WaitTime"] as! String
                }
            }
        }
        public var dataEntityList: [GetMetaTableOutputResponseBody.Data.DataEntityList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataEntityList != nil {
                var tmp : [Any] = []
                for k in self.dataEntityList! {
                    tmp.append(k.toMap())
                }
                map["DataEntityList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataEntityList") {
                var tmp : [GetMetaTableOutputResponseBody.Data.DataEntityList] = []
                for v in dict["DataEntityList"] as! [Any] {
                    var model = GetMetaTableOutputResponseBody.Data.DataEntityList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataEntityList = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: GetMetaTableOutputResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetMetaTableOutputResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaTableOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaTableOutputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaTablePartitionRequest : Tea.TeaModel {
    public class SortCriterion : Tea.TeaModel {
        public var order: String?

        public var sortField: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.order != nil {
                map["Order"] = self.order!
            }
            if self.sortField != nil {
                map["SortField"] = self.sortField!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Order") {
                self.order = dict["Order"] as! String
            }
            if dict.keys.contains("SortField") {
                self.sortField = dict["SortField"] as! String
            }
        }
    }
    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var sortCriterion: GetMetaTablePartitionRequest.SortCriterion?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sortCriterion?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortCriterion != nil {
            map["SortCriterion"] = self.sortCriterion?.toMap()
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortCriterion") {
            var model = GetMetaTablePartitionRequest.SortCriterion()
            model.fromMap(dict["SortCriterion"] as! [String: Any])
            self.sortCriterion = model
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class GetMetaTablePartitionShrinkRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var sortCriterionShrink: String?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortCriterionShrink != nil {
            map["SortCriterion"] = self.sortCriterionShrink!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortCriterion") {
            self.sortCriterionShrink = dict["SortCriterion"] as! String
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class GetMetaTablePartitionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataEntityList : Tea.TeaModel {
            public var comment: String?

            public var createTime: Int64?

            public var dataSize: Int64?

            public var modifiedTime: Int64?

            public var partitionGuid: String?

            public var partitionLocation: String?

            public var partitionName: String?

            public var partitionPath: String?

            public var partitionType: String?

            public var recordCount: Int64?

            public var tableGuid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dataSize != nil {
                    map["DataSize"] = self.dataSize!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.partitionGuid != nil {
                    map["PartitionGuid"] = self.partitionGuid!
                }
                if self.partitionLocation != nil {
                    map["PartitionLocation"] = self.partitionLocation!
                }
                if self.partitionName != nil {
                    map["PartitionName"] = self.partitionName!
                }
                if self.partitionPath != nil {
                    map["PartitionPath"] = self.partitionPath!
                }
                if self.partitionType != nil {
                    map["PartitionType"] = self.partitionType!
                }
                if self.recordCount != nil {
                    map["RecordCount"] = self.recordCount!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Comment") {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DataSize") {
                    self.dataSize = dict["DataSize"] as! Int64
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! Int64
                }
                if dict.keys.contains("PartitionGuid") {
                    self.partitionGuid = dict["PartitionGuid"] as! String
                }
                if dict.keys.contains("PartitionLocation") {
                    self.partitionLocation = dict["PartitionLocation"] as! String
                }
                if dict.keys.contains("PartitionName") {
                    self.partitionName = dict["PartitionName"] as! String
                }
                if dict.keys.contains("PartitionPath") {
                    self.partitionPath = dict["PartitionPath"] as! String
                }
                if dict.keys.contains("PartitionType") {
                    self.partitionType = dict["PartitionType"] as! String
                }
                if dict.keys.contains("RecordCount") {
                    self.recordCount = dict["RecordCount"] as! Int64
                }
                if dict.keys.contains("TableGuid") {
                    self.tableGuid = dict["TableGuid"] as! String
                }
            }
        }
        public var dataEntityList: [GetMetaTablePartitionResponseBody.Data.DataEntityList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataEntityList != nil {
                var tmp : [Any] = []
                for k in self.dataEntityList! {
                    tmp.append(k.toMap())
                }
                map["DataEntityList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataEntityList") {
                var tmp : [GetMetaTablePartitionResponseBody.Data.DataEntityList] = []
                for v in dict["DataEntityList"] as! [Any] {
                    var model = GetMetaTablePartitionResponseBody.Data.DataEntityList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataEntityList = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: GetMetaTablePartitionResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetMetaTablePartitionResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaTablePartitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTablePartitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaTablePartitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaTableProducingTasksRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var dbName: String?

    public var schemaName: String?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("SchemaName") {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class GetMetaTableProducingTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var taskId: String?

        public var taskName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskName") {
                self.taskName = dict["TaskName"] as! String
            }
        }
    }
    public var data: [GetMetaTableProducingTasksResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [GetMetaTableProducingTasksResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetMetaTableProducingTasksResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaTableProducingTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableProducingTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaTableProducingTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaTableThemeLevelRequest : Tea.TeaModel {
    public var dataSourceType: String?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
    }
}

public class GetMetaTableThemeLevelResponseBody : Tea.TeaModel {
    public class Entity : Tea.TeaModel {
        public class Level : Tea.TeaModel {
            public var description_: String?

            public var levelId: Int64?

            public var name: String?

            public var type: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.levelId != nil {
                    map["LevelId"] = self.levelId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("LevelId") {
                    self.levelId = dict["LevelId"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! Int32
                }
            }
        }
        public class Theme : Tea.TeaModel {
            public var level: Int32?

            public var name: String?

            public var parentId: Int64?

            public var themeId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.themeId != nil {
                    map["ThemeId"] = self.themeId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Level") {
                    self.level = dict["Level"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ParentId") {
                    self.parentId = dict["ParentId"] as! Int64
                }
                if dict.keys.contains("ThemeId") {
                    self.themeId = dict["ThemeId"] as! Int64
                }
            }
        }
        public var level: [GetMetaTableThemeLevelResponseBody.Entity.Level]?

        public var theme: [GetMetaTableThemeLevelResponseBody.Entity.Theme]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.level != nil {
                var tmp : [Any] = []
                for k in self.level! {
                    tmp.append(k.toMap())
                }
                map["Level"] = tmp
            }
            if self.theme != nil {
                var tmp : [Any] = []
                for k in self.theme! {
                    tmp.append(k.toMap())
                }
                map["Theme"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Level") {
                var tmp : [GetMetaTableThemeLevelResponseBody.Entity.Level] = []
                for v in dict["Level"] as! [Any] {
                    var model = GetMetaTableThemeLevelResponseBody.Entity.Level()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.level = tmp
            }
            if dict.keys.contains("Theme") {
                var tmp : [GetMetaTableThemeLevelResponseBody.Entity.Theme] = []
                for v in dict["Theme"] as! [Any] {
                    var model = GetMetaTableThemeLevelResponseBody.Entity.Theme()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.theme = tmp
            }
        }
    }
    public var entity: GetMetaTableThemeLevelResponseBody.Entity?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.entity?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entity != nil {
            map["Entity"] = self.entity?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Entity") {
            var model = GetMetaTableThemeLevelResponseBody.Entity()
            model.fromMap(dict["Entity"] as! [String: Any])
            self.entity = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaTableThemeLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableThemeLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaTableThemeLevelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMigrationProcessRequest : Tea.TeaModel {
    public var migrationId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationId != nil {
            map["MigrationId"] = self.migrationId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MigrationId") {
            self.migrationId = dict["MigrationId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class GetMigrationProcessResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var taskName: String?

        public var taskStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskName") {
                self.taskName = dict["TaskName"] as! String
            }
            if dict.keys.contains("TaskStatus") {
                self.taskStatus = dict["TaskStatus"] as! String
            }
        }
    }
    public var data: [GetMigrationProcessResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [GetMigrationProcessResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetMigrationProcessResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMigrationProcessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMigrationProcessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMigrationProcessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMigrationSummaryRequest : Tea.TeaModel {
    public var migrationId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationId != nil {
            map["MigrationId"] = self.migrationId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MigrationId") {
            self.migrationId = dict["MigrationId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class GetMigrationSummaryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createUser: String?

        public var downloadUrl: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var migrationId: Int64?

        public var name: String?

        public var opUser: String?

        public var projectId: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.downloadUrl != nil {
                map["DownloadUrl"] = self.downloadUrl!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.migrationId != nil {
                map["MigrationId"] = self.migrationId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.opUser != nil {
                map["OpUser"] = self.opUser!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateUser") {
                self.createUser = dict["CreateUser"] as! String
            }
            if dict.keys.contains("DownloadUrl") {
                self.downloadUrl = dict["DownloadUrl"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! Int64
            }
            if dict.keys.contains("MigrationId") {
                self.migrationId = dict["MigrationId"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OpUser") {
                self.opUser = dict["OpUser"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: GetMigrationSummaryResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetMigrationSummaryResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMigrationSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMigrationSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMigrationSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodeRequest : Tea.TeaModel {
    public var nodeId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class GetNodeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var baselineId: Int64?

        public var businessId: Int64?

        public var connection: String?

        public var createTime: Int64?

        public var cronExpress: String?

        public var deployDate: Int64?

        public var description_: String?

        public var dqcDescription: String?

        public var dqcType: Int32?

        public var fileId: Int64?

        public var fileType: Int32?

        public var fileVersion: Int32?

        public var modifyTime: Int64?

        public var nodeId: Int64?

        public var nodeName: String?

        public var ownerId: String?

        public var paramValues: String?

        public var priority: Int32?

        public var programType: String?

        public var projectId: Int64?

        public var relatedFlowId: Int64?

        public var repeatInterval: Int64?

        public var repeatMode: Int32?

        public var repeatability: String?

        public var resGroupIdentifier: String?

        public var resGroupName: String?

        public var schedulerType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineId != nil {
                map["BaselineId"] = self.baselineId!
            }
            if self.businessId != nil {
                map["BusinessId"] = self.businessId!
            }
            if self.connection != nil {
                map["Connection"] = self.connection!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.cronExpress != nil {
                map["CronExpress"] = self.cronExpress!
            }
            if self.deployDate != nil {
                map["DeployDate"] = self.deployDate!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dqcDescription != nil {
                map["DqcDescription"] = self.dqcDescription!
            }
            if self.dqcType != nil {
                map["DqcType"] = self.dqcType!
            }
            if self.fileId != nil {
                map["FileId"] = self.fileId!
            }
            if self.fileType != nil {
                map["FileType"] = self.fileType!
            }
            if self.fileVersion != nil {
                map["FileVersion"] = self.fileVersion!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.paramValues != nil {
                map["ParamValues"] = self.paramValues!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.programType != nil {
                map["ProgramType"] = self.programType!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.relatedFlowId != nil {
                map["RelatedFlowId"] = self.relatedFlowId!
            }
            if self.repeatInterval != nil {
                map["RepeatInterval"] = self.repeatInterval!
            }
            if self.repeatMode != nil {
                map["RepeatMode"] = self.repeatMode!
            }
            if self.repeatability != nil {
                map["Repeatability"] = self.repeatability!
            }
            if self.resGroupIdentifier != nil {
                map["ResGroupIdentifier"] = self.resGroupIdentifier!
            }
            if self.resGroupName != nil {
                map["ResGroupName"] = self.resGroupName!
            }
            if self.schedulerType != nil {
                map["SchedulerType"] = self.schedulerType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BaselineId") {
                self.baselineId = dict["BaselineId"] as! Int64
            }
            if dict.keys.contains("BusinessId") {
                self.businessId = dict["BusinessId"] as! Int64
            }
            if dict.keys.contains("Connection") {
                self.connection = dict["Connection"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CronExpress") {
                self.cronExpress = dict["CronExpress"] as! String
            }
            if dict.keys.contains("DeployDate") {
                self.deployDate = dict["DeployDate"] as! Int64
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DqcDescription") {
                self.dqcDescription = dict["DqcDescription"] as! String
            }
            if dict.keys.contains("DqcType") {
                self.dqcType = dict["DqcType"] as! Int32
            }
            if dict.keys.contains("FileId") {
                self.fileId = dict["FileId"] as! Int64
            }
            if dict.keys.contains("FileType") {
                self.fileType = dict["FileType"] as! Int32
            }
            if dict.keys.contains("FileVersion") {
                self.fileVersion = dict["FileVersion"] as! Int32
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! Int64
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("OwnerId") {
                self.ownerId = dict["OwnerId"] as! String
            }
            if dict.keys.contains("ParamValues") {
                self.paramValues = dict["ParamValues"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("ProgramType") {
                self.programType = dict["ProgramType"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("RelatedFlowId") {
                self.relatedFlowId = dict["RelatedFlowId"] as! Int64
            }
            if dict.keys.contains("RepeatInterval") {
                self.repeatInterval = dict["RepeatInterval"] as! Int64
            }
            if dict.keys.contains("RepeatMode") {
                self.repeatMode = dict["RepeatMode"] as! Int32
            }
            if dict.keys.contains("Repeatability") {
                self.repeatability = dict["Repeatability"] as! String
            }
            if dict.keys.contains("ResGroupIdentifier") {
                self.resGroupIdentifier = dict["ResGroupIdentifier"] as! String
            }
            if dict.keys.contains("ResGroupName") {
                self.resGroupName = dict["ResGroupName"] as! String
            }
            if dict.keys.contains("SchedulerType") {
                self.schedulerType = dict["SchedulerType"] as! String
            }
        }
    }
    public var data: GetNodeResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetNodeResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodeChildrenRequest : Tea.TeaModel {
    public var nodeId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class GetNodeChildrenResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Nodes : Tea.TeaModel {
            public var baselineId: Int64?

            public var cronExpress: String?

            public var nodeId: Int64?

            public var nodeName: String?

            public var ownerId: String?

            public var priority: Int32?

            public var programType: String?

            public var projectId: Int64?

            public var repeatability: Bool?

            public var schedulerType: String?

            public var stepType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.cronExpress != nil {
                    map["CronExpress"] = self.cronExpress!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.programType != nil {
                    map["ProgramType"] = self.programType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.repeatability != nil {
                    map["Repeatability"] = self.repeatability!
                }
                if self.schedulerType != nil {
                    map["SchedulerType"] = self.schedulerType!
                }
                if self.stepType != nil {
                    map["StepType"] = self.stepType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("CronExpress") {
                    self.cronExpress = dict["CronExpress"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("OwnerId") {
                    self.ownerId = dict["OwnerId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ProgramType") {
                    self.programType = dict["ProgramType"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("Repeatability") {
                    self.repeatability = dict["Repeatability"] as! Bool
                }
                if dict.keys.contains("SchedulerType") {
                    self.schedulerType = dict["SchedulerType"] as! String
                }
                if dict.keys.contains("StepType") {
                    self.stepType = dict["StepType"] as! String
                }
            }
        }
        public var nodes: [GetNodeChildrenResponseBody.Data.Nodes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Nodes") {
                var tmp : [GetNodeChildrenResponseBody.Data.Nodes] = []
                for v in dict["Nodes"] as! [Any] {
                    var model = GetNodeChildrenResponseBody.Data.Nodes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodes = tmp
            }
        }
    }
    public var data: GetNodeChildrenResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetNodeChildrenResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetNodeChildrenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeChildrenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNodeChildrenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodeCodeRequest : Tea.TeaModel {
    public var nodeId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class GetNodeCodeResponseBody : Tea.TeaModel {
    public var data: String?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetNodeCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNodeCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodeOnBaselineRequest : Tea.TeaModel {
    public var baselineId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineId") {
            self.baselineId = dict["BaselineId"] as! Int64
        }
    }
}

public class GetNodeOnBaselineResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var nodeId: Int64?

        public var nodeName: String?

        public var owner: String?

        public var projectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! Int64
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
        }
    }
    public var data: [GetNodeOnBaselineResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [GetNodeOnBaselineResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetNodeOnBaselineResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetNodeOnBaselineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeOnBaselineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNodeOnBaselineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodeParentsRequest : Tea.TeaModel {
    public var nodeId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class GetNodeParentsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Nodes : Tea.TeaModel {
            public var baselineId: Int64?

            public var cronExpress: String?

            public var nodeId: Int64?

            public var nodeName: String?

            public var ownerId: String?

            public var priority: Int32?

            public var programType: String?

            public var projectId: Int64?

            public var repeatability: Bool?

            public var schedulerType: String?

            public var stepType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.cronExpress != nil {
                    map["CronExpress"] = self.cronExpress!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.programType != nil {
                    map["ProgramType"] = self.programType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.repeatability != nil {
                    map["Repeatability"] = self.repeatability!
                }
                if self.schedulerType != nil {
                    map["SchedulerType"] = self.schedulerType!
                }
                if self.stepType != nil {
                    map["StepType"] = self.stepType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("CronExpress") {
                    self.cronExpress = dict["CronExpress"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("OwnerId") {
                    self.ownerId = dict["OwnerId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ProgramType") {
                    self.programType = dict["ProgramType"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("Repeatability") {
                    self.repeatability = dict["Repeatability"] as! Bool
                }
                if dict.keys.contains("SchedulerType") {
                    self.schedulerType = dict["SchedulerType"] as! String
                }
                if dict.keys.contains("StepType") {
                    self.stepType = dict["StepType"] as! String
                }
            }
        }
        public var nodes: [GetNodeParentsResponseBody.Data.Nodes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Nodes") {
                var tmp : [GetNodeParentsResponseBody.Data.Nodes] = []
                for v in dict["Nodes"] as! [Any] {
                    var model = GetNodeParentsResponseBody.Data.Nodes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodes = tmp
            }
        }
    }
    public var data: GetNodeParentsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetNodeParentsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetNodeParentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeParentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNodeParentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodeTypeListInfoRequest : Tea.TeaModel {
    public var keyword: String?

    public var locale: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.locale != nil {
            map["Locale"] = self.locale!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Locale") {
            self.locale = dict["Locale"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class GetNodeTypeListInfoResponseBody : Tea.TeaModel {
    public class NodeTypeInfoList : Tea.TeaModel {
        public class NodeTypeInfo : Tea.TeaModel {
            public var nodeType: Int32?

            public var nodeTypeName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nodeType != nil {
                    map["NodeType"] = self.nodeType!
                }
                if self.nodeTypeName != nil {
                    map["NodeTypeName"] = self.nodeTypeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NodeType") {
                    self.nodeType = dict["NodeType"] as! Int32
                }
                if dict.keys.contains("NodeTypeName") {
                    self.nodeTypeName = dict["NodeTypeName"] as! String
                }
            }
        }
        public var nodeTypeInfo: [GetNodeTypeListInfoResponseBody.NodeTypeInfoList.NodeTypeInfo]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeTypeInfo != nil {
                var tmp : [Any] = []
                for k in self.nodeTypeInfo! {
                    tmp.append(k.toMap())
                }
                map["NodeTypeInfo"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeTypeInfo") {
                var tmp : [GetNodeTypeListInfoResponseBody.NodeTypeInfoList.NodeTypeInfo] = []
                for v in dict["NodeTypeInfo"] as! [Any] {
                    var model = GetNodeTypeListInfoResponseBody.NodeTypeInfoList.NodeTypeInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeTypeInfo = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var nodeTypeInfoList: GetNodeTypeListInfoResponseBody.NodeTypeInfoList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeTypeInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeTypeInfoList != nil {
            map["NodeTypeInfoList"] = self.nodeTypeInfoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeTypeInfoList") {
            var model = GetNodeTypeListInfoResponseBody.NodeTypeInfoList()
            model.fromMap(dict["NodeTypeInfoList"] as! [String: Any])
            self.nodeTypeInfoList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetNodeTypeListInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeTypeListInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNodeTypeListInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOpRiskDataRequest : Tea.TeaModel {
    public var date: String?

    public var name: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var riskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.date != nil {
            map["Date"] = self.date!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.riskType != nil {
            map["RiskType"] = self.riskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Date") {
            self.date = dict["Date"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RiskType") {
            self.riskType = dict["RiskType"] as! String
        }
    }
}

public class GetOpRiskDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var riskData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.riskData != nil {
            map["RiskData"] = self.riskData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RiskData") {
            self.riskData = dict["RiskData"] as! String
        }
    }
}

public class GetOpRiskDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpRiskDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOpRiskDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOpSensitiveDataRequest : Tea.TeaModel {
    public var date: String?

    public var name: String?

    public var opType: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.date != nil {
            map["Date"] = self.date!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.opType != nil {
            map["OpType"] = self.opType!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Date") {
            self.date = dict["Date"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OpType") {
            self.opType = dict["OpType"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class GetOpSensitiveDataResponseBody : Tea.TeaModel {
    public var opSensitiveData: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.opSensitiveData != nil {
            map["OpSensitiveData"] = self.opSensitiveData!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpSensitiveData") {
            self.opSensitiveData = dict["OpSensitiveData"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetOpSensitiveDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpSensitiveDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOpSensitiveDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOptionValueForProjectRequest : Tea.TeaModel {
    public var extensionCode: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extensionCode != nil {
            map["ExtensionCode"] = self.extensionCode!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExtensionCode") {
            self.extensionCode = dict["ExtensionCode"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class GetOptionValueForProjectResponseBody : Tea.TeaModel {
    public var optionValue: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.optionValue != nil {
            map["OptionValue"] = self.optionValue!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OptionValue") {
            self.optionValue = dict["OptionValue"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetOptionValueForProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOptionValueForProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOptionValueForProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPermissionApplyOrderDetailRequest : Tea.TeaModel {
    public var flowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowId") {
            self.flowId = dict["FlowId"] as! String
        }
    }
}

public class GetPermissionApplyOrderDetailResponseBody : Tea.TeaModel {
    public class ApplyOrderDetail : Tea.TeaModel {
        public class ApproveAccountList : Tea.TeaModel {
            public var baseId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baseId != nil {
                    map["BaseId"] = self.baseId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaseId") {
                    self.baseId = dict["BaseId"] as! String
                }
            }
        }
        public class ApproveContent : Tea.TeaModel {
            public class ProjectMeta : Tea.TeaModel {
                public class ObjectMetaList : Tea.TeaModel {
                    public class ColumnMetaList : Tea.TeaModel {
                        public var columnActions: [String]?

                        public var columnComment: String?

                        public var columnName: String?

                        public var securityLevel: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.columnActions != nil {
                                map["ColumnActions"] = self.columnActions!
                            }
                            if self.columnComment != nil {
                                map["ColumnComment"] = self.columnComment!
                            }
                            if self.columnName != nil {
                                map["ColumnName"] = self.columnName!
                            }
                            if self.securityLevel != nil {
                                map["SecurityLevel"] = self.securityLevel!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ColumnActions") {
                                self.columnActions = dict["ColumnActions"] as! [String]
                            }
                            if dict.keys.contains("ColumnComment") {
                                self.columnComment = dict["ColumnComment"] as! String
                            }
                            if dict.keys.contains("ColumnName") {
                                self.columnName = dict["ColumnName"] as! String
                            }
                            if dict.keys.contains("SecurityLevel") {
                                self.securityLevel = dict["SecurityLevel"] as! String
                            }
                        }
                    }
                    public var actions: [String]?

                    public var columnMetaList: [GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent.ProjectMeta.ObjectMetaList.ColumnMetaList]?

                    public var objectName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.actions != nil {
                            map["Actions"] = self.actions!
                        }
                        if self.columnMetaList != nil {
                            var tmp : [Any] = []
                            for k in self.columnMetaList! {
                                tmp.append(k.toMap())
                            }
                            map["ColumnMetaList"] = tmp
                        }
                        if self.objectName != nil {
                            map["ObjectName"] = self.objectName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Actions") {
                            self.actions = dict["Actions"] as! [String]
                        }
                        if dict.keys.contains("ColumnMetaList") {
                            var tmp : [GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent.ProjectMeta.ObjectMetaList.ColumnMetaList] = []
                            for v in dict["ColumnMetaList"] as! [Any] {
                                var model = GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent.ProjectMeta.ObjectMetaList.ColumnMetaList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.columnMetaList = tmp
                        }
                        if dict.keys.contains("ObjectName") {
                            self.objectName = dict["ObjectName"] as! String
                        }
                    }
                }
                public var maxComputeProjectName: String?

                public var objectMetaList: [GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent.ProjectMeta.ObjectMetaList]?

                public var workspaceId: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxComputeProjectName != nil {
                        map["MaxComputeProjectName"] = self.maxComputeProjectName!
                    }
                    if self.objectMetaList != nil {
                        var tmp : [Any] = []
                        for k in self.objectMetaList! {
                            tmp.append(k.toMap())
                        }
                        map["ObjectMetaList"] = tmp
                    }
                    if self.workspaceId != nil {
                        map["WorkspaceId"] = self.workspaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MaxComputeProjectName") {
                        self.maxComputeProjectName = dict["MaxComputeProjectName"] as! String
                    }
                    if dict.keys.contains("ObjectMetaList") {
                        var tmp : [GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent.ProjectMeta.ObjectMetaList] = []
                        for v in dict["ObjectMetaList"] as! [Any] {
                            var model = GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent.ProjectMeta.ObjectMetaList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.objectMetaList = tmp
                    }
                    if dict.keys.contains("WorkspaceId") {
                        self.workspaceId = dict["WorkspaceId"] as! Int32
                    }
                }
            }
            public var applyReason: String?

            public var deadline: Int64?

            public var orderType: Int32?

            public var projectMeta: GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent.ProjectMeta?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.projectMeta?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applyReason != nil {
                    map["ApplyReason"] = self.applyReason!
                }
                if self.deadline != nil {
                    map["Deadline"] = self.deadline!
                }
                if self.orderType != nil {
                    map["OrderType"] = self.orderType!
                }
                if self.projectMeta != nil {
                    map["ProjectMeta"] = self.projectMeta?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApplyReason") {
                    self.applyReason = dict["ApplyReason"] as! String
                }
                if dict.keys.contains("Deadline") {
                    self.deadline = dict["Deadline"] as! Int64
                }
                if dict.keys.contains("OrderType") {
                    self.orderType = dict["OrderType"] as! Int32
                }
                if dict.keys.contains("ProjectMeta") {
                    var model = GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent.ProjectMeta()
                    model.fromMap(dict["ProjectMeta"] as! [String: Any])
                    self.projectMeta = model
                }
            }
        }
        public class GranteeObjectList : Tea.TeaModel {
            public var granteeId: String?

            public var granteeName: String?

            public var granteeType: Int32?

            public var granteeTypeSub: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.granteeId != nil {
                    map["GranteeId"] = self.granteeId!
                }
                if self.granteeName != nil {
                    map["GranteeName"] = self.granteeName!
                }
                if self.granteeType != nil {
                    map["GranteeType"] = self.granteeType!
                }
                if self.granteeTypeSub != nil {
                    map["GranteeTypeSub"] = self.granteeTypeSub!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GranteeId") {
                    self.granteeId = dict["GranteeId"] as! String
                }
                if dict.keys.contains("GranteeName") {
                    self.granteeName = dict["GranteeName"] as! String
                }
                if dict.keys.contains("GranteeType") {
                    self.granteeType = dict["GranteeType"] as! Int32
                }
                if dict.keys.contains("GranteeTypeSub") {
                    self.granteeTypeSub = dict["GranteeTypeSub"] as! Int32
                }
            }
        }
        public var applyBaseId: String?

        public var applyTimestamp: Int64?

        public var approveAccountList: [GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveAccountList]?

        public var approveContent: GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent?

        public var flowId: String?

        public var flowStatus: Int32?

        public var granteeObjectList: [GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.GranteeObjectList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.approveContent?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applyBaseId != nil {
                map["ApplyBaseId"] = self.applyBaseId!
            }
            if self.applyTimestamp != nil {
                map["ApplyTimestamp"] = self.applyTimestamp!
            }
            if self.approveAccountList != nil {
                var tmp : [Any] = []
                for k in self.approveAccountList! {
                    tmp.append(k.toMap())
                }
                map["ApproveAccountList"] = tmp
            }
            if self.approveContent != nil {
                map["ApproveContent"] = self.approveContent?.toMap()
            }
            if self.flowId != nil {
                map["FlowId"] = self.flowId!
            }
            if self.flowStatus != nil {
                map["FlowStatus"] = self.flowStatus!
            }
            if self.granteeObjectList != nil {
                var tmp : [Any] = []
                for k in self.granteeObjectList! {
                    tmp.append(k.toMap())
                }
                map["GranteeObjectList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplyBaseId") {
                self.applyBaseId = dict["ApplyBaseId"] as! String
            }
            if dict.keys.contains("ApplyTimestamp") {
                self.applyTimestamp = dict["ApplyTimestamp"] as! Int64
            }
            if dict.keys.contains("ApproveAccountList") {
                var tmp : [GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveAccountList] = []
                for v in dict["ApproveAccountList"] as! [Any] {
                    var model = GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveAccountList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.approveAccountList = tmp
            }
            if dict.keys.contains("ApproveContent") {
                var model = GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent()
                model.fromMap(dict["ApproveContent"] as! [String: Any])
                self.approveContent = model
            }
            if dict.keys.contains("FlowId") {
                self.flowId = dict["FlowId"] as! String
            }
            if dict.keys.contains("FlowStatus") {
                self.flowStatus = dict["FlowStatus"] as! Int32
            }
            if dict.keys.contains("GranteeObjectList") {
                var tmp : [GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.GranteeObjectList] = []
                for v in dict["GranteeObjectList"] as! [Any] {
                    var model = GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.GranteeObjectList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.granteeObjectList = tmp
            }
        }
    }
    public var applyOrderDetail: GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applyOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applyOrderDetail != nil {
            map["ApplyOrderDetail"] = self.applyOrderDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplyOrderDetail") {
            var model = GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail()
            model.fromMap(dict["ApplyOrderDetail"] as! [String: Any])
            self.applyOrderDetail = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPermissionApplyOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPermissionApplyOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPermissionApplyOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProjectRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class GetProjectResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var appkey: String?

        public var baseProject: Bool?

        public var defaultDiResourceGroupIdentifier: String?

        public var destination: Int32?

        public var devStorageQuota: String?

        public var developmentType: Int32?

        public var disableDevelopment: Bool?

        public var envTypes: [String]?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var isAllowDownload: Int32?

        public var isDefault: Int32?

        public var maxFlowNode: Int32?

        public var prodStorageQuota: String?

        public var projectDescription: String?

        public var projectId: Int32?

        public var projectIdentifier: String?

        public var projectMode: Int32?

        public var projectName: String?

        public var projectOwnerBaseId: String?

        public var protectedMode: Int32?

        public var residentArea: String?

        public var resourceManagerResourceGroupId: String?

        public var schedulerMaxRetryTimes: Int32?

        public var schedulerRetryInterval: Int32?

        public var status: Int32?

        public var tablePrivacyMode: Int32?

        public var tags: [GetProjectResponseBody.Data.Tags]?

        public var tenantId: Int64?

        public var useProxyOdpsAccount: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appkey != nil {
                map["Appkey"] = self.appkey!
            }
            if self.baseProject != nil {
                map["BaseProject"] = self.baseProject!
            }
            if self.defaultDiResourceGroupIdentifier != nil {
                map["DefaultDiResourceGroupIdentifier"] = self.defaultDiResourceGroupIdentifier!
            }
            if self.destination != nil {
                map["Destination"] = self.destination!
            }
            if self.devStorageQuota != nil {
                map["DevStorageQuota"] = self.devStorageQuota!
            }
            if self.developmentType != nil {
                map["DevelopmentType"] = self.developmentType!
            }
            if self.disableDevelopment != nil {
                map["DisableDevelopment"] = self.disableDevelopment!
            }
            if self.envTypes != nil {
                map["EnvTypes"] = self.envTypes!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.isAllowDownload != nil {
                map["IsAllowDownload"] = self.isAllowDownload!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.maxFlowNode != nil {
                map["MaxFlowNode"] = self.maxFlowNode!
            }
            if self.prodStorageQuota != nil {
                map["ProdStorageQuota"] = self.prodStorageQuota!
            }
            if self.projectDescription != nil {
                map["ProjectDescription"] = self.projectDescription!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectIdentifier != nil {
                map["ProjectIdentifier"] = self.projectIdentifier!
            }
            if self.projectMode != nil {
                map["ProjectMode"] = self.projectMode!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.projectOwnerBaseId != nil {
                map["ProjectOwnerBaseId"] = self.projectOwnerBaseId!
            }
            if self.protectedMode != nil {
                map["ProtectedMode"] = self.protectedMode!
            }
            if self.residentArea != nil {
                map["ResidentArea"] = self.residentArea!
            }
            if self.resourceManagerResourceGroupId != nil {
                map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
            }
            if self.schedulerMaxRetryTimes != nil {
                map["SchedulerMaxRetryTimes"] = self.schedulerMaxRetryTimes!
            }
            if self.schedulerRetryInterval != nil {
                map["SchedulerRetryInterval"] = self.schedulerRetryInterval!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tablePrivacyMode != nil {
                map["TablePrivacyMode"] = self.tablePrivacyMode!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.useProxyOdpsAccount != nil {
                map["UseProxyOdpsAccount"] = self.useProxyOdpsAccount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Appkey") {
                self.appkey = dict["Appkey"] as! String
            }
            if dict.keys.contains("BaseProject") {
                self.baseProject = dict["BaseProject"] as! Bool
            }
            if dict.keys.contains("DefaultDiResourceGroupIdentifier") {
                self.defaultDiResourceGroupIdentifier = dict["DefaultDiResourceGroupIdentifier"] as! String
            }
            if dict.keys.contains("Destination") {
                self.destination = dict["Destination"] as! Int32
            }
            if dict.keys.contains("DevStorageQuota") {
                self.devStorageQuota = dict["DevStorageQuota"] as! String
            }
            if dict.keys.contains("DevelopmentType") {
                self.developmentType = dict["DevelopmentType"] as! Int32
            }
            if dict.keys.contains("DisableDevelopment") {
                self.disableDevelopment = dict["DisableDevelopment"] as! Bool
            }
            if dict.keys.contains("EnvTypes") {
                self.envTypes = dict["EnvTypes"] as! [String]
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("IsAllowDownload") {
                self.isAllowDownload = dict["IsAllowDownload"] as! Int32
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! Int32
            }
            if dict.keys.contains("MaxFlowNode") {
                self.maxFlowNode = dict["MaxFlowNode"] as! Int32
            }
            if dict.keys.contains("ProdStorageQuota") {
                self.prodStorageQuota = dict["ProdStorageQuota"] as! String
            }
            if dict.keys.contains("ProjectDescription") {
                self.projectDescription = dict["ProjectDescription"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int32
            }
            if dict.keys.contains("ProjectIdentifier") {
                self.projectIdentifier = dict["ProjectIdentifier"] as! String
            }
            if dict.keys.contains("ProjectMode") {
                self.projectMode = dict["ProjectMode"] as! Int32
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
            if dict.keys.contains("ProjectOwnerBaseId") {
                self.projectOwnerBaseId = dict["ProjectOwnerBaseId"] as! String
            }
            if dict.keys.contains("ProtectedMode") {
                self.protectedMode = dict["ProtectedMode"] as! Int32
            }
            if dict.keys.contains("ResidentArea") {
                self.residentArea = dict["ResidentArea"] as! String
            }
            if dict.keys.contains("ResourceManagerResourceGroupId") {
                self.resourceManagerResourceGroupId = dict["ResourceManagerResourceGroupId"] as! String
            }
            if dict.keys.contains("SchedulerMaxRetryTimes") {
                self.schedulerMaxRetryTimes = dict["SchedulerMaxRetryTimes"] as! Int32
            }
            if dict.keys.contains("SchedulerRetryInterval") {
                self.schedulerRetryInterval = dict["SchedulerRetryInterval"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("TablePrivacyMode") {
                self.tablePrivacyMode = dict["TablePrivacyMode"] as! Int32
            }
            if dict.keys.contains("Tags") {
                var tmp : [GetProjectResponseBody.Data.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = GetProjectResponseBody.Data.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
            if dict.keys.contains("UseProxyOdpsAccount") {
                self.useProxyOdpsAccount = dict["UseProxyOdpsAccount"] as! Bool
            }
        }
    }
    public var data: GetProjectResponseBody.Data?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetProjectResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProjectDetailRequest : Tea.TeaModel {
    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class GetProjectDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var defaultDiResourceGroupIdentifier: String?

        public var developmentType: Int32?

        public var disableDevelopment: Bool?

        public var envTypes: [String]?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var isAllowDownload: Int32?

        public var isDefault: Int32?

        public var projectDescription: String?

        public var projectId: Int32?

        public var projectIdentifier: String?

        public var projectMode: Int32?

        public var projectName: String?

        public var projectOwnerBaseId: String?

        public var protectedMode: Int32?

        public var residentArea: String?

        public var resourceManagerResourceGroupId: String?

        public var schedulerMaxRetryTimes: Int32?

        public var schedulerRetryInterval: Int32?

        public var status: Int32?

        public var tablePrivacyMode: Int32?

        public var tags: [GetProjectDetailResponseBody.Data.Tags]?

        public var tenantId: Int64?

        public var useProxyOdpsAccount: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultDiResourceGroupIdentifier != nil {
                map["DefaultDiResourceGroupIdentifier"] = self.defaultDiResourceGroupIdentifier!
            }
            if self.developmentType != nil {
                map["DevelopmentType"] = self.developmentType!
            }
            if self.disableDevelopment != nil {
                map["DisableDevelopment"] = self.disableDevelopment!
            }
            if self.envTypes != nil {
                map["EnvTypes"] = self.envTypes!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.isAllowDownload != nil {
                map["IsAllowDownload"] = self.isAllowDownload!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.projectDescription != nil {
                map["ProjectDescription"] = self.projectDescription!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectIdentifier != nil {
                map["ProjectIdentifier"] = self.projectIdentifier!
            }
            if self.projectMode != nil {
                map["ProjectMode"] = self.projectMode!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.projectOwnerBaseId != nil {
                map["ProjectOwnerBaseId"] = self.projectOwnerBaseId!
            }
            if self.protectedMode != nil {
                map["ProtectedMode"] = self.protectedMode!
            }
            if self.residentArea != nil {
                map["ResidentArea"] = self.residentArea!
            }
            if self.resourceManagerResourceGroupId != nil {
                map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
            }
            if self.schedulerMaxRetryTimes != nil {
                map["SchedulerMaxRetryTimes"] = self.schedulerMaxRetryTimes!
            }
            if self.schedulerRetryInterval != nil {
                map["SchedulerRetryInterval"] = self.schedulerRetryInterval!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tablePrivacyMode != nil {
                map["TablePrivacyMode"] = self.tablePrivacyMode!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.useProxyOdpsAccount != nil {
                map["UseProxyOdpsAccount"] = self.useProxyOdpsAccount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultDiResourceGroupIdentifier") {
                self.defaultDiResourceGroupIdentifier = dict["DefaultDiResourceGroupIdentifier"] as! String
            }
            if dict.keys.contains("DevelopmentType") {
                self.developmentType = dict["DevelopmentType"] as! Int32
            }
            if dict.keys.contains("DisableDevelopment") {
                self.disableDevelopment = dict["DisableDevelopment"] as! Bool
            }
            if dict.keys.contains("EnvTypes") {
                self.envTypes = dict["EnvTypes"] as! [String]
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("IsAllowDownload") {
                self.isAllowDownload = dict["IsAllowDownload"] as! Int32
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! Int32
            }
            if dict.keys.contains("ProjectDescription") {
                self.projectDescription = dict["ProjectDescription"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int32
            }
            if dict.keys.contains("ProjectIdentifier") {
                self.projectIdentifier = dict["ProjectIdentifier"] as! String
            }
            if dict.keys.contains("ProjectMode") {
                self.projectMode = dict["ProjectMode"] as! Int32
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
            if dict.keys.contains("ProjectOwnerBaseId") {
                self.projectOwnerBaseId = dict["ProjectOwnerBaseId"] as! String
            }
            if dict.keys.contains("ProtectedMode") {
                self.protectedMode = dict["ProtectedMode"] as! Int32
            }
            if dict.keys.contains("ResidentArea") {
                self.residentArea = dict["ResidentArea"] as! String
            }
            if dict.keys.contains("ResourceManagerResourceGroupId") {
                self.resourceManagerResourceGroupId = dict["ResourceManagerResourceGroupId"] as! String
            }
            if dict.keys.contains("SchedulerMaxRetryTimes") {
                self.schedulerMaxRetryTimes = dict["SchedulerMaxRetryTimes"] as! Int32
            }
            if dict.keys.contains("SchedulerRetryInterval") {
                self.schedulerRetryInterval = dict["SchedulerRetryInterval"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("TablePrivacyMode") {
                self.tablePrivacyMode = dict["TablePrivacyMode"] as! Int32
            }
            if dict.keys.contains("Tags") {
                var tmp : [GetProjectDetailResponseBody.Data.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = GetProjectDetailResponseBody.Data.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
            if dict.keys.contains("UseProxyOdpsAccount") {
                self.useProxyOdpsAccount = dict["UseProxyOdpsAccount"] as! Bool
            }
        }
    }
    public var data: GetProjectDetailResponseBody.Data?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetProjectDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetProjectDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProjectDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetProjectDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetQualityEntityRequest : Tea.TeaModel {
    public var envType: String?

    public var matchExpression: String?

    public var projectId: Int64?

    public var projectName: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.matchExpression != nil {
            map["MatchExpression"] = self.matchExpression!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("MatchExpression") {
            self.matchExpression = dict["MatchExpression"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class GetQualityEntityResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createTime: Int64?

        public var entityLevel: Int32?

        public var envType: String?

        public var followers: String?

        public var hasRelativeNode: Bool?

        public var id: Int64?

        public var matchExpression: String?

        public var modifyTime: Int64?

        public var modifyUser: String?

        public var onDuty: String?

        public var onDutyAccountName: String?

        public var projectName: String?

        public var relativeNode: String?

        public var sql: Int32?

        public var tableName: String?

        public var task: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.entityLevel != nil {
                map["EntityLevel"] = self.entityLevel!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.followers != nil {
                map["Followers"] = self.followers!
            }
            if self.hasRelativeNode != nil {
                map["HasRelativeNode"] = self.hasRelativeNode!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchExpression != nil {
                map["MatchExpression"] = self.matchExpression!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser!
            }
            if self.onDuty != nil {
                map["OnDuty"] = self.onDuty!
            }
            if self.onDutyAccountName != nil {
                map["OnDutyAccountName"] = self.onDutyAccountName!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.relativeNode != nil {
                map["RelativeNode"] = self.relativeNode!
            }
            if self.sql != nil {
                map["Sql"] = self.sql!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.task != nil {
                map["Task"] = self.task!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("EntityLevel") {
                self.entityLevel = dict["EntityLevel"] as! Int32
            }
            if dict.keys.contains("EnvType") {
                self.envType = dict["EnvType"] as! String
            }
            if dict.keys.contains("Followers") {
                self.followers = dict["Followers"] as! String
            }
            if dict.keys.contains("HasRelativeNode") {
                self.hasRelativeNode = dict["HasRelativeNode"] as! Bool
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MatchExpression") {
                self.matchExpression = dict["MatchExpression"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("ModifyUser") {
                self.modifyUser = dict["ModifyUser"] as! String
            }
            if dict.keys.contains("OnDuty") {
                self.onDuty = dict["OnDuty"] as! String
            }
            if dict.keys.contains("OnDutyAccountName") {
                self.onDutyAccountName = dict["OnDutyAccountName"] as! String
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
            if dict.keys.contains("RelativeNode") {
                self.relativeNode = dict["RelativeNode"] as! String
            }
            if dict.keys.contains("Sql") {
                self.sql = dict["Sql"] as! Int32
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
            if dict.keys.contains("Task") {
                self.task = dict["Task"] as! Int32
            }
        }
    }
    public var data: [GetQualityEntityResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [GetQualityEntityResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetQualityEntityResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetQualityEntityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQualityEntityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetQualityEntityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetQualityFollowerRequest : Tea.TeaModel {
    public var entityId: Int64?

    public var projectId: Int64?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
    }
}

public class GetQualityFollowerResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var alarmMode: Int32?

        public var createTime: Int64?

        public var entityId: String?

        public var follower: String?

        public var followerAccountName: String?

        public var id: Int64?

        public var modifyTime: Int64?

        public var projectName: String?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmMode != nil {
                map["AlarmMode"] = self.alarmMode!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.entityId != nil {
                map["EntityId"] = self.entityId!
            }
            if self.follower != nil {
                map["Follower"] = self.follower!
            }
            if self.followerAccountName != nil {
                map["FollowerAccountName"] = self.followerAccountName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmMode") {
                self.alarmMode = dict["AlarmMode"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("EntityId") {
                self.entityId = dict["EntityId"] as! String
            }
            if dict.keys.contains("Follower") {
                self.follower = dict["Follower"] as! String
            }
            if dict.keys.contains("FollowerAccountName") {
                self.followerAccountName = dict["FollowerAccountName"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
        }
    }
    public var data: [GetQualityFollowerResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [GetQualityFollowerResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetQualityFollowerResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetQualityFollowerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQualityFollowerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetQualityFollowerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetQualityRuleRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var projectName: String?

    public var ruleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! Int64
        }
    }
}

public class GetQualityRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var blockType: Int32?

        public var checker: Int32?

        public var checkerName: String?

        public var comment: String?

        public var criticalThreshold: String?

        public var entityId: Int64?

        public var expectValue: String?

        public var fixCheck: Bool?

        public var id: Int64?

        public var methodId: Int32?

        public var methodName: String?

        public var onDuty: String?

        public var onDutyAccountName: String?

        public var openSwitch: Bool?

        public var operator_: String?

        public var predictType: Int32?

        public var property: String?

        public var ruleName: String?

        public var ruleType: Int32?

        public var taskSetting: String?

        public var templateId: Int32?

        public var templateName: String?

        public var trend: String?

        public var warningThreshold: String?

        public var whereCondition: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.blockType != nil {
                map["BlockType"] = self.blockType!
            }
            if self.checker != nil {
                map["Checker"] = self.checker!
            }
            if self.checkerName != nil {
                map["CheckerName"] = self.checkerName!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.criticalThreshold != nil {
                map["CriticalThreshold"] = self.criticalThreshold!
            }
            if self.entityId != nil {
                map["EntityId"] = self.entityId!
            }
            if self.expectValue != nil {
                map["ExpectValue"] = self.expectValue!
            }
            if self.fixCheck != nil {
                map["FixCheck"] = self.fixCheck!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.methodId != nil {
                map["MethodId"] = self.methodId!
            }
            if self.methodName != nil {
                map["MethodName"] = self.methodName!
            }
            if self.onDuty != nil {
                map["OnDuty"] = self.onDuty!
            }
            if self.onDutyAccountName != nil {
                map["OnDutyAccountName"] = self.onDutyAccountName!
            }
            if self.openSwitch != nil {
                map["OpenSwitch"] = self.openSwitch!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.predictType != nil {
                map["PredictType"] = self.predictType!
            }
            if self.property != nil {
                map["Property"] = self.property!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.ruleType != nil {
                map["RuleType"] = self.ruleType!
            }
            if self.taskSetting != nil {
                map["TaskSetting"] = self.taskSetting!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.trend != nil {
                map["Trend"] = self.trend!
            }
            if self.warningThreshold != nil {
                map["WarningThreshold"] = self.warningThreshold!
            }
            if self.whereCondition != nil {
                map["WhereCondition"] = self.whereCondition!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BlockType") {
                self.blockType = dict["BlockType"] as! Int32
            }
            if dict.keys.contains("Checker") {
                self.checker = dict["Checker"] as! Int32
            }
            if dict.keys.contains("CheckerName") {
                self.checkerName = dict["CheckerName"] as! String
            }
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CriticalThreshold") {
                self.criticalThreshold = dict["CriticalThreshold"] as! String
            }
            if dict.keys.contains("EntityId") {
                self.entityId = dict["EntityId"] as! Int64
            }
            if dict.keys.contains("ExpectValue") {
                self.expectValue = dict["ExpectValue"] as! String
            }
            if dict.keys.contains("FixCheck") {
                self.fixCheck = dict["FixCheck"] as! Bool
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MethodId") {
                self.methodId = dict["MethodId"] as! Int32
            }
            if dict.keys.contains("MethodName") {
                self.methodName = dict["MethodName"] as! String
            }
            if dict.keys.contains("OnDuty") {
                self.onDuty = dict["OnDuty"] as! String
            }
            if dict.keys.contains("OnDutyAccountName") {
                self.onDutyAccountName = dict["OnDutyAccountName"] as! String
            }
            if dict.keys.contains("OpenSwitch") {
                self.openSwitch = dict["OpenSwitch"] as! Bool
            }
            if dict.keys.contains("Operator") {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("PredictType") {
                self.predictType = dict["PredictType"] as! Int32
            }
            if dict.keys.contains("Property") {
                self.property = dict["Property"] as! String
            }
            if dict.keys.contains("RuleName") {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("RuleType") {
                self.ruleType = dict["RuleType"] as! Int32
            }
            if dict.keys.contains("TaskSetting") {
                self.taskSetting = dict["TaskSetting"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! Int32
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("Trend") {
                self.trend = dict["Trend"] as! String
            }
            if dict.keys.contains("WarningThreshold") {
                self.warningThreshold = dict["WarningThreshold"] as! String
            }
            if dict.keys.contains("WhereCondition") {
                self.whereCondition = dict["WhereCondition"] as! String
            }
        }
    }
    public var data: GetQualityRuleResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetQualityRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetQualityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQualityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetQualityRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRemindRequest : Tea.TeaModel {
    public var remindId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remindId != nil {
            map["RemindId"] = self.remindId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RemindId") {
            self.remindId = dict["RemindId"] as! Int64
        }
    }
}

public class GetRemindResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Baselines : Tea.TeaModel {
            public var baselineId: Int64?

            public var baselineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.baselineName != nil {
                    map["BaselineName"] = self.baselineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("BaselineName") {
                    self.baselineName = dict["BaselineName"] as! String
                }
            }
        }
        public class BizProcesses : Tea.TeaModel {
            public var bizId: Int64?

            public var bizProcessName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.bizProcessName != nil {
                    map["BizProcessName"] = self.bizProcessName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizId") {
                    self.bizId = dict["BizId"] as! Int64
                }
                if dict.keys.contains("BizProcessName") {
                    self.bizProcessName = dict["BizProcessName"] as! String
                }
            }
        }
        public class Nodes : Tea.TeaModel {
            public var nodeId: Int64?

            public var nodeName: String?

            public var owner: String?

            public var projectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
            }
        }
        public class Projects : Tea.TeaModel {
            public var projectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
            }
        }
        public class Receivers : Tea.TeaModel {
            public var alertTargets: [String]?

            public var alertUnit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertTargets != nil {
                    map["AlertTargets"] = self.alertTargets!
                }
                if self.alertUnit != nil {
                    map["AlertUnit"] = self.alertUnit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertTargets") {
                    self.alertTargets = dict["AlertTargets"] as! [String]
                }
                if dict.keys.contains("AlertUnit") {
                    self.alertUnit = dict["AlertUnit"] as! String
                }
            }
        }
        public class Robots : Tea.TeaModel {
            public var atAll: Bool?

            public var webUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.atAll != nil {
                    map["AtAll"] = self.atAll!
                }
                if self.webUrl != nil {
                    map["WebUrl"] = self.webUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AtAll") {
                    self.atAll = dict["AtAll"] as! Bool
                }
                if dict.keys.contains("WebUrl") {
                    self.webUrl = dict["WebUrl"] as! String
                }
            }
        }
        public var alertInterval: Int32?

        public var alertMethods: [String]?

        public var alertTargets: [String]?

        public var alertUnit: String?

        public var allowNodes: [Int64]?

        public var baselines: [GetRemindResponseBody.Data.Baselines]?

        public var bizProcesses: [GetRemindResponseBody.Data.BizProcesses]?

        public var detail: String?

        public var dndEnd: String?

        public var dndStart: String?

        public var founder: String?

        public var maxAlertTimes: Int32?

        public var nodes: [GetRemindResponseBody.Data.Nodes]?

        public var projects: [GetRemindResponseBody.Data.Projects]?

        public var receivers: [GetRemindResponseBody.Data.Receivers]?

        public var remindId: Int64?

        public var remindName: String?

        public var remindType: String?

        public var remindUnit: String?

        public var robots: [GetRemindResponseBody.Data.Robots]?

        public var useflag: Bool?

        public var webhooks: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertInterval != nil {
                map["AlertInterval"] = self.alertInterval!
            }
            if self.alertMethods != nil {
                map["AlertMethods"] = self.alertMethods!
            }
            if self.alertTargets != nil {
                map["AlertTargets"] = self.alertTargets!
            }
            if self.alertUnit != nil {
                map["AlertUnit"] = self.alertUnit!
            }
            if self.allowNodes != nil {
                map["AllowNodes"] = self.allowNodes!
            }
            if self.baselines != nil {
                var tmp : [Any] = []
                for k in self.baselines! {
                    tmp.append(k.toMap())
                }
                map["Baselines"] = tmp
            }
            if self.bizProcesses != nil {
                var tmp : [Any] = []
                for k in self.bizProcesses! {
                    tmp.append(k.toMap())
                }
                map["BizProcesses"] = tmp
            }
            if self.detail != nil {
                map["Detail"] = self.detail!
            }
            if self.dndEnd != nil {
                map["DndEnd"] = self.dndEnd!
            }
            if self.dndStart != nil {
                map["DndStart"] = self.dndStart!
            }
            if self.founder != nil {
                map["Founder"] = self.founder!
            }
            if self.maxAlertTimes != nil {
                map["MaxAlertTimes"] = self.maxAlertTimes!
            }
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            if self.projects != nil {
                var tmp : [Any] = []
                for k in self.projects! {
                    tmp.append(k.toMap())
                }
                map["Projects"] = tmp
            }
            if self.receivers != nil {
                var tmp : [Any] = []
                for k in self.receivers! {
                    tmp.append(k.toMap())
                }
                map["Receivers"] = tmp
            }
            if self.remindId != nil {
                map["RemindId"] = self.remindId!
            }
            if self.remindName != nil {
                map["RemindName"] = self.remindName!
            }
            if self.remindType != nil {
                map["RemindType"] = self.remindType!
            }
            if self.remindUnit != nil {
                map["RemindUnit"] = self.remindUnit!
            }
            if self.robots != nil {
                var tmp : [Any] = []
                for k in self.robots! {
                    tmp.append(k.toMap())
                }
                map["Robots"] = tmp
            }
            if self.useflag != nil {
                map["Useflag"] = self.useflag!
            }
            if self.webhooks != nil {
                map["Webhooks"] = self.webhooks!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertInterval") {
                self.alertInterval = dict["AlertInterval"] as! Int32
            }
            if dict.keys.contains("AlertMethods") {
                self.alertMethods = dict["AlertMethods"] as! [String]
            }
            if dict.keys.contains("AlertTargets") {
                self.alertTargets = dict["AlertTargets"] as! [String]
            }
            if dict.keys.contains("AlertUnit") {
                self.alertUnit = dict["AlertUnit"] as! String
            }
            if dict.keys.contains("AllowNodes") {
                self.allowNodes = dict["AllowNodes"] as! [Int64]
            }
            if dict.keys.contains("Baselines") {
                var tmp : [GetRemindResponseBody.Data.Baselines] = []
                for v in dict["Baselines"] as! [Any] {
                    var model = GetRemindResponseBody.Data.Baselines()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.baselines = tmp
            }
            if dict.keys.contains("BizProcesses") {
                var tmp : [GetRemindResponseBody.Data.BizProcesses] = []
                for v in dict["BizProcesses"] as! [Any] {
                    var model = GetRemindResponseBody.Data.BizProcesses()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.bizProcesses = tmp
            }
            if dict.keys.contains("Detail") {
                self.detail = dict["Detail"] as! String
            }
            if dict.keys.contains("DndEnd") {
                self.dndEnd = dict["DndEnd"] as! String
            }
            if dict.keys.contains("DndStart") {
                self.dndStart = dict["DndStart"] as! String
            }
            if dict.keys.contains("Founder") {
                self.founder = dict["Founder"] as! String
            }
            if dict.keys.contains("MaxAlertTimes") {
                self.maxAlertTimes = dict["MaxAlertTimes"] as! Int32
            }
            if dict.keys.contains("Nodes") {
                var tmp : [GetRemindResponseBody.Data.Nodes] = []
                for v in dict["Nodes"] as! [Any] {
                    var model = GetRemindResponseBody.Data.Nodes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodes = tmp
            }
            if dict.keys.contains("Projects") {
                var tmp : [GetRemindResponseBody.Data.Projects] = []
                for v in dict["Projects"] as! [Any] {
                    var model = GetRemindResponseBody.Data.Projects()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.projects = tmp
            }
            if dict.keys.contains("Receivers") {
                var tmp : [GetRemindResponseBody.Data.Receivers] = []
                for v in dict["Receivers"] as! [Any] {
                    var model = GetRemindResponseBody.Data.Receivers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.receivers = tmp
            }
            if dict.keys.contains("RemindId") {
                self.remindId = dict["RemindId"] as! Int64
            }
            if dict.keys.contains("RemindName") {
                self.remindName = dict["RemindName"] as! String
            }
            if dict.keys.contains("RemindType") {
                self.remindType = dict["RemindType"] as! String
            }
            if dict.keys.contains("RemindUnit") {
                self.remindUnit = dict["RemindUnit"] as! String
            }
            if dict.keys.contains("Robots") {
                var tmp : [GetRemindResponseBody.Data.Robots] = []
                for v in dict["Robots"] as! [Any] {
                    var model = GetRemindResponseBody.Data.Robots()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.robots = tmp
            }
            if dict.keys.contains("Useflag") {
                self.useflag = dict["Useflag"] as! Bool
            }
            if dict.keys.contains("Webhooks") {
                self.webhooks = dict["Webhooks"] as! [String]
            }
        }
    }
    public var data: GetRemindResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetRemindResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetRemindResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRemindResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRemindResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSensitiveDataRequest : Tea.TeaModel {
    public var name: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class GetSensitiveDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var sensitiveData: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sensitiveData != nil {
            map["SensitiveData"] = self.sensitiveData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SensitiveData") {
            self.sensitiveData = dict["SensitiveData"] as! [String: Any]
        }
    }
}

public class GetSensitiveDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSensitiveDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSensitiveDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSuccessInstanceTrendRequest : Tea.TeaModel {
    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class GetSuccessInstanceTrendResponseBody : Tea.TeaModel {
    public class InstanceStatusTrend : Tea.TeaModel {
        public class AvgTrend : Tea.TeaModel {
            public var count: Int32?

            public var timePoint: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timePoint != nil {
                    map["TimePoint"] = self.timePoint!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("TimePoint") {
                    self.timePoint = dict["TimePoint"] as! String
                }
            }
        }
        public class TodayTrend : Tea.TeaModel {
            public var count: Int32?

            public var timePoint: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timePoint != nil {
                    map["TimePoint"] = self.timePoint!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("TimePoint") {
                    self.timePoint = dict["TimePoint"] as! String
                }
            }
        }
        public class YesterdayTrend : Tea.TeaModel {
            public var count: Int32?

            public var timePoint: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timePoint != nil {
                    map["TimePoint"] = self.timePoint!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("TimePoint") {
                    self.timePoint = dict["TimePoint"] as! String
                }
            }
        }
        public var avgTrend: [GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.AvgTrend]?

        public var todayTrend: [GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.TodayTrend]?

        public var yesterdayTrend: [GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.YesterdayTrend]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avgTrend != nil {
                var tmp : [Any] = []
                for k in self.avgTrend! {
                    tmp.append(k.toMap())
                }
                map["AvgTrend"] = tmp
            }
            if self.todayTrend != nil {
                var tmp : [Any] = []
                for k in self.todayTrend! {
                    tmp.append(k.toMap())
                }
                map["TodayTrend"] = tmp
            }
            if self.yesterdayTrend != nil {
                var tmp : [Any] = []
                for k in self.yesterdayTrend! {
                    tmp.append(k.toMap())
                }
                map["YesterdayTrend"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvgTrend") {
                var tmp : [GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.AvgTrend] = []
                for v in dict["AvgTrend"] as! [Any] {
                    var model = GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.AvgTrend()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.avgTrend = tmp
            }
            if dict.keys.contains("TodayTrend") {
                var tmp : [GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.TodayTrend] = []
                for v in dict["TodayTrend"] as! [Any] {
                    var model = GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.TodayTrend()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.todayTrend = tmp
            }
            if dict.keys.contains("YesterdayTrend") {
                var tmp : [GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.YesterdayTrend] = []
                for v in dict["YesterdayTrend"] as! [Any] {
                    var model = GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.YesterdayTrend()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.yesterdayTrend = tmp
            }
        }
    }
    public var instanceStatusTrend: GetSuccessInstanceTrendResponseBody.InstanceStatusTrend?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceStatusTrend?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceStatusTrend != nil {
            map["InstanceStatusTrend"] = self.instanceStatusTrend?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceStatusTrend") {
            var model = GetSuccessInstanceTrendResponseBody.InstanceStatusTrend()
            model.fromMap(dict["InstanceStatusTrend"] as! [String: Any])
            self.instanceStatusTrend = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetSuccessInstanceTrendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSuccessInstanceTrendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSuccessInstanceTrendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTopicRequest : Tea.TeaModel {
    public var topicId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.topicId != nil {
            map["TopicId"] = self.topicId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TopicId") {
            self.topicId = dict["TopicId"] as! Int64
        }
    }
}

public class GetTopicResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var addTime: Int64?

        public var alertTime: Int64?

        public var assigner: String?

        public var baselineBuffer: Int64?

        public var baselineId: Int64?

        public var baselineInGroupId: Int32?

        public var baselineName: String?

        public var baselineStatus: String?

        public var buffer: Int64?

        public var dealTime: Int64?

        public var dealUser: String?

        public var fixTime: Int64?

        public var happenTime: Int64?

        public var instanceId: Int64?

        public var nextAlertTime: Int64?

        public var nodeId: Int64?

        public var nodeName: String?

        public var owner: String?

        public var projectId: Int64?

        public var topicId: Int64?

        public var topicName: String?

        public var topicStatus: String?

        public var topicType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addTime != nil {
                map["AddTime"] = self.addTime!
            }
            if self.alertTime != nil {
                map["AlertTime"] = self.alertTime!
            }
            if self.assigner != nil {
                map["Assigner"] = self.assigner!
            }
            if self.baselineBuffer != nil {
                map["BaselineBuffer"] = self.baselineBuffer!
            }
            if self.baselineId != nil {
                map["BaselineId"] = self.baselineId!
            }
            if self.baselineInGroupId != nil {
                map["BaselineInGroupId"] = self.baselineInGroupId!
            }
            if self.baselineName != nil {
                map["BaselineName"] = self.baselineName!
            }
            if self.baselineStatus != nil {
                map["BaselineStatus"] = self.baselineStatus!
            }
            if self.buffer != nil {
                map["Buffer"] = self.buffer!
            }
            if self.dealTime != nil {
                map["DealTime"] = self.dealTime!
            }
            if self.dealUser != nil {
                map["DealUser"] = self.dealUser!
            }
            if self.fixTime != nil {
                map["FixTime"] = self.fixTime!
            }
            if self.happenTime != nil {
                map["HappenTime"] = self.happenTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.nextAlertTime != nil {
                map["NextAlertTime"] = self.nextAlertTime!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.topicId != nil {
                map["TopicId"] = self.topicId!
            }
            if self.topicName != nil {
                map["TopicName"] = self.topicName!
            }
            if self.topicStatus != nil {
                map["TopicStatus"] = self.topicStatus!
            }
            if self.topicType != nil {
                map["TopicType"] = self.topicType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddTime") {
                self.addTime = dict["AddTime"] as! Int64
            }
            if dict.keys.contains("AlertTime") {
                self.alertTime = dict["AlertTime"] as! Int64
            }
            if dict.keys.contains("Assigner") {
                self.assigner = dict["Assigner"] as! String
            }
            if dict.keys.contains("BaselineBuffer") {
                self.baselineBuffer = dict["BaselineBuffer"] as! Int64
            }
            if dict.keys.contains("BaselineId") {
                self.baselineId = dict["BaselineId"] as! Int64
            }
            if dict.keys.contains("BaselineInGroupId") {
                self.baselineInGroupId = dict["BaselineInGroupId"] as! Int32
            }
            if dict.keys.contains("BaselineName") {
                self.baselineName = dict["BaselineName"] as! String
            }
            if dict.keys.contains("BaselineStatus") {
                self.baselineStatus = dict["BaselineStatus"] as! String
            }
            if dict.keys.contains("Buffer") {
                self.buffer = dict["Buffer"] as! Int64
            }
            if dict.keys.contains("DealTime") {
                self.dealTime = dict["DealTime"] as! Int64
            }
            if dict.keys.contains("DealUser") {
                self.dealUser = dict["DealUser"] as! String
            }
            if dict.keys.contains("FixTime") {
                self.fixTime = dict["FixTime"] as! Int64
            }
            if dict.keys.contains("HappenTime") {
                self.happenTime = dict["HappenTime"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("NextAlertTime") {
                self.nextAlertTime = dict["NextAlertTime"] as! Int64
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! Int64
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("TopicId") {
                self.topicId = dict["TopicId"] as! Int64
            }
            if dict.keys.contains("TopicName") {
                self.topicName = dict["TopicName"] as! String
            }
            if dict.keys.contains("TopicStatus") {
                self.topicStatus = dict["TopicStatus"] as! String
            }
            if dict.keys.contains("TopicType") {
                self.topicType = dict["TopicType"] as! String
            }
        }
    }
    public var data: GetTopicResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetTopicResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetTopicResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTopicResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTopicResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTopicInfluenceRequest : Tea.TeaModel {
    public var topicId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.topicId != nil {
            map["TopicId"] = self.topicId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TopicId") {
            self.topicId = dict["TopicId"] as! Int64
        }
    }
}

public class GetTopicInfluenceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Influences : Tea.TeaModel {
            public var baselineId: Int64?

            public var baselineName: String?

            public var bizdate: Int64?

            public var buffer: Int64?

            public var inGroupId: Int32?

            public var owner: String?

            public var priority: Int32?

            public var projectId: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.baselineName != nil {
                    map["BaselineName"] = self.baselineName!
                }
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.buffer != nil {
                    map["Buffer"] = self.buffer!
                }
                if self.inGroupId != nil {
                    map["InGroupId"] = self.inGroupId!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("BaselineName") {
                    self.baselineName = dict["BaselineName"] as! String
                }
                if dict.keys.contains("Bizdate") {
                    self.bizdate = dict["Bizdate"] as! Int64
                }
                if dict.keys.contains("Buffer") {
                    self.buffer = dict["Buffer"] as! Int64
                }
                if dict.keys.contains("InGroupId") {
                    self.inGroupId = dict["InGroupId"] as! Int32
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var influences: [GetTopicInfluenceResponseBody.Data.Influences]?

        public var topicId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.influences != nil {
                var tmp : [Any] = []
                for k in self.influences! {
                    tmp.append(k.toMap())
                }
                map["Influences"] = tmp
            }
            if self.topicId != nil {
                map["TopicId"] = self.topicId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Influences") {
                var tmp : [GetTopicInfluenceResponseBody.Data.Influences] = []
                for v in dict["Influences"] as! [Any] {
                    var model = GetTopicInfluenceResponseBody.Data.Influences()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.influences = tmp
            }
            if dict.keys.contains("TopicId") {
                self.topicId = dict["TopicId"] as! Int64
            }
        }
    }
    public var data: GetTopicInfluenceResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetTopicInfluenceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetTopicInfluenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTopicInfluenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTopicInfluenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportDataSourcesRequest : Tea.TeaModel {
    public var dataSources: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSources != nil {
            map["DataSources"] = self.dataSources!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataSources") {
            self.dataSources = dict["DataSources"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class ImportDataSourcesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Bool
            }
        }
    }
    public var data: ImportDataSourcesResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ImportDataSourcesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ImportDataSourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportDataSourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportDataSourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAlertMessagesRequest : Tea.TeaModel {
    public var alertMethods: String?

    public var alertRuleTypes: String?

    public var alertUser: String?

    public var baselineId: Int64?

    public var beginTime: String?

    public var endTime: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remindId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertMethods != nil {
            map["AlertMethods"] = self.alertMethods!
        }
        if self.alertRuleTypes != nil {
            map["AlertRuleTypes"] = self.alertRuleTypes!
        }
        if self.alertUser != nil {
            map["AlertUser"] = self.alertUser!
        }
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remindId != nil {
            map["RemindId"] = self.remindId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertMethods") {
            self.alertMethods = dict["AlertMethods"] as! String
        }
        if dict.keys.contains("AlertRuleTypes") {
            self.alertRuleTypes = dict["AlertRuleTypes"] as! String
        }
        if dict.keys.contains("AlertUser") {
            self.alertUser = dict["AlertUser"] as! String
        }
        if dict.keys.contains("BaselineId") {
            self.baselineId = dict["BaselineId"] as! Int64
        }
        if dict.keys.contains("BeginTime") {
            self.beginTime = dict["BeginTime"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RemindId") {
            self.remindId = dict["RemindId"] as! Int64
        }
    }
}

public class ListAlertMessagesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AlertMessages : Tea.TeaModel {
            public class Instances : Tea.TeaModel {
                public var instanceId: Int64?

                public var nodeId: Int64?

                public var nodeName: String?

                public var projectId: Int64?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.nodeName != nil {
                        map["NodeName"] = self.nodeName!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! Int64
                    }
                    if dict.keys.contains("NodeId") {
                        self.nodeId = dict["NodeId"] as! Int64
                    }
                    if dict.keys.contains("NodeName") {
                        self.nodeName = dict["NodeName"] as! String
                    }
                    if dict.keys.contains("ProjectId") {
                        self.projectId = dict["ProjectId"] as! Int64
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class Nodes : Tea.TeaModel {
                public var nodeId: Int64?

                public var nodeName: String?

                public var owner: String?

                public var projectId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.nodeName != nil {
                        map["NodeName"] = self.nodeName!
                    }
                    if self.owner != nil {
                        map["Owner"] = self.owner!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NodeId") {
                        self.nodeId = dict["NodeId"] as! Int64
                    }
                    if dict.keys.contains("NodeName") {
                        self.nodeName = dict["NodeName"] as! String
                    }
                    if dict.keys.contains("Owner") {
                        self.owner = dict["Owner"] as! String
                    }
                    if dict.keys.contains("ProjectId") {
                        self.projectId = dict["ProjectId"] as! Int64
                    }
                }
            }
            public class SlaAlert : Tea.TeaModel {
                public var baselineId: Int64?

                public var baselineName: String?

                public var baselineOwner: String?

                public var bizdate: Int64?

                public var inGroupId: Int32?

                public var projectId: Int64?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.baselineId != nil {
                        map["BaselineId"] = self.baselineId!
                    }
                    if self.baselineName != nil {
                        map["BaselineName"] = self.baselineName!
                    }
                    if self.baselineOwner != nil {
                        map["BaselineOwner"] = self.baselineOwner!
                    }
                    if self.bizdate != nil {
                        map["Bizdate"] = self.bizdate!
                    }
                    if self.inGroupId != nil {
                        map["InGroupId"] = self.inGroupId!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BaselineId") {
                        self.baselineId = dict["BaselineId"] as! Int64
                    }
                    if dict.keys.contains("BaselineName") {
                        self.baselineName = dict["BaselineName"] as! String
                    }
                    if dict.keys.contains("BaselineOwner") {
                        self.baselineOwner = dict["BaselineOwner"] as! String
                    }
                    if dict.keys.contains("Bizdate") {
                        self.bizdate = dict["Bizdate"] as! Int64
                    }
                    if dict.keys.contains("InGroupId") {
                        self.inGroupId = dict["InGroupId"] as! Int32
                    }
                    if dict.keys.contains("ProjectId") {
                        self.projectId = dict["ProjectId"] as! Int64
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class Topics : Tea.TeaModel {
                public var instanceId: Int64?

                public var nodeId: Int64?

                public var topicId: Int64?

                public var topicName: String?

                public var topicOwner: String?

                public var topicStatus: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.topicId != nil {
                        map["TopicId"] = self.topicId!
                    }
                    if self.topicName != nil {
                        map["TopicName"] = self.topicName!
                    }
                    if self.topicOwner != nil {
                        map["TopicOwner"] = self.topicOwner!
                    }
                    if self.topicStatus != nil {
                        map["TopicStatus"] = self.topicStatus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! Int64
                    }
                    if dict.keys.contains("NodeId") {
                        self.nodeId = dict["NodeId"] as! Int64
                    }
                    if dict.keys.contains("TopicId") {
                        self.topicId = dict["TopicId"] as! Int64
                    }
                    if dict.keys.contains("TopicName") {
                        self.topicName = dict["TopicName"] as! String
                    }
                    if dict.keys.contains("TopicOwner") {
                        self.topicOwner = dict["TopicOwner"] as! String
                    }
                    if dict.keys.contains("TopicStatus") {
                        self.topicStatus = dict["TopicStatus"] as! String
                    }
                }
            }
            public var alertId: Int64?

            public var alertMessageStatus: String?

            public var alertMethod: String?

            public var alertTime: Int64?

            public var alertUser: String?

            public var content: String?

            public var instances: [ListAlertMessagesResponseBody.Data.AlertMessages.Instances]?

            public var nodes: [ListAlertMessagesResponseBody.Data.AlertMessages.Nodes]?

            public var remindId: Int64?

            public var remindName: String?

            public var slaAlert: ListAlertMessagesResponseBody.Data.AlertMessages.SlaAlert?

            public var source: String?

            public var topics: [ListAlertMessagesResponseBody.Data.AlertMessages.Topics]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.slaAlert?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertId != nil {
                    map["AlertId"] = self.alertId!
                }
                if self.alertMessageStatus != nil {
                    map["AlertMessageStatus"] = self.alertMessageStatus!
                }
                if self.alertMethod != nil {
                    map["AlertMethod"] = self.alertMethod!
                }
                if self.alertTime != nil {
                    map["AlertTime"] = self.alertTime!
                }
                if self.alertUser != nil {
                    map["AlertUser"] = self.alertUser!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.instances != nil {
                    var tmp : [Any] = []
                    for k in self.instances! {
                        tmp.append(k.toMap())
                    }
                    map["Instances"] = tmp
                }
                if self.nodes != nil {
                    var tmp : [Any] = []
                    for k in self.nodes! {
                        tmp.append(k.toMap())
                    }
                    map["Nodes"] = tmp
                }
                if self.remindId != nil {
                    map["RemindId"] = self.remindId!
                }
                if self.remindName != nil {
                    map["RemindName"] = self.remindName!
                }
                if self.slaAlert != nil {
                    map["SlaAlert"] = self.slaAlert?.toMap()
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.topics != nil {
                    var tmp : [Any] = []
                    for k in self.topics! {
                        tmp.append(k.toMap())
                    }
                    map["Topics"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertId") {
                    self.alertId = dict["AlertId"] as! Int64
                }
                if dict.keys.contains("AlertMessageStatus") {
                    self.alertMessageStatus = dict["AlertMessageStatus"] as! String
                }
                if dict.keys.contains("AlertMethod") {
                    self.alertMethod = dict["AlertMethod"] as! String
                }
                if dict.keys.contains("AlertTime") {
                    self.alertTime = dict["AlertTime"] as! Int64
                }
                if dict.keys.contains("AlertUser") {
                    self.alertUser = dict["AlertUser"] as! String
                }
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("Instances") {
                    var tmp : [ListAlertMessagesResponseBody.Data.AlertMessages.Instances] = []
                    for v in dict["Instances"] as! [Any] {
                        var model = ListAlertMessagesResponseBody.Data.AlertMessages.Instances()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.instances = tmp
                }
                if dict.keys.contains("Nodes") {
                    var tmp : [ListAlertMessagesResponseBody.Data.AlertMessages.Nodes] = []
                    for v in dict["Nodes"] as! [Any] {
                        var model = ListAlertMessagesResponseBody.Data.AlertMessages.Nodes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.nodes = tmp
                }
                if dict.keys.contains("RemindId") {
                    self.remindId = dict["RemindId"] as! Int64
                }
                if dict.keys.contains("RemindName") {
                    self.remindName = dict["RemindName"] as! String
                }
                if dict.keys.contains("SlaAlert") {
                    var model = ListAlertMessagesResponseBody.Data.AlertMessages.SlaAlert()
                    model.fromMap(dict["SlaAlert"] as! [String: Any])
                    self.slaAlert = model
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Topics") {
                    var tmp : [ListAlertMessagesResponseBody.Data.AlertMessages.Topics] = []
                    for v in dict["Topics"] as! [Any] {
                        var model = ListAlertMessagesResponseBody.Data.AlertMessages.Topics()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.topics = tmp
                }
            }
        }
        public var alertMessages: [ListAlertMessagesResponseBody.Data.AlertMessages]?

        public var pageNumber: String?

        public var pageSize: String?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertMessages != nil {
                var tmp : [Any] = []
                for k in self.alertMessages! {
                    tmp.append(k.toMap())
                }
                map["AlertMessages"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertMessages") {
                var tmp : [ListAlertMessagesResponseBody.Data.AlertMessages] = []
                for v in dict["AlertMessages"] as! [Any] {
                    var model = ListAlertMessagesResponseBody.Data.AlertMessages()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertMessages = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! String
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! String
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! String
            }
        }
    }
    public var data: ListAlertMessagesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListAlertMessagesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAlertMessagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAlertMessagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAlertMessagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBaselineConfigsRequest : Tea.TeaModel {
    public var baselineTypes: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var priority: String?

    public var projectId: Int64?

    public var searchText: String?

    public var useflag: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineTypes != nil {
            map["BaselineTypes"] = self.baselineTypes!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.searchText != nil {
            map["SearchText"] = self.searchText!
        }
        if self.useflag != nil {
            map["Useflag"] = self.useflag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineTypes") {
            self.baselineTypes = dict["BaselineTypes"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SearchText") {
            self.searchText = dict["SearchText"] as! String
        }
        if dict.keys.contains("Useflag") {
            self.useflag = dict["Useflag"] as! Bool
        }
    }
}

public class ListBaselineConfigsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Baselines : Tea.TeaModel {
            public var baselineId: Int64?

            public var baselineName: String?

            public var baselineType: String?

            public var expHour: Int32?

            public var expMinu: Int32?

            public var hourExpDetail: String?

            public var hourSlaDetail: String?

            public var isDefault: Bool?

            public var owner: String?

            public var priority: Int32?

            public var projectId: Int64?

            public var slaHour: Int32?

            public var slaMinu: Int32?

            public var useFlag: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.baselineName != nil {
                    map["BaselineName"] = self.baselineName!
                }
                if self.baselineType != nil {
                    map["BaselineType"] = self.baselineType!
                }
                if self.expHour != nil {
                    map["ExpHour"] = self.expHour!
                }
                if self.expMinu != nil {
                    map["ExpMinu"] = self.expMinu!
                }
                if self.hourExpDetail != nil {
                    map["HourExpDetail"] = self.hourExpDetail!
                }
                if self.hourSlaDetail != nil {
                    map["HourSlaDetail"] = self.hourSlaDetail!
                }
                if self.isDefault != nil {
                    map["IsDefault"] = self.isDefault!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.slaHour != nil {
                    map["SlaHour"] = self.slaHour!
                }
                if self.slaMinu != nil {
                    map["SlaMinu"] = self.slaMinu!
                }
                if self.useFlag != nil {
                    map["UseFlag"] = self.useFlag!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("BaselineName") {
                    self.baselineName = dict["BaselineName"] as! String
                }
                if dict.keys.contains("BaselineType") {
                    self.baselineType = dict["BaselineType"] as! String
                }
                if dict.keys.contains("ExpHour") {
                    self.expHour = dict["ExpHour"] as! Int32
                }
                if dict.keys.contains("ExpMinu") {
                    self.expMinu = dict["ExpMinu"] as! Int32
                }
                if dict.keys.contains("HourExpDetail") {
                    self.hourExpDetail = dict["HourExpDetail"] as! String
                }
                if dict.keys.contains("HourSlaDetail") {
                    self.hourSlaDetail = dict["HourSlaDetail"] as! String
                }
                if dict.keys.contains("IsDefault") {
                    self.isDefault = dict["IsDefault"] as! Bool
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("SlaHour") {
                    self.slaHour = dict["SlaHour"] as! Int32
                }
                if dict.keys.contains("SlaMinu") {
                    self.slaMinu = dict["SlaMinu"] as! Int32
                }
                if dict.keys.contains("UseFlag") {
                    self.useFlag = dict["UseFlag"] as! Bool
                }
            }
        }
        public var baselines: [ListBaselineConfigsResponseBody.Data.Baselines]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselines != nil {
                var tmp : [Any] = []
                for k in self.baselines! {
                    tmp.append(k.toMap())
                }
                map["Baselines"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Baselines") {
                var tmp : [ListBaselineConfigsResponseBody.Data.Baselines] = []
                for v in dict["Baselines"] as! [Any] {
                    var model = ListBaselineConfigsResponseBody.Data.Baselines()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.baselines = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListBaselineConfigsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListBaselineConfigsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListBaselineConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBaselineConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListBaselineConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBaselineStatusesRequest : Tea.TeaModel {
    public var baselineTypes: String?

    public var bizdate: String?

    public var finishStatus: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var priority: String?

    public var searchText: String?

    public var status: String?

    public var topicId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineTypes != nil {
            map["BaselineTypes"] = self.baselineTypes!
        }
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.finishStatus != nil {
            map["FinishStatus"] = self.finishStatus!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.searchText != nil {
            map["SearchText"] = self.searchText!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.topicId != nil {
            map["TopicId"] = self.topicId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineTypes") {
            self.baselineTypes = dict["BaselineTypes"] as! String
        }
        if dict.keys.contains("Bizdate") {
            self.bizdate = dict["Bizdate"] as! String
        }
        if dict.keys.contains("FinishStatus") {
            self.finishStatus = dict["FinishStatus"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("SearchText") {
            self.searchText = dict["SearchText"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TopicId") {
            self.topicId = dict["TopicId"] as! Int64
        }
    }
}

public class ListBaselineStatusesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BaselineStatuses : Tea.TeaModel {
            public var baselineId: Int64?

            public var baselineName: String?

            public var baselineType: String?

            public var bizdate: Int64?

            public var buffer: Int64?

            public var endCast: Int64?

            public var expTime: Int64?

            public var finishStatus: String?

            public var finishTime: Int64?

            public var inGroupId: Int32?

            public var owner: String?

            public var priority: Int32?

            public var projectId: Int64?

            public var slaTime: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.baselineName != nil {
                    map["BaselineName"] = self.baselineName!
                }
                if self.baselineType != nil {
                    map["BaselineType"] = self.baselineType!
                }
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.buffer != nil {
                    map["Buffer"] = self.buffer!
                }
                if self.endCast != nil {
                    map["EndCast"] = self.endCast!
                }
                if self.expTime != nil {
                    map["ExpTime"] = self.expTime!
                }
                if self.finishStatus != nil {
                    map["FinishStatus"] = self.finishStatus!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.inGroupId != nil {
                    map["InGroupId"] = self.inGroupId!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.slaTime != nil {
                    map["SlaTime"] = self.slaTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("BaselineName") {
                    self.baselineName = dict["BaselineName"] as! String
                }
                if dict.keys.contains("BaselineType") {
                    self.baselineType = dict["BaselineType"] as! String
                }
                if dict.keys.contains("Bizdate") {
                    self.bizdate = dict["Bizdate"] as! Int64
                }
                if dict.keys.contains("Buffer") {
                    self.buffer = dict["Buffer"] as! Int64
                }
                if dict.keys.contains("EndCast") {
                    self.endCast = dict["EndCast"] as! Int64
                }
                if dict.keys.contains("ExpTime") {
                    self.expTime = dict["ExpTime"] as! Int64
                }
                if dict.keys.contains("FinishStatus") {
                    self.finishStatus = dict["FinishStatus"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! Int64
                }
                if dict.keys.contains("InGroupId") {
                    self.inGroupId = dict["InGroupId"] as! Int32
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("SlaTime") {
                    self.slaTime = dict["SlaTime"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var baselineStatuses: [ListBaselineStatusesResponseBody.Data.BaselineStatuses]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineStatuses != nil {
                var tmp : [Any] = []
                for k in self.baselineStatuses! {
                    tmp.append(k.toMap())
                }
                map["BaselineStatuses"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BaselineStatuses") {
                var tmp : [ListBaselineStatusesResponseBody.Data.BaselineStatuses] = []
                for v in dict["BaselineStatuses"] as! [Any] {
                    var model = ListBaselineStatusesResponseBody.Data.BaselineStatuses()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.baselineStatuses = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListBaselineStatusesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListBaselineStatusesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListBaselineStatusesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBaselineStatusesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListBaselineStatusesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBaselinesRequest : Tea.TeaModel {
    public var baselineTypes: String?

    public var enable: Bool?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var priority: String?

    public var projectId: Int64?

    public var searchText: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineTypes != nil {
            map["BaselineTypes"] = self.baselineTypes!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.searchText != nil {
            map["SearchText"] = self.searchText!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineTypes") {
            self.baselineTypes = dict["BaselineTypes"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SearchText") {
            self.searchText = dict["SearchText"] as! String
        }
    }
}

public class ListBaselinesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Baselines : Tea.TeaModel {
            public class OverTimeSettings : Tea.TeaModel {
                public var cycle: Int32?

                public var time: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cycle != nil {
                        map["Cycle"] = self.cycle!
                    }
                    if self.time != nil {
                        map["Time"] = self.time!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cycle") {
                        self.cycle = dict["Cycle"] as! Int32
                    }
                    if dict.keys.contains("Time") {
                        self.time = dict["Time"] as! String
                    }
                }
            }
            public var alertEnabled: Bool?

            public var alertMarginThreshold: Int32?

            public var baselineId: Int64?

            public var baselineName: String?

            public var baselineType: String?

            public var enabled: Bool?

            public var overTimeSettings: [ListBaselinesResponseBody.Data.Baselines.OverTimeSettings]?

            public var owner: String?

            public var priority: Int32?

            public var projectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertEnabled != nil {
                    map["AlertEnabled"] = self.alertEnabled!
                }
                if self.alertMarginThreshold != nil {
                    map["AlertMarginThreshold"] = self.alertMarginThreshold!
                }
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.baselineName != nil {
                    map["BaselineName"] = self.baselineName!
                }
                if self.baselineType != nil {
                    map["BaselineType"] = self.baselineType!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.overTimeSettings != nil {
                    var tmp : [Any] = []
                    for k in self.overTimeSettings! {
                        tmp.append(k.toMap())
                    }
                    map["OverTimeSettings"] = tmp
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertEnabled") {
                    self.alertEnabled = dict["AlertEnabled"] as! Bool
                }
                if dict.keys.contains("AlertMarginThreshold") {
                    self.alertMarginThreshold = dict["AlertMarginThreshold"] as! Int32
                }
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("BaselineName") {
                    self.baselineName = dict["BaselineName"] as! String
                }
                if dict.keys.contains("BaselineType") {
                    self.baselineType = dict["BaselineType"] as! String
                }
                if dict.keys.contains("Enabled") {
                    self.enabled = dict["Enabled"] as! Bool
                }
                if dict.keys.contains("OverTimeSettings") {
                    var tmp : [ListBaselinesResponseBody.Data.Baselines.OverTimeSettings] = []
                    for v in dict["OverTimeSettings"] as! [Any] {
                        var model = ListBaselinesResponseBody.Data.Baselines.OverTimeSettings()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.overTimeSettings = tmp
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
            }
        }
        public var baselines: [ListBaselinesResponseBody.Data.Baselines]?

        public var pageNumber: String?

        public var pageSize: String?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselines != nil {
                var tmp : [Any] = []
                for k in self.baselines! {
                    tmp.append(k.toMap())
                }
                map["Baselines"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Baselines") {
                var tmp : [ListBaselinesResponseBody.Data.Baselines] = []
                for v in dict["Baselines"] as! [Any] {
                    var model = ListBaselinesResponseBody.Data.Baselines()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.baselines = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! String
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! String
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! String
            }
        }
    }
    public var data: ListBaselinesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListBaselinesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListBaselinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBaselinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListBaselinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBusinessRequest : Tea.TeaModel {
    public var keyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class ListBusinessResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Business : Tea.TeaModel {
            public var businessId: Int64?

            public var businessName: String?

            public var description_: String?

            public var owner: String?

            public var projectId: Int64?

            public var useType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessId != nil {
                    map["BusinessId"] = self.businessId!
                }
                if self.businessName != nil {
                    map["BusinessName"] = self.businessName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.useType != nil {
                    map["UseType"] = self.useType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessId") {
                    self.businessId = dict["BusinessId"] as! Int64
                }
                if dict.keys.contains("BusinessName") {
                    self.businessName = dict["BusinessName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("UseType") {
                    self.useType = dict["UseType"] as! String
                }
            }
        }
        public var business: [ListBusinessResponseBody.Data.Business]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.business != nil {
                var tmp : [Any] = []
                for k in self.business! {
                    tmp.append(k.toMap())
                }
                map["Business"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Business") {
                var tmp : [ListBusinessResponseBody.Data.Business] = []
                for v in dict["Business"] as! [Any] {
                    var model = ListBusinessResponseBody.Data.Business()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.business = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListBusinessResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListBusinessResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListBusinessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBusinessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListBusinessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCalcEnginesRequest : Tea.TeaModel {
    public var calcEngineType: String?

    public var envType: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calcEngineType != nil {
            map["CalcEngineType"] = self.calcEngineType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalcEngineType") {
            self.calcEngineType = dict["CalcEngineType"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class ListCalcEnginesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CalcEngines : Tea.TeaModel {
            public var bindingProjectId: Int32?

            public var bindingProjectName: String?

            public var calcEngineType: String?

            public var dwRegion: String?

            public var engineId: Int32?

            public var engineInfo: [String: Any]?

            public var envType: String?

            public var gmtCreate: String?

            public var isDefault: Bool?

            public var name: String?

            public var region: String?

            public var taskAuthType: String?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindingProjectId != nil {
                    map["BindingProjectId"] = self.bindingProjectId!
                }
                if self.bindingProjectName != nil {
                    map["BindingProjectName"] = self.bindingProjectName!
                }
                if self.calcEngineType != nil {
                    map["CalcEngineType"] = self.calcEngineType!
                }
                if self.dwRegion != nil {
                    map["DwRegion"] = self.dwRegion!
                }
                if self.engineId != nil {
                    map["EngineId"] = self.engineId!
                }
                if self.engineInfo != nil {
                    map["EngineInfo"] = self.engineInfo!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.isDefault != nil {
                    map["IsDefault"] = self.isDefault!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.taskAuthType != nil {
                    map["TaskAuthType"] = self.taskAuthType!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BindingProjectId") {
                    self.bindingProjectId = dict["BindingProjectId"] as! Int32
                }
                if dict.keys.contains("BindingProjectName") {
                    self.bindingProjectName = dict["BindingProjectName"] as! String
                }
                if dict.keys.contains("CalcEngineType") {
                    self.calcEngineType = dict["CalcEngineType"] as! String
                }
                if dict.keys.contains("DwRegion") {
                    self.dwRegion = dict["DwRegion"] as! String
                }
                if dict.keys.contains("EngineId") {
                    self.engineId = dict["EngineId"] as! Int32
                }
                if dict.keys.contains("EngineInfo") {
                    self.engineInfo = dict["EngineInfo"] as! [String: Any]
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("IsDefault") {
                    self.isDefault = dict["IsDefault"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("TaskAuthType") {
                    self.taskAuthType = dict["TaskAuthType"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
            }
        }
        public var calcEngines: [ListCalcEnginesResponseBody.Data.CalcEngines]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.calcEngines != nil {
                var tmp : [Any] = []
                for k in self.calcEngines! {
                    tmp.append(k.toMap())
                }
                map["CalcEngines"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CalcEngines") {
                var tmp : [ListCalcEnginesResponseBody.Data.CalcEngines] = []
                for v in dict["CalcEngines"] as! [Any] {
                    var model = ListCalcEnginesResponseBody.Data.CalcEngines()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.calcEngines = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListCalcEnginesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListCalcEnginesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListCalcEnginesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCalcEnginesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCalcEnginesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCheckProcessesRequest : Tea.TeaModel {
    public var eventCode: String?

    public var messageId: String?

    public var operator_: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventCode != nil {
            map["EventCode"] = self.eventCode!
        }
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        if self.operator_ != nil {
            map["Operator"] = self.operator_!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventCode") {
            self.eventCode = dict["EventCode"] as! String
        }
        if dict.keys.contains("MessageId") {
            self.messageId = dict["MessageId"] as! String
        }
        if dict.keys.contains("Operator") {
            self.operator_ = dict["Operator"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListCheckProcessesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class CheckProcesses : Tea.TeaModel {
            public var eventCode: String?

            public var eventName: String?

            public var eventNameEn: String?

            public var messageId: String?

            public var operator_: String?

            public var processId: String?

            public var processName: String?

            public var projectId: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventCode != nil {
                    map["EventCode"] = self.eventCode!
                }
                if self.eventName != nil {
                    map["EventName"] = self.eventName!
                }
                if self.eventNameEn != nil {
                    map["EventNameEn"] = self.eventNameEn!
                }
                if self.messageId != nil {
                    map["MessageId"] = self.messageId!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.processId != nil {
                    map["ProcessId"] = self.processId!
                }
                if self.processName != nil {
                    map["ProcessName"] = self.processName!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EventCode") {
                    self.eventCode = dict["EventCode"] as! String
                }
                if dict.keys.contains("EventName") {
                    self.eventName = dict["EventName"] as! String
                }
                if dict.keys.contains("EventNameEn") {
                    self.eventNameEn = dict["EventNameEn"] as! String
                }
                if dict.keys.contains("MessageId") {
                    self.messageId = dict["MessageId"] as! String
                }
                if dict.keys.contains("Operator") {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("ProcessId") {
                    self.processId = dict["ProcessId"] as! String
                }
                if dict.keys.contains("ProcessName") {
                    self.processName = dict["ProcessName"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var checkProcesses: [ListCheckProcessesResponseBody.PagingInfo.CheckProcesses]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkProcesses != nil {
                var tmp : [Any] = []
                for k in self.checkProcesses! {
                    tmp.append(k.toMap())
                }
                map["CheckProcesses"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckProcesses") {
                var tmp : [ListCheckProcessesResponseBody.PagingInfo.CheckProcesses] = []
                for v in dict["CheckProcesses"] as! [Any] {
                    var model = ListCheckProcessesResponseBody.PagingInfo.CheckProcesses()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.checkProcesses = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListCheckProcessesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListCheckProcessesResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCheckProcessesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCheckProcessesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCheckProcessesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterConfigsRequest : Tea.TeaModel {
    public var clusterId: Int64?

    public var configType: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configType != nil {
            map["ConfigType"] = self.configType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! Int64
        }
        if dict.keys.contains("ConfigType") {
            self.configType = dict["ConfigType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class ListClusterConfigsResponseBody : Tea.TeaModel {
    public var clusterConfigs: [ClusterConfig]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterConfigs != nil {
            var tmp : [Any] = []
            for k in self.clusterConfigs! {
                tmp.append(k.toMap())
            }
            map["ClusterConfigs"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterConfigs") {
            var tmp : [ClusterConfig] = []
            for v in dict["ClusterConfigs"] as! [Any] {
                var model = ClusterConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.clusterConfigs = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListClusterConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListClusterConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClustersRequest : Tea.TeaModel {
    public var clusterType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListClustersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusters: [Cluster]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusters != nil {
                var tmp : [Any] = []
                for k in self.clusters! {
                    tmp.append(k.toMap())
                }
                map["Clusters"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Clusters") {
                var tmp : [Cluster] = []
                for v in dict["Clusters"] as! [Any] {
                    var model = Cluster()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clusters = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListClustersResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListClustersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListClustersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListConnectionsRequest : Tea.TeaModel {
    public var connectionType: String?

    public var envType: Int32?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var status: String?

    public var subType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionType != nil {
            map["ConnectionType"] = self.connectionType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.subType != nil {
            map["SubType"] = self.subType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConnectionType") {
            self.connectionType = dict["ConnectionType"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SubType") {
            self.subType = dict["SubType"] as! String
        }
    }
}

public class ListConnectionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Connections : Tea.TeaModel {
            public var bindingCalcEngineId: Int32?

            public var connectStatus: Int32?

            public var connectionType: String?

            public var content: String?

            public var defaultEngine: Bool?

            public var description_: String?

            public var envType: Int32?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int32?

            public var name: String?

            public var operator_: String?

            public var projectId: Int32?

            public var sequence: Int32?

            public var shared: Bool?

            public var status: Int32?

            public var subType: String?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindingCalcEngineId != nil {
                    map["BindingCalcEngineId"] = self.bindingCalcEngineId!
                }
                if self.connectStatus != nil {
                    map["ConnectStatus"] = self.connectStatus!
                }
                if self.connectionType != nil {
                    map["ConnectionType"] = self.connectionType!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.defaultEngine != nil {
                    map["DefaultEngine"] = self.defaultEngine!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.sequence != nil {
                    map["Sequence"] = self.sequence!
                }
                if self.shared != nil {
                    map["Shared"] = self.shared!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.subType != nil {
                    map["SubType"] = self.subType!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BindingCalcEngineId") {
                    self.bindingCalcEngineId = dict["BindingCalcEngineId"] as! Int32
                }
                if dict.keys.contains("ConnectStatus") {
                    self.connectStatus = dict["ConnectStatus"] as! Int32
                }
                if dict.keys.contains("ConnectionType") {
                    self.connectionType = dict["ConnectionType"] as! String
                }
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("DefaultEngine") {
                    self.defaultEngine = dict["DefaultEngine"] as! Bool
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! Int32
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Operator") {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int32
                }
                if dict.keys.contains("Sequence") {
                    self.sequence = dict["Sequence"] as! Int32
                }
                if dict.keys.contains("Shared") {
                    self.shared = dict["Shared"] as! Bool
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("SubType") {
                    self.subType = dict["SubType"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
            }
        }
        public var connections: [ListConnectionsResponseBody.Data.Connections]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connections != nil {
                var tmp : [Any] = []
                for k in self.connections! {
                    tmp.append(k.toMap())
                }
                map["Connections"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Connections") {
                var tmp : [ListConnectionsResponseBody.Data.Connections] = []
                for v in dict["Connections"] as! [Any] {
                    var model = ListConnectionsResponseBody.Data.Connections()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.connections = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListConnectionsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListConnectionsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListConnectionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDIAlarmRulesRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class ListDIAlarmRulesResponseBody : Tea.TeaModel {
    public class DIAlarmRulePaging : Tea.TeaModel {
        public class DIJobAlarmRules : Tea.TeaModel {
            public class NotificationSettings : Tea.TeaModel {
                public class NotificationChannels : Tea.TeaModel {
                    public var channels: [String]?

                    public var severity: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.severity != nil {
                            map["Severity"] = self.severity!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! [String]
                        }
                        if dict.keys.contains("Severity") {
                            self.severity = dict["Severity"] as! String
                        }
                    }
                }
                public class NotificationReceivers : Tea.TeaModel {
                    public var receiverType: String?

                    public var receiverValues: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.receiverType != nil {
                            map["ReceiverType"] = self.receiverType!
                        }
                        if self.receiverValues != nil {
                            map["ReceiverValues"] = self.receiverValues!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ReceiverType") {
                            self.receiverType = dict["ReceiverType"] as! String
                        }
                        if dict.keys.contains("ReceiverValues") {
                            self.receiverValues = dict["ReceiverValues"] as! [String]
                        }
                    }
                }
                public var inhibitionInterval: Int32?

                public var notificationChannels: [ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.NotificationSettings.NotificationChannels]?

                public var notificationReceivers: [ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.NotificationSettings.NotificationReceivers]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.inhibitionInterval != nil {
                        map["InhibitionInterval"] = self.inhibitionInterval!
                    }
                    if self.notificationChannels != nil {
                        var tmp : [Any] = []
                        for k in self.notificationChannels! {
                            tmp.append(k.toMap())
                        }
                        map["NotificationChannels"] = tmp
                    }
                    if self.notificationReceivers != nil {
                        var tmp : [Any] = []
                        for k in self.notificationReceivers! {
                            tmp.append(k.toMap())
                        }
                        map["NotificationReceivers"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InhibitionInterval") {
                        self.inhibitionInterval = dict["InhibitionInterval"] as! Int32
                    }
                    if dict.keys.contains("NotificationChannels") {
                        var tmp : [ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.NotificationSettings.NotificationChannels] = []
                        for v in dict["NotificationChannels"] as! [Any] {
                            var model = ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.NotificationSettings.NotificationChannels()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.notificationChannels = tmp
                    }
                    if dict.keys.contains("NotificationReceivers") {
                        var tmp : [ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.NotificationSettings.NotificationReceivers] = []
                        for v in dict["NotificationReceivers"] as! [Any] {
                            var model = ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.NotificationSettings.NotificationReceivers()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.notificationReceivers = tmp
                    }
                }
            }
            public class TriggerConditions : Tea.TeaModel {
                public var duration: Int64?

                public var severity: String?

                public var threshold: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.severity != nil {
                        map["Severity"] = self.severity!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! Int64
                    }
                    if dict.keys.contains("Severity") {
                        self.severity = dict["Severity"] as! String
                    }
                    if dict.keys.contains("Threshold") {
                        self.threshold = dict["Threshold"] as! Int64
                    }
                }
            }
            public var DIAlarmRuleId: Int64?

            public var DIJobId: Int64?

            public var description_: String?

            public var enabled: Bool?

            public var metricType: String?

            public var notificationSettings: ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.NotificationSettings?

            public var triggerConditions: [ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.TriggerConditions]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.notificationSettings?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DIAlarmRuleId != nil {
                    map["DIAlarmRuleId"] = self.DIAlarmRuleId!
                }
                if self.DIJobId != nil {
                    map["DIJobId"] = self.DIJobId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.metricType != nil {
                    map["MetricType"] = self.metricType!
                }
                if self.notificationSettings != nil {
                    map["NotificationSettings"] = self.notificationSettings?.toMap()
                }
                if self.triggerConditions != nil {
                    var tmp : [Any] = []
                    for k in self.triggerConditions! {
                        tmp.append(k.toMap())
                    }
                    map["TriggerConditions"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DIAlarmRuleId") {
                    self.DIAlarmRuleId = dict["DIAlarmRuleId"] as! Int64
                }
                if dict.keys.contains("DIJobId") {
                    self.DIJobId = dict["DIJobId"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Enabled") {
                    self.enabled = dict["Enabled"] as! Bool
                }
                if dict.keys.contains("MetricType") {
                    self.metricType = dict["MetricType"] as! String
                }
                if dict.keys.contains("NotificationSettings") {
                    var model = ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.NotificationSettings()
                    model.fromMap(dict["NotificationSettings"] as! [String: Any])
                    self.notificationSettings = model
                }
                if dict.keys.contains("TriggerConditions") {
                    var tmp : [ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.TriggerConditions] = []
                    for v in dict["TriggerConditions"] as! [Any] {
                        var model = ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.TriggerConditions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.triggerConditions = tmp
                }
            }
        }
        public var DIJobAlarmRules: [ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DIJobAlarmRules != nil {
                var tmp : [Any] = []
                for k in self.DIJobAlarmRules! {
                    tmp.append(k.toMap())
                }
                map["DIJobAlarmRules"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DIJobAlarmRules") {
                var tmp : [ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules] = []
                for v in dict["DIJobAlarmRules"] as! [Any] {
                    var model = ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.DIJobAlarmRules = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var DIAlarmRulePaging: ListDIAlarmRulesResponseBody.DIAlarmRulePaging?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DIAlarmRulePaging?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRulePaging != nil {
            map["DIAlarmRulePaging"] = self.DIAlarmRulePaging?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIAlarmRulePaging") {
            var model = ListDIAlarmRulesResponseBody.DIAlarmRulePaging()
            model.fromMap(dict["DIAlarmRulePaging"] as! [String: Any])
            self.DIAlarmRulePaging = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDIAlarmRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDIAlarmRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDIAlarmRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDIJobsRequest : Tea.TeaModel {
    public var destinationDataSourceType: String?

    public var jobName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var sourceDataSourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationDataSourceType != nil {
            map["DestinationDataSourceType"] = self.destinationDataSourceType!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sourceDataSourceType != nil {
            map["SourceDataSourceType"] = self.sourceDataSourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationDataSourceType") {
            self.destinationDataSourceType = dict["DestinationDataSourceType"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SourceDataSourceType") {
            self.sourceDataSourceType = dict["SourceDataSourceType"] as! String
        }
    }
}

public class ListDIJobsResponseBody : Tea.TeaModel {
    public class DIJobPaging : Tea.TeaModel {
        public class DIJobs : Tea.TeaModel {
            public var DIJobId: Int64?

            public var destinationDataSourceType: String?

            public var jobName: String?

            public var jobStatus: String?

            public var migrationType: String?

            public var projectId: Int64?

            public var sourceDataSourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DIJobId != nil {
                    map["DIJobId"] = self.DIJobId!
                }
                if self.destinationDataSourceType != nil {
                    map["DestinationDataSourceType"] = self.destinationDataSourceType!
                }
                if self.jobName != nil {
                    map["JobName"] = self.jobName!
                }
                if self.jobStatus != nil {
                    map["JobStatus"] = self.jobStatus!
                }
                if self.migrationType != nil {
                    map["MigrationType"] = self.migrationType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.sourceDataSourceType != nil {
                    map["SourceDataSourceType"] = self.sourceDataSourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DIJobId") {
                    self.DIJobId = dict["DIJobId"] as! Int64
                }
                if dict.keys.contains("DestinationDataSourceType") {
                    self.destinationDataSourceType = dict["DestinationDataSourceType"] as! String
                }
                if dict.keys.contains("JobName") {
                    self.jobName = dict["JobName"] as! String
                }
                if dict.keys.contains("JobStatus") {
                    self.jobStatus = dict["JobStatus"] as! String
                }
                if dict.keys.contains("MigrationType") {
                    self.migrationType = dict["MigrationType"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("SourceDataSourceType") {
                    self.sourceDataSourceType = dict["SourceDataSourceType"] as! String
                }
            }
        }
        public var DIJobs: [ListDIJobsResponseBody.DIJobPaging.DIJobs]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DIJobs != nil {
                var tmp : [Any] = []
                for k in self.DIJobs! {
                    tmp.append(k.toMap())
                }
                map["DIJobs"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DIJobs") {
                var tmp : [ListDIJobsResponseBody.DIJobPaging.DIJobs] = []
                for v in dict["DIJobs"] as! [Any] {
                    var model = ListDIJobsResponseBody.DIJobPaging.DIJobs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.DIJobs = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var DIJobPaging: ListDIJobsResponseBody.DIJobPaging?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DIJobPaging?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobPaging != nil {
            map["DIJobPaging"] = self.DIJobPaging?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobPaging") {
            var model = ListDIJobsResponseBody.DIJobPaging()
            model.fromMap(dict["DIJobPaging"] as! [String: Any])
            self.DIJobPaging = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDIJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDIJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDIJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDIProjectConfigRequest : Tea.TeaModel {
    public var destinationType: String?

    public var projectId: Int64?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationType") {
            self.destinationType = dict["DestinationType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class ListDIProjectConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var config: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! String
            }
        }
    }
    public var data: ListDIProjectConfigResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListDIProjectConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDIProjectConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDIProjectConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDIProjectConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDagsRequest : Tea.TeaModel {
    public var opSeq: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.opSeq != nil {
            map["OpSeq"] = self.opSeq!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpSeq") {
            self.opSeq = dict["OpSeq"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class ListDagsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Dags : Tea.TeaModel {
            public var bizdate: Int64?

            public var createTime: Int64?

            public var createUser: String?

            public var dagId: Int64?

            public var finishTime: Int64?

            public var gmtdate: Int64?

            public var modifyTime: Int64?

            public var name: String?

            public var opSeq: Int64?

            public var projectId: Int64?

            public var startTime: Int64?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.dagId != nil {
                    map["DagId"] = self.dagId!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.gmtdate != nil {
                    map["Gmtdate"] = self.gmtdate!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.opSeq != nil {
                    map["OpSeq"] = self.opSeq!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bizdate") {
                    self.bizdate = dict["Bizdate"] as! Int64
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CreateUser") {
                    self.createUser = dict["CreateUser"] as! String
                }
                if dict.keys.contains("DagId") {
                    self.dagId = dict["DagId"] as! Int64
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! Int64
                }
                if dict.keys.contains("Gmtdate") {
                    self.gmtdate = dict["Gmtdate"] as! Int64
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OpSeq") {
                    self.opSeq = dict["OpSeq"] as! Int64
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var dags: [ListDagsResponseBody.Data.Dags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dags != nil {
                var tmp : [Any] = []
                for k in self.dags! {
                    tmp.append(k.toMap())
                }
                map["Dags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Dags") {
                var tmp : [ListDagsResponseBody.Data.Dags] = []
                for v in dict["Dags"] as! [Any] {
                    var model = ListDagsResponseBody.Data.Dags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dags = tmp
            }
        }
    }
    public var data: ListDagsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListDagsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataServiceApiAuthoritiesRequest : Tea.TeaModel {
    public var apiNameKeyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiNameKeyword != nil {
            map["ApiNameKeyword"] = self.apiNameKeyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiNameKeyword") {
            self.apiNameKeyword = dict["ApiNameKeyword"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class ListDataServiceApiAuthoritiesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ApiAuthorizationList : Tea.TeaModel {
            public class AuthorizationRecords : Tea.TeaModel {
                public var createdTime: String?

                public var creatorId: String?

                public var endTime: String?

                public var projectId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.createdTime != nil {
                        map["CreatedTime"] = self.createdTime!
                    }
                    if self.creatorId != nil {
                        map["CreatorId"] = self.creatorId!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CreatedTime") {
                        self.createdTime = dict["CreatedTime"] as! String
                    }
                    if dict.keys.contains("CreatorId") {
                        self.creatorId = dict["CreatorId"] as! String
                    }
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! String
                    }
                    if dict.keys.contains("ProjectId") {
                        self.projectId = dict["ProjectId"] as! Int64
                    }
                }
            }
            public var apiId: Int64?

            public var apiName: String?

            public var apiPath: String?

            public var apiStatus: Int32?

            public var authorizationRecords: [ListDataServiceApiAuthoritiesResponseBody.Data.ApiAuthorizationList.AuthorizationRecords]?

            public var createdTime: String?

            public var creatorId: String?

            public var groupId: String?

            public var modifiedTime: String?

            public var projectId: Int64?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiPath != nil {
                    map["ApiPath"] = self.apiPath!
                }
                if self.apiStatus != nil {
                    map["ApiStatus"] = self.apiStatus!
                }
                if self.authorizationRecords != nil {
                    var tmp : [Any] = []
                    for k in self.authorizationRecords! {
                        tmp.append(k.toMap())
                    }
                    map["AuthorizationRecords"] = tmp
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! Int64
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiPath") {
                    self.apiPath = dict["ApiPath"] as! String
                }
                if dict.keys.contains("ApiStatus") {
                    self.apiStatus = dict["ApiStatus"] as! Int32
                }
                if dict.keys.contains("AuthorizationRecords") {
                    var tmp : [ListDataServiceApiAuthoritiesResponseBody.Data.ApiAuthorizationList.AuthorizationRecords] = []
                    for v in dict["AuthorizationRecords"] as! [Any] {
                        var model = ListDataServiceApiAuthoritiesResponseBody.Data.ApiAuthorizationList.AuthorizationRecords()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.authorizationRecords = tmp
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("CreatorId") {
                    self.creatorId = dict["CreatorId"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
            }
        }
        public var apiAuthorizationList: [ListDataServiceApiAuthoritiesResponseBody.Data.ApiAuthorizationList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiAuthorizationList != nil {
                var tmp : [Any] = []
                for k in self.apiAuthorizationList! {
                    tmp.append(k.toMap())
                }
                map["ApiAuthorizationList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiAuthorizationList") {
                var tmp : [ListDataServiceApiAuthoritiesResponseBody.Data.ApiAuthorizationList] = []
                for v in dict["ApiAuthorizationList"] as! [Any] {
                    var model = ListDataServiceApiAuthoritiesResponseBody.Data.ApiAuthorizationList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiAuthorizationList = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListDataServiceApiAuthoritiesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListDataServiceApiAuthoritiesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataServiceApiAuthoritiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataServiceApiAuthoritiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataServiceApiAuthoritiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataServiceApiTestRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListDataServiceApiTestResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var apiId: Int64?

        public var costTime: Int32?

        public var createTime: Int64?

        public var paramMap: String?

        public var retCode: Int64?

        public var retResult: String?

        public var status: String?

        public var testId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiId != nil {
                map["ApiId"] = self.apiId!
            }
            if self.costTime != nil {
                map["CostTime"] = self.costTime!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.paramMap != nil {
                map["ParamMap"] = self.paramMap!
            }
            if self.retCode != nil {
                map["RetCode"] = self.retCode!
            }
            if self.retResult != nil {
                map["RetResult"] = self.retResult!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.testId != nil {
                map["TestId"] = self.testId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiId") {
                self.apiId = dict["ApiId"] as! Int64
            }
            if dict.keys.contains("CostTime") {
                self.costTime = dict["CostTime"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ParamMap") {
                self.paramMap = dict["ParamMap"] as! String
            }
            if dict.keys.contains("RetCode") {
                self.retCode = dict["RetCode"] as! Int64
            }
            if dict.keys.contains("RetResult") {
                self.retResult = dict["RetResult"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TestId") {
                self.testId = dict["TestId"] as! Int64
            }
        }
    }
    public var data: [ListDataServiceApiTestResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListDataServiceApiTestResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListDataServiceApiTestResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDataServiceApiTestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataServiceApiTestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataServiceApiTestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataServiceApisRequest : Tea.TeaModel {
    public var apiNameKeyword: String?

    public var apiPathKeyword: String?

    public var creatorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiNameKeyword != nil {
            map["ApiNameKeyword"] = self.apiNameKeyword!
        }
        if self.apiPathKeyword != nil {
            map["ApiPathKeyword"] = self.apiPathKeyword!
        }
        if self.creatorId != nil {
            map["CreatorId"] = self.creatorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiNameKeyword") {
            self.apiNameKeyword = dict["ApiNameKeyword"] as! String
        }
        if dict.keys.contains("ApiPathKeyword") {
            self.apiPathKeyword = dict["ApiPathKeyword"] as! String
        }
        if dict.keys.contains("CreatorId") {
            self.creatorId = dict["CreatorId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class ListDataServiceApisResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Apis : Tea.TeaModel {
            public class RegistrationDetails : Tea.TeaModel {
                public class RegistrationErrorCodes : Tea.TeaModel {
                    public var errorCode: String?

                    public var errorMessage: String?

                    public var errorSolution: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorMessage != nil {
                            map["ErrorMessage"] = self.errorMessage!
                        }
                        if self.errorSolution != nil {
                            map["ErrorSolution"] = self.errorSolution!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ErrorCode") {
                            self.errorCode = dict["ErrorCode"] as! String
                        }
                        if dict.keys.contains("ErrorMessage") {
                            self.errorMessage = dict["ErrorMessage"] as! String
                        }
                        if dict.keys.contains("ErrorSolution") {
                            self.errorSolution = dict["ErrorSolution"] as! String
                        }
                    }
                }
                public class RegistrationRequestParameters : Tea.TeaModel {
                    public var columnName: String?

                    public var defaultValue: String?

                    public var exampleValue: String?

                    public var isRequiredParameter: Bool?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public var parameterOperator: Int32?

                    public var parameterPosition: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.columnName != nil {
                            map["ColumnName"] = self.columnName!
                        }
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.isRequiredParameter != nil {
                            map["IsRequiredParameter"] = self.isRequiredParameter!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        if self.parameterOperator != nil {
                            map["ParameterOperator"] = self.parameterOperator!
                        }
                        if self.parameterPosition != nil {
                            map["ParameterPosition"] = self.parameterPosition!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ColumnName") {
                            self.columnName = dict["ColumnName"] as! String
                        }
                        if dict.keys.contains("DefaultValue") {
                            self.defaultValue = dict["DefaultValue"] as! String
                        }
                        if dict.keys.contains("ExampleValue") {
                            self.exampleValue = dict["ExampleValue"] as! String
                        }
                        if dict.keys.contains("IsRequiredParameter") {
                            self.isRequiredParameter = dict["IsRequiredParameter"] as! Bool
                        }
                        if dict.keys.contains("ParameterDataType") {
                            self.parameterDataType = dict["ParameterDataType"] as! Int32
                        }
                        if dict.keys.contains("ParameterDescription") {
                            self.parameterDescription = dict["ParameterDescription"] as! String
                        }
                        if dict.keys.contains("ParameterName") {
                            self.parameterName = dict["ParameterName"] as! String
                        }
                        if dict.keys.contains("ParameterOperator") {
                            self.parameterOperator = dict["ParameterOperator"] as! Int32
                        }
                        if dict.keys.contains("ParameterPosition") {
                            self.parameterPosition = dict["ParameterPosition"] as! Int32
                        }
                    }
                }
                public var failedResultSample: String?

                public var registrationErrorCodes: [ListDataServiceApisResponseBody.Data.Apis.RegistrationDetails.RegistrationErrorCodes]?

                public var registrationRequestParameters: [ListDataServiceApisResponseBody.Data.Apis.RegistrationDetails.RegistrationRequestParameters]?

                public var serviceContentType: Int32?

                public var serviceHost: String?

                public var servicePath: String?

                public var serviceRequestBodyDescription: String?

                public var successfulResultSample: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.failedResultSample != nil {
                        map["FailedResultSample"] = self.failedResultSample!
                    }
                    if self.registrationErrorCodes != nil {
                        var tmp : [Any] = []
                        for k in self.registrationErrorCodes! {
                            tmp.append(k.toMap())
                        }
                        map["RegistrationErrorCodes"] = tmp
                    }
                    if self.registrationRequestParameters != nil {
                        var tmp : [Any] = []
                        for k in self.registrationRequestParameters! {
                            tmp.append(k.toMap())
                        }
                        map["RegistrationRequestParameters"] = tmp
                    }
                    if self.serviceContentType != nil {
                        map["ServiceContentType"] = self.serviceContentType!
                    }
                    if self.serviceHost != nil {
                        map["ServiceHost"] = self.serviceHost!
                    }
                    if self.servicePath != nil {
                        map["ServicePath"] = self.servicePath!
                    }
                    if self.serviceRequestBodyDescription != nil {
                        map["ServiceRequestBodyDescription"] = self.serviceRequestBodyDescription!
                    }
                    if self.successfulResultSample != nil {
                        map["SuccessfulResultSample"] = self.successfulResultSample!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FailedResultSample") {
                        self.failedResultSample = dict["FailedResultSample"] as! String
                    }
                    if dict.keys.contains("RegistrationErrorCodes") {
                        var tmp : [ListDataServiceApisResponseBody.Data.Apis.RegistrationDetails.RegistrationErrorCodes] = []
                        for v in dict["RegistrationErrorCodes"] as! [Any] {
                            var model = ListDataServiceApisResponseBody.Data.Apis.RegistrationDetails.RegistrationErrorCodes()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.registrationErrorCodes = tmp
                    }
                    if dict.keys.contains("RegistrationRequestParameters") {
                        var tmp : [ListDataServiceApisResponseBody.Data.Apis.RegistrationDetails.RegistrationRequestParameters] = []
                        for v in dict["RegistrationRequestParameters"] as! [Any] {
                            var model = ListDataServiceApisResponseBody.Data.Apis.RegistrationDetails.RegistrationRequestParameters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.registrationRequestParameters = tmp
                    }
                    if dict.keys.contains("ServiceContentType") {
                        self.serviceContentType = dict["ServiceContentType"] as! Int32
                    }
                    if dict.keys.contains("ServiceHost") {
                        self.serviceHost = dict["ServiceHost"] as! String
                    }
                    if dict.keys.contains("ServicePath") {
                        self.servicePath = dict["ServicePath"] as! String
                    }
                    if dict.keys.contains("ServiceRequestBodyDescription") {
                        self.serviceRequestBodyDescription = dict["ServiceRequestBodyDescription"] as! String
                    }
                    if dict.keys.contains("SuccessfulResultSample") {
                        self.successfulResultSample = dict["SuccessfulResultSample"] as! String
                    }
                }
            }
            public class ScriptDetails : Tea.TeaModel {
                public class ScriptConnection : Tea.TeaModel {
                    public var connectionId: Int64?

                    public var tableName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.connectionId != nil {
                            map["ConnectionId"] = self.connectionId!
                        }
                        if self.tableName != nil {
                            map["TableName"] = self.tableName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ConnectionId") {
                            self.connectionId = dict["ConnectionId"] as! Int64
                        }
                        if dict.keys.contains("TableName") {
                            self.tableName = dict["TableName"] as! String
                        }
                    }
                }
                public class ScriptRequestParameters : Tea.TeaModel {
                    public var columnName: String?

                    public var defaultValue: String?

                    public var exampleValue: String?

                    public var isRequiredParameter: Bool?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public var parameterOperator: Int32?

                    public var parameterPosition: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.columnName != nil {
                            map["ColumnName"] = self.columnName!
                        }
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.isRequiredParameter != nil {
                            map["IsRequiredParameter"] = self.isRequiredParameter!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        if self.parameterOperator != nil {
                            map["ParameterOperator"] = self.parameterOperator!
                        }
                        if self.parameterPosition != nil {
                            map["ParameterPosition"] = self.parameterPosition!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ColumnName") {
                            self.columnName = dict["ColumnName"] as! String
                        }
                        if dict.keys.contains("DefaultValue") {
                            self.defaultValue = dict["DefaultValue"] as! String
                        }
                        if dict.keys.contains("ExampleValue") {
                            self.exampleValue = dict["ExampleValue"] as! String
                        }
                        if dict.keys.contains("IsRequiredParameter") {
                            self.isRequiredParameter = dict["IsRequiredParameter"] as! Bool
                        }
                        if dict.keys.contains("ParameterDataType") {
                            self.parameterDataType = dict["ParameterDataType"] as! Int32
                        }
                        if dict.keys.contains("ParameterDescription") {
                            self.parameterDescription = dict["ParameterDescription"] as! String
                        }
                        if dict.keys.contains("ParameterName") {
                            self.parameterName = dict["ParameterName"] as! String
                        }
                        if dict.keys.contains("ParameterOperator") {
                            self.parameterOperator = dict["ParameterOperator"] as! Int32
                        }
                        if dict.keys.contains("ParameterPosition") {
                            self.parameterPosition = dict["ParameterPosition"] as! Int32
                        }
                    }
                }
                public class ScriptResponseParameters : Tea.TeaModel {
                    public var columnName: String?

                    public var exampleValue: String?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.columnName != nil {
                            map["ColumnName"] = self.columnName!
                        }
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ColumnName") {
                            self.columnName = dict["ColumnName"] as! String
                        }
                        if dict.keys.contains("ExampleValue") {
                            self.exampleValue = dict["ExampleValue"] as! String
                        }
                        if dict.keys.contains("ParameterDataType") {
                            self.parameterDataType = dict["ParameterDataType"] as! Int32
                        }
                        if dict.keys.contains("ParameterDescription") {
                            self.parameterDescription = dict["ParameterDescription"] as! String
                        }
                        if dict.keys.contains("ParameterName") {
                            self.parameterName = dict["ParameterName"] as! String
                        }
                    }
                }
                public var isPagedResponse: Bool?

                public var script: String?

                public var scriptConnection: ListDataServiceApisResponseBody.Data.Apis.ScriptDetails.ScriptConnection?

                public var scriptRequestParameters: [ListDataServiceApisResponseBody.Data.Apis.ScriptDetails.ScriptRequestParameters]?

                public var scriptResponseParameters: [ListDataServiceApisResponseBody.Data.Apis.ScriptDetails.ScriptResponseParameters]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.scriptConnection?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.isPagedResponse != nil {
                        map["IsPagedResponse"] = self.isPagedResponse!
                    }
                    if self.script != nil {
                        map["Script"] = self.script!
                    }
                    if self.scriptConnection != nil {
                        map["ScriptConnection"] = self.scriptConnection?.toMap()
                    }
                    if self.scriptRequestParameters != nil {
                        var tmp : [Any] = []
                        for k in self.scriptRequestParameters! {
                            tmp.append(k.toMap())
                        }
                        map["ScriptRequestParameters"] = tmp
                    }
                    if self.scriptResponseParameters != nil {
                        var tmp : [Any] = []
                        for k in self.scriptResponseParameters! {
                            tmp.append(k.toMap())
                        }
                        map["ScriptResponseParameters"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IsPagedResponse") {
                        self.isPagedResponse = dict["IsPagedResponse"] as! Bool
                    }
                    if dict.keys.contains("Script") {
                        self.script = dict["Script"] as! String
                    }
                    if dict.keys.contains("ScriptConnection") {
                        var model = ListDataServiceApisResponseBody.Data.Apis.ScriptDetails.ScriptConnection()
                        model.fromMap(dict["ScriptConnection"] as! [String: Any])
                        self.scriptConnection = model
                    }
                    if dict.keys.contains("ScriptRequestParameters") {
                        var tmp : [ListDataServiceApisResponseBody.Data.Apis.ScriptDetails.ScriptRequestParameters] = []
                        for v in dict["ScriptRequestParameters"] as! [Any] {
                            var model = ListDataServiceApisResponseBody.Data.Apis.ScriptDetails.ScriptRequestParameters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.scriptRequestParameters = tmp
                    }
                    if dict.keys.contains("ScriptResponseParameters") {
                        var tmp : [ListDataServiceApisResponseBody.Data.Apis.ScriptDetails.ScriptResponseParameters] = []
                        for v in dict["ScriptResponseParameters"] as! [Any] {
                            var model = ListDataServiceApisResponseBody.Data.Apis.ScriptDetails.ScriptResponseParameters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.scriptResponseParameters = tmp
                    }
                }
            }
            public class WizardDetails : Tea.TeaModel {
                public class WizardConnection : Tea.TeaModel {
                    public var connectionId: Int64?

                    public var tableName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.connectionId != nil {
                            map["ConnectionId"] = self.connectionId!
                        }
                        if self.tableName != nil {
                            map["TableName"] = self.tableName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ConnectionId") {
                            self.connectionId = dict["ConnectionId"] as! Int64
                        }
                        if dict.keys.contains("TableName") {
                            self.tableName = dict["TableName"] as! String
                        }
                    }
                }
                public class WizardRequestParameters : Tea.TeaModel {
                    public var columnName: String?

                    public var defaultValue: String?

                    public var exampleValue: String?

                    public var isRequiredParameter: Bool?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public var parameterOperator: Int32?

                    public var parameterPosition: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.columnName != nil {
                            map["ColumnName"] = self.columnName!
                        }
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.isRequiredParameter != nil {
                            map["IsRequiredParameter"] = self.isRequiredParameter!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        if self.parameterOperator != nil {
                            map["ParameterOperator"] = self.parameterOperator!
                        }
                        if self.parameterPosition != nil {
                            map["ParameterPosition"] = self.parameterPosition!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ColumnName") {
                            self.columnName = dict["ColumnName"] as! String
                        }
                        if dict.keys.contains("DefaultValue") {
                            self.defaultValue = dict["DefaultValue"] as! String
                        }
                        if dict.keys.contains("ExampleValue") {
                            self.exampleValue = dict["ExampleValue"] as! String
                        }
                        if dict.keys.contains("IsRequiredParameter") {
                            self.isRequiredParameter = dict["IsRequiredParameter"] as! Bool
                        }
                        if dict.keys.contains("ParameterDataType") {
                            self.parameterDataType = dict["ParameterDataType"] as! Int32
                        }
                        if dict.keys.contains("ParameterDescription") {
                            self.parameterDescription = dict["ParameterDescription"] as! String
                        }
                        if dict.keys.contains("ParameterName") {
                            self.parameterName = dict["ParameterName"] as! String
                        }
                        if dict.keys.contains("ParameterOperator") {
                            self.parameterOperator = dict["ParameterOperator"] as! Int32
                        }
                        if dict.keys.contains("ParameterPosition") {
                            self.parameterPosition = dict["ParameterPosition"] as! Int32
                        }
                    }
                }
                public class WizardResponseParameters : Tea.TeaModel {
                    public var columnName: String?

                    public var exampleValue: String?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.columnName != nil {
                            map["ColumnName"] = self.columnName!
                        }
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ColumnName") {
                            self.columnName = dict["ColumnName"] as! String
                        }
                        if dict.keys.contains("ExampleValue") {
                            self.exampleValue = dict["ExampleValue"] as! String
                        }
                        if dict.keys.contains("ParameterDataType") {
                            self.parameterDataType = dict["ParameterDataType"] as! Int32
                        }
                        if dict.keys.contains("ParameterDescription") {
                            self.parameterDescription = dict["ParameterDescription"] as! String
                        }
                        if dict.keys.contains("ParameterName") {
                            self.parameterName = dict["ParameterName"] as! String
                        }
                    }
                }
                public var isPagedResponse: Bool?

                public var wizardConnection: ListDataServiceApisResponseBody.Data.Apis.WizardDetails.WizardConnection?

                public var wizardRequestParameters: [ListDataServiceApisResponseBody.Data.Apis.WizardDetails.WizardRequestParameters]?

                public var wizardResponseParameters: [ListDataServiceApisResponseBody.Data.Apis.WizardDetails.WizardResponseParameters]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.wizardConnection?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.isPagedResponse != nil {
                        map["IsPagedResponse"] = self.isPagedResponse!
                    }
                    if self.wizardConnection != nil {
                        map["WizardConnection"] = self.wizardConnection?.toMap()
                    }
                    if self.wizardRequestParameters != nil {
                        var tmp : [Any] = []
                        for k in self.wizardRequestParameters! {
                            tmp.append(k.toMap())
                        }
                        map["WizardRequestParameters"] = tmp
                    }
                    if self.wizardResponseParameters != nil {
                        var tmp : [Any] = []
                        for k in self.wizardResponseParameters! {
                            tmp.append(k.toMap())
                        }
                        map["WizardResponseParameters"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IsPagedResponse") {
                        self.isPagedResponse = dict["IsPagedResponse"] as! Bool
                    }
                    if dict.keys.contains("WizardConnection") {
                        var model = ListDataServiceApisResponseBody.Data.Apis.WizardDetails.WizardConnection()
                        model.fromMap(dict["WizardConnection"] as! [String: Any])
                        self.wizardConnection = model
                    }
                    if dict.keys.contains("WizardRequestParameters") {
                        var tmp : [ListDataServiceApisResponseBody.Data.Apis.WizardDetails.WizardRequestParameters] = []
                        for v in dict["WizardRequestParameters"] as! [Any] {
                            var model = ListDataServiceApisResponseBody.Data.Apis.WizardDetails.WizardRequestParameters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.wizardRequestParameters = tmp
                    }
                    if dict.keys.contains("WizardResponseParameters") {
                        var tmp : [ListDataServiceApisResponseBody.Data.Apis.WizardDetails.WizardResponseParameters] = []
                        for v in dict["WizardResponseParameters"] as! [Any] {
                            var model = ListDataServiceApisResponseBody.Data.Apis.WizardDetails.WizardResponseParameters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.wizardResponseParameters = tmp
                    }
                }
            }
            public var apiId: Int64?

            public var apiMode: Int32?

            public var apiName: String?

            public var apiPath: String?

            public var createdTime: String?

            public var creatorId: String?

            public var description_: String?

            public var folderId: Int64?

            public var groupId: String?

            public var modifiedTime: String?

            public var operatorId: String?

            public var projectId: Int64?

            public var protocols: [Int32]?

            public var registrationDetails: ListDataServiceApisResponseBody.Data.Apis.RegistrationDetails?

            public var requestMethod: Int32?

            public var responseContentType: Int32?

            public var scriptDetails: ListDataServiceApisResponseBody.Data.Apis.ScriptDetails?

            public var status: Int32?

            public var tenantId: Int64?

            public var timeout: Int32?

            public var visibleRange: Int32?

            public var wizardDetails: ListDataServiceApisResponseBody.Data.Apis.WizardDetails?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.registrationDetails?.validate()
                try self.scriptDetails?.validate()
                try self.wizardDetails?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiMode != nil {
                    map["ApiMode"] = self.apiMode!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiPath != nil {
                    map["ApiPath"] = self.apiPath!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.folderId != nil {
                    map["FolderId"] = self.folderId!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.operatorId != nil {
                    map["OperatorId"] = self.operatorId!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.protocols != nil {
                    map["Protocols"] = self.protocols!
                }
                if self.registrationDetails != nil {
                    map["RegistrationDetails"] = self.registrationDetails?.toMap()
                }
                if self.requestMethod != nil {
                    map["RequestMethod"] = self.requestMethod!
                }
                if self.responseContentType != nil {
                    map["ResponseContentType"] = self.responseContentType!
                }
                if self.scriptDetails != nil {
                    map["ScriptDetails"] = self.scriptDetails?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.visibleRange != nil {
                    map["VisibleRange"] = self.visibleRange!
                }
                if self.wizardDetails != nil {
                    map["WizardDetails"] = self.wizardDetails?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! Int64
                }
                if dict.keys.contains("ApiMode") {
                    self.apiMode = dict["ApiMode"] as! Int32
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiPath") {
                    self.apiPath = dict["ApiPath"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("CreatorId") {
                    self.creatorId = dict["CreatorId"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("FolderId") {
                    self.folderId = dict["FolderId"] as! Int64
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("OperatorId") {
                    self.operatorId = dict["OperatorId"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("Protocols") {
                    self.protocols = dict["Protocols"] as! [Int32]
                }
                if dict.keys.contains("RegistrationDetails") {
                    var model = ListDataServiceApisResponseBody.Data.Apis.RegistrationDetails()
                    model.fromMap(dict["RegistrationDetails"] as! [String: Any])
                    self.registrationDetails = model
                }
                if dict.keys.contains("RequestMethod") {
                    self.requestMethod = dict["RequestMethod"] as! Int32
                }
                if dict.keys.contains("ResponseContentType") {
                    self.responseContentType = dict["ResponseContentType"] as! Int32
                }
                if dict.keys.contains("ScriptDetails") {
                    var model = ListDataServiceApisResponseBody.Data.Apis.ScriptDetails()
                    model.fromMap(dict["ScriptDetails"] as! [String: Any])
                    self.scriptDetails = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int32
                }
                if dict.keys.contains("VisibleRange") {
                    self.visibleRange = dict["VisibleRange"] as! Int32
                }
                if dict.keys.contains("WizardDetails") {
                    var model = ListDataServiceApisResponseBody.Data.Apis.WizardDetails()
                    model.fromMap(dict["WizardDetails"] as! [String: Any])
                    self.wizardDetails = model
                }
            }
        }
        public var apis: [ListDataServiceApisResponseBody.Data.Apis]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apis != nil {
                var tmp : [Any] = []
                for k in self.apis! {
                    tmp.append(k.toMap())
                }
                map["Apis"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Apis") {
                var tmp : [ListDataServiceApisResponseBody.Data.Apis] = []
                for v in dict["Apis"] as! [Any] {
                    var model = ListDataServiceApisResponseBody.Data.Apis()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apis = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListDataServiceApisResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListDataServiceApisResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataServiceApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataServiceApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataServiceApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataServiceApplicationsRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectIdList: String?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectIdList != nil {
            map["ProjectIdList"] = self.projectIdList!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectIdList") {
            self.projectIdList = dict["ProjectIdList"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class ListDataServiceApplicationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Applications : Tea.TeaModel {
            public var applicationId: Int64?

            public var applicationName: String?

            public var projectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applicationId != nil {
                    map["ApplicationId"] = self.applicationId!
                }
                if self.applicationName != nil {
                    map["ApplicationName"] = self.applicationName!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApplicationId") {
                    self.applicationId = dict["ApplicationId"] as! Int64
                }
                if dict.keys.contains("ApplicationName") {
                    self.applicationName = dict["ApplicationName"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
            }
        }
        public var applications: [ListDataServiceApplicationsResponseBody.Data.Applications]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applications != nil {
                var tmp : [Any] = []
                for k in self.applications! {
                    tmp.append(k.toMap())
                }
                map["Applications"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Applications") {
                var tmp : [ListDataServiceApplicationsResponseBody.Data.Applications] = []
                for v in dict["Applications"] as! [Any] {
                    var model = ListDataServiceApplicationsResponseBody.Data.Applications()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.applications = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListDataServiceApplicationsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListDataServiceApplicationsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataServiceApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataServiceApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataServiceApplicationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataServiceAuthorizedApisRequest : Tea.TeaModel {
    public var apiNameKeyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiNameKeyword != nil {
            map["ApiNameKeyword"] = self.apiNameKeyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiNameKeyword") {
            self.apiNameKeyword = dict["ApiNameKeyword"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class ListDataServiceAuthorizedApisResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ApiAuthorizedList : Tea.TeaModel {
            public var apiId: Int64?

            public var apiName: String?

            public var apiPath: String?

            public var apiStatus: Int32?

            public var createdTime: String?

            public var creatorId: String?

            public var grantCreatedTime: String?

            public var grantEndTime: String?

            public var grantOperatorId: String?

            public var groupId: String?

            public var modifiedTime: String?

            public var projectId: Int64?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiPath != nil {
                    map["ApiPath"] = self.apiPath!
                }
                if self.apiStatus != nil {
                    map["ApiStatus"] = self.apiStatus!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.grantCreatedTime != nil {
                    map["GrantCreatedTime"] = self.grantCreatedTime!
                }
                if self.grantEndTime != nil {
                    map["GrantEndTime"] = self.grantEndTime!
                }
                if self.grantOperatorId != nil {
                    map["GrantOperatorId"] = self.grantOperatorId!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! Int64
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiPath") {
                    self.apiPath = dict["ApiPath"] as! String
                }
                if dict.keys.contains("ApiStatus") {
                    self.apiStatus = dict["ApiStatus"] as! Int32
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("CreatorId") {
                    self.creatorId = dict["CreatorId"] as! String
                }
                if dict.keys.contains("GrantCreatedTime") {
                    self.grantCreatedTime = dict["GrantCreatedTime"] as! String
                }
                if dict.keys.contains("GrantEndTime") {
                    self.grantEndTime = dict["GrantEndTime"] as! String
                }
                if dict.keys.contains("GrantOperatorId") {
                    self.grantOperatorId = dict["GrantOperatorId"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
            }
        }
        public var apiAuthorizedList: [ListDataServiceAuthorizedApisResponseBody.Data.ApiAuthorizedList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiAuthorizedList != nil {
                var tmp : [Any] = []
                for k in self.apiAuthorizedList! {
                    tmp.append(k.toMap())
                }
                map["ApiAuthorizedList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiAuthorizedList") {
                var tmp : [ListDataServiceAuthorizedApisResponseBody.Data.ApiAuthorizedList] = []
                for v in dict["ApiAuthorizedList"] as! [Any] {
                    var model = ListDataServiceAuthorizedApisResponseBody.Data.ApiAuthorizedList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiAuthorizedList = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListDataServiceAuthorizedApisResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListDataServiceAuthorizedApisResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataServiceAuthorizedApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataServiceAuthorizedApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataServiceAuthorizedApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataServiceFoldersRequest : Tea.TeaModel {
    public var folderNameKeyword: String?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderNameKeyword != nil {
            map["FolderNameKeyword"] = self.folderNameKeyword!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FolderNameKeyword") {
            self.folderNameKeyword = dict["FolderNameKeyword"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class ListDataServiceFoldersResponseBody : Tea.TeaModel {
    public class FolderPagingResult : Tea.TeaModel {
        public class Folders : Tea.TeaModel {
            public var createdTime: String?

            public var folderId: Int64?

            public var folderName: String?

            public var groupId: String?

            public var modifiedTime: String?

            public var parentId: Int64?

            public var projectId: Int64?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.folderId != nil {
                    map["FolderId"] = self.folderId!
                }
                if self.folderName != nil {
                    map["FolderName"] = self.folderName!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("FolderId") {
                    self.folderId = dict["FolderId"] as! Int64
                }
                if dict.keys.contains("FolderName") {
                    self.folderName = dict["FolderName"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ParentId") {
                    self.parentId = dict["ParentId"] as! Int64
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
            }
        }
        public var folders: [ListDataServiceFoldersResponseBody.FolderPagingResult.Folders]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.folders != nil {
                var tmp : [Any] = []
                for k in self.folders! {
                    tmp.append(k.toMap())
                }
                map["Folders"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Folders") {
                var tmp : [ListDataServiceFoldersResponseBody.FolderPagingResult.Folders] = []
                for v in dict["Folders"] as! [Any] {
                    var model = ListDataServiceFoldersResponseBody.FolderPagingResult.Folders()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.folders = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var folderPagingResult: ListDataServiceFoldersResponseBody.FolderPagingResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.folderPagingResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderPagingResult != nil {
            map["FolderPagingResult"] = self.folderPagingResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FolderPagingResult") {
            var model = ListDataServiceFoldersResponseBody.FolderPagingResult()
            model.fromMap(dict["FolderPagingResult"] as! [String: Any])
            self.folderPagingResult = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDataServiceFoldersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataServiceFoldersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataServiceFoldersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataServiceGroupsRequest : Tea.TeaModel {
    public var groupNameKeyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupNameKeyword != nil {
            map["GroupNameKeyword"] = self.groupNameKeyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupNameKeyword") {
            self.groupNameKeyword = dict["GroupNameKeyword"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class ListDataServiceGroupsResponseBody : Tea.TeaModel {
    public class GroupPagingResult : Tea.TeaModel {
        public class Groups : Tea.TeaModel {
            public var apiGatewayGroupId: String?

            public var createdTime: String?

            public var creatorId: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var modifiedTime: String?

            public var projectId: Int64?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiGatewayGroupId != nil {
                    map["ApiGatewayGroupId"] = self.apiGatewayGroupId!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiGatewayGroupId") {
                    self.apiGatewayGroupId = dict["ApiGatewayGroupId"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("CreatorId") {
                    self.creatorId = dict["CreatorId"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
            }
        }
        public var groups: [ListDataServiceGroupsResponseBody.GroupPagingResult.Groups]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groups != nil {
                var tmp : [Any] = []
                for k in self.groups! {
                    tmp.append(k.toMap())
                }
                map["Groups"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Groups") {
                var tmp : [ListDataServiceGroupsResponseBody.GroupPagingResult.Groups] = []
                for v in dict["Groups"] as! [Any] {
                    var model = ListDataServiceGroupsResponseBody.GroupPagingResult.Groups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.groups = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var groupPagingResult: ListDataServiceGroupsResponseBody.GroupPagingResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.groupPagingResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupPagingResult != nil {
            map["GroupPagingResult"] = self.groupPagingResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupPagingResult") {
            var model = ListDataServiceGroupsResponseBody.GroupPagingResult()
            model.fromMap(dict["GroupPagingResult"] as! [String: Any])
            self.groupPagingResult = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDataServiceGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataServiceGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataServiceGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataServicePublishedApisRequest : Tea.TeaModel {
    public var apiNameKeyword: String?

    public var apiPathKeyword: String?

    public var creatorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiNameKeyword != nil {
            map["ApiNameKeyword"] = self.apiNameKeyword!
        }
        if self.apiPathKeyword != nil {
            map["ApiPathKeyword"] = self.apiPathKeyword!
        }
        if self.creatorId != nil {
            map["CreatorId"] = self.creatorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiNameKeyword") {
            self.apiNameKeyword = dict["ApiNameKeyword"] as! String
        }
        if dict.keys.contains("ApiPathKeyword") {
            self.apiPathKeyword = dict["ApiPathKeyword"] as! String
        }
        if dict.keys.contains("CreatorId") {
            self.creatorId = dict["CreatorId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class ListDataServicePublishedApisResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Apis : Tea.TeaModel {
            public class RegistrationDetails : Tea.TeaModel {
                public class RegistrationErrorCodes : Tea.TeaModel {
                    public var errorCode: String?

                    public var errorMessage: String?

                    public var errorSolution: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorMessage != nil {
                            map["ErrorMessage"] = self.errorMessage!
                        }
                        if self.errorSolution != nil {
                            map["ErrorSolution"] = self.errorSolution!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ErrorCode") {
                            self.errorCode = dict["ErrorCode"] as! String
                        }
                        if dict.keys.contains("ErrorMessage") {
                            self.errorMessage = dict["ErrorMessage"] as! String
                        }
                        if dict.keys.contains("ErrorSolution") {
                            self.errorSolution = dict["ErrorSolution"] as! String
                        }
                    }
                }
                public class RegistrationRequestParameters : Tea.TeaModel {
                    public var defaultValue: String?

                    public var exampleValue: String?

                    public var isRequiredParameter: Bool?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public var parameterOperator: Int32?

                    public var parameterPosition: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.isRequiredParameter != nil {
                            map["IsRequiredParameter"] = self.isRequiredParameter!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        if self.parameterOperator != nil {
                            map["ParameterOperator"] = self.parameterOperator!
                        }
                        if self.parameterPosition != nil {
                            map["ParameterPosition"] = self.parameterPosition!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DefaultValue") {
                            self.defaultValue = dict["DefaultValue"] as! String
                        }
                        if dict.keys.contains("ExampleValue") {
                            self.exampleValue = dict["ExampleValue"] as! String
                        }
                        if dict.keys.contains("IsRequiredParameter") {
                            self.isRequiredParameter = dict["IsRequiredParameter"] as! Bool
                        }
                        if dict.keys.contains("ParameterDataType") {
                            self.parameterDataType = dict["ParameterDataType"] as! Int32
                        }
                        if dict.keys.contains("ParameterDescription") {
                            self.parameterDescription = dict["ParameterDescription"] as! String
                        }
                        if dict.keys.contains("ParameterName") {
                            self.parameterName = dict["ParameterName"] as! String
                        }
                        if dict.keys.contains("ParameterOperator") {
                            self.parameterOperator = dict["ParameterOperator"] as! Int32
                        }
                        if dict.keys.contains("ParameterPosition") {
                            self.parameterPosition = dict["ParameterPosition"] as! Int32
                        }
                    }
                }
                public var failedResultSample: String?

                public var registrationErrorCodes: [ListDataServicePublishedApisResponseBody.Data.Apis.RegistrationDetails.RegistrationErrorCodes]?

                public var registrationRequestParameters: [ListDataServicePublishedApisResponseBody.Data.Apis.RegistrationDetails.RegistrationRequestParameters]?

                public var serviceContentType: Int32?

                public var serviceHost: String?

                public var servicePath: String?

                public var serviceRequestBodyDescription: String?

                public var successfulResultSample: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.failedResultSample != nil {
                        map["FailedResultSample"] = self.failedResultSample!
                    }
                    if self.registrationErrorCodes != nil {
                        var tmp : [Any] = []
                        for k in self.registrationErrorCodes! {
                            tmp.append(k.toMap())
                        }
                        map["RegistrationErrorCodes"] = tmp
                    }
                    if self.registrationRequestParameters != nil {
                        var tmp : [Any] = []
                        for k in self.registrationRequestParameters! {
                            tmp.append(k.toMap())
                        }
                        map["RegistrationRequestParameters"] = tmp
                    }
                    if self.serviceContentType != nil {
                        map["ServiceContentType"] = self.serviceContentType!
                    }
                    if self.serviceHost != nil {
                        map["ServiceHost"] = self.serviceHost!
                    }
                    if self.servicePath != nil {
                        map["ServicePath"] = self.servicePath!
                    }
                    if self.serviceRequestBodyDescription != nil {
                        map["ServiceRequestBodyDescription"] = self.serviceRequestBodyDescription!
                    }
                    if self.successfulResultSample != nil {
                        map["SuccessfulResultSample"] = self.successfulResultSample!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FailedResultSample") {
                        self.failedResultSample = dict["FailedResultSample"] as! String
                    }
                    if dict.keys.contains("RegistrationErrorCodes") {
                        var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis.RegistrationDetails.RegistrationErrorCodes] = []
                        for v in dict["RegistrationErrorCodes"] as! [Any] {
                            var model = ListDataServicePublishedApisResponseBody.Data.Apis.RegistrationDetails.RegistrationErrorCodes()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.registrationErrorCodes = tmp
                    }
                    if dict.keys.contains("RegistrationRequestParameters") {
                        var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis.RegistrationDetails.RegistrationRequestParameters] = []
                        for v in dict["RegistrationRequestParameters"] as! [Any] {
                            var model = ListDataServicePublishedApisResponseBody.Data.Apis.RegistrationDetails.RegistrationRequestParameters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.registrationRequestParameters = tmp
                    }
                    if dict.keys.contains("ServiceContentType") {
                        self.serviceContentType = dict["ServiceContentType"] as! Int32
                    }
                    if dict.keys.contains("ServiceHost") {
                        self.serviceHost = dict["ServiceHost"] as! String
                    }
                    if dict.keys.contains("ServicePath") {
                        self.servicePath = dict["ServicePath"] as! String
                    }
                    if dict.keys.contains("ServiceRequestBodyDescription") {
                        self.serviceRequestBodyDescription = dict["ServiceRequestBodyDescription"] as! String
                    }
                    if dict.keys.contains("SuccessfulResultSample") {
                        self.successfulResultSample = dict["SuccessfulResultSample"] as! String
                    }
                }
            }
            public class ScriptDetails : Tea.TeaModel {
                public class ScriptConnection : Tea.TeaModel {
                    public var connectionId: Int64?

                    public var tableName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.connectionId != nil {
                            map["ConnectionId"] = self.connectionId!
                        }
                        if self.tableName != nil {
                            map["TableName"] = self.tableName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ConnectionId") {
                            self.connectionId = dict["ConnectionId"] as! Int64
                        }
                        if dict.keys.contains("TableName") {
                            self.tableName = dict["TableName"] as! String
                        }
                    }
                }
                public class ScriptErrorCodes : Tea.TeaModel {
                    public var errorCode: String?

                    public var errorMessage: String?

                    public var errorSolution: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorMessage != nil {
                            map["ErrorMessage"] = self.errorMessage!
                        }
                        if self.errorSolution != nil {
                            map["ErrorSolution"] = self.errorSolution!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ErrorCode") {
                            self.errorCode = dict["ErrorCode"] as! String
                        }
                        if dict.keys.contains("ErrorMessage") {
                            self.errorMessage = dict["ErrorMessage"] as! String
                        }
                        if dict.keys.contains("ErrorSolution") {
                            self.errorSolution = dict["ErrorSolution"] as! String
                        }
                    }
                }
                public class ScriptRequestParameters : Tea.TeaModel {
                    public var defaultValue: String?

                    public var exampleValue: String?

                    public var isRequiredParameter: Bool?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public var parameterOperator: Int32?

                    public var parameterPosition: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.isRequiredParameter != nil {
                            map["IsRequiredParameter"] = self.isRequiredParameter!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        if self.parameterOperator != nil {
                            map["ParameterOperator"] = self.parameterOperator!
                        }
                        if self.parameterPosition != nil {
                            map["ParameterPosition"] = self.parameterPosition!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DefaultValue") {
                            self.defaultValue = dict["DefaultValue"] as! String
                        }
                        if dict.keys.contains("ExampleValue") {
                            self.exampleValue = dict["ExampleValue"] as! String
                        }
                        if dict.keys.contains("IsRequiredParameter") {
                            self.isRequiredParameter = dict["IsRequiredParameter"] as! Bool
                        }
                        if dict.keys.contains("ParameterDataType") {
                            self.parameterDataType = dict["ParameterDataType"] as! Int32
                        }
                        if dict.keys.contains("ParameterDescription") {
                            self.parameterDescription = dict["ParameterDescription"] as! String
                        }
                        if dict.keys.contains("ParameterName") {
                            self.parameterName = dict["ParameterName"] as! String
                        }
                        if dict.keys.contains("ParameterOperator") {
                            self.parameterOperator = dict["ParameterOperator"] as! Int32
                        }
                        if dict.keys.contains("ParameterPosition") {
                            self.parameterPosition = dict["ParameterPosition"] as! Int32
                        }
                    }
                }
                public class ScriptResponseParameters : Tea.TeaModel {
                    public var exampleValue: String?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExampleValue") {
                            self.exampleValue = dict["ExampleValue"] as! String
                        }
                        if dict.keys.contains("ParameterDataType") {
                            self.parameterDataType = dict["ParameterDataType"] as! Int32
                        }
                        if dict.keys.contains("ParameterDescription") {
                            self.parameterDescription = dict["ParameterDescription"] as! String
                        }
                        if dict.keys.contains("ParameterName") {
                            self.parameterName = dict["ParameterName"] as! String
                        }
                    }
                }
                public var failedResultSample: String?

                public var isPagedResponse: Bool?

                public var script: String?

                public var scriptConnection: ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptConnection?

                public var scriptErrorCodes: [ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptErrorCodes]?

                public var scriptRequestParameters: [ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptRequestParameters]?

                public var scriptResponseParameters: [ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptResponseParameters]?

                public var successfulResultSample: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.scriptConnection?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.failedResultSample != nil {
                        map["FailedResultSample"] = self.failedResultSample!
                    }
                    if self.isPagedResponse != nil {
                        map["IsPagedResponse"] = self.isPagedResponse!
                    }
                    if self.script != nil {
                        map["Script"] = self.script!
                    }
                    if self.scriptConnection != nil {
                        map["ScriptConnection"] = self.scriptConnection?.toMap()
                    }
                    if self.scriptErrorCodes != nil {
                        var tmp : [Any] = []
                        for k in self.scriptErrorCodes! {
                            tmp.append(k.toMap())
                        }
                        map["ScriptErrorCodes"] = tmp
                    }
                    if self.scriptRequestParameters != nil {
                        var tmp : [Any] = []
                        for k in self.scriptRequestParameters! {
                            tmp.append(k.toMap())
                        }
                        map["ScriptRequestParameters"] = tmp
                    }
                    if self.scriptResponseParameters != nil {
                        var tmp : [Any] = []
                        for k in self.scriptResponseParameters! {
                            tmp.append(k.toMap())
                        }
                        map["ScriptResponseParameters"] = tmp
                    }
                    if self.successfulResultSample != nil {
                        map["SuccessfulResultSample"] = self.successfulResultSample!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FailedResultSample") {
                        self.failedResultSample = dict["FailedResultSample"] as! String
                    }
                    if dict.keys.contains("IsPagedResponse") {
                        self.isPagedResponse = dict["IsPagedResponse"] as! Bool
                    }
                    if dict.keys.contains("Script") {
                        self.script = dict["Script"] as! String
                    }
                    if dict.keys.contains("ScriptConnection") {
                        var model = ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptConnection()
                        model.fromMap(dict["ScriptConnection"] as! [String: Any])
                        self.scriptConnection = model
                    }
                    if dict.keys.contains("ScriptErrorCodes") {
                        var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptErrorCodes] = []
                        for v in dict["ScriptErrorCodes"] as! [Any] {
                            var model = ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptErrorCodes()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.scriptErrorCodes = tmp
                    }
                    if dict.keys.contains("ScriptRequestParameters") {
                        var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptRequestParameters] = []
                        for v in dict["ScriptRequestParameters"] as! [Any] {
                            var model = ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptRequestParameters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.scriptRequestParameters = tmp
                    }
                    if dict.keys.contains("ScriptResponseParameters") {
                        var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptResponseParameters] = []
                        for v in dict["ScriptResponseParameters"] as! [Any] {
                            var model = ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptResponseParameters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.scriptResponseParameters = tmp
                    }
                    if dict.keys.contains("SuccessfulResultSample") {
                        self.successfulResultSample = dict["SuccessfulResultSample"] as! String
                    }
                }
            }
            public class WizardDetails : Tea.TeaModel {
                public class WizardConnection : Tea.TeaModel {
                    public var connectionId: Int64?

                    public var tableName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.connectionId != nil {
                            map["ConnectionId"] = self.connectionId!
                        }
                        if self.tableName != nil {
                            map["TableName"] = self.tableName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ConnectionId") {
                            self.connectionId = dict["ConnectionId"] as! Int64
                        }
                        if dict.keys.contains("TableName") {
                            self.tableName = dict["TableName"] as! String
                        }
                    }
                }
                public class WizardErrorCodes : Tea.TeaModel {
                    public var errorCode: String?

                    public var errorMessage: String?

                    public var errorSolution: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorMessage != nil {
                            map["ErrorMessage"] = self.errorMessage!
                        }
                        if self.errorSolution != nil {
                            map["ErrorSolution"] = self.errorSolution!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ErrorCode") {
                            self.errorCode = dict["ErrorCode"] as! String
                        }
                        if dict.keys.contains("ErrorMessage") {
                            self.errorMessage = dict["ErrorMessage"] as! String
                        }
                        if dict.keys.contains("ErrorSolution") {
                            self.errorSolution = dict["ErrorSolution"] as! String
                        }
                    }
                }
                public class WizardRequestParameters : Tea.TeaModel {
                    public var defaultValue: String?

                    public var exampleValue: String?

                    public var isRequiredParameter: Bool?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public var parameterOperator: Int32?

                    public var parameterPosition: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.isRequiredParameter != nil {
                            map["IsRequiredParameter"] = self.isRequiredParameter!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        if self.parameterOperator != nil {
                            map["ParameterOperator"] = self.parameterOperator!
                        }
                        if self.parameterPosition != nil {
                            map["ParameterPosition"] = self.parameterPosition!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DefaultValue") {
                            self.defaultValue = dict["DefaultValue"] as! String
                        }
                        if dict.keys.contains("ExampleValue") {
                            self.exampleValue = dict["ExampleValue"] as! String
                        }
                        if dict.keys.contains("IsRequiredParameter") {
                            self.isRequiredParameter = dict["IsRequiredParameter"] as! Bool
                        }
                        if dict.keys.contains("ParameterDataType") {
                            self.parameterDataType = dict["ParameterDataType"] as! Int32
                        }
                        if dict.keys.contains("ParameterDescription") {
                            self.parameterDescription = dict["ParameterDescription"] as! String
                        }
                        if dict.keys.contains("ParameterName") {
                            self.parameterName = dict["ParameterName"] as! String
                        }
                        if dict.keys.contains("ParameterOperator") {
                            self.parameterOperator = dict["ParameterOperator"] as! Int32
                        }
                        if dict.keys.contains("ParameterPosition") {
                            self.parameterPosition = dict["ParameterPosition"] as! Int32
                        }
                    }
                }
                public class WizardResponseParameters : Tea.TeaModel {
                    public var exampleValue: String?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExampleValue") {
                            self.exampleValue = dict["ExampleValue"] as! String
                        }
                        if dict.keys.contains("ParameterDataType") {
                            self.parameterDataType = dict["ParameterDataType"] as! Int32
                        }
                        if dict.keys.contains("ParameterDescription") {
                            self.parameterDescription = dict["ParameterDescription"] as! String
                        }
                        if dict.keys.contains("ParameterName") {
                            self.parameterName = dict["ParameterName"] as! String
                        }
                    }
                }
                public var failedResultSample: String?

                public var isPagedResponse: Bool?

                public var successfulResultSample: String?

                public var wizardConnection: ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardConnection?

                public var wizardErrorCodes: [ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardErrorCodes]?

                public var wizardRequestParameters: [ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardRequestParameters]?

                public var wizardResponseParameters: [ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardResponseParameters]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.wizardConnection?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.failedResultSample != nil {
                        map["FailedResultSample"] = self.failedResultSample!
                    }
                    if self.isPagedResponse != nil {
                        map["IsPagedResponse"] = self.isPagedResponse!
                    }
                    if self.successfulResultSample != nil {
                        map["SuccessfulResultSample"] = self.successfulResultSample!
                    }
                    if self.wizardConnection != nil {
                        map["WizardConnection"] = self.wizardConnection?.toMap()
                    }
                    if self.wizardErrorCodes != nil {
                        var tmp : [Any] = []
                        for k in self.wizardErrorCodes! {
                            tmp.append(k.toMap())
                        }
                        map["WizardErrorCodes"] = tmp
                    }
                    if self.wizardRequestParameters != nil {
                        var tmp : [Any] = []
                        for k in self.wizardRequestParameters! {
                            tmp.append(k.toMap())
                        }
                        map["WizardRequestParameters"] = tmp
                    }
                    if self.wizardResponseParameters != nil {
                        var tmp : [Any] = []
                        for k in self.wizardResponseParameters! {
                            tmp.append(k.toMap())
                        }
                        map["WizardResponseParameters"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FailedResultSample") {
                        self.failedResultSample = dict["FailedResultSample"] as! String
                    }
                    if dict.keys.contains("IsPagedResponse") {
                        self.isPagedResponse = dict["IsPagedResponse"] as! Bool
                    }
                    if dict.keys.contains("SuccessfulResultSample") {
                        self.successfulResultSample = dict["SuccessfulResultSample"] as! String
                    }
                    if dict.keys.contains("WizardConnection") {
                        var model = ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardConnection()
                        model.fromMap(dict["WizardConnection"] as! [String: Any])
                        self.wizardConnection = model
                    }
                    if dict.keys.contains("WizardErrorCodes") {
                        var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardErrorCodes] = []
                        for v in dict["WizardErrorCodes"] as! [Any] {
                            var model = ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardErrorCodes()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.wizardErrorCodes = tmp
                    }
                    if dict.keys.contains("WizardRequestParameters") {
                        var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardRequestParameters] = []
                        for v in dict["WizardRequestParameters"] as! [Any] {
                            var model = ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardRequestParameters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.wizardRequestParameters = tmp
                    }
                    if dict.keys.contains("WizardResponseParameters") {
                        var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardResponseParameters] = []
                        for v in dict["WizardResponseParameters"] as! [Any] {
                            var model = ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardResponseParameters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.wizardResponseParameters = tmp
                    }
                }
            }
            public var apiId: Int64?

            public var apiMode: Int32?

            public var apiName: String?

            public var apiPath: String?

            public var createdTime: String?

            public var creatorId: String?

            public var description_: String?

            public var groupId: String?

            public var modifiedTime: String?

            public var operatorId: String?

            public var projectId: Int64?

            public var protocols: [Int32]?

            public var registrationDetails: ListDataServicePublishedApisResponseBody.Data.Apis.RegistrationDetails?

            public var requestMethod: Int32?

            public var responseContentType: Int32?

            public var scriptDetails: ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails?

            public var status: Int32?

            public var tenantId: Int64?

            public var timeout: Int32?

            public var visibleRange: Int32?

            public var wizardDetails: ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.registrationDetails?.validate()
                try self.scriptDetails?.validate()
                try self.wizardDetails?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiMode != nil {
                    map["ApiMode"] = self.apiMode!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiPath != nil {
                    map["ApiPath"] = self.apiPath!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.operatorId != nil {
                    map["OperatorId"] = self.operatorId!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.protocols != nil {
                    map["Protocols"] = self.protocols!
                }
                if self.registrationDetails != nil {
                    map["RegistrationDetails"] = self.registrationDetails?.toMap()
                }
                if self.requestMethod != nil {
                    map["RequestMethod"] = self.requestMethod!
                }
                if self.responseContentType != nil {
                    map["ResponseContentType"] = self.responseContentType!
                }
                if self.scriptDetails != nil {
                    map["ScriptDetails"] = self.scriptDetails?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.visibleRange != nil {
                    map["VisibleRange"] = self.visibleRange!
                }
                if self.wizardDetails != nil {
                    map["WizardDetails"] = self.wizardDetails?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! Int64
                }
                if dict.keys.contains("ApiMode") {
                    self.apiMode = dict["ApiMode"] as! Int32
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiPath") {
                    self.apiPath = dict["ApiPath"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("CreatorId") {
                    self.creatorId = dict["CreatorId"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("OperatorId") {
                    self.operatorId = dict["OperatorId"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("Protocols") {
                    self.protocols = dict["Protocols"] as! [Int32]
                }
                if dict.keys.contains("RegistrationDetails") {
                    var model = ListDataServicePublishedApisResponseBody.Data.Apis.RegistrationDetails()
                    model.fromMap(dict["RegistrationDetails"] as! [String: Any])
                    self.registrationDetails = model
                }
                if dict.keys.contains("RequestMethod") {
                    self.requestMethod = dict["RequestMethod"] as! Int32
                }
                if dict.keys.contains("ResponseContentType") {
                    self.responseContentType = dict["ResponseContentType"] as! Int32
                }
                if dict.keys.contains("ScriptDetails") {
                    var model = ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails()
                    model.fromMap(dict["ScriptDetails"] as! [String: Any])
                    self.scriptDetails = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int32
                }
                if dict.keys.contains("VisibleRange") {
                    self.visibleRange = dict["VisibleRange"] as! Int32
                }
                if dict.keys.contains("WizardDetails") {
                    var model = ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails()
                    model.fromMap(dict["WizardDetails"] as! [String: Any])
                    self.wizardDetails = model
                }
            }
        }
        public var apis: [ListDataServicePublishedApisResponseBody.Data.Apis]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apis != nil {
                var tmp : [Any] = []
                for k in self.apis! {
                    tmp.append(k.toMap())
                }
                map["Apis"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Apis") {
                var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis] = []
                for v in dict["Apis"] as! [Any] {
                    var model = ListDataServicePublishedApisResponseBody.Data.Apis()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apis = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListDataServicePublishedApisResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListDataServicePublishedApisResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataServicePublishedApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataServicePublishedApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataServicePublishedApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataSourcesRequest : Tea.TeaModel {
    public var dataSourceType: String?

    public var envType: Int32?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var status: String?

    public var subType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.subType != nil {
            map["SubType"] = self.subType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SubType") {
            self.subType = dict["SubType"] as! String
        }
    }
}

public class ListDataSourcesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataSources : Tea.TeaModel {
            public var bindingCalcEngineId: Int64?

            public var connectStatus: Int32?

            public var content: String?

            public var dataSourceType: String?

            public var defaultEngine: Bool?

            public var description_: String?

            public var envType: Int32?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var name: String?

            public var operator_: String?

            public var projectId: Int32?

            public var sequence: Int32?

            public var shared: Bool?

            public var status: Int32?

            public var subType: String?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindingCalcEngineId != nil {
                    map["BindingCalcEngineId"] = self.bindingCalcEngineId!
                }
                if self.connectStatus != nil {
                    map["ConnectStatus"] = self.connectStatus!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.dataSourceType != nil {
                    map["DataSourceType"] = self.dataSourceType!
                }
                if self.defaultEngine != nil {
                    map["DefaultEngine"] = self.defaultEngine!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.sequence != nil {
                    map["Sequence"] = self.sequence!
                }
                if self.shared != nil {
                    map["Shared"] = self.shared!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.subType != nil {
                    map["SubType"] = self.subType!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BindingCalcEngineId") {
                    self.bindingCalcEngineId = dict["BindingCalcEngineId"] as! Int64
                }
                if dict.keys.contains("ConnectStatus") {
                    self.connectStatus = dict["ConnectStatus"] as! Int32
                }
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("DataSourceType") {
                    self.dataSourceType = dict["DataSourceType"] as! String
                }
                if dict.keys.contains("DefaultEngine") {
                    self.defaultEngine = dict["DefaultEngine"] as! Bool
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! Int32
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Operator") {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int32
                }
                if dict.keys.contains("Sequence") {
                    self.sequence = dict["Sequence"] as! Int32
                }
                if dict.keys.contains("Shared") {
                    self.shared = dict["Shared"] as! Bool
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("SubType") {
                    self.subType = dict["SubType"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
            }
        }
        public var dataSources: [ListDataSourcesResponseBody.Data.DataSources]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSources != nil {
                var tmp : [Any] = []
                for k in self.dataSources! {
                    tmp.append(k.toMap())
                }
                map["DataSources"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataSources") {
                var tmp : [ListDataSourcesResponseBody.Data.DataSources] = []
                for v in dict["DataSources"] as! [Any] {
                    var model = ListDataSourcesResponseBody.Data.DataSources()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataSources = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListDataSourcesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListDataSourcesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataSourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataSourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataSourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDeploymentsRequest : Tea.TeaModel {
    public var creator: String?

    public var endCreateTime: Int64?

    public var endExecuteTime: Int64?

    public var executor: String?

    public var keyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        if self.endCreateTime != nil {
            map["EndCreateTime"] = self.endCreateTime!
        }
        if self.endExecuteTime != nil {
            map["EndExecuteTime"] = self.endExecuteTime!
        }
        if self.executor != nil {
            map["Executor"] = self.executor!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Creator") {
            self.creator = dict["Creator"] as! String
        }
        if dict.keys.contains("EndCreateTime") {
            self.endCreateTime = dict["EndCreateTime"] as! Int64
        }
        if dict.keys.contains("EndExecuteTime") {
            self.endExecuteTime = dict["EndExecuteTime"] as! Int64
        }
        if dict.keys.contains("Executor") {
            self.executor = dict["Executor"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class ListDeploymentsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Deployments : Tea.TeaModel {
            public var createTime: Int64?

            public var creator: String?

            public var errorMessage: String?

            public var executeTime: Int64?

            public var executor: String?

            public var id: Int64?

            public var name: String?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.executeTime != nil {
                    map["ExecuteTime"] = self.executeTime!
                }
                if self.executor != nil {
                    map["Executor"] = self.executor!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Creator") {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("ExecuteTime") {
                    self.executeTime = dict["ExecuteTime"] as! Int64
                }
                if dict.keys.contains("Executor") {
                    self.executor = dict["Executor"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var deployments: [ListDeploymentsResponseBody.Data.Deployments]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deployments != nil {
                var tmp : [Any] = []
                for k in self.deployments! {
                    tmp.append(k.toMap())
                }
                map["Deployments"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Deployments") {
                var tmp : [ListDeploymentsResponseBody.Data.Deployments] = []
                for v in dict["Deployments"] as! [Any] {
                    var model = ListDeploymentsResponseBody.Data.Deployments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deployments = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: ListDeploymentsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListDeploymentsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDeploymentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDeploymentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDeploymentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEnabledExtensionsForProjectRequest : Tea.TeaModel {
    public var eventCode: String?

    public var fileType: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventCode != nil {
            map["EventCode"] = self.eventCode!
        }
        if self.fileType != nil {
            map["FileType"] = self.fileType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventCode") {
            self.eventCode = dict["EventCode"] as! String
        }
        if dict.keys.contains("FileType") {
            self.fileType = dict["FileType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class ListEnabledExtensionsForProjectResponseBody : Tea.TeaModel {
    public class Extensions : Tea.TeaModel {
        public var createUser: String?

        public var extensionCode: String?

        public var extensionDesc: String?

        public var extensionName: String?

        public var modifyUser: String?

        public var owner: String?

        public var parameterSetting: String?

        public var tenantId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.extensionCode != nil {
                map["ExtensionCode"] = self.extensionCode!
            }
            if self.extensionDesc != nil {
                map["ExtensionDesc"] = self.extensionDesc!
            }
            if self.extensionName != nil {
                map["ExtensionName"] = self.extensionName!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.parameterSetting != nil {
                map["ParameterSetting"] = self.parameterSetting!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateUser") {
                self.createUser = dict["CreateUser"] as! String
            }
            if dict.keys.contains("ExtensionCode") {
                self.extensionCode = dict["ExtensionCode"] as! String
            }
            if dict.keys.contains("ExtensionDesc") {
                self.extensionDesc = dict["ExtensionDesc"] as! String
            }
            if dict.keys.contains("ExtensionName") {
                self.extensionName = dict["ExtensionName"] as! String
            }
            if dict.keys.contains("ModifyUser") {
                self.modifyUser = dict["ModifyUser"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("ParameterSetting") {
                self.parameterSetting = dict["ParameterSetting"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
        }
    }
    public var extensions: [ListEnabledExtensionsForProjectResponseBody.Extensions]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extensions != nil {
            var tmp : [Any] = []
            for k in self.extensions! {
                tmp.append(k.toMap())
            }
            map["Extensions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Extensions") {
            var tmp : [ListEnabledExtensionsForProjectResponseBody.Extensions] = []
            for v in dict["Extensions"] as! [Any] {
                var model = ListEnabledExtensionsForProjectResponseBody.Extensions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.extensions = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListEnabledExtensionsForProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEnabledExtensionsForProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEnabledExtensionsForProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEntitiesByTagsRequest : Tea.TeaModel {
    public var entityType: String?

    public var nextToken: String?

    public var pageSize: Int32?

    public var tags: [UserEntityTag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityType != nil {
            map["EntityType"] = self.entityType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityType") {
            self.entityType = dict["EntityType"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Tags") {
            var tmp : [UserEntityTag] = []
            for v in dict["Tags"] as! [Any] {
                var model = UserEntityTag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListEntitiesByTagsShrinkRequest : Tea.TeaModel {
    public var entityType: String?

    public var nextToken: String?

    public var pageSize: Int32?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityType != nil {
            map["EntityType"] = self.entityType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityType") {
            self.entityType = dict["EntityType"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Tags") {
            self.tagsShrink = dict["Tags"] as! String
        }
    }
}

public class ListEntitiesByTagsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var entityList: [Entity]?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.entityList != nil {
                var tmp : [Any] = []
                for k in self.entityList! {
                    tmp.append(k.toMap())
                }
                map["EntityList"] = tmp
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EntityList") {
                var tmp : [Entity] = []
                for v in dict["EntityList"] as! [Any] {
                    var model = Entity()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.entityList = tmp
            }
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
        }
    }
    public var data: ListEntitiesByTagsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListEntitiesByTagsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListEntitiesByTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEntitiesByTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEntitiesByTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEntityTagsRequest : Tea.TeaModel {
    public var qualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QualifiedName") {
            self.qualifiedName = dict["QualifiedName"] as! String
        }
    }
}

public class ListEntityTagsResponseBody : Tea.TeaModel {
    public var data: [UserEntityTag]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [UserEntityTag] = []
            for v in dict["Data"] as! [Any] {
                var model = UserEntityTag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListEntityTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEntityTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEntityTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListExtensionsRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListExtensionsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Extensions : Tea.TeaModel {
            public class BindEventList : Tea.TeaModel {
                public var eventCode: String?

                public var eventName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.eventCode != nil {
                        map["EventCode"] = self.eventCode!
                    }
                    if self.eventName != nil {
                        map["EventName"] = self.eventName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EventCode") {
                        self.eventCode = dict["EventCode"] as! String
                    }
                    if dict.keys.contains("EventName") {
                        self.eventName = dict["EventName"] as! String
                    }
                }
            }
            public var bindEventList: [ListExtensionsResponseBody.PagingInfo.Extensions.BindEventList]?

            public var extensionCode: String?

            public var extensionDesc: String?

            public var extensionName: String?

            public var owner: String?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindEventList != nil {
                    var tmp : [Any] = []
                    for k in self.bindEventList! {
                        tmp.append(k.toMap())
                    }
                    map["BindEventList"] = tmp
                }
                if self.extensionCode != nil {
                    map["ExtensionCode"] = self.extensionCode!
                }
                if self.extensionDesc != nil {
                    map["ExtensionDesc"] = self.extensionDesc!
                }
                if self.extensionName != nil {
                    map["ExtensionName"] = self.extensionName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BindEventList") {
                    var tmp : [ListExtensionsResponseBody.PagingInfo.Extensions.BindEventList] = []
                    for v in dict["BindEventList"] as! [Any] {
                        var model = ListExtensionsResponseBody.PagingInfo.Extensions.BindEventList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.bindEventList = tmp
                }
                if dict.keys.contains("ExtensionCode") {
                    self.extensionCode = dict["ExtensionCode"] as! String
                }
                if dict.keys.contains("ExtensionDesc") {
                    self.extensionDesc = dict["ExtensionDesc"] as! String
                }
                if dict.keys.contains("ExtensionName") {
                    self.extensionName = dict["ExtensionName"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var extensions: [ListExtensionsResponseBody.PagingInfo.Extensions]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extensions != nil {
                var tmp : [Any] = []
                for k in self.extensions! {
                    tmp.append(k.toMap())
                }
                map["Extensions"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extensions") {
                var tmp : [ListExtensionsResponseBody.PagingInfo.Extensions] = []
                for v in dict["Extensions"] as! [Any] {
                    var model = ListExtensionsResponseBody.PagingInfo.Extensions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.extensions = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListExtensionsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListExtensionsResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListExtensionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListExtensionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListExtensionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFileTypeRequest : Tea.TeaModel {
    public var keyword: String?

    public var locale: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.locale != nil {
            map["Locale"] = self.locale!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Locale") {
            self.locale = dict["Locale"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class ListFileTypeResponseBody : Tea.TeaModel {
    public class NodeTypeInfoList : Tea.TeaModel {
        public class NodeTypeInfo : Tea.TeaModel {
            public var nodeType: Int32?

            public var nodeTypeName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nodeType != nil {
                    map["NodeType"] = self.nodeType!
                }
                if self.nodeTypeName != nil {
                    map["NodeTypeName"] = self.nodeTypeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NodeType") {
                    self.nodeType = dict["NodeType"] as! Int32
                }
                if dict.keys.contains("NodeTypeName") {
                    self.nodeTypeName = dict["NodeTypeName"] as! String
                }
            }
        }
        public var nodeTypeInfo: [ListFileTypeResponseBody.NodeTypeInfoList.NodeTypeInfo]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeTypeInfo != nil {
                var tmp : [Any] = []
                for k in self.nodeTypeInfo! {
                    tmp.append(k.toMap())
                }
                map["NodeTypeInfo"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeTypeInfo") {
                var tmp : [ListFileTypeResponseBody.NodeTypeInfoList.NodeTypeInfo] = []
                for v in dict["NodeTypeInfo"] as! [Any] {
                    var model = ListFileTypeResponseBody.NodeTypeInfoList.NodeTypeInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeTypeInfo = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var nodeTypeInfoList: ListFileTypeResponseBody.NodeTypeInfoList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeTypeInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeTypeInfoList != nil {
            map["NodeTypeInfoList"] = self.nodeTypeInfoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeTypeInfoList") {
            var model = ListFileTypeResponseBody.NodeTypeInfoList()
            model.fromMap(dict["NodeTypeInfoList"] as! [String: Any])
            self.nodeTypeInfoList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListFileTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFileTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListFileTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFileVersionsRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class ListFileVersionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class FileVersions : Tea.TeaModel {
            public var changeType: String?

            public var comment: String?

            public var commitTime: Int64?

            public var commitUser: String?

            public var fileContent: String?

            public var fileName: String?

            public var filePropertyContent: String?

            public var fileVersion: Int32?

            public var isCurrentProd: Bool?

            public var nodeContent: String?

            public var nodeId: Int64?

            public var status: String?

            public var useType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.changeType != nil {
                    map["ChangeType"] = self.changeType!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.commitTime != nil {
                    map["CommitTime"] = self.commitTime!
                }
                if self.commitUser != nil {
                    map["CommitUser"] = self.commitUser!
                }
                if self.fileContent != nil {
                    map["FileContent"] = self.fileContent!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.filePropertyContent != nil {
                    map["FilePropertyContent"] = self.filePropertyContent!
                }
                if self.fileVersion != nil {
                    map["FileVersion"] = self.fileVersion!
                }
                if self.isCurrentProd != nil {
                    map["IsCurrentProd"] = self.isCurrentProd!
                }
                if self.nodeContent != nil {
                    map["NodeContent"] = self.nodeContent!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.useType != nil {
                    map["UseType"] = self.useType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChangeType") {
                    self.changeType = dict["ChangeType"] as! String
                }
                if dict.keys.contains("Comment") {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("CommitTime") {
                    self.commitTime = dict["CommitTime"] as! Int64
                }
                if dict.keys.contains("CommitUser") {
                    self.commitUser = dict["CommitUser"] as! String
                }
                if dict.keys.contains("FileContent") {
                    self.fileContent = dict["FileContent"] as! String
                }
                if dict.keys.contains("FileName") {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("FilePropertyContent") {
                    self.filePropertyContent = dict["FilePropertyContent"] as! String
                }
                if dict.keys.contains("FileVersion") {
                    self.fileVersion = dict["FileVersion"] as! Int32
                }
                if dict.keys.contains("IsCurrentProd") {
                    self.isCurrentProd = dict["IsCurrentProd"] as! Bool
                }
                if dict.keys.contains("NodeContent") {
                    self.nodeContent = dict["NodeContent"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UseType") {
                    self.useType = dict["UseType"] as! String
                }
            }
        }
        public var fileVersions: [ListFileVersionsResponseBody.Data.FileVersions]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileVersions != nil {
                var tmp : [Any] = []
                for k in self.fileVersions! {
                    tmp.append(k.toMap())
                }
                map["FileVersions"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileVersions") {
                var tmp : [ListFileVersionsResponseBody.Data.FileVersions] = []
                for v in dict["FileVersions"] as! [Any] {
                    var model = ListFileVersionsResponseBody.Data.FileVersions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileVersions = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListFileVersionsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListFileVersionsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListFileVersionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFileVersionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListFileVersionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFilesRequest : Tea.TeaModel {
    public var commitStatus: Int32?

    public var exactFileName: String?

    public var fileFolderPath: String?

    public var fileIdIn: String?

    public var fileTypes: String?

    public var keyword: String?

    public var lastEditUser: String?

    public var needAbsoluteFolderPath: Bool?

    public var needContent: Bool?

    public var nodeId: Int64?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var useType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commitStatus != nil {
            map["CommitStatus"] = self.commitStatus!
        }
        if self.exactFileName != nil {
            map["ExactFileName"] = self.exactFileName!
        }
        if self.fileFolderPath != nil {
            map["FileFolderPath"] = self.fileFolderPath!
        }
        if self.fileIdIn != nil {
            map["FileIdIn"] = self.fileIdIn!
        }
        if self.fileTypes != nil {
            map["FileTypes"] = self.fileTypes!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lastEditUser != nil {
            map["LastEditUser"] = self.lastEditUser!
        }
        if self.needAbsoluteFolderPath != nil {
            map["NeedAbsoluteFolderPath"] = self.needAbsoluteFolderPath!
        }
        if self.needContent != nil {
            map["NeedContent"] = self.needContent!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.useType != nil {
            map["UseType"] = self.useType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommitStatus") {
            self.commitStatus = dict["CommitStatus"] as! Int32
        }
        if dict.keys.contains("ExactFileName") {
            self.exactFileName = dict["ExactFileName"] as! String
        }
        if dict.keys.contains("FileFolderPath") {
            self.fileFolderPath = dict["FileFolderPath"] as! String
        }
        if dict.keys.contains("FileIdIn") {
            self.fileIdIn = dict["FileIdIn"] as! String
        }
        if dict.keys.contains("FileTypes") {
            self.fileTypes = dict["FileTypes"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("LastEditUser") {
            self.lastEditUser = dict["LastEditUser"] as! String
        }
        if dict.keys.contains("NeedAbsoluteFolderPath") {
            self.needAbsoluteFolderPath = dict["NeedAbsoluteFolderPath"] as! Bool
        }
        if dict.keys.contains("NeedContent") {
            self.needContent = dict["NeedContent"] as! Bool
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
        if dict.keys.contains("UseType") {
            self.useType = dict["UseType"] as! String
        }
    }
}

public class ListFilesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Files : Tea.TeaModel {
            public var absoluteFolderPath: String?

            public var autoParsing: Bool?

            public var bizId: Int64?

            public var businessId: Int64?

            public var commitStatus: Int32?

            public var connectionName: String?

            public var content: String?

            public var createTime: Int64?

            public var createUser: String?

            public var currentVersion: Int32?

            public var fileDescription: String?

            public var fileFolderId: String?

            public var fileId: Int64?

            public var fileName: String?

            public var fileType: Int32?

            public var isMaxCompute: Bool?

            public var lastEditTime: Int64?

            public var lastEditUser: String?

            public var nodeId: Int64?

            public var owner: String?

            public var parentId: Int64?

            public var useType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.absoluteFolderPath != nil {
                    map["AbsoluteFolderPath"] = self.absoluteFolderPath!
                }
                if self.autoParsing != nil {
                    map["AutoParsing"] = self.autoParsing!
                }
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.businessId != nil {
                    map["BusinessId"] = self.businessId!
                }
                if self.commitStatus != nil {
                    map["CommitStatus"] = self.commitStatus!
                }
                if self.connectionName != nil {
                    map["ConnectionName"] = self.connectionName!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.currentVersion != nil {
                    map["CurrentVersion"] = self.currentVersion!
                }
                if self.fileDescription != nil {
                    map["FileDescription"] = self.fileDescription!
                }
                if self.fileFolderId != nil {
                    map["FileFolderId"] = self.fileFolderId!
                }
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.fileType != nil {
                    map["FileType"] = self.fileType!
                }
                if self.isMaxCompute != nil {
                    map["IsMaxCompute"] = self.isMaxCompute!
                }
                if self.lastEditTime != nil {
                    map["LastEditTime"] = self.lastEditTime!
                }
                if self.lastEditUser != nil {
                    map["LastEditUser"] = self.lastEditUser!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.useType != nil {
                    map["UseType"] = self.useType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbsoluteFolderPath") {
                    self.absoluteFolderPath = dict["AbsoluteFolderPath"] as! String
                }
                if dict.keys.contains("AutoParsing") {
                    self.autoParsing = dict["AutoParsing"] as! Bool
                }
                if dict.keys.contains("BizId") {
                    self.bizId = dict["BizId"] as! Int64
                }
                if dict.keys.contains("BusinessId") {
                    self.businessId = dict["BusinessId"] as! Int64
                }
                if dict.keys.contains("CommitStatus") {
                    self.commitStatus = dict["CommitStatus"] as! Int32
                }
                if dict.keys.contains("ConnectionName") {
                    self.connectionName = dict["ConnectionName"] as! String
                }
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CreateUser") {
                    self.createUser = dict["CreateUser"] as! String
                }
                if dict.keys.contains("CurrentVersion") {
                    self.currentVersion = dict["CurrentVersion"] as! Int32
                }
                if dict.keys.contains("FileDescription") {
                    self.fileDescription = dict["FileDescription"] as! String
                }
                if dict.keys.contains("FileFolderId") {
                    self.fileFolderId = dict["FileFolderId"] as! String
                }
                if dict.keys.contains("FileId") {
                    self.fileId = dict["FileId"] as! Int64
                }
                if dict.keys.contains("FileName") {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("FileType") {
                    self.fileType = dict["FileType"] as! Int32
                }
                if dict.keys.contains("IsMaxCompute") {
                    self.isMaxCompute = dict["IsMaxCompute"] as! Bool
                }
                if dict.keys.contains("LastEditTime") {
                    self.lastEditTime = dict["LastEditTime"] as! Int64
                }
                if dict.keys.contains("LastEditUser") {
                    self.lastEditUser = dict["LastEditUser"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("ParentId") {
                    self.parentId = dict["ParentId"] as! Int64
                }
                if dict.keys.contains("UseType") {
                    self.useType = dict["UseType"] as! String
                }
            }
        }
        public var files: [ListFilesResponseBody.Data.Files]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.files != nil {
                var tmp : [Any] = []
                for k in self.files! {
                    tmp.append(k.toMap())
                }
                map["Files"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Files") {
                var tmp : [ListFilesResponseBody.Data.Files] = []
                for v in dict["Files"] as! [Any] {
                    var model = ListFilesResponseBody.Data.Files()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.files = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListFilesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListFilesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFoldersRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var parentFolderPath: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentFolderPath != nil {
            map["ParentFolderPath"] = self.parentFolderPath!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ParentFolderPath") {
            self.parentFolderPath = dict["ParentFolderPath"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class ListFoldersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Folders : Tea.TeaModel {
            public var folderId: String?

            public var folderPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.folderId != nil {
                    map["FolderId"] = self.folderId!
                }
                if self.folderPath != nil {
                    map["FolderPath"] = self.folderPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FolderId") {
                    self.folderId = dict["FolderId"] as! String
                }
                if dict.keys.contains("FolderPath") {
                    self.folderPath = dict["FolderPath"] as! String
                }
            }
        }
        public var folders: [ListFoldersResponseBody.Data.Folders]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.folders != nil {
                var tmp : [Any] = []
                for k in self.folders! {
                    tmp.append(k.toMap())
                }
                map["Folders"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Folders") {
                var tmp : [ListFoldersResponseBody.Data.Folders] = []
                for v in dict["Folders"] as! [Any] {
                    var model = ListFoldersResponseBody.Data.Folders()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.folders = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListFoldersResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListFoldersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListFoldersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFoldersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListFoldersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInnerNodesRequest : Tea.TeaModel {
    public var nodeName: String?

    public var outerNodeId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var programType: String?

    public var projectEnv: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.outerNodeId != nil {
            map["OuterNodeId"] = self.outerNodeId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.programType != nil {
            map["ProgramType"] = self.programType!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeName") {
            self.nodeName = dict["NodeName"] as! String
        }
        if dict.keys.contains("OuterNodeId") {
            self.outerNodeId = dict["OuterNodeId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProgramType") {
            self.programType = dict["ProgramType"] as! String
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class ListInnerNodesResponseBody : Tea.TeaModel {
    public class Paging : Tea.TeaModel {
        public class Nodes : Tea.TeaModel {
            public var baselineId: Int64?

            public var businessId: Int64?

            public var connection: String?

            public var cronExpress: String?

            public var description_: String?

            public var dqcDescription: String?

            public var dqcType: String?

            public var nodeId: Int64?

            public var nodeName: String?

            public var ownerId: String?

            public var paramValues: String?

            public var priority: Int32?

            public var programType: String?

            public var projectId: Int64?

            public var repeatInterval: Int64?

            public var repeatability: Bool?

            public var resGroupName: String?

            public var schedulerType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.businessId != nil {
                    map["BusinessId"] = self.businessId!
                }
                if self.connection != nil {
                    map["Connection"] = self.connection!
                }
                if self.cronExpress != nil {
                    map["CronExpress"] = self.cronExpress!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.dqcDescription != nil {
                    map["DqcDescription"] = self.dqcDescription!
                }
                if self.dqcType != nil {
                    map["DqcType"] = self.dqcType!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.paramValues != nil {
                    map["ParamValues"] = self.paramValues!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.programType != nil {
                    map["ProgramType"] = self.programType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.repeatInterval != nil {
                    map["RepeatInterval"] = self.repeatInterval!
                }
                if self.repeatability != nil {
                    map["Repeatability"] = self.repeatability!
                }
                if self.resGroupName != nil {
                    map["ResGroupName"] = self.resGroupName!
                }
                if self.schedulerType != nil {
                    map["SchedulerType"] = self.schedulerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("BusinessId") {
                    self.businessId = dict["BusinessId"] as! Int64
                }
                if dict.keys.contains("Connection") {
                    self.connection = dict["Connection"] as! String
                }
                if dict.keys.contains("CronExpress") {
                    self.cronExpress = dict["CronExpress"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DqcDescription") {
                    self.dqcDescription = dict["DqcDescription"] as! String
                }
                if dict.keys.contains("DqcType") {
                    self.dqcType = dict["DqcType"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("OwnerId") {
                    self.ownerId = dict["OwnerId"] as! String
                }
                if dict.keys.contains("ParamValues") {
                    self.paramValues = dict["ParamValues"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ProgramType") {
                    self.programType = dict["ProgramType"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("RepeatInterval") {
                    self.repeatInterval = dict["RepeatInterval"] as! Int64
                }
                if dict.keys.contains("Repeatability") {
                    self.repeatability = dict["Repeatability"] as! Bool
                }
                if dict.keys.contains("ResGroupName") {
                    self.resGroupName = dict["ResGroupName"] as! String
                }
                if dict.keys.contains("SchedulerType") {
                    self.schedulerType = dict["SchedulerType"] as! String
                }
            }
        }
        public var nodes: [ListInnerNodesResponseBody.Paging.Nodes]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Nodes") {
                var tmp : [ListInnerNodesResponseBody.Paging.Nodes] = []
                for v in dict["Nodes"] as! [Any] {
                    var model = ListInnerNodesResponseBody.Paging.Nodes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodes = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var paging: ListInnerNodesResponseBody.Paging?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.paging?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.paging != nil {
            map["Paging"] = self.paging?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Paging") {
            var model = ListInnerNodesResponseBody.Paging()
            model.fromMap(dict["Paging"] as! [String: Any])
            self.paging = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListInnerNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInnerNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInnerNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstanceAmountRequest : Tea.TeaModel {
    public var beginDate: String?

    public var endDate: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginDate != nil {
            map["BeginDate"] = self.beginDate!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginDate") {
            self.beginDate = dict["BeginDate"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class ListInstanceAmountResponseBody : Tea.TeaModel {
    public class InstanceCounts : Tea.TeaModel {
        public var count: Int32?

        public var date: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.date != nil {
                map["Date"] = self.date!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("Date") {
                self.date = dict["Date"] as! Int64
            }
        }
    }
    public var instanceCounts: [ListInstanceAmountResponseBody.InstanceCounts]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceCounts != nil {
            var tmp : [Any] = []
            for k in self.instanceCounts! {
                tmp.append(k.toMap())
            }
            map["InstanceCounts"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceCounts") {
            var tmp : [ListInstanceAmountResponseBody.InstanceCounts] = []
            for v in dict["InstanceCounts"] as! [Any] {
                var model = ListInstanceAmountResponseBody.InstanceCounts()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceCounts = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListInstanceAmountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceAmountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstanceAmountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstanceHistoryRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class ListInstanceHistoryResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public var beginRunningTime: Int64?

        public var beginWaitResTime: Int64?

        public var beginWaitTimeTime: Int64?

        public var bizdate: Int64?

        public var createTime: Int64?

        public var cycTime: Int64?

        public var dagId: Int64?

        public var dagType: String?

        public var errorMessage: String?

        public var finishTime: Int64?

        public var instanceHistoryId: Int64?

        public var instanceId: Int64?

        public var modifyTime: Int64?

        public var nodeId: Int64?

        public var nodeName: String?

        public var status: String?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.beginRunningTime != nil {
                map["BeginRunningTime"] = self.beginRunningTime!
            }
            if self.beginWaitResTime != nil {
                map["BeginWaitResTime"] = self.beginWaitResTime!
            }
            if self.beginWaitTimeTime != nil {
                map["BeginWaitTimeTime"] = self.beginWaitTimeTime!
            }
            if self.bizdate != nil {
                map["Bizdate"] = self.bizdate!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.cycTime != nil {
                map["CycTime"] = self.cycTime!
            }
            if self.dagId != nil {
                map["DagId"] = self.dagId!
            }
            if self.dagType != nil {
                map["DagType"] = self.dagType!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.instanceHistoryId != nil {
                map["InstanceHistoryId"] = self.instanceHistoryId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BeginRunningTime") {
                self.beginRunningTime = dict["BeginRunningTime"] as! Int64
            }
            if dict.keys.contains("BeginWaitResTime") {
                self.beginWaitResTime = dict["BeginWaitResTime"] as! Int64
            }
            if dict.keys.contains("BeginWaitTimeTime") {
                self.beginWaitTimeTime = dict["BeginWaitTimeTime"] as! Int64
            }
            if dict.keys.contains("Bizdate") {
                self.bizdate = dict["Bizdate"] as! Int64
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CycTime") {
                self.cycTime = dict["CycTime"] as! Int64
            }
            if dict.keys.contains("DagId") {
                self.dagId = dict["DagId"] as! Int64
            }
            if dict.keys.contains("DagType") {
                self.dagType = dict["DagType"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! Int64
            }
            if dict.keys.contains("InstanceHistoryId") {
                self.instanceHistoryId = dict["InstanceHistoryId"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! Int64
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskType") {
                self.taskType = dict["TaskType"] as! String
            }
        }
    }
    public var instances: [ListInstanceHistoryResponseBody.Instances]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            var tmp : [ListInstanceHistoryResponseBody.Instances] = []
            for v in dict["Instances"] as! [Any] {
                var model = ListInstanceHistoryResponseBody.Instances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instances = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListInstanceHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstanceHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstancesRequest : Tea.TeaModel {
    public var beginBizdate: String?

    public var bizName: String?

    public var bizdate: String?

    public var dagId: Int64?

    public var endBizdate: String?

    public var nodeId: Int64?

    public var nodeName: String?

    public var orderBy: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var programType: String?

    public var projectEnv: String?

    public var projectId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginBizdate != nil {
            map["BeginBizdate"] = self.beginBizdate!
        }
        if self.bizName != nil {
            map["BizName"] = self.bizName!
        }
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.endBizdate != nil {
            map["EndBizdate"] = self.endBizdate!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.programType != nil {
            map["ProgramType"] = self.programType!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginBizdate") {
            self.beginBizdate = dict["BeginBizdate"] as! String
        }
        if dict.keys.contains("BizName") {
            self.bizName = dict["BizName"] as! String
        }
        if dict.keys.contains("Bizdate") {
            self.bizdate = dict["Bizdate"] as! String
        }
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("EndBizdate") {
            self.endBizdate = dict["EndBizdate"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("NodeName") {
            self.nodeName = dict["NodeName"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProgramType") {
            self.programType = dict["ProgramType"] as! String
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Instances : Tea.TeaModel {
            public var baselineId: Int64?

            public var beginRunningTime: Int64?

            public var beginWaitResTime: Int64?

            public var beginWaitTimeTime: Int64?

            public var bizdate: Int64?

            public var businessId: Int64?

            public var connection: String?

            public var createTime: Int64?

            public var createUser: String?

            public var cycTime: Int64?

            public var dagId: Int64?

            public var dagType: String?

            public var dqcDescription: String?

            public var dqcType: Int32?

            public var errorMessage: String?

            public var finishTime: Int64?

            public var instanceId: Int64?

            public var modifyTime: Int64?

            public var nodeId: Int64?

            public var nodeName: String?

            public var paramValues: String?

            public var priority: Int32?

            public var relatedFlowId: Int64?

            public var repeatInterval: Int64?

            public var repeatability: Bool?

            public var status: String?

            public var taskRerunTime: Int32?

            public var taskType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.beginRunningTime != nil {
                    map["BeginRunningTime"] = self.beginRunningTime!
                }
                if self.beginWaitResTime != nil {
                    map["BeginWaitResTime"] = self.beginWaitResTime!
                }
                if self.beginWaitTimeTime != nil {
                    map["BeginWaitTimeTime"] = self.beginWaitTimeTime!
                }
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.businessId != nil {
                    map["BusinessId"] = self.businessId!
                }
                if self.connection != nil {
                    map["Connection"] = self.connection!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.cycTime != nil {
                    map["CycTime"] = self.cycTime!
                }
                if self.dagId != nil {
                    map["DagId"] = self.dagId!
                }
                if self.dagType != nil {
                    map["DagType"] = self.dagType!
                }
                if self.dqcDescription != nil {
                    map["DqcDescription"] = self.dqcDescription!
                }
                if self.dqcType != nil {
                    map["DqcType"] = self.dqcType!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.paramValues != nil {
                    map["ParamValues"] = self.paramValues!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.relatedFlowId != nil {
                    map["RelatedFlowId"] = self.relatedFlowId!
                }
                if self.repeatInterval != nil {
                    map["RepeatInterval"] = self.repeatInterval!
                }
                if self.repeatability != nil {
                    map["Repeatability"] = self.repeatability!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskRerunTime != nil {
                    map["TaskRerunTime"] = self.taskRerunTime!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("BeginRunningTime") {
                    self.beginRunningTime = dict["BeginRunningTime"] as! Int64
                }
                if dict.keys.contains("BeginWaitResTime") {
                    self.beginWaitResTime = dict["BeginWaitResTime"] as! Int64
                }
                if dict.keys.contains("BeginWaitTimeTime") {
                    self.beginWaitTimeTime = dict["BeginWaitTimeTime"] as! Int64
                }
                if dict.keys.contains("Bizdate") {
                    self.bizdate = dict["Bizdate"] as! Int64
                }
                if dict.keys.contains("BusinessId") {
                    self.businessId = dict["BusinessId"] as! Int64
                }
                if dict.keys.contains("Connection") {
                    self.connection = dict["Connection"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CreateUser") {
                    self.createUser = dict["CreateUser"] as! String
                }
                if dict.keys.contains("CycTime") {
                    self.cycTime = dict["CycTime"] as! Int64
                }
                if dict.keys.contains("DagId") {
                    self.dagId = dict["DagId"] as! Int64
                }
                if dict.keys.contains("DagType") {
                    self.dagType = dict["DagType"] as! String
                }
                if dict.keys.contains("DqcDescription") {
                    self.dqcDescription = dict["DqcDescription"] as! String
                }
                if dict.keys.contains("DqcType") {
                    self.dqcType = dict["DqcType"] as! Int32
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! Int64
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("ParamValues") {
                    self.paramValues = dict["ParamValues"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("RelatedFlowId") {
                    self.relatedFlowId = dict["RelatedFlowId"] as! Int64
                }
                if dict.keys.contains("RepeatInterval") {
                    self.repeatInterval = dict["RepeatInterval"] as! Int64
                }
                if dict.keys.contains("Repeatability") {
                    self.repeatability = dict["Repeatability"] as! Bool
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskRerunTime") {
                    self.taskRerunTime = dict["TaskRerunTime"] as! Int32
                }
                if dict.keys.contains("TaskType") {
                    self.taskType = dict["TaskType"] as! String
                }
            }
        }
        public var instances: [ListInstancesResponseBody.Data.Instances]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instances != nil {
                var tmp : [Any] = []
                for k in self.instances! {
                    tmp.append(k.toMap())
                }
                map["Instances"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Instances") {
                var tmp : [ListInstancesResponseBody.Data.Instances] = []
                for v in dict["Instances"] as! [Any] {
                    var model = ListInstancesResponseBody.Data.Instances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instances = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListInstancesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListInstancesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLineageRequest : Tea.TeaModel {
    public var direction: String?

    public var entityQualifiedName: String?

    public var keyword: String?

    public var nextToken: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.entityQualifiedName != nil {
            map["EntityQualifiedName"] = self.entityQualifiedName!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("EntityQualifiedName") {
            self.entityQualifiedName = dict["EntityQualifiedName"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListLineageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataEntityList : Tea.TeaModel {
            public class RelationList : Tea.TeaModel {
                public var channel: String?

                public var datasource: String?

                public var guid: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.channel != nil {
                        map["Channel"] = self.channel!
                    }
                    if self.datasource != nil {
                        map["Datasource"] = self.datasource!
                    }
                    if self.guid != nil {
                        map["Guid"] = self.guid!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Channel") {
                        self.channel = dict["Channel"] as! String
                    }
                    if dict.keys.contains("Datasource") {
                        self.datasource = dict["Datasource"] as! String
                    }
                    if dict.keys.contains("Guid") {
                        self.guid = dict["Guid"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var createTimestamp: Int64?

            public var entity: Entity?

            public var relationList: [ListLineageResponseBody.Data.DataEntityList.RelationList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.entity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.entity != nil {
                    map["Entity"] = self.entity?.toMap()
                }
                if self.relationList != nil {
                    var tmp : [Any] = []
                    for k in self.relationList! {
                        tmp.append(k.toMap())
                    }
                    map["RelationList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("Entity") {
                    var model = Entity()
                    model.fromMap(dict["Entity"] as! [String: Any])
                    self.entity = model
                }
                if dict.keys.contains("RelationList") {
                    var tmp : [ListLineageResponseBody.Data.DataEntityList.RelationList] = []
                    for v in dict["RelationList"] as! [Any] {
                        var model = ListLineageResponseBody.Data.DataEntityList.RelationList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.relationList = tmp
                }
            }
        }
        public var dataEntityList: [ListLineageResponseBody.Data.DataEntityList]?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataEntityList != nil {
                var tmp : [Any] = []
                for k in self.dataEntityList! {
                    tmp.append(k.toMap())
                }
                map["DataEntityList"] = tmp
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataEntityList") {
                var tmp : [ListLineageResponseBody.Data.DataEntityList] = []
                for v in dict["DataEntityList"] as! [Any] {
                    var model = ListLineageResponseBody.Data.DataEntityList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataEntityList = tmp
            }
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
        }
    }
    public var data: ListLineageResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListLineageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListLineageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLineageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLineageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListManualDagInstancesRequest : Tea.TeaModel {
    public var dagId: String?

    public var projectEnv: String?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! String
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
    }
}

public class ListManualDagInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public var beginRunningTime: Int64?

        public var beginWaitResTime: Int64?

        public var beginWaitTimeTime: Int64?

        public var bizDate: Int64?

        public var createTime: Int64?

        public var createUser: String?

        public var cycTime: Int64?

        public var dagId: Int64?

        public var dagType: String?

        public var finishTime: Int64?

        public var instanceId: Int64?

        public var modifyTime: Int64?

        public var nodeId: Int64?

        public var nodeName: String?

        public var paramValues: String?

        public var status: String?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.beginRunningTime != nil {
                map["BeginRunningTime"] = self.beginRunningTime!
            }
            if self.beginWaitResTime != nil {
                map["BeginWaitResTime"] = self.beginWaitResTime!
            }
            if self.beginWaitTimeTime != nil {
                map["BeginWaitTimeTime"] = self.beginWaitTimeTime!
            }
            if self.bizDate != nil {
                map["BizDate"] = self.bizDate!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.cycTime != nil {
                map["CycTime"] = self.cycTime!
            }
            if self.dagId != nil {
                map["DagId"] = self.dagId!
            }
            if self.dagType != nil {
                map["DagType"] = self.dagType!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.paramValues != nil {
                map["ParamValues"] = self.paramValues!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BeginRunningTime") {
                self.beginRunningTime = dict["BeginRunningTime"] as! Int64
            }
            if dict.keys.contains("BeginWaitResTime") {
                self.beginWaitResTime = dict["BeginWaitResTime"] as! Int64
            }
            if dict.keys.contains("BeginWaitTimeTime") {
                self.beginWaitTimeTime = dict["BeginWaitTimeTime"] as! Int64
            }
            if dict.keys.contains("BizDate") {
                self.bizDate = dict["BizDate"] as! Int64
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreateUser") {
                self.createUser = dict["CreateUser"] as! String
            }
            if dict.keys.contains("CycTime") {
                self.cycTime = dict["CycTime"] as! Int64
            }
            if dict.keys.contains("DagId") {
                self.dagId = dict["DagId"] as! Int64
            }
            if dict.keys.contains("DagType") {
                self.dagType = dict["DagType"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! Int64
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("ParamValues") {
                self.paramValues = dict["ParamValues"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskType") {
                self.taskType = dict["TaskType"] as! String
            }
        }
    }
    public var instances: [ListManualDagInstancesResponseBody.Instances]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            var tmp : [ListManualDagInstancesResponseBody.Instances] = []
            for v in dict["Instances"] as! [Any] {
                var model = ListManualDagInstancesResponseBody.Instances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instances = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListManualDagInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListManualDagInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListManualDagInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMeasureDataRequest : Tea.TeaModel {
    public var componentCode: String?

    public var domainCode: String?

    public var endTime: Int64?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.componentCode != nil {
            map["ComponentCode"] = self.componentCode!
        }
        if self.domainCode != nil {
            map["DomainCode"] = self.domainCode!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ComponentCode") {
            self.componentCode = dict["ComponentCode"] as! String
        }
        if dict.keys.contains("DomainCode") {
            self.domainCode = dict["DomainCode"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListMeasureDataResponseBody : Tea.TeaModel {
    public class MeasureDatas : Tea.TeaModel {
        public var componentCode: String?

        public var domainCode: String?

        public var endTime: Int64?

        public var startTime: Int64?

        public var usage: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.componentCode != nil {
                map["ComponentCode"] = self.componentCode!
            }
            if self.domainCode != nil {
                map["DomainCode"] = self.domainCode!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.usage != nil {
                map["Usage"] = self.usage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComponentCode") {
                self.componentCode = dict["ComponentCode"] as! String
            }
            if dict.keys.contains("DomainCode") {
                self.domainCode = dict["DomainCode"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Usage") {
                self.usage = dict["Usage"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var measureDatas: [ListMeasureDataResponseBody.MeasureDatas]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.measureDatas != nil {
            var tmp : [Any] = []
            for k in self.measureDatas! {
                tmp.append(k.toMap())
            }
            map["MeasureDatas"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("MeasureDatas") {
            var tmp : [ListMeasureDataResponseBody.MeasureDatas] = []
            for v in dict["MeasureDatas"] as! [Any] {
                var model = ListMeasureDataResponseBody.MeasureDatas()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.measureDatas = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListMeasureDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMeasureDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMeasureDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMetaCollectionEntitiesRequest : Tea.TeaModel {
    public var collectionQualifiedName: String?

    public var entityType: String?

    public var keyword: String?

    public var nextToken: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectionQualifiedName != nil {
            map["CollectionQualifiedName"] = self.collectionQualifiedName!
        }
        if self.entityType != nil {
            map["EntityType"] = self.entityType!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CollectionQualifiedName") {
            self.collectionQualifiedName = dict["CollectionQualifiedName"] as! String
        }
        if dict.keys.contains("EntityType") {
            self.entityType = dict["EntityType"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListMetaCollectionEntitiesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var entityList: [Entity]?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.entityList != nil {
                var tmp : [Any] = []
                for k in self.entityList! {
                    tmp.append(k.toMap())
                }
                map["EntityList"] = tmp
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EntityList") {
                var tmp : [Entity] = []
                for v in dict["EntityList"] as! [Any] {
                    var model = Entity()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.entityList = tmp
            }
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
        }
    }
    public var data: ListMetaCollectionEntitiesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListMetaCollectionEntitiesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListMetaCollectionEntitiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMetaCollectionEntitiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMetaCollectionEntitiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMetaCollectionsRequest : Tea.TeaModel {
    public var administrator: String?

    public var collectionType: String?

    public var creator: String?

    public var follower: String?

    public var keyword: String?

    public var nextToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var parentQualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.administrator != nil {
            map["Administrator"] = self.administrator!
        }
        if self.collectionType != nil {
            map["CollectionType"] = self.collectionType!
        }
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        if self.follower != nil {
            map["Follower"] = self.follower!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentQualifiedName != nil {
            map["ParentQualifiedName"] = self.parentQualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Administrator") {
            self.administrator = dict["Administrator"] as! String
        }
        if dict.keys.contains("CollectionType") {
            self.collectionType = dict["CollectionType"] as! String
        }
        if dict.keys.contains("Creator") {
            self.creator = dict["Creator"] as! String
        }
        if dict.keys.contains("Follower") {
            self.follower = dict["Follower"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ParentQualifiedName") {
            self.parentQualifiedName = dict["ParentQualifiedName"] as! String
        }
    }
}

public class ListMetaCollectionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var collectionList: [Collection]?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.collectionList != nil {
                var tmp : [Any] = []
                for k in self.collectionList! {
                    tmp.append(k.toMap())
                }
                map["CollectionList"] = tmp
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CollectionList") {
                var tmp : [Collection] = []
                for v in dict["CollectionList"] as! [Any] {
                    var model = Collection()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.collectionList = tmp
            }
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
        }
    }
    public var data: ListMetaCollectionsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListMetaCollectionsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListMetaCollectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMetaCollectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMetaCollectionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMetaDBRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class ListMetaDBResponseBody : Tea.TeaModel {
    public class DatabaseInfo : Tea.TeaModel {
        public class DbList : Tea.TeaModel {
            public var createTimeStamp: Int64?

            public var location: String?

            public var modifiedTimeStamp: Int64?

            public var name: String?

            public var ownerId: String?

            public var type: String?

            public var UUID: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTimeStamp != nil {
                    map["CreateTimeStamp"] = self.createTimeStamp!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.modifiedTimeStamp != nil {
                    map["ModifiedTimeStamp"] = self.modifiedTimeStamp!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.UUID != nil {
                    map["UUID"] = self.UUID!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTimeStamp") {
                    self.createTimeStamp = dict["CreateTimeStamp"] as! Int64
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ModifiedTimeStamp") {
                    self.modifiedTimeStamp = dict["ModifiedTimeStamp"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OwnerId") {
                    self.ownerId = dict["OwnerId"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UUID") {
                    self.UUID = dict["UUID"] as! String
                }
            }
        }
        public var dbList: [ListMetaDBResponseBody.DatabaseInfo.DbList]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbList != nil {
                var tmp : [Any] = []
                for k in self.dbList! {
                    tmp.append(k.toMap())
                }
                map["DbList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbList") {
                var tmp : [ListMetaDBResponseBody.DatabaseInfo.DbList] = []
                for v in dict["DbList"] as! [Any] {
                    var model = ListMetaDBResponseBody.DatabaseInfo.DbList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dbList = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var databaseInfo: ListMetaDBResponseBody.DatabaseInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.databaseInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseInfo != nil {
            map["DatabaseInfo"] = self.databaseInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseInfo") {
            var model = ListMetaDBResponseBody.DatabaseInfo()
            model.fromMap(dict["DatabaseInfo"] as! [String: Any])
            self.databaseInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMetaDBResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMetaDBResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMetaDBResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMigrationsRequest : Tea.TeaModel {
    public var migrationType: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationType != nil {
            map["MigrationType"] = self.migrationType!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MigrationType") {
            self.migrationType = dict["MigrationType"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class ListMigrationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Migrations : Tea.TeaModel {
            public var createTime: Int64?

            public var createUser: String?

            public var createUserName: String?

            public var description_: String?

            public var downloadUrl: String?

            public var id: Int64?

            public var message: String?

            public var migrationType: String?

            public var name: String?

            public var packageType: String?

            public var projectId: Int64?

            public var status: String?

            public var tenantId: Int64?

            public var updateTime: Int64?

            public var updateUser: String?

            public var updateUserName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.createUserName != nil {
                    map["CreateUserName"] = self.createUserName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.downloadUrl != nil {
                    map["DownloadUrl"] = self.downloadUrl!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.migrationType != nil {
                    map["MigrationType"] = self.migrationType!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.packageType != nil {
                    map["PackageType"] = self.packageType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateUser != nil {
                    map["UpdateUser"] = self.updateUser!
                }
                if self.updateUserName != nil {
                    map["UpdateUserName"] = self.updateUserName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CreateUser") {
                    self.createUser = dict["CreateUser"] as! String
                }
                if dict.keys.contains("CreateUserName") {
                    self.createUserName = dict["CreateUserName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DownloadUrl") {
                    self.downloadUrl = dict["DownloadUrl"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("MigrationType") {
                    self.migrationType = dict["MigrationType"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PackageType") {
                    self.packageType = dict["PackageType"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UpdateUser") {
                    self.updateUser = dict["UpdateUser"] as! String
                }
                if dict.keys.contains("UpdateUserName") {
                    self.updateUserName = dict["UpdateUserName"] as! String
                }
            }
        }
        public var migrations: [ListMigrationsResponseBody.Data.Migrations]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.migrations != nil {
                var tmp : [Any] = []
                for k in self.migrations! {
                    tmp.append(k.toMap())
                }
                map["Migrations"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Migrations") {
                var tmp : [ListMigrationsResponseBody.Data.Migrations] = []
                for v in dict["Migrations"] as! [Any] {
                    var model = ListMigrationsResponseBody.Data.Migrations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.migrations = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListMigrationsResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListMigrationsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListMigrationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMigrationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMigrationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNodeIORequest : Tea.TeaModel {
    public var ioType: String?

    public var nodeId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ioType != nil {
            map["IoType"] = self.ioType!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IoType") {
            self.ioType = dict["IoType"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class ListNodeIOResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var data: String?

        public var nodeId: Int64?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! Int64
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
        }
    }
    public var data: [ListNodeIOResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListNodeIOResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListNodeIOResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListNodeIOResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodeIOResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNodeIOResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNodeInputOrOutputRequest : Tea.TeaModel {
    public var ioType: String?

    public var nodeId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ioType != nil {
            map["IoType"] = self.ioType!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IoType") {
            self.ioType = dict["IoType"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class ListNodeInputOrOutputResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var data: String?

        public var nodeId: Int64?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! Int64
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
        }
    }
    public var data: [ListNodeInputOrOutputResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListNodeInputOrOutputResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListNodeInputOrOutputResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListNodeInputOrOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodeInputOrOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNodeInputOrOutputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNodesRequest : Tea.TeaModel {
    public var bizName: String?

    public var nodeName: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var programType: String?

    public var projectEnv: String?

    public var projectId: Int64?

    public var schedulerType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizName != nil {
            map["BizName"] = self.bizName!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.programType != nil {
            map["ProgramType"] = self.programType!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.schedulerType != nil {
            map["SchedulerType"] = self.schedulerType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizName") {
            self.bizName = dict["BizName"] as! String
        }
        if dict.keys.contains("NodeName") {
            self.nodeName = dict["NodeName"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProgramType") {
            self.programType = dict["ProgramType"] as! String
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SchedulerType") {
            self.schedulerType = dict["SchedulerType"] as! String
        }
    }
}

public class ListNodesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Nodes : Tea.TeaModel {
            public var baselineId: Int64?

            public var businessId: Int64?

            public var connection: String?

            public var createTime: Int64?

            public var cronExpress: String?

            public var deployDate: Int64?

            public var description_: String?

            public var dqcDescription: String?

            public var dqcType: Int32?

            public var fileId: Int64?

            public var fileType: Int32?

            public var fileVersion: Int32?

            public var modifyTime: Int64?

            public var nodeId: Int64?

            public var nodeName: String?

            public var ownerId: String?

            public var paramValues: String?

            public var priority: Int32?

            public var programType: String?

            public var projectId: Int64?

            public var relatedFlowId: Int64?

            public var repeatInterval: Int64?

            public var repeatMode: Int32?

            public var repeatability: Bool?

            public var resGroupIdentifier: String?

            public var resGroupName: String?

            public var schedulerType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.businessId != nil {
                    map["BusinessId"] = self.businessId!
                }
                if self.connection != nil {
                    map["Connection"] = self.connection!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.cronExpress != nil {
                    map["CronExpress"] = self.cronExpress!
                }
                if self.deployDate != nil {
                    map["DeployDate"] = self.deployDate!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.dqcDescription != nil {
                    map["DqcDescription"] = self.dqcDescription!
                }
                if self.dqcType != nil {
                    map["DqcType"] = self.dqcType!
                }
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.fileType != nil {
                    map["FileType"] = self.fileType!
                }
                if self.fileVersion != nil {
                    map["FileVersion"] = self.fileVersion!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.paramValues != nil {
                    map["ParamValues"] = self.paramValues!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.programType != nil {
                    map["ProgramType"] = self.programType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.relatedFlowId != nil {
                    map["RelatedFlowId"] = self.relatedFlowId!
                }
                if self.repeatInterval != nil {
                    map["RepeatInterval"] = self.repeatInterval!
                }
                if self.repeatMode != nil {
                    map["RepeatMode"] = self.repeatMode!
                }
                if self.repeatability != nil {
                    map["Repeatability"] = self.repeatability!
                }
                if self.resGroupIdentifier != nil {
                    map["ResGroupIdentifier"] = self.resGroupIdentifier!
                }
                if self.resGroupName != nil {
                    map["ResGroupName"] = self.resGroupName!
                }
                if self.schedulerType != nil {
                    map["SchedulerType"] = self.schedulerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("BusinessId") {
                    self.businessId = dict["BusinessId"] as! Int64
                }
                if dict.keys.contains("Connection") {
                    self.connection = dict["Connection"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CronExpress") {
                    self.cronExpress = dict["CronExpress"] as! String
                }
                if dict.keys.contains("DeployDate") {
                    self.deployDate = dict["DeployDate"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DqcDescription") {
                    self.dqcDescription = dict["DqcDescription"] as! String
                }
                if dict.keys.contains("DqcType") {
                    self.dqcType = dict["DqcType"] as! Int32
                }
                if dict.keys.contains("FileId") {
                    self.fileId = dict["FileId"] as! Int64
                }
                if dict.keys.contains("FileType") {
                    self.fileType = dict["FileType"] as! Int32
                }
                if dict.keys.contains("FileVersion") {
                    self.fileVersion = dict["FileVersion"] as! Int32
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! Int64
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("OwnerId") {
                    self.ownerId = dict["OwnerId"] as! String
                }
                if dict.keys.contains("ParamValues") {
                    self.paramValues = dict["ParamValues"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ProgramType") {
                    self.programType = dict["ProgramType"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("RelatedFlowId") {
                    self.relatedFlowId = dict["RelatedFlowId"] as! Int64
                }
                if dict.keys.contains("RepeatInterval") {
                    self.repeatInterval = dict["RepeatInterval"] as! Int64
                }
                if dict.keys.contains("RepeatMode") {
                    self.repeatMode = dict["RepeatMode"] as! Int32
                }
                if dict.keys.contains("Repeatability") {
                    self.repeatability = dict["Repeatability"] as! Bool
                }
                if dict.keys.contains("ResGroupIdentifier") {
                    self.resGroupIdentifier = dict["ResGroupIdentifier"] as! String
                }
                if dict.keys.contains("ResGroupName") {
                    self.resGroupName = dict["ResGroupName"] as! String
                }
                if dict.keys.contains("SchedulerType") {
                    self.schedulerType = dict["SchedulerType"] as! String
                }
            }
        }
        public var nodes: [ListNodesResponseBody.Data.Nodes]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Nodes") {
                var tmp : [ListNodesResponseBody.Data.Nodes] = []
                for v in dict["Nodes"] as! [Any] {
                    var model = ListNodesResponseBody.Data.Nodes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodes = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListNodesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListNodesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNodesByBaselineRequest : Tea.TeaModel {
    public var baselineId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineId") {
            self.baselineId = dict["BaselineId"] as! Int64
        }
    }
}

public class ListNodesByBaselineResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var nodeId: Int64?

        public var nodeName: String?

        public var owner: String?

        public var projectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! Int64
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
        }
    }
    public var data: [ListNodesByBaselineResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListNodesByBaselineResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListNodesByBaselineResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ListNodesByBaselineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodesByBaselineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNodesByBaselineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNodesByOutputRequest : Tea.TeaModel {
    public var outputs: String?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.outputs != nil {
            map["Outputs"] = self.outputs!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Outputs") {
            self.outputs = dict["Outputs"] as! String
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class ListNodesByOutputResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class NodeList : Tea.TeaModel {
            public var baselineId: Int64?

            public var connection: String?

            public var cronExpress: String?

            public var description_: String?

            public var dqcDescription: String?

            public var dqcType: Int32?

            public var fileType: String?

            public var nodeId: Int64?

            public var nodeName: String?

            public var ownerId: String?

            public var paramValues: String?

            public var priority: Int32?

            public var programType: String?

            public var projectId: Int64?

            public var relatedFlowId: Int64?

            public var repeatInterval: Int32?

            public var repeatability: Bool?

            public var resGroupName: String?

            public var schedulerType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.connection != nil {
                    map["Connection"] = self.connection!
                }
                if self.cronExpress != nil {
                    map["CronExpress"] = self.cronExpress!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.dqcDescription != nil {
                    map["DqcDescription"] = self.dqcDescription!
                }
                if self.dqcType != nil {
                    map["DqcType"] = self.dqcType!
                }
                if self.fileType != nil {
                    map["FileType"] = self.fileType!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.paramValues != nil {
                    map["ParamValues"] = self.paramValues!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.programType != nil {
                    map["ProgramType"] = self.programType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.relatedFlowId != nil {
                    map["RelatedFlowId"] = self.relatedFlowId!
                }
                if self.repeatInterval != nil {
                    map["RepeatInterval"] = self.repeatInterval!
                }
                if self.repeatability != nil {
                    map["Repeatability"] = self.repeatability!
                }
                if self.resGroupName != nil {
                    map["ResGroupName"] = self.resGroupName!
                }
                if self.schedulerType != nil {
                    map["SchedulerType"] = self.schedulerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("Connection") {
                    self.connection = dict["Connection"] as! String
                }
                if dict.keys.contains("CronExpress") {
                    self.cronExpress = dict["CronExpress"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DqcDescription") {
                    self.dqcDescription = dict["DqcDescription"] as! String
                }
                if dict.keys.contains("DqcType") {
                    self.dqcType = dict["DqcType"] as! Int32
                }
                if dict.keys.contains("FileType") {
                    self.fileType = dict["FileType"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("OwnerId") {
                    self.ownerId = dict["OwnerId"] as! String
                }
                if dict.keys.contains("ParamValues") {
                    self.paramValues = dict["ParamValues"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ProgramType") {
                    self.programType = dict["ProgramType"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("RelatedFlowId") {
                    self.relatedFlowId = dict["RelatedFlowId"] as! Int64
                }
                if dict.keys.contains("RepeatInterval") {
                    self.repeatInterval = dict["RepeatInterval"] as! Int32
                }
                if dict.keys.contains("Repeatability") {
                    self.repeatability = dict["Repeatability"] as! Bool
                }
                if dict.keys.contains("ResGroupName") {
                    self.resGroupName = dict["ResGroupName"] as! String
                }
                if dict.keys.contains("SchedulerType") {
                    self.schedulerType = dict["SchedulerType"] as! String
                }
            }
        }
        public var nodeList: [ListNodesByOutputResponseBody.Data.NodeList]?

        public var output: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeList != nil {
                var tmp : [Any] = []
                for k in self.nodeList! {
                    tmp.append(k.toMap())
                }
                map["NodeList"] = tmp
            }
            if self.output != nil {
                map["Output"] = self.output!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeList") {
                var tmp : [ListNodesByOutputResponseBody.Data.NodeList] = []
                for v in dict["NodeList"] as! [Any] {
                    var model = ListNodesByOutputResponseBody.Data.NodeList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeList = tmp
            }
            if dict.keys.contains("Output") {
                self.output = dict["Output"] as! String
            }
        }
    }
    public var data: [ListNodesByOutputResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListNodesByOutputResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListNodesByOutputResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListNodesByOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodesByOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNodesByOutputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPermissionApplyOrdersRequest : Tea.TeaModel {
    public var applyType: String?

    public var catalogName: String?

    public var endTime: Int64?

    public var engineType: String?

    public var flowStatus: Int32?

    public var maxComputeProjectName: String?

    public var orderType: Int32?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var queryType: Int32?

    public var startTime: Int64?

    public var tableName: String?

    public var workspaceId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applyType != nil {
            map["ApplyType"] = self.applyType!
        }
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.engineType != nil {
            map["EngineType"] = self.engineType!
        }
        if self.flowStatus != nil {
            map["FlowStatus"] = self.flowStatus!
        }
        if self.maxComputeProjectName != nil {
            map["MaxComputeProjectName"] = self.maxComputeProjectName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queryType != nil {
            map["QueryType"] = self.queryType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplyType") {
            self.applyType = dict["ApplyType"] as! String
        }
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("EngineType") {
            self.engineType = dict["EngineType"] as! String
        }
        if dict.keys.contains("FlowStatus") {
            self.flowStatus = dict["FlowStatus"] as! Int32
        }
        if dict.keys.contains("MaxComputeProjectName") {
            self.maxComputeProjectName = dict["MaxComputeProjectName"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! Int32
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("QueryType") {
            self.queryType = dict["QueryType"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! Int32
        }
    }
}

public class ListPermissionApplyOrdersResponseBody : Tea.TeaModel {
    public class ApplyOrders : Tea.TeaModel {
        public class ApplyOrder : Tea.TeaModel {
            public class ApproveContent : Tea.TeaModel {
                public class ProjectMeta : Tea.TeaModel {
                    public class ObjectMetaList : Tea.TeaModel {
                        public var actions: [String]?

                        public var objectName: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.actions != nil {
                                map["Actions"] = self.actions!
                            }
                            if self.objectName != nil {
                                map["ObjectName"] = self.objectName!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Actions") {
                                self.actions = dict["Actions"] as! [String]
                            }
                            if dict.keys.contains("ObjectName") {
                                self.objectName = dict["ObjectName"] as! String
                            }
                        }
                    }
                    public var objectMetaList: [ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder.ApproveContent.ProjectMeta.ObjectMetaList]?

                    public var workspaceName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.objectMetaList != nil {
                            var tmp : [Any] = []
                            for k in self.objectMetaList! {
                                tmp.append(k.toMap())
                            }
                            map["ObjectMetaList"] = tmp
                        }
                        if self.workspaceName != nil {
                            map["WorkspaceName"] = self.workspaceName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ObjectMetaList") {
                            var tmp : [ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder.ApproveContent.ProjectMeta.ObjectMetaList] = []
                            for v in dict["ObjectMetaList"] as! [Any] {
                                var model = ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder.ApproveContent.ProjectMeta.ObjectMetaList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.objectMetaList = tmp
                        }
                        if dict.keys.contains("WorkspaceName") {
                            self.workspaceName = dict["WorkspaceName"] as! String
                        }
                    }
                }
                public var applyReason: String?

                public var orderType: Int32?

                public var projectMeta: ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder.ApproveContent.ProjectMeta?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.projectMeta?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.applyReason != nil {
                        map["ApplyReason"] = self.applyReason!
                    }
                    if self.orderType != nil {
                        map["OrderType"] = self.orderType!
                    }
                    if self.projectMeta != nil {
                        map["ProjectMeta"] = self.projectMeta?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ApplyReason") {
                        self.applyReason = dict["ApplyReason"] as! String
                    }
                    if dict.keys.contains("OrderType") {
                        self.orderType = dict["OrderType"] as! Int32
                    }
                    if dict.keys.contains("ProjectMeta") {
                        var model = ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder.ApproveContent.ProjectMeta()
                        model.fromMap(dict["ProjectMeta"] as! [String: Any])
                        self.projectMeta = model
                    }
                }
            }
            public var applyBaseId: String?

            public var applyTimestamp: Int64?

            public var approveContent: ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder.ApproveContent?

            public var flowId: String?

            public var flowStatus: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.approveContent?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applyBaseId != nil {
                    map["ApplyBaseId"] = self.applyBaseId!
                }
                if self.applyTimestamp != nil {
                    map["ApplyTimestamp"] = self.applyTimestamp!
                }
                if self.approveContent != nil {
                    map["ApproveContent"] = self.approveContent?.toMap()
                }
                if self.flowId != nil {
                    map["FlowId"] = self.flowId!
                }
                if self.flowStatus != nil {
                    map["FlowStatus"] = self.flowStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApplyBaseId") {
                    self.applyBaseId = dict["ApplyBaseId"] as! String
                }
                if dict.keys.contains("ApplyTimestamp") {
                    self.applyTimestamp = dict["ApplyTimestamp"] as! Int64
                }
                if dict.keys.contains("ApproveContent") {
                    var model = ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder.ApproveContent()
                    model.fromMap(dict["ApproveContent"] as! [String: Any])
                    self.approveContent = model
                }
                if dict.keys.contains("FlowId") {
                    self.flowId = dict["FlowId"] as! String
                }
                if dict.keys.contains("FlowStatus") {
                    self.flowStatus = dict["FlowStatus"] as! Int32
                }
            }
        }
        public var applyOrder: [ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applyOrder != nil {
                var tmp : [Any] = []
                for k in self.applyOrder! {
                    tmp.append(k.toMap())
                }
                map["ApplyOrder"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplyOrder") {
                var tmp : [ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder] = []
                for v in dict["ApplyOrder"] as! [Any] {
                    var model = ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.applyOrder = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var applyOrders: ListPermissionApplyOrdersResponseBody.ApplyOrders?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applyOrders?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applyOrders != nil {
            map["ApplyOrders"] = self.applyOrders?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplyOrders") {
            var model = ListPermissionApplyOrdersResponseBody.ApplyOrders()
            model.fromMap(dict["ApplyOrders"] as! [String: Any])
            self.applyOrders = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPermissionApplyOrdersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPermissionApplyOrdersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPermissionApplyOrdersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProgramTypeCountRequest : Tea.TeaModel {
    public var projectEnv: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class ListProgramTypeCountResponseBody : Tea.TeaModel {
    public class ProgramTypeAndCounts : Tea.TeaModel {
        public var count: Int32?

        public var programType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.programType != nil {
                map["ProgramType"] = self.programType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("ProgramType") {
                self.programType = dict["ProgramType"] as! String
            }
        }
    }
    public var programTypeAndCounts: [ListProgramTypeCountResponseBody.ProgramTypeAndCounts]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.programTypeAndCounts != nil {
            var tmp : [Any] = []
            for k in self.programTypeAndCounts! {
                tmp.append(k.toMap())
            }
            map["ProgramTypeAndCounts"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProgramTypeAndCounts") {
            var tmp : [ListProgramTypeCountResponseBody.ProgramTypeAndCounts] = []
            for v in dict["ProgramTypeAndCounts"] as! [Any] {
                var model = ListProgramTypeCountResponseBody.ProgramTypeAndCounts()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.programTypeAndCounts = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListProgramTypeCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProgramTypeCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProgramTypeCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProjectIdsRequest : Tea.TeaModel {
    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListProjectIdsResponseBody : Tea.TeaModel {
    public var projectIds: [Int64]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectIds != nil {
            map["ProjectIds"] = self.projectIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectIds") {
            self.projectIds = dict["ProjectIds"] as! [Int64]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListProjectIdsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectIdsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProjectIdsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProjectMembersRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class ListProjectMembersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ProjectMemberList : Tea.TeaModel {
            public class ProjectRoleList : Tea.TeaModel {
                public var projectRoleCode: String?

                public var projectRoleId: Int32?

                public var projectRoleName: String?

                public var projectRoleType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.projectRoleCode != nil {
                        map["ProjectRoleCode"] = self.projectRoleCode!
                    }
                    if self.projectRoleId != nil {
                        map["ProjectRoleId"] = self.projectRoleId!
                    }
                    if self.projectRoleName != nil {
                        map["ProjectRoleName"] = self.projectRoleName!
                    }
                    if self.projectRoleType != nil {
                        map["ProjectRoleType"] = self.projectRoleType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ProjectRoleCode") {
                        self.projectRoleCode = dict["ProjectRoleCode"] as! String
                    }
                    if dict.keys.contains("ProjectRoleId") {
                        self.projectRoleId = dict["ProjectRoleId"] as! Int32
                    }
                    if dict.keys.contains("ProjectRoleName") {
                        self.projectRoleName = dict["ProjectRoleName"] as! String
                    }
                    if dict.keys.contains("ProjectRoleType") {
                        self.projectRoleType = dict["ProjectRoleType"] as! String
                    }
                }
            }
            public var nick: String?

            public var projectMemberId: String?

            public var projectMemberName: String?

            public var projectMemberType: String?

            public var projectRoleList: [ListProjectMembersResponseBody.Data.ProjectMemberList.ProjectRoleList]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nick != nil {
                    map["Nick"] = self.nick!
                }
                if self.projectMemberId != nil {
                    map["ProjectMemberId"] = self.projectMemberId!
                }
                if self.projectMemberName != nil {
                    map["ProjectMemberName"] = self.projectMemberName!
                }
                if self.projectMemberType != nil {
                    map["ProjectMemberType"] = self.projectMemberType!
                }
                if self.projectRoleList != nil {
                    var tmp : [Any] = []
                    for k in self.projectRoleList! {
                        tmp.append(k.toMap())
                    }
                    map["ProjectRoleList"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Nick") {
                    self.nick = dict["Nick"] as! String
                }
                if dict.keys.contains("ProjectMemberId") {
                    self.projectMemberId = dict["ProjectMemberId"] as! String
                }
                if dict.keys.contains("ProjectMemberName") {
                    self.projectMemberName = dict["ProjectMemberName"] as! String
                }
                if dict.keys.contains("ProjectMemberType") {
                    self.projectMemberType = dict["ProjectMemberType"] as! String
                }
                if dict.keys.contains("ProjectRoleList") {
                    var tmp : [ListProjectMembersResponseBody.Data.ProjectMemberList.ProjectRoleList] = []
                    for v in dict["ProjectRoleList"] as! [Any] {
                        var model = ListProjectMembersResponseBody.Data.ProjectMemberList.ProjectRoleList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.projectRoleList = tmp
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var projectMemberList: [ListProjectMembersResponseBody.Data.ProjectMemberList]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.projectMemberList != nil {
                var tmp : [Any] = []
                for k in self.projectMemberList! {
                    tmp.append(k.toMap())
                }
                map["ProjectMemberList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("ProjectMemberList") {
                var tmp : [ListProjectMembersResponseBody.Data.ProjectMemberList] = []
                for v in dict["ProjectMemberList"] as! [Any] {
                    var model = ListProjectMembersResponseBody.Data.ProjectMemberList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.projectMemberList = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListProjectMembersResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListProjectMembersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListProjectMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProjectMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProjectRolesRequest : Tea.TeaModel {
    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class ListProjectRolesResponseBody : Tea.TeaModel {
    public class ProjectRoleList : Tea.TeaModel {
        public var projectRoleCode: String?

        public var projectRoleId: Int32?

        public var projectRoleName: String?

        public var projectRoleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.projectRoleCode != nil {
                map["ProjectRoleCode"] = self.projectRoleCode!
            }
            if self.projectRoleId != nil {
                map["ProjectRoleId"] = self.projectRoleId!
            }
            if self.projectRoleName != nil {
                map["ProjectRoleName"] = self.projectRoleName!
            }
            if self.projectRoleType != nil {
                map["ProjectRoleType"] = self.projectRoleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ProjectRoleCode") {
                self.projectRoleCode = dict["ProjectRoleCode"] as! String
            }
            if dict.keys.contains("ProjectRoleId") {
                self.projectRoleId = dict["ProjectRoleId"] as! Int32
            }
            if dict.keys.contains("ProjectRoleName") {
                self.projectRoleName = dict["ProjectRoleName"] as! String
            }
            if dict.keys.contains("ProjectRoleType") {
                self.projectRoleType = dict["ProjectRoleType"] as! String
            }
        }
    }
    public var projectRoleList: [ListProjectRolesResponseBody.ProjectRoleList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectRoleList != nil {
            var tmp : [Any] = []
            for k in self.projectRoleList! {
                tmp.append(k.toMap())
            }
            map["ProjectRoleList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectRoleList") {
            var tmp : [ListProjectRolesResponseBody.ProjectRoleList] = []
            for v in dict["ProjectRoleList"] as! [Any] {
                var model = ListProjectRolesResponseBody.ProjectRoleList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.projectRoleList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListProjectRolesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectRolesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProjectRolesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProjectsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceManagerResourceGroupId: String?

    public var tags: [ListProjectsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceManagerResourceGroupId != nil {
            map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceManagerResourceGroupId") {
            self.resourceManagerResourceGroupId = dict["ResourceManagerResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListProjectsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListProjectsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListProjectsShrinkRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceManagerResourceGroupId: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceManagerResourceGroupId != nil {
            map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceManagerResourceGroupId") {
            self.resourceManagerResourceGroupId = dict["ResourceManagerResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tagsShrink = dict["Tags"] as! String
        }
    }
}

public class ListProjectsResponseBody : Tea.TeaModel {
    public class PageResult : Tea.TeaModel {
        public class ProjectList : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var disableDevelopment: Bool?

            public var isDefault: Int32?

            public var projectDescription: String?

            public var projectId: Int64?

            public var projectIdentifier: String?

            public var projectName: String?

            public var projectOwnerBaseId: String?

            public var projectStatus: Int32?

            public var projectStatusCode: String?

            public var resourceManagerResourceGroupId: String?

            public var tablePrivacyMode: Int32?

            public var tags: [ListProjectsResponseBody.PageResult.ProjectList.Tags]?

            public var useProxyOdpsAccount: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disableDevelopment != nil {
                    map["DisableDevelopment"] = self.disableDevelopment!
                }
                if self.isDefault != nil {
                    map["IsDefault"] = self.isDefault!
                }
                if self.projectDescription != nil {
                    map["ProjectDescription"] = self.projectDescription!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.projectIdentifier != nil {
                    map["ProjectIdentifier"] = self.projectIdentifier!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                if self.projectOwnerBaseId != nil {
                    map["ProjectOwnerBaseId"] = self.projectOwnerBaseId!
                }
                if self.projectStatus != nil {
                    map["ProjectStatus"] = self.projectStatus!
                }
                if self.projectStatusCode != nil {
                    map["ProjectStatusCode"] = self.projectStatusCode!
                }
                if self.resourceManagerResourceGroupId != nil {
                    map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
                }
                if self.tablePrivacyMode != nil {
                    map["TablePrivacyMode"] = self.tablePrivacyMode!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.useProxyOdpsAccount != nil {
                    map["UseProxyOdpsAccount"] = self.useProxyOdpsAccount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisableDevelopment") {
                    self.disableDevelopment = dict["DisableDevelopment"] as! Bool
                }
                if dict.keys.contains("IsDefault") {
                    self.isDefault = dict["IsDefault"] as! Int32
                }
                if dict.keys.contains("ProjectDescription") {
                    self.projectDescription = dict["ProjectDescription"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("ProjectIdentifier") {
                    self.projectIdentifier = dict["ProjectIdentifier"] as! String
                }
                if dict.keys.contains("ProjectName") {
                    self.projectName = dict["ProjectName"] as! String
                }
                if dict.keys.contains("ProjectOwnerBaseId") {
                    self.projectOwnerBaseId = dict["ProjectOwnerBaseId"] as! String
                }
                if dict.keys.contains("ProjectStatus") {
                    self.projectStatus = dict["ProjectStatus"] as! Int32
                }
                if dict.keys.contains("ProjectStatusCode") {
                    self.projectStatusCode = dict["ProjectStatusCode"] as! String
                }
                if dict.keys.contains("ResourceManagerResourceGroupId") {
                    self.resourceManagerResourceGroupId = dict["ResourceManagerResourceGroupId"] as! String
                }
                if dict.keys.contains("TablePrivacyMode") {
                    self.tablePrivacyMode = dict["TablePrivacyMode"] as! Int32
                }
                if dict.keys.contains("Tags") {
                    var tmp : [ListProjectsResponseBody.PageResult.ProjectList.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = ListProjectsResponseBody.PageResult.ProjectList.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
                if dict.keys.contains("UseProxyOdpsAccount") {
                    self.useProxyOdpsAccount = dict["UseProxyOdpsAccount"] as! Bool
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var projectList: [ListProjectsResponseBody.PageResult.ProjectList]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.projectList != nil {
                var tmp : [Any] = []
                for k in self.projectList! {
                    tmp.append(k.toMap())
                }
                map["ProjectList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("ProjectList") {
                var tmp : [ListProjectsResponseBody.PageResult.ProjectList] = []
                for v in dict["ProjectList"] as! [Any] {
                    var model = ListProjectsResponseBody.PageResult.ProjectList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.projectList = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pageResult: ListProjectsResponseBody.PageResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageResult != nil {
            map["PageResult"] = self.pageResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageResult") {
            var model = ListProjectsResponseBody.PageResult()
            model.fromMap(dict["PageResult"] as! [String: Any])
            self.pageResult = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListProjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProjectsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListQualityResultsByEntityRequest : Tea.TeaModel {
    public var endDate: String?

    public var entityId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectName: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class ListQualityResultsByEntityResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RuleChecks : Tea.TeaModel {
            public class ReferenceValue : Tea.TeaModel {
                public var bizDate: String?

                public var discreteProperty: String?

                public var singleCheckResult: Int32?

                public var threshold: Double?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizDate != nil {
                        map["BizDate"] = self.bizDate!
                    }
                    if self.discreteProperty != nil {
                        map["DiscreteProperty"] = self.discreteProperty!
                    }
                    if self.singleCheckResult != nil {
                        map["SingleCheckResult"] = self.singleCheckResult!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BizDate") {
                        self.bizDate = dict["BizDate"] as! String
                    }
                    if dict.keys.contains("DiscreteProperty") {
                        self.discreteProperty = dict["DiscreteProperty"] as! String
                    }
                    if dict.keys.contains("SingleCheckResult") {
                        self.singleCheckResult = dict["SingleCheckResult"] as! Int32
                    }
                    if dict.keys.contains("Threshold") {
                        self.threshold = dict["Threshold"] as! Double
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class SampleValue : Tea.TeaModel {
                public var bizDate: String?

                public var discreteProperty: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizDate != nil {
                        map["BizDate"] = self.bizDate!
                    }
                    if self.discreteProperty != nil {
                        map["DiscreteProperty"] = self.discreteProperty!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BizDate") {
                        self.bizDate = dict["BizDate"] as! String
                    }
                    if dict.keys.contains("DiscreteProperty") {
                        self.discreteProperty = dict["DiscreteProperty"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public var actualExpression: String?

            public var beginTime: Int64?

            public var bizDate: Int64?

            public var blockType: Int32?

            public var checkResult: Int32?

            public var checkResultStatus: Int32?

            public var checkerId: Int32?

            public var checkerName: String?

            public var checkerType: Int32?

            public var comment: String?

            public var criticalThreshold: Double?

            public var dateType: String?

            public var discreteCheck: Bool?

            public var endTime: Int64?

            public var entityId: Int64?

            public var expectValue: Double?

            public var externalId: String?

            public var externalType: String?

            public var fixedCheck: Bool?

            public var id: Int64?

            public var isPrediction: Bool?

            public var lowerValue: Double?

            public var matchExpression: String?

            public var methodName: String?

            public var op: String?

            public var projectName: String?

            public var property: String?

            public var referenceValue: [ListQualityResultsByEntityResponseBody.Data.RuleChecks.ReferenceValue]?

            public var resultString: String?

            public var ruleId: Int64?

            public var ruleName: String?

            public var sampleValue: [ListQualityResultsByEntityResponseBody.Data.RuleChecks.SampleValue]?

            public var tableName: String?

            public var taskId: String?

            public var templateId: Int32?

            public var templateName: String?

            public var timeCost: String?

            public var trend: String?

            public var upperValue: Double?

            public var warningThreshold: Double?

            public var whereCondition: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actualExpression != nil {
                    map["ActualExpression"] = self.actualExpression!
                }
                if self.beginTime != nil {
                    map["BeginTime"] = self.beginTime!
                }
                if self.bizDate != nil {
                    map["BizDate"] = self.bizDate!
                }
                if self.blockType != nil {
                    map["BlockType"] = self.blockType!
                }
                if self.checkResult != nil {
                    map["CheckResult"] = self.checkResult!
                }
                if self.checkResultStatus != nil {
                    map["CheckResultStatus"] = self.checkResultStatus!
                }
                if self.checkerId != nil {
                    map["CheckerId"] = self.checkerId!
                }
                if self.checkerName != nil {
                    map["CheckerName"] = self.checkerName!
                }
                if self.checkerType != nil {
                    map["CheckerType"] = self.checkerType!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.criticalThreshold != nil {
                    map["CriticalThreshold"] = self.criticalThreshold!
                }
                if self.dateType != nil {
                    map["DateType"] = self.dateType!
                }
                if self.discreteCheck != nil {
                    map["DiscreteCheck"] = self.discreteCheck!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.entityId != nil {
                    map["EntityId"] = self.entityId!
                }
                if self.expectValue != nil {
                    map["ExpectValue"] = self.expectValue!
                }
                if self.externalId != nil {
                    map["ExternalId"] = self.externalId!
                }
                if self.externalType != nil {
                    map["ExternalType"] = self.externalType!
                }
                if self.fixedCheck != nil {
                    map["FixedCheck"] = self.fixedCheck!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isPrediction != nil {
                    map["IsPrediction"] = self.isPrediction!
                }
                if self.lowerValue != nil {
                    map["LowerValue"] = self.lowerValue!
                }
                if self.matchExpression != nil {
                    map["MatchExpression"] = self.matchExpression!
                }
                if self.methodName != nil {
                    map["MethodName"] = self.methodName!
                }
                if self.op != nil {
                    map["Op"] = self.op!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                if self.property != nil {
                    map["Property"] = self.property!
                }
                if self.referenceValue != nil {
                    var tmp : [Any] = []
                    for k in self.referenceValue! {
                        tmp.append(k.toMap())
                    }
                    map["ReferenceValue"] = tmp
                }
                if self.resultString != nil {
                    map["ResultString"] = self.resultString!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.sampleValue != nil {
                    var tmp : [Any] = []
                    for k in self.sampleValue! {
                        tmp.append(k.toMap())
                    }
                    map["SampleValue"] = tmp
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.timeCost != nil {
                    map["TimeCost"] = self.timeCost!
                }
                if self.trend != nil {
                    map["Trend"] = self.trend!
                }
                if self.upperValue != nil {
                    map["UpperValue"] = self.upperValue!
                }
                if self.warningThreshold != nil {
                    map["WarningThreshold"] = self.warningThreshold!
                }
                if self.whereCondition != nil {
                    map["WhereCondition"] = self.whereCondition!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActualExpression") {
                    self.actualExpression = dict["ActualExpression"] as! String
                }
                if dict.keys.contains("BeginTime") {
                    self.beginTime = dict["BeginTime"] as! Int64
                }
                if dict.keys.contains("BizDate") {
                    self.bizDate = dict["BizDate"] as! Int64
                }
                if dict.keys.contains("BlockType") {
                    self.blockType = dict["BlockType"] as! Int32
                }
                if dict.keys.contains("CheckResult") {
                    self.checkResult = dict["CheckResult"] as! Int32
                }
                if dict.keys.contains("CheckResultStatus") {
                    self.checkResultStatus = dict["CheckResultStatus"] as! Int32
                }
                if dict.keys.contains("CheckerId") {
                    self.checkerId = dict["CheckerId"] as! Int32
                }
                if dict.keys.contains("CheckerName") {
                    self.checkerName = dict["CheckerName"] as! String
                }
                if dict.keys.contains("CheckerType") {
                    self.checkerType = dict["CheckerType"] as! Int32
                }
                if dict.keys.contains("Comment") {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("CriticalThreshold") {
                    self.criticalThreshold = dict["CriticalThreshold"] as! Double
                }
                if dict.keys.contains("DateType") {
                    self.dateType = dict["DateType"] as! String
                }
                if dict.keys.contains("DiscreteCheck") {
                    self.discreteCheck = dict["DiscreteCheck"] as! Bool
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("EntityId") {
                    self.entityId = dict["EntityId"] as! Int64
                }
                if dict.keys.contains("ExpectValue") {
                    self.expectValue = dict["ExpectValue"] as! Double
                }
                if dict.keys.contains("ExternalId") {
                    self.externalId = dict["ExternalId"] as! String
                }
                if dict.keys.contains("ExternalType") {
                    self.externalType = dict["ExternalType"] as! String
                }
                if dict.keys.contains("FixedCheck") {
                    self.fixedCheck = dict["FixedCheck"] as! Bool
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsPrediction") {
                    self.isPrediction = dict["IsPrediction"] as! Bool
                }
                if dict.keys.contains("LowerValue") {
                    self.lowerValue = dict["LowerValue"] as! Double
                }
                if dict.keys.contains("MatchExpression") {
                    self.matchExpression = dict["MatchExpression"] as! String
                }
                if dict.keys.contains("MethodName") {
                    self.methodName = dict["MethodName"] as! String
                }
                if dict.keys.contains("Op") {
                    self.op = dict["Op"] as! String
                }
                if dict.keys.contains("ProjectName") {
                    self.projectName = dict["ProjectName"] as! String
                }
                if dict.keys.contains("Property") {
                    self.property = dict["Property"] as! String
                }
                if dict.keys.contains("ReferenceValue") {
                    var tmp : [ListQualityResultsByEntityResponseBody.Data.RuleChecks.ReferenceValue] = []
                    for v in dict["ReferenceValue"] as! [Any] {
                        var model = ListQualityResultsByEntityResponseBody.Data.RuleChecks.ReferenceValue()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.referenceValue = tmp
                }
                if dict.keys.contains("ResultString") {
                    self.resultString = dict["ResultString"] as! String
                }
                if dict.keys.contains("RuleId") {
                    self.ruleId = dict["RuleId"] as! Int64
                }
                if dict.keys.contains("RuleName") {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("SampleValue") {
                    var tmp : [ListQualityResultsByEntityResponseBody.Data.RuleChecks.SampleValue] = []
                    for v in dict["SampleValue"] as! [Any] {
                        var model = ListQualityResultsByEntityResponseBody.Data.RuleChecks.SampleValue()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.sampleValue = tmp
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("TemplateId") {
                    self.templateId = dict["TemplateId"] as! Int32
                }
                if dict.keys.contains("TemplateName") {
                    self.templateName = dict["TemplateName"] as! String
                }
                if dict.keys.contains("TimeCost") {
                    self.timeCost = dict["TimeCost"] as! String
                }
                if dict.keys.contains("Trend") {
                    self.trend = dict["Trend"] as! String
                }
                if dict.keys.contains("UpperValue") {
                    self.upperValue = dict["UpperValue"] as! Double
                }
                if dict.keys.contains("WarningThreshold") {
                    self.warningThreshold = dict["WarningThreshold"] as! Double
                }
                if dict.keys.contains("WhereCondition") {
                    self.whereCondition = dict["WhereCondition"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var ruleChecks: [ListQualityResultsByEntityResponseBody.Data.RuleChecks]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.ruleChecks != nil {
                var tmp : [Any] = []
                for k in self.ruleChecks! {
                    tmp.append(k.toMap())
                }
                map["RuleChecks"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("RuleChecks") {
                var tmp : [ListQualityResultsByEntityResponseBody.Data.RuleChecks] = []
                for v in dict["RuleChecks"] as! [Any] {
                    var model = ListQualityResultsByEntityResponseBody.Data.RuleChecks()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ruleChecks = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: ListQualityResultsByEntityResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListQualityResultsByEntityResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListQualityResultsByEntityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListQualityResultsByEntityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListQualityResultsByEntityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListQualityResultsByRuleRequest : Tea.TeaModel {
    public var endDate: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectName: String?

    public var ruleId: Int64?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! Int64
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class ListQualityResultsByRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RuleChecks : Tea.TeaModel {
            public class ReferenceValue : Tea.TeaModel {
                public var bizDate: String?

                public var discreteProperty: String?

                public var singleCheckResult: Int32?

                public var threshold: Double?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizDate != nil {
                        map["BizDate"] = self.bizDate!
                    }
                    if self.discreteProperty != nil {
                        map["DiscreteProperty"] = self.discreteProperty!
                    }
                    if self.singleCheckResult != nil {
                        map["SingleCheckResult"] = self.singleCheckResult!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BizDate") {
                        self.bizDate = dict["BizDate"] as! String
                    }
                    if dict.keys.contains("DiscreteProperty") {
                        self.discreteProperty = dict["DiscreteProperty"] as! String
                    }
                    if dict.keys.contains("SingleCheckResult") {
                        self.singleCheckResult = dict["SingleCheckResult"] as! Int32
                    }
                    if dict.keys.contains("Threshold") {
                        self.threshold = dict["Threshold"] as! Double
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public class SampleValue : Tea.TeaModel {
                public var bizDate: String?

                public var discreteProperty: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizDate != nil {
                        map["BizDate"] = self.bizDate!
                    }
                    if self.discreteProperty != nil {
                        map["DiscreteProperty"] = self.discreteProperty!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BizDate") {
                        self.bizDate = dict["BizDate"] as! String
                    }
                    if dict.keys.contains("DiscreteProperty") {
                        self.discreteProperty = dict["DiscreteProperty"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public var actualExpression: String?

            public var beginTime: Int64?

            public var bizDate: Int64?

            public var blockType: Int32?

            public var checkResult: Int32?

            public var checkResultStatus: Int32?

            public var checkerId: Int32?

            public var checkerName: String?

            public var checkerType: Int32?

            public var comment: String?

            public var criticalThreshold: Double?

            public var dateType: String?

            public var discreteCheck: Bool?

            public var endTime: Int64?

            public var entityId: Int64?

            public var expectValue: Double?

            public var externalId: String?

            public var externalType: String?

            public var fixedCheck: Bool?

            public var id: Int64?

            public var isPrediction: Bool?

            public var lowerValue: Double?

            public var matchExpression: String?

            public var methodName: String?

            public var op: String?

            public var open_: Bool?

            public var projectName: String?

            public var property: String?

            public var referenceValue: [ListQualityResultsByRuleResponseBody.Data.RuleChecks.ReferenceValue]?

            public var resultString: String?

            public var ruleId: Int64?

            public var ruleName: String?

            public var sampleValue: [ListQualityResultsByRuleResponseBody.Data.RuleChecks.SampleValue]?

            public var tableName: String?

            public var taskId: String?

            public var templateId: Int32?

            public var templateName: String?

            public var timeCost: String?

            public var trend: String?

            public var upperValue: Double?

            public var warningThreshold: Double?

            public var whereCondition: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actualExpression != nil {
                    map["ActualExpression"] = self.actualExpression!
                }
                if self.beginTime != nil {
                    map["BeginTime"] = self.beginTime!
                }
                if self.bizDate != nil {
                    map["BizDate"] = self.bizDate!
                }
                if self.blockType != nil {
                    map["BlockType"] = self.blockType!
                }
                if self.checkResult != nil {
                    map["CheckResult"] = self.checkResult!
                }
                if self.checkResultStatus != nil {
                    map["CheckResultStatus"] = self.checkResultStatus!
                }
                if self.checkerId != nil {
                    map["CheckerId"] = self.checkerId!
                }
                if self.checkerName != nil {
                    map["CheckerName"] = self.checkerName!
                }
                if self.checkerType != nil {
                    map["CheckerType"] = self.checkerType!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.criticalThreshold != nil {
                    map["CriticalThreshold"] = self.criticalThreshold!
                }
                if self.dateType != nil {
                    map["DateType"] = self.dateType!
                }
                if self.discreteCheck != nil {
                    map["DiscreteCheck"] = self.discreteCheck!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.entityId != nil {
                    map["EntityId"] = self.entityId!
                }
                if self.expectValue != nil {
                    map["ExpectValue"] = self.expectValue!
                }
                if self.externalId != nil {
                    map["ExternalId"] = self.externalId!
                }
                if self.externalType != nil {
                    map["ExternalType"] = self.externalType!
                }
                if self.fixedCheck != nil {
                    map["FixedCheck"] = self.fixedCheck!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isPrediction != nil {
                    map["IsPrediction"] = self.isPrediction!
                }
                if self.lowerValue != nil {
                    map["LowerValue"] = self.lowerValue!
                }
                if self.matchExpression != nil {
                    map["MatchExpression"] = self.matchExpression!
                }
                if self.methodName != nil {
                    map["MethodName"] = self.methodName!
                }
                if self.op != nil {
                    map["Op"] = self.op!
                }
                if self.open_ != nil {
                    map["Open"] = self.open_!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                if self.property != nil {
                    map["Property"] = self.property!
                }
                if self.referenceValue != nil {
                    var tmp : [Any] = []
                    for k in self.referenceValue! {
                        tmp.append(k.toMap())
                    }
                    map["ReferenceValue"] = tmp
                }
                if self.resultString != nil {
                    map["ResultString"] = self.resultString!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.sampleValue != nil {
                    var tmp : [Any] = []
                    for k in self.sampleValue! {
                        tmp.append(k.toMap())
                    }
                    map["SampleValue"] = tmp
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.timeCost != nil {
                    map["TimeCost"] = self.timeCost!
                }
                if self.trend != nil {
                    map["Trend"] = self.trend!
                }
                if self.upperValue != nil {
                    map["UpperValue"] = self.upperValue!
                }
                if self.warningThreshold != nil {
                    map["WarningThreshold"] = self.warningThreshold!
                }
                if self.whereCondition != nil {
                    map["WhereCondition"] = self.whereCondition!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActualExpression") {
                    self.actualExpression = dict["ActualExpression"] as! String
                }
                if dict.keys.contains("BeginTime") {
                    self.beginTime = dict["BeginTime"] as! Int64
                }
                if dict.keys.contains("BizDate") {
                    self.bizDate = dict["BizDate"] as! Int64
                }
                if dict.keys.contains("BlockType") {
                    self.blockType = dict["BlockType"] as! Int32
                }
                if dict.keys.contains("CheckResult") {
                    self.checkResult = dict["CheckResult"] as! Int32
                }
                if dict.keys.contains("CheckResultStatus") {
                    self.checkResultStatus = dict["CheckResultStatus"] as! Int32
                }
                if dict.keys.contains("CheckerId") {
                    self.checkerId = dict["CheckerId"] as! Int32
                }
                if dict.keys.contains("CheckerName") {
                    self.checkerName = dict["CheckerName"] as! String
                }
                if dict.keys.contains("CheckerType") {
                    self.checkerType = dict["CheckerType"] as! Int32
                }
                if dict.keys.contains("Comment") {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("CriticalThreshold") {
                    self.criticalThreshold = dict["CriticalThreshold"] as! Double
                }
                if dict.keys.contains("DateType") {
                    self.dateType = dict["DateType"] as! String
                }
                if dict.keys.contains("DiscreteCheck") {
                    self.discreteCheck = dict["DiscreteCheck"] as! Bool
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("EntityId") {
                    self.entityId = dict["EntityId"] as! Int64
                }
                if dict.keys.contains("ExpectValue") {
                    self.expectValue = dict["ExpectValue"] as! Double
                }
                if dict.keys.contains("ExternalId") {
                    self.externalId = dict["ExternalId"] as! String
                }
                if dict.keys.contains("ExternalType") {
                    self.externalType = dict["ExternalType"] as! String
                }
                if dict.keys.contains("FixedCheck") {
                    self.fixedCheck = dict["FixedCheck"] as! Bool
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsPrediction") {
                    self.isPrediction = dict["IsPrediction"] as! Bool
                }
                if dict.keys.contains("LowerValue") {
                    self.lowerValue = dict["LowerValue"] as! Double
                }
                if dict.keys.contains("MatchExpression") {
                    self.matchExpression = dict["MatchExpression"] as! String
                }
                if dict.keys.contains("MethodName") {
                    self.methodName = dict["MethodName"] as! String
                }
                if dict.keys.contains("Op") {
                    self.op = dict["Op"] as! String
                }
                if dict.keys.contains("Open") {
                    self.open_ = dict["Open"] as! Bool
                }
                if dict.keys.contains("ProjectName") {
                    self.projectName = dict["ProjectName"] as! String
                }
                if dict.keys.contains("Property") {
                    self.property = dict["Property"] as! String
                }
                if dict.keys.contains("ReferenceValue") {
                    var tmp : [ListQualityResultsByRuleResponseBody.Data.RuleChecks.ReferenceValue] = []
                    for v in dict["ReferenceValue"] as! [Any] {
                        var model = ListQualityResultsByRuleResponseBody.Data.RuleChecks.ReferenceValue()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.referenceValue = tmp
                }
                if dict.keys.contains("ResultString") {
                    self.resultString = dict["ResultString"] as! String
                }
                if dict.keys.contains("RuleId") {
                    self.ruleId = dict["RuleId"] as! Int64
                }
                if dict.keys.contains("RuleName") {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("SampleValue") {
                    var tmp : [ListQualityResultsByRuleResponseBody.Data.RuleChecks.SampleValue] = []
                    for v in dict["SampleValue"] as! [Any] {
                        var model = ListQualityResultsByRuleResponseBody.Data.RuleChecks.SampleValue()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.sampleValue = tmp
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("TemplateId") {
                    self.templateId = dict["TemplateId"] as! Int32
                }
                if dict.keys.contains("TemplateName") {
                    self.templateName = dict["TemplateName"] as! String
                }
                if dict.keys.contains("TimeCost") {
                    self.timeCost = dict["TimeCost"] as! String
                }
                if dict.keys.contains("Trend") {
                    self.trend = dict["Trend"] as! String
                }
                if dict.keys.contains("UpperValue") {
                    self.upperValue = dict["UpperValue"] as! Double
                }
                if dict.keys.contains("WarningThreshold") {
                    self.warningThreshold = dict["WarningThreshold"] as! Double
                }
                if dict.keys.contains("WhereCondition") {
                    self.whereCondition = dict["WhereCondition"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var ruleChecks: [ListQualityResultsByRuleResponseBody.Data.RuleChecks]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.ruleChecks != nil {
                var tmp : [Any] = []
                for k in self.ruleChecks! {
                    tmp.append(k.toMap())
                }
                map["RuleChecks"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("RuleChecks") {
                var tmp : [ListQualityResultsByRuleResponseBody.Data.RuleChecks] = []
                for v in dict["RuleChecks"] as! [Any] {
                    var model = ListQualityResultsByRuleResponseBody.Data.RuleChecks()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ruleChecks = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: ListQualityResultsByRuleResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListQualityResultsByRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListQualityResultsByRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListQualityResultsByRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListQualityResultsByRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListQualityRulesRequest : Tea.TeaModel {
    public var entityId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
    }
}

public class ListQualityRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Rules : Tea.TeaModel {
            public var blockType: Int32?

            public var checkerId: Int32?

            public var comment: String?

            public var criticalThreshold: String?

            public var entityId: Int64?

            public var expectValue: String?

            public var fixCheck: Bool?

            public var historyCriticalThreshold: String?

            public var historyWarningThreshold: String?

            public var id: Int64?

            public var matchExpression: String?

            public var methodId: Int32?

            public var methodName: String?

            public var onDuty: String?

            public var onDutyAccountName: String?

            public var projectName: String?

            public var property: String?

            public var propertyKey: String?

            public var ruleCheckerRelationId: Int64?

            public var ruleName: String?

            public var ruleType: Int32?

            public var tableName: String?

            public var templateId: Int32?

            public var templateName: String?

            public var trend: String?

            public var warningThreshold: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blockType != nil {
                    map["BlockType"] = self.blockType!
                }
                if self.checkerId != nil {
                    map["CheckerId"] = self.checkerId!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.criticalThreshold != nil {
                    map["CriticalThreshold"] = self.criticalThreshold!
                }
                if self.entityId != nil {
                    map["EntityId"] = self.entityId!
                }
                if self.expectValue != nil {
                    map["ExpectValue"] = self.expectValue!
                }
                if self.fixCheck != nil {
                    map["FixCheck"] = self.fixCheck!
                }
                if self.historyCriticalThreshold != nil {
                    map["HistoryCriticalThreshold"] = self.historyCriticalThreshold!
                }
                if self.historyWarningThreshold != nil {
                    map["HistoryWarningThreshold"] = self.historyWarningThreshold!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.matchExpression != nil {
                    map["MatchExpression"] = self.matchExpression!
                }
                if self.methodId != nil {
                    map["MethodId"] = self.methodId!
                }
                if self.methodName != nil {
                    map["MethodName"] = self.methodName!
                }
                if self.onDuty != nil {
                    map["OnDuty"] = self.onDuty!
                }
                if self.onDutyAccountName != nil {
                    map["OnDutyAccountName"] = self.onDutyAccountName!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                if self.property != nil {
                    map["Property"] = self.property!
                }
                if self.propertyKey != nil {
                    map["PropertyKey"] = self.propertyKey!
                }
                if self.ruleCheckerRelationId != nil {
                    map["RuleCheckerRelationId"] = self.ruleCheckerRelationId!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.ruleType != nil {
                    map["RuleType"] = self.ruleType!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.trend != nil {
                    map["Trend"] = self.trend!
                }
                if self.warningThreshold != nil {
                    map["WarningThreshold"] = self.warningThreshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BlockType") {
                    self.blockType = dict["BlockType"] as! Int32
                }
                if dict.keys.contains("CheckerId") {
                    self.checkerId = dict["CheckerId"] as! Int32
                }
                if dict.keys.contains("Comment") {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("CriticalThreshold") {
                    self.criticalThreshold = dict["CriticalThreshold"] as! String
                }
                if dict.keys.contains("EntityId") {
                    self.entityId = dict["EntityId"] as! Int64
                }
                if dict.keys.contains("ExpectValue") {
                    self.expectValue = dict["ExpectValue"] as! String
                }
                if dict.keys.contains("FixCheck") {
                    self.fixCheck = dict["FixCheck"] as! Bool
                }
                if dict.keys.contains("HistoryCriticalThreshold") {
                    self.historyCriticalThreshold = dict["HistoryCriticalThreshold"] as! String
                }
                if dict.keys.contains("HistoryWarningThreshold") {
                    self.historyWarningThreshold = dict["HistoryWarningThreshold"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("MatchExpression") {
                    self.matchExpression = dict["MatchExpression"] as! String
                }
                if dict.keys.contains("MethodId") {
                    self.methodId = dict["MethodId"] as! Int32
                }
                if dict.keys.contains("MethodName") {
                    self.methodName = dict["MethodName"] as! String
                }
                if dict.keys.contains("OnDuty") {
                    self.onDuty = dict["OnDuty"] as! String
                }
                if dict.keys.contains("OnDutyAccountName") {
                    self.onDutyAccountName = dict["OnDutyAccountName"] as! String
                }
                if dict.keys.contains("ProjectName") {
                    self.projectName = dict["ProjectName"] as! String
                }
                if dict.keys.contains("Property") {
                    self.property = dict["Property"] as! String
                }
                if dict.keys.contains("PropertyKey") {
                    self.propertyKey = dict["PropertyKey"] as! String
                }
                if dict.keys.contains("RuleCheckerRelationId") {
                    self.ruleCheckerRelationId = dict["RuleCheckerRelationId"] as! Int64
                }
                if dict.keys.contains("RuleName") {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("RuleType") {
                    self.ruleType = dict["RuleType"] as! Int32
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("TemplateId") {
                    self.templateId = dict["TemplateId"] as! Int32
                }
                if dict.keys.contains("TemplateName") {
                    self.templateName = dict["TemplateName"] as! String
                }
                if dict.keys.contains("Trend") {
                    self.trend = dict["Trend"] as! String
                }
                if dict.keys.contains("WarningThreshold") {
                    self.warningThreshold = dict["WarningThreshold"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var rules: [ListQualityRulesResponseBody.Data.Rules]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Rules") {
                var tmp : [ListQualityRulesResponseBody.Data.Rules] = []
                for v in dict["Rules"] as! [Any] {
                    var model = ListQualityRulesResponseBody.Data.Rules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.rules = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: ListQualityRulesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListQualityRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListQualityRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListQualityRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListQualityRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRefDISyncTasksRequest : Tea.TeaModel {
    public var datasourceName: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var projectId: Int64?

    public var refType: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasourceName != nil {
            map["DatasourceName"] = self.datasourceName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.refType != nil {
            map["RefType"] = self.refType!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasourceName") {
            self.datasourceName = dict["DatasourceName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RefType") {
            self.refType = dict["RefType"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class ListRefDISyncTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DISyncTasks : Tea.TeaModel {
            public var diDestinationDatasource: String?

            public var diSourceDatasource: String?

            public var nodeId: Int64?

            public var nodeName: String?

            public var taskType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diDestinationDatasource != nil {
                    map["DiDestinationDatasource"] = self.diDestinationDatasource!
                }
                if self.diSourceDatasource != nil {
                    map["DiSourceDatasource"] = self.diSourceDatasource!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiDestinationDatasource") {
                    self.diDestinationDatasource = dict["DiDestinationDatasource"] as! String
                }
                if dict.keys.contains("DiSourceDatasource") {
                    self.diSourceDatasource = dict["DiSourceDatasource"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("TaskType") {
                    self.taskType = dict["TaskType"] as! String
                }
            }
        }
        public var DISyncTasks: [ListRefDISyncTasksResponseBody.Data.DISyncTasks]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DISyncTasks != nil {
                var tmp : [Any] = []
                for k in self.DISyncTasks! {
                    tmp.append(k.toMap())
                }
                map["DISyncTasks"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DISyncTasks") {
                var tmp : [ListRefDISyncTasksResponseBody.Data.DISyncTasks] = []
                for v in dict["DISyncTasks"] as! [Any] {
                    var model = ListRefDISyncTasksResponseBody.Data.DISyncTasks()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.DISyncTasks = tmp
            }
        }
    }
    public var data: ListRefDISyncTasksResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListRefDISyncTasksResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListRefDISyncTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRefDISyncTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRefDISyncTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRemindsRequest : Tea.TeaModel {
    public var alertTarget: String?

    public var founder: String?

    public var nodeId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remindTypes: String?

    public var searchText: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertTarget != nil {
            map["AlertTarget"] = self.alertTarget!
        }
        if self.founder != nil {
            map["Founder"] = self.founder!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remindTypes != nil {
            map["RemindTypes"] = self.remindTypes!
        }
        if self.searchText != nil {
            map["SearchText"] = self.searchText!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertTarget") {
            self.alertTarget = dict["AlertTarget"] as! String
        }
        if dict.keys.contains("Founder") {
            self.founder = dict["Founder"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RemindTypes") {
            self.remindTypes = dict["RemindTypes"] as! String
        }
        if dict.keys.contains("SearchText") {
            self.searchText = dict["SearchText"] as! String
        }
    }
}

public class ListRemindsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Reminds : Tea.TeaModel {
            public var alertMethods: [String]?

            public var alertTargets: [String]?

            public var alertUnit: String?

            public var baselineIds: [Int64]?

            public var bizProcessIds: [Int64]?

            public var dndEnd: String?

            public var dndStart: String?

            public var founder: String?

            public var nodeIds: [Int64]?

            public var projectIds: [Int64]?

            public var remindId: Int64?

            public var remindName: String?

            public var remindType: String?

            public var remindUnit: String?

            public var useflag: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertMethods != nil {
                    map["AlertMethods"] = self.alertMethods!
                }
                if self.alertTargets != nil {
                    map["AlertTargets"] = self.alertTargets!
                }
                if self.alertUnit != nil {
                    map["AlertUnit"] = self.alertUnit!
                }
                if self.baselineIds != nil {
                    map["BaselineIds"] = self.baselineIds!
                }
                if self.bizProcessIds != nil {
                    map["BizProcessIds"] = self.bizProcessIds!
                }
                if self.dndEnd != nil {
                    map["DndEnd"] = self.dndEnd!
                }
                if self.dndStart != nil {
                    map["DndStart"] = self.dndStart!
                }
                if self.founder != nil {
                    map["Founder"] = self.founder!
                }
                if self.nodeIds != nil {
                    map["NodeIds"] = self.nodeIds!
                }
                if self.projectIds != nil {
                    map["ProjectIds"] = self.projectIds!
                }
                if self.remindId != nil {
                    map["RemindId"] = self.remindId!
                }
                if self.remindName != nil {
                    map["RemindName"] = self.remindName!
                }
                if self.remindType != nil {
                    map["RemindType"] = self.remindType!
                }
                if self.remindUnit != nil {
                    map["RemindUnit"] = self.remindUnit!
                }
                if self.useflag != nil {
                    map["Useflag"] = self.useflag!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertMethods") {
                    self.alertMethods = dict["AlertMethods"] as! [String]
                }
                if dict.keys.contains("AlertTargets") {
                    self.alertTargets = dict["AlertTargets"] as! [String]
                }
                if dict.keys.contains("AlertUnit") {
                    self.alertUnit = dict["AlertUnit"] as! String
                }
                if dict.keys.contains("BaselineIds") {
                    self.baselineIds = dict["BaselineIds"] as! [Int64]
                }
                if dict.keys.contains("BizProcessIds") {
                    self.bizProcessIds = dict["BizProcessIds"] as! [Int64]
                }
                if dict.keys.contains("DndEnd") {
                    self.dndEnd = dict["DndEnd"] as! String
                }
                if dict.keys.contains("DndStart") {
                    self.dndStart = dict["DndStart"] as! String
                }
                if dict.keys.contains("Founder") {
                    self.founder = dict["Founder"] as! String
                }
                if dict.keys.contains("NodeIds") {
                    self.nodeIds = dict["NodeIds"] as! [Int64]
                }
                if dict.keys.contains("ProjectIds") {
                    self.projectIds = dict["ProjectIds"] as! [Int64]
                }
                if dict.keys.contains("RemindId") {
                    self.remindId = dict["RemindId"] as! Int64
                }
                if dict.keys.contains("RemindName") {
                    self.remindName = dict["RemindName"] as! String
                }
                if dict.keys.contains("RemindType") {
                    self.remindType = dict["RemindType"] as! String
                }
                if dict.keys.contains("RemindUnit") {
                    self.remindUnit = dict["RemindUnit"] as! String
                }
                if dict.keys.contains("Useflag") {
                    self.useflag = dict["Useflag"] as! Bool
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var reminds: [ListRemindsResponseBody.Data.Reminds]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.reminds != nil {
                var tmp : [Any] = []
                for k in self.reminds! {
                    tmp.append(k.toMap())
                }
                map["Reminds"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Reminds") {
                var tmp : [ListRemindsResponseBody.Data.Reminds] = []
                for v in dict["Reminds"] as! [Any] {
                    var model = ListRemindsResponseBody.Data.Reminds()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.reminds = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListRemindsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListRemindsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListRemindsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRemindsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRemindsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListResourceGroupsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var bizExtKey: String?

    public var keyword: String?

    public var resourceGroupType: Int32?

    public var resourceManagerResourceGroupId: String?

    public var tags: [ListResourceGroupsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizExtKey != nil {
            map["BizExtKey"] = self.bizExtKey!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.resourceGroupType != nil {
            map["ResourceGroupType"] = self.resourceGroupType!
        }
        if self.resourceManagerResourceGroupId != nil {
            map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizExtKey") {
            self.bizExtKey = dict["BizExtKey"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("ResourceGroupType") {
            self.resourceGroupType = dict["ResourceGroupType"] as! Int32
        }
        if dict.keys.contains("ResourceManagerResourceGroupId") {
            self.resourceManagerResourceGroupId = dict["ResourceManagerResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListResourceGroupsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListResourceGroupsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListResourceGroupsShrinkRequest : Tea.TeaModel {
    public var bizExtKey: String?

    public var keyword: String?

    public var resourceGroupType: Int32?

    public var resourceManagerResourceGroupId: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizExtKey != nil {
            map["BizExtKey"] = self.bizExtKey!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.resourceGroupType != nil {
            map["ResourceGroupType"] = self.resourceGroupType!
        }
        if self.resourceManagerResourceGroupId != nil {
            map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizExtKey") {
            self.bizExtKey = dict["BizExtKey"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("ResourceGroupType") {
            self.resourceGroupType = dict["ResourceGroupType"] as! Int32
        }
        if dict.keys.contains("ResourceManagerResourceGroupId") {
            self.resourceManagerResourceGroupId = dict["ResourceManagerResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tagsShrink = dict["Tags"] as! String
        }
    }
}

public class ListResourceGroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var bizExtKey: String?

        public var cluster: String?

        public var createTime: String?

        public var enableKp: Bool?

        public var id: Int64?

        public var identifier: String?

        public var isDefault: Bool?

        public var mode: String?

        public var name: String?

        public var resourceGroupType: String?

        public var resourceManagerResourceGroupId: String?

        public var sequence: Int32?

        public var specs: [String: Any]?

        public var status: Int32?

        public var tags: [ListResourceGroupsResponseBody.Data.Tags]?

        public var tenantId: Int64?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizExtKey != nil {
                map["BizExtKey"] = self.bizExtKey!
            }
            if self.cluster != nil {
                map["Cluster"] = self.cluster!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.enableKp != nil {
                map["EnableKp"] = self.enableKp!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.identifier != nil {
                map["Identifier"] = self.identifier!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.resourceGroupType != nil {
                map["ResourceGroupType"] = self.resourceGroupType!
            }
            if self.resourceManagerResourceGroupId != nil {
                map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
            }
            if self.sequence != nil {
                map["Sequence"] = self.sequence!
            }
            if self.specs != nil {
                map["Specs"] = self.specs!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizExtKey") {
                self.bizExtKey = dict["BizExtKey"] as! String
            }
            if dict.keys.contains("Cluster") {
                self.cluster = dict["Cluster"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("EnableKp") {
                self.enableKp = dict["EnableKp"] as! Bool
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Identifier") {
                self.identifier = dict["Identifier"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("Mode") {
                self.mode = dict["Mode"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ResourceGroupType") {
                self.resourceGroupType = dict["ResourceGroupType"] as! String
            }
            if dict.keys.contains("ResourceManagerResourceGroupId") {
                self.resourceManagerResourceGroupId = dict["ResourceManagerResourceGroupId"] as! String
            }
            if dict.keys.contains("Sequence") {
                self.sequence = dict["Sequence"] as! Int32
            }
            if dict.keys.contains("Specs") {
                self.specs = dict["Specs"] as! [String: Any]
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Tags") {
                var tmp : [ListResourceGroupsResponseBody.Data.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListResourceGroupsResponseBody.Data.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var data: [ListResourceGroupsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListResourceGroupsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListResourceGroupsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListResourceGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResourceGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListResourceGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListShiftPersonnelsRequest : Tea.TeaModel {
    public var beginTime: Int64?

    public var endTime: Int64?

    public var shiftPersonUID: String?

    public var shiftScheduleIdentifier: String?

    public var userType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.shiftPersonUID != nil {
            map["ShiftPersonUID"] = self.shiftPersonUID!
        }
        if self.shiftScheduleIdentifier != nil {
            map["ShiftScheduleIdentifier"] = self.shiftScheduleIdentifier!
        }
        if self.userType != nil {
            map["UserType"] = self.userType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTime") {
            self.beginTime = dict["BeginTime"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ShiftPersonUID") {
            self.shiftPersonUID = dict["ShiftPersonUID"] as! String
        }
        if dict.keys.contains("ShiftScheduleIdentifier") {
            self.shiftScheduleIdentifier = dict["ShiftScheduleIdentifier"] as! String
        }
        if dict.keys.contains("UserType") {
            self.userType = dict["UserType"] as! String
        }
    }
}

public class ListShiftPersonnelsResponseBody : Tea.TeaModel {
    public class Paging : Tea.TeaModel {
        public class ShiftPersons : Tea.TeaModel {
            public var beginTime: Int64?

            public var endTime: Int64?

            public var shiftPersonName: String?

            public var shiftPersonUID: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beginTime != nil {
                    map["BeginTime"] = self.beginTime!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.shiftPersonName != nil {
                    map["ShiftPersonName"] = self.shiftPersonName!
                }
                if self.shiftPersonUID != nil {
                    map["ShiftPersonUID"] = self.shiftPersonUID!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BeginTime") {
                    self.beginTime = dict["BeginTime"] as! Int64
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("ShiftPersonName") {
                    self.shiftPersonName = dict["ShiftPersonName"] as! String
                }
                if dict.keys.contains("ShiftPersonUID") {
                    self.shiftPersonUID = dict["ShiftPersonUID"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var shiftPersons: [ListShiftPersonnelsResponseBody.Paging.ShiftPersons]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.shiftPersons != nil {
                var tmp : [Any] = []
                for k in self.shiftPersons! {
                    tmp.append(k.toMap())
                }
                map["ShiftPersons"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("ShiftPersons") {
                var tmp : [ListShiftPersonnelsResponseBody.Paging.ShiftPersons] = []
                for v in dict["ShiftPersons"] as! [Any] {
                    var model = ListShiftPersonnelsResponseBody.Paging.ShiftPersons()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.shiftPersons = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var paging: ListShiftPersonnelsResponseBody.Paging?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.paging?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.paging != nil {
            map["Paging"] = self.paging?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Paging") {
            var model = ListShiftPersonnelsResponseBody.Paging()
            model.fromMap(dict["Paging"] as! [String: Any])
            self.paging = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListShiftPersonnelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListShiftPersonnelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListShiftPersonnelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListShiftSchedulesRequest : Tea.TeaModel {
    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var shiftScheduleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.shiftScheduleName != nil {
            map["ShiftScheduleName"] = self.shiftScheduleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ShiftScheduleName") {
            self.shiftScheduleName = dict["ShiftScheduleName"] as! String
        }
    }
}

public class ListShiftSchedulesResponseBody : Tea.TeaModel {
    public class Paging : Tea.TeaModel {
        public class ShiftSchedules : Tea.TeaModel {
            public var shiftScheduleIdentifier: String?

            public var shiftScheduleName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.shiftScheduleIdentifier != nil {
                    map["ShiftScheduleIdentifier"] = self.shiftScheduleIdentifier!
                }
                if self.shiftScheduleName != nil {
                    map["ShiftScheduleName"] = self.shiftScheduleName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ShiftScheduleIdentifier") {
                    self.shiftScheduleIdentifier = dict["ShiftScheduleIdentifier"] as! String
                }
                if dict.keys.contains("ShiftScheduleName") {
                    self.shiftScheduleName = dict["ShiftScheduleName"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var shiftSchedules: [ListShiftSchedulesResponseBody.Paging.ShiftSchedules]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.shiftSchedules != nil {
                var tmp : [Any] = []
                for k in self.shiftSchedules! {
                    tmp.append(k.toMap())
                }
                map["ShiftSchedules"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("ShiftSchedules") {
                var tmp : [ListShiftSchedulesResponseBody.Paging.ShiftSchedules] = []
                for v in dict["ShiftSchedules"] as! [Any] {
                    var model = ListShiftSchedulesResponseBody.Paging.ShiftSchedules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.shiftSchedules = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var paging: ListShiftSchedulesResponseBody.Paging?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.paging?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.paging != nil {
            map["Paging"] = self.paging?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Paging") {
            var model = ListShiftSchedulesResponseBody.Paging()
            model.fromMap(dict["Paging"] as! [String: Any])
            self.paging = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListShiftSchedulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListShiftSchedulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListShiftSchedulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSuccessInstanceAmountRequest : Tea.TeaModel {
    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class ListSuccessInstanceAmountResponseBody : Tea.TeaModel {
    public class InstanceStatusTrend : Tea.TeaModel {
        public class AvgTrend : Tea.TeaModel {
            public var count: Int32?

            public var timePoint: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timePoint != nil {
                    map["TimePoint"] = self.timePoint!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("TimePoint") {
                    self.timePoint = dict["TimePoint"] as! String
                }
            }
        }
        public class TodayTrend : Tea.TeaModel {
            public var count: Int32?

            public var timePoint: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timePoint != nil {
                    map["TimePoint"] = self.timePoint!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("TimePoint") {
                    self.timePoint = dict["TimePoint"] as! String
                }
            }
        }
        public class YesterdayTrend : Tea.TeaModel {
            public var count: Int32?

            public var timePoint: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timePoint != nil {
                    map["TimePoint"] = self.timePoint!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("TimePoint") {
                    self.timePoint = dict["TimePoint"] as! String
                }
            }
        }
        public var avgTrend: [ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.AvgTrend]?

        public var todayTrend: [ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.TodayTrend]?

        public var yesterdayTrend: [ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.YesterdayTrend]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avgTrend != nil {
                var tmp : [Any] = []
                for k in self.avgTrend! {
                    tmp.append(k.toMap())
                }
                map["AvgTrend"] = tmp
            }
            if self.todayTrend != nil {
                var tmp : [Any] = []
                for k in self.todayTrend! {
                    tmp.append(k.toMap())
                }
                map["TodayTrend"] = tmp
            }
            if self.yesterdayTrend != nil {
                var tmp : [Any] = []
                for k in self.yesterdayTrend! {
                    tmp.append(k.toMap())
                }
                map["YesterdayTrend"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvgTrend") {
                var tmp : [ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.AvgTrend] = []
                for v in dict["AvgTrend"] as! [Any] {
                    var model = ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.AvgTrend()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.avgTrend = tmp
            }
            if dict.keys.contains("TodayTrend") {
                var tmp : [ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.TodayTrend] = []
                for v in dict["TodayTrend"] as! [Any] {
                    var model = ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.TodayTrend()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.todayTrend = tmp
            }
            if dict.keys.contains("YesterdayTrend") {
                var tmp : [ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.YesterdayTrend] = []
                for v in dict["YesterdayTrend"] as! [Any] {
                    var model = ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.YesterdayTrend()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.yesterdayTrend = tmp
            }
        }
    }
    public var instanceStatusTrend: ListSuccessInstanceAmountResponseBody.InstanceStatusTrend?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceStatusTrend?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceStatusTrend != nil {
            map["InstanceStatusTrend"] = self.instanceStatusTrend?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceStatusTrend") {
            var model = ListSuccessInstanceAmountResponseBody.InstanceStatusTrend()
            model.fromMap(dict["InstanceStatusTrend"] as! [String: Any])
            self.instanceStatusTrend = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSuccessInstanceAmountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSuccessInstanceAmountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSuccessInstanceAmountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTableLevelRequest : Tea.TeaModel {
    public var levelType: Int32?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.levelType != nil {
            map["LevelType"] = self.levelType!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LevelType") {
            self.levelType = dict["LevelType"] as! Int32
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class ListTableLevelResponseBody : Tea.TeaModel {
    public class TableLevelInfo : Tea.TeaModel {
        public class LevelList : Tea.TeaModel {
            public var description_: String?

            public var levelId: Int64?

            public var levelType: Int32?

            public var name: String?

            public var projectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.levelId != nil {
                    map["LevelId"] = self.levelId!
                }
                if self.levelType != nil {
                    map["LevelType"] = self.levelType!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("LevelId") {
                    self.levelId = dict["LevelId"] as! Int64
                }
                if dict.keys.contains("LevelType") {
                    self.levelType = dict["LevelType"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
            }
        }
        public var levelList: [ListTableLevelResponseBody.TableLevelInfo.LevelList]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.levelList != nil {
                var tmp : [Any] = []
                for k in self.levelList! {
                    tmp.append(k.toMap())
                }
                map["LevelList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LevelList") {
                var tmp : [ListTableLevelResponseBody.TableLevelInfo.LevelList] = []
                for v in dict["LevelList"] as! [Any] {
                    var model = ListTableLevelResponseBody.TableLevelInfo.LevelList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.levelList = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public var tableLevelInfo: ListTableLevelResponseBody.TableLevelInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tableLevelInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tableLevelInfo != nil {
            map["TableLevelInfo"] = self.tableLevelInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TableLevelInfo") {
            var model = ListTableLevelResponseBody.TableLevelInfo()
            model.fromMap(dict["TableLevelInfo"] as! [String: Any])
            self.tableLevelInfo = model
        }
    }
}

public class ListTableLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTableLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTableLevelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTableThemeRequest : Tea.TeaModel {
    public var pageNum: Int32?

    public var pageSize: Int32?

    public var parentId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class ListTableThemeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ThemeList : Tea.TeaModel {
            public var createTimeStamp: Int64?

            public var creator: String?

            public var level: Int32?

            public var name: String?

            public var parentId: Int64?

            public var projectId: Int64?

            public var themeId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTimeStamp != nil {
                    map["CreateTimeStamp"] = self.createTimeStamp!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.themeId != nil {
                    map["ThemeId"] = self.themeId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTimeStamp") {
                    self.createTimeStamp = dict["CreateTimeStamp"] as! Int64
                }
                if dict.keys.contains("Creator") {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("Level") {
                    self.level = dict["Level"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ParentId") {
                    self.parentId = dict["ParentId"] as! Int64
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("ThemeId") {
                    self.themeId = dict["ThemeId"] as! Int64
                }
            }
        }
        public var themeList: [ListTableThemeResponseBody.Data.ThemeList]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.themeList != nil {
                var tmp : [Any] = []
                for k in self.themeList! {
                    tmp.append(k.toMap())
                }
                map["ThemeList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ThemeList") {
                var tmp : [ListTableThemeResponseBody.Data.ThemeList] = []
                for v in dict["ThemeList"] as! [Any] {
                    var model = ListTableThemeResponseBody.Data.ThemeList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.themeList = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: ListTableThemeResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListTableThemeResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListTableThemeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTableThemeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTableThemeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTablesRequest : Tea.TeaModel {
    public var dataSourceType: String?

    public var nextToken: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListTablesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TableEntityList : Tea.TeaModel {
            public class EntityContent : Tea.TeaModel {
                public var dataSourceQualifiedName: String?

                public var dataSourceUniqueId: String?

                public var databaseName: String?

                public var instanceId: String?

                public var projectName: String?

                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataSourceQualifiedName != nil {
                        map["DataSourceQualifiedName"] = self.dataSourceQualifiedName!
                    }
                    if self.dataSourceUniqueId != nil {
                        map["DataSourceUniqueId"] = self.dataSourceUniqueId!
                    }
                    if self.databaseName != nil {
                        map["DatabaseName"] = self.databaseName!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.projectName != nil {
                        map["ProjectName"] = self.projectName!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DataSourceQualifiedName") {
                        self.dataSourceQualifiedName = dict["DataSourceQualifiedName"] as! String
                    }
                    if dict.keys.contains("DataSourceUniqueId") {
                        self.dataSourceUniqueId = dict["DataSourceUniqueId"] as! String
                    }
                    if dict.keys.contains("DatabaseName") {
                        self.databaseName = dict["DatabaseName"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("ProjectName") {
                        self.projectName = dict["ProjectName"] as! String
                    }
                    if dict.keys.contains("TableName") {
                        self.tableName = dict["TableName"] as! String
                    }
                }
            }
            public var entityContent: ListTablesResponseBody.Data.TableEntityList.EntityContent?

            public var entityQualifiedName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.entityContent?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.entityContent != nil {
                    map["EntityContent"] = self.entityContent?.toMap()
                }
                if self.entityQualifiedName != nil {
                    map["EntityQualifiedName"] = self.entityQualifiedName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EntityContent") {
                    var model = ListTablesResponseBody.Data.TableEntityList.EntityContent()
                    model.fromMap(dict["EntityContent"] as! [String: Any])
                    self.entityContent = model
                }
                if dict.keys.contains("EntityQualifiedName") {
                    self.entityQualifiedName = dict["EntityQualifiedName"] as! String
                }
            }
        }
        public var nextToken: String?

        public var tableEntityList: [ListTablesResponseBody.Data.TableEntityList]?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.tableEntityList != nil {
                var tmp : [Any] = []
                for k in self.tableEntityList! {
                    tmp.append(k.toMap())
                }
                map["TableEntityList"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
            if dict.keys.contains("TableEntityList") {
                var tmp : [ListTablesResponseBody.Data.TableEntityList] = []
                for v in dict["TableEntityList"] as! [Any] {
                    var model = ListTablesResponseBody.Data.TableEntityList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableEntityList = tmp
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var data: ListTablesResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListTablesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTopicsRequest : Tea.TeaModel {
    public var beginTime: String?

    public var endTime: String?

    public var instanceId: Int64?

    public var nodeId: Int64?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var topicStatuses: String?

    public var topicTypes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.topicStatuses != nil {
            map["TopicStatuses"] = self.topicStatuses!
        }
        if self.topicTypes != nil {
            map["TopicTypes"] = self.topicTypes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTime") {
            self.beginTime = dict["BeginTime"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TopicStatuses") {
            self.topicStatuses = dict["TopicStatuses"] as! String
        }
        if dict.keys.contains("TopicTypes") {
            self.topicTypes = dict["TopicTypes"] as! String
        }
    }
}

public class ListTopicsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Topics : Tea.TeaModel {
            public var addTime: Int64?

            public var fixTime: Int64?

            public var happenTime: Int64?

            public var instanceId: Int64?

            public var nodeId: Int64?

            public var nodeName: String?

            public var nodeOwner: String?

            public var projectId: Int64?

            public var topicId: Int64?

            public var topicName: String?

            public var topicStatus: String?

            public var topicType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addTime != nil {
                    map["AddTime"] = self.addTime!
                }
                if self.fixTime != nil {
                    map["FixTime"] = self.fixTime!
                }
                if self.happenTime != nil {
                    map["HappenTime"] = self.happenTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.nodeOwner != nil {
                    map["NodeOwner"] = self.nodeOwner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.topicId != nil {
                    map["TopicId"] = self.topicId!
                }
                if self.topicName != nil {
                    map["TopicName"] = self.topicName!
                }
                if self.topicStatus != nil {
                    map["TopicStatus"] = self.topicStatus!
                }
                if self.topicType != nil {
                    map["TopicType"] = self.topicType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddTime") {
                    self.addTime = dict["AddTime"] as! Int64
                }
                if dict.keys.contains("FixTime") {
                    self.fixTime = dict["FixTime"] as! Int64
                }
                if dict.keys.contains("HappenTime") {
                    self.happenTime = dict["HappenTime"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("NodeOwner") {
                    self.nodeOwner = dict["NodeOwner"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("TopicId") {
                    self.topicId = dict["TopicId"] as! Int64
                }
                if dict.keys.contains("TopicName") {
                    self.topicName = dict["TopicName"] as! String
                }
                if dict.keys.contains("TopicStatus") {
                    self.topicStatus = dict["TopicStatus"] as! String
                }
                if dict.keys.contains("TopicType") {
                    self.topicType = dict["TopicType"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var topics: [ListTopicsResponseBody.Data.Topics]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.topics != nil {
                var tmp : [Any] = []
                for k in self.topics! {
                    tmp.append(k.toMap())
                }
                map["Topics"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Topics") {
                var tmp : [ListTopicsResponseBody.Data.Topics] = []
                for v in dict["Topics"] as! [Any] {
                    var model = ListTopicsResponseBody.Data.Topics()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.topics = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: ListTopicsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListTopicsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListTopicsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTopicsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTopicsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OfflineNodeRequest : Tea.TeaModel {
    public var nodeId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class OfflineNodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class OfflineNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OfflineNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OfflineNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PublishDataServiceApiRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class PublishDataServiceApiResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PublishDataServiceApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublishDataServiceApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PublishDataServiceApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryDISyncTaskConfigProcessResultRequest : Tea.TeaModel {
    public var asyncProcessId: Int64?

    public var projectId: Int64?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asyncProcessId != nil {
            map["AsyncProcessId"] = self.asyncProcessId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AsyncProcessId") {
            self.asyncProcessId = dict["AsyncProcessId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class QueryDISyncTaskConfigProcessResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public var taskContent: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskContent != nil {
                map["TaskContent"] = self.taskContent!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskContent") {
                self.taskContent = dict["TaskContent"] as! String
            }
        }
    }
    public var data: QueryDISyncTaskConfigProcessResultResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = QueryDISyncTaskConfigProcessResultResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryDISyncTaskConfigProcessResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryDISyncTaskConfigProcessResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryDISyncTaskConfigProcessResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryDefaultTemplateRequest : Tea.TeaModel {
    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class QueryDefaultTemplateResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryDefaultTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryDefaultTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryDefaultTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryPublicModelEngineRequest : Tea.TeaModel {
    public var projectId: String?

    public var text: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.text != nil {
            map["Text"] = self.text!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Text") {
            self.text = dict["Text"] as! String
        }
    }
}

public class QueryPublicModelEngineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var returnValue: [[String: Any]]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.returnValue != nil {
            map["ReturnValue"] = self.returnValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReturnValue") {
            self.returnValue = dict["ReturnValue"] as! [[String: Any]]
        }
    }
}

public class QueryPublicModelEngineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryPublicModelEngineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryPublicModelEngineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryRecognizeDataByRuleTypeRequest : Tea.TeaModel {
    public var recognizeRulesType: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recognizeRulesType != nil {
            map["RecognizeRulesType"] = self.recognizeRulesType!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecognizeRulesType") {
            self.recognizeRulesType = dict["RecognizeRulesType"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class QueryRecognizeDataByRuleTypeResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryRecognizeDataByRuleTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryRecognizeDataByRuleTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryRecognizeDataByRuleTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryRecognizeRuleDetailRequest : Tea.TeaModel {
    public var sensitiveName: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sensitiveName != nil {
            map["SensitiveName"] = self.sensitiveName!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SensitiveName") {
            self.sensitiveName = dict["SensitiveName"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class QueryRecognizeRuleDetailResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryRecognizeRuleDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryRecognizeRuleDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryRecognizeRuleDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryRecognizeRulesTypeResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryRecognizeRulesTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryRecognizeRulesTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryRecognizeRulesTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySensClassificationRequest : Tea.TeaModel {
    public var templateId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class QuerySensClassificationResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QuerySensClassificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySensClassificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySensClassificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySensLevelRequest : Tea.TeaModel {
    public var templateId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantId != nil {
            map["tenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("tenantId") {
            self.tenantId = dict["tenantId"] as! String
        }
    }
}

public class QuerySensLevelResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QuerySensLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySensLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySensLevelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySensNodeInfoRequest : Tea.TeaModel {
    public var nodeId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sensitiveName: String?

    public var templateId: String?

    public var tenantId: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sensitiveName != nil {
            map["SensitiveName"] = self.sensitiveName!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SensitiveName") {
            self.sensitiveName = dict["SensitiveName"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! Int32
        }
    }
}

public class QuerySensNodeInfoResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QuerySensNodeInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySensNodeInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySensNodeInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterLineageRelationRequest : Tea.TeaModel {
    public var lineageRelationRegisterVO: LineageRelationRegisterVO?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lineageRelationRegisterVO?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lineageRelationRegisterVO != nil {
            map["LineageRelationRegisterVO"] = self.lineageRelationRegisterVO?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LineageRelationRegisterVO") {
            var model = LineageRelationRegisterVO()
            model.fromMap(dict["LineageRelationRegisterVO"] as! [String: Any])
            self.lineageRelationRegisterVO = model
        }
    }
}

public class RegisterLineageRelationShrinkRequest : Tea.TeaModel {
    public var lineageRelationRegisterVOShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lineageRelationRegisterVOShrink != nil {
            map["LineageRelationRegisterVO"] = self.lineageRelationRegisterVOShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LineageRelationRegisterVO") {
            self.lineageRelationRegisterVOShrink = dict["LineageRelationRegisterVO"] as! String
        }
    }
}

public class RegisterLineageRelationResponseBody : Tea.TeaModel {
    public class LineageRelation : Tea.TeaModel {
        public var destEntityQualifiedName: String?

        public var relationshipGuid: String?

        public var srcEntityQualifiedName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.destEntityQualifiedName != nil {
                map["DestEntityQualifiedName"] = self.destEntityQualifiedName!
            }
            if self.relationshipGuid != nil {
                map["RelationshipGuid"] = self.relationshipGuid!
            }
            if self.srcEntityQualifiedName != nil {
                map["SrcEntityQualifiedName"] = self.srcEntityQualifiedName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DestEntityQualifiedName") {
                self.destEntityQualifiedName = dict["DestEntityQualifiedName"] as! String
            }
            if dict.keys.contains("RelationshipGuid") {
                self.relationshipGuid = dict["RelationshipGuid"] as! String
            }
            if dict.keys.contains("SrcEntityQualifiedName") {
                self.srcEntityQualifiedName = dict["SrcEntityQualifiedName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var lineageRelation: RegisterLineageRelationResponseBody.LineageRelation?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lineageRelation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.lineageRelation != nil {
            map["LineageRelation"] = self.lineageRelation?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("LineageRelation") {
            var model = RegisterLineageRelationResponseBody.LineageRelation()
            model.fromMap(dict["LineageRelation"] as! [String: Any])
            self.lineageRelation = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RegisterLineageRelationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterLineageRelationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RegisterLineageRelationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveEntityTagsRequest : Tea.TeaModel {
    public var qualifiedName: String?

    public var tagKeys: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QualifiedName") {
            self.qualifiedName = dict["QualifiedName"] as! String
        }
        if dict.keys.contains("TagKeys") {
            self.tagKeys = dict["TagKeys"] as! [String]
        }
    }
}

public class RemoveEntityTagsShrinkRequest : Tea.TeaModel {
    public var qualifiedName: String?

    public var tagKeysShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        if self.tagKeysShrink != nil {
            map["TagKeys"] = self.tagKeysShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QualifiedName") {
            self.qualifiedName = dict["QualifiedName"] as! String
        }
        if dict.keys.contains("TagKeys") {
            self.tagKeysShrink = dict["TagKeys"] as! String
        }
    }
}

public class RemoveEntityTagsResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RemoveEntityTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveEntityTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveEntityTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveProjectMemberFromRoleRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var roleCode: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCode != nil {
            map["RoleCode"] = self.roleCode!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RoleCode") {
            self.roleCode = dict["RoleCode"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class RemoveProjectMemberFromRoleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveProjectMemberFromRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveProjectMemberFromRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveProjectMemberFromRoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartInstanceRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class RestartInstanceResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RestartInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RestartInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumeInstanceRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class ResumeInstanceResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ResumeInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResumeInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokeTablePermissionRequest : Tea.TeaModel {
    public var actions: String?

    public var maxComputeProjectName: String?

    public var revokeUserId: String?

    public var revokeUserName: String?

    public var tableName: String?

    public var workspaceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actions != nil {
            map["Actions"] = self.actions!
        }
        if self.maxComputeProjectName != nil {
            map["MaxComputeProjectName"] = self.maxComputeProjectName!
        }
        if self.revokeUserId != nil {
            map["RevokeUserId"] = self.revokeUserId!
        }
        if self.revokeUserName != nil {
            map["RevokeUserName"] = self.revokeUserName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Actions") {
            self.actions = dict["Actions"] as! String
        }
        if dict.keys.contains("MaxComputeProjectName") {
            self.maxComputeProjectName = dict["MaxComputeProjectName"] as! String
        }
        if dict.keys.contains("RevokeUserId") {
            self.revokeUserId = dict["RevokeUserId"] as! String
        }
        if dict.keys.contains("RevokeUserName") {
            self.revokeUserName = dict["RevokeUserName"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! Int64
        }
    }
}

public class RevokeTablePermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var revokeSuccess: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.revokeSuccess != nil {
            map["RevokeSuccess"] = self.revokeSuccess!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RevokeSuccess") {
            self.revokeSuccess = dict["RevokeSuccess"] as! Bool
        }
    }
}

public class RevokeTablePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeTablePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RevokeTablePermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunCycleDagNodesRequest : Tea.TeaModel {
    public var alertNoticeType: String?

    public var alertType: String?

    public var bizBeginTime: String?

    public var bizEndTime: String?

    public var concurrentRuns: Int32?

    public var endBizDate: String?

    public var excludeNodeIds: String?

    public var includeNodeIds: String?

    public var name: String?

    public var nodeParams: String?

    public var parallelism: Bool?

    public var projectEnv: String?

    public var rootNodeId: Int64?

    public var startBizDate: String?

    public var startFutureInstanceImmediately: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertNoticeType != nil {
            map["AlertNoticeType"] = self.alertNoticeType!
        }
        if self.alertType != nil {
            map["AlertType"] = self.alertType!
        }
        if self.bizBeginTime != nil {
            map["BizBeginTime"] = self.bizBeginTime!
        }
        if self.bizEndTime != nil {
            map["BizEndTime"] = self.bizEndTime!
        }
        if self.concurrentRuns != nil {
            map["ConcurrentRuns"] = self.concurrentRuns!
        }
        if self.endBizDate != nil {
            map["EndBizDate"] = self.endBizDate!
        }
        if self.excludeNodeIds != nil {
            map["ExcludeNodeIds"] = self.excludeNodeIds!
        }
        if self.includeNodeIds != nil {
            map["IncludeNodeIds"] = self.includeNodeIds!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nodeParams != nil {
            map["NodeParams"] = self.nodeParams!
        }
        if self.parallelism != nil {
            map["Parallelism"] = self.parallelism!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.rootNodeId != nil {
            map["RootNodeId"] = self.rootNodeId!
        }
        if self.startBizDate != nil {
            map["StartBizDate"] = self.startBizDate!
        }
        if self.startFutureInstanceImmediately != nil {
            map["StartFutureInstanceImmediately"] = self.startFutureInstanceImmediately!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertNoticeType") {
            self.alertNoticeType = dict["AlertNoticeType"] as! String
        }
        if dict.keys.contains("AlertType") {
            self.alertType = dict["AlertType"] as! String
        }
        if dict.keys.contains("BizBeginTime") {
            self.bizBeginTime = dict["BizBeginTime"] as! String
        }
        if dict.keys.contains("BizEndTime") {
            self.bizEndTime = dict["BizEndTime"] as! String
        }
        if dict.keys.contains("ConcurrentRuns") {
            self.concurrentRuns = dict["ConcurrentRuns"] as! Int32
        }
        if dict.keys.contains("EndBizDate") {
            self.endBizDate = dict["EndBizDate"] as! String
        }
        if dict.keys.contains("ExcludeNodeIds") {
            self.excludeNodeIds = dict["ExcludeNodeIds"] as! String
        }
        if dict.keys.contains("IncludeNodeIds") {
            self.includeNodeIds = dict["IncludeNodeIds"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NodeParams") {
            self.nodeParams = dict["NodeParams"] as! String
        }
        if dict.keys.contains("Parallelism") {
            self.parallelism = dict["Parallelism"] as! Bool
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("RootNodeId") {
            self.rootNodeId = dict["RootNodeId"] as! Int64
        }
        if dict.keys.contains("StartBizDate") {
            self.startBizDate = dict["StartBizDate"] as! String
        }
        if dict.keys.contains("StartFutureInstanceImmediately") {
            self.startFutureInstanceImmediately = dict["StartFutureInstanceImmediately"] as! Bool
        }
    }
}

public class RunCycleDagNodesResponseBody : Tea.TeaModel {
    public var data: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RunCycleDagNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunCycleDagNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RunCycleDagNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunManualDagNodesRequest : Tea.TeaModel {
    public var bizDate: String?

    public var dagParameters: String?

    public var endBizDate: String?

    public var excludeNodeIds: String?

    public var flowName: String?

    public var includeNodeIds: String?

    public var nodeParameters: String?

    public var projectEnv: String?

    public var projectId: Int64?

    public var projectName: String?

    public var startBizDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizDate != nil {
            map["BizDate"] = self.bizDate!
        }
        if self.dagParameters != nil {
            map["DagParameters"] = self.dagParameters!
        }
        if self.endBizDate != nil {
            map["EndBizDate"] = self.endBizDate!
        }
        if self.excludeNodeIds != nil {
            map["ExcludeNodeIds"] = self.excludeNodeIds!
        }
        if self.flowName != nil {
            map["FlowName"] = self.flowName!
        }
        if self.includeNodeIds != nil {
            map["IncludeNodeIds"] = self.includeNodeIds!
        }
        if self.nodeParameters != nil {
            map["NodeParameters"] = self.nodeParameters!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.startBizDate != nil {
            map["StartBizDate"] = self.startBizDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizDate") {
            self.bizDate = dict["BizDate"] as! String
        }
        if dict.keys.contains("DagParameters") {
            self.dagParameters = dict["DagParameters"] as! String
        }
        if dict.keys.contains("EndBizDate") {
            self.endBizDate = dict["EndBizDate"] as! String
        }
        if dict.keys.contains("ExcludeNodeIds") {
            self.excludeNodeIds = dict["ExcludeNodeIds"] as! String
        }
        if dict.keys.contains("FlowName") {
            self.flowName = dict["FlowName"] as! String
        }
        if dict.keys.contains("IncludeNodeIds") {
            self.includeNodeIds = dict["IncludeNodeIds"] as! String
        }
        if dict.keys.contains("NodeParameters") {
            self.nodeParameters = dict["NodeParameters"] as! String
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("StartBizDate") {
            self.startBizDate = dict["StartBizDate"] as! String
        }
    }
}

public class RunManualDagNodesResponseBody : Tea.TeaModel {
    public var dagId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RunManualDagNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunManualDagNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RunManualDagNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunSmokeTestRequest : Tea.TeaModel {
    public var bizdate: String?

    public var name: String?

    public var nodeId: Int64?

    public var nodeParams: String?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeParams != nil {
            map["NodeParams"] = self.nodeParams!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizdate") {
            self.bizdate = dict["Bizdate"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("NodeParams") {
            self.nodeParams = dict["NodeParams"] as! String
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class RunSmokeTestResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RunSmokeTestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunSmokeTestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RunSmokeTestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunTriggerNodeRequest : Tea.TeaModel {
    public var appId: Int64?

    public var bizDate: Int64?

    public var cycleTime: Int64?

    public var nodeId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.bizDate != nil {
            map["BizDate"] = self.bizDate!
        }
        if self.cycleTime != nil {
            map["CycleTime"] = self.cycleTime!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("BizDate") {
            self.bizDate = dict["BizDate"] as! Int64
        }
        if dict.keys.contains("CycleTime") {
            self.cycleTime = dict["CycleTime"] as! Int64
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
    }
}

public class RunTriggerNodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RunTriggerNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunTriggerNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RunTriggerNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveDataServiceApiTestResultRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var autoGenerate: Bool?

    public var failResultSample: String?

    public var projectId: Int64?

    public var resultSample: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.autoGenerate != nil {
            map["AutoGenerate"] = self.autoGenerate!
        }
        if self.failResultSample != nil {
            map["FailResultSample"] = self.failResultSample!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resultSample != nil {
            map["ResultSample"] = self.resultSample!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! Int64
        }
        if dict.keys.contains("AutoGenerate") {
            self.autoGenerate = dict["AutoGenerate"] as! Bool
        }
        if dict.keys.contains("FailResultSample") {
            self.failResultSample = dict["FailResultSample"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ResultSample") {
            self.resultSample = dict["ResultSample"] as! String
        }
    }
}

public class SaveDataServiceApiTestResultResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SaveDataServiceApiTestResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveDataServiceApiTestResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveDataServiceApiTestResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ScanSensitiveDataRequest : Tea.TeaModel {
    public var data: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
    }
}

public class ScanSensitiveDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var sensitives: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sensitives != nil {
            map["Sensitives"] = self.sensitives!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Sensitives") {
            self.sensitives = dict["Sensitives"] as! [String: Any]
        }
    }
}

public class ScanSensitiveDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ScanSensitiveDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ScanSensitiveDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMetaTablesRequest : Tea.TeaModel {
    public var appGuid: String?

    public var clusterId: String?

    public var dataSourceType: String?

    public var entityType: Int32?

    public var keyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var schema: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGuid != nil {
            map["AppGuid"] = self.appGuid!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.entityType != nil {
            map["EntityType"] = self.entityType!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppGuid") {
            self.appGuid = dict["AppGuid"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("EntityType") {
            self.entityType = dict["EntityType"] as! Int32
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Schema") {
            self.schema = dict["Schema"] as! String
        }
    }
}

public class SearchMetaTablesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataEntityList : Tea.TeaModel {
            public var clusterId: String?

            public var databaseName: String?

            public var entityType: Int32?

            public var envType: Int32?

            public var ownerId: String?

            public var projectId: Int64?

            public var projectName: String?

            public var schema: String?

            public var tableGuid: String?

            public var tableName: String?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.entityType != nil {
                    map["EntityType"] = self.entityType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                if self.schema != nil {
                    map["Schema"] = self.schema!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("DatabaseName") {
                    self.databaseName = dict["DatabaseName"] as! String
                }
                if dict.keys.contains("EntityType") {
                    self.entityType = dict["EntityType"] as! Int32
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! Int32
                }
                if dict.keys.contains("OwnerId") {
                    self.ownerId = dict["OwnerId"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("ProjectName") {
                    self.projectName = dict["ProjectName"] as! String
                }
                if dict.keys.contains("Schema") {
                    self.schema = dict["Schema"] as! String
                }
                if dict.keys.contains("TableGuid") {
                    self.tableGuid = dict["TableGuid"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
            }
        }
        public var dataEntityList: [SearchMetaTablesResponseBody.Data.DataEntityList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataEntityList != nil {
                var tmp : [Any] = []
                for k in self.dataEntityList! {
                    tmp.append(k.toMap())
                }
                map["DataEntityList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataEntityList") {
                var tmp : [SearchMetaTablesResponseBody.Data.DataEntityList] = []
                for v in dict["DataEntityList"] as! [Any] {
                    var model = SearchMetaTablesResponseBody.Data.DataEntityList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataEntityList = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: SearchMetaTablesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SearchMetaTablesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SearchMetaTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMetaTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMetaTablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchNodesByOutputRequest : Tea.TeaModel {
    public var outputs: String?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.outputs != nil {
            map["Outputs"] = self.outputs!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Outputs") {
            self.outputs = dict["Outputs"] as! String
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class SearchNodesByOutputResponseBody : Tea.TeaModel {
    public var data: [String: Any]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String: Any]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SearchNodesByOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchNodesByOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchNodesByOutputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDataSourceShareRequest : Tea.TeaModel {
    public var datasourceName: String?

    public var envType: String?

    public var projectId: Int64?

    public var projectPermissions: String?

    public var userPermissions: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasourceName != nil {
            map["DatasourceName"] = self.datasourceName!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectPermissions != nil {
            map["ProjectPermissions"] = self.projectPermissions!
        }
        if self.userPermissions != nil {
            map["UserPermissions"] = self.userPermissions!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasourceName") {
            self.datasourceName = dict["DatasourceName"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectPermissions") {
            self.projectPermissions = dict["ProjectPermissions"] as! String
        }
        if dict.keys.contains("UserPermissions") {
            self.userPermissions = dict["UserPermissions"] as! String
        }
    }
}

public class SetDataSourceShareResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: SetDataSourceShareResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SetDataSourceShareResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetDataSourceShareResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDataSourceShareResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDataSourceShareResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetEntityTagsRequest : Tea.TeaModel {
    public var qualifiedName: String?

    public var tags: [UserEntityTag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QualifiedName") {
            self.qualifiedName = dict["QualifiedName"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [UserEntityTag] = []
            for v in dict["Tags"] as! [Any] {
                var model = UserEntityTag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class SetEntityTagsShrinkRequest : Tea.TeaModel {
    public var qualifiedName: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QualifiedName") {
            self.qualifiedName = dict["QualifiedName"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tagsShrink = dict["Tags"] as! String
        }
    }
}

public class SetEntityTagsResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetEntityTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetEntityTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetEntityTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetSuccessInstanceRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class SetSuccessInstanceResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetSuccessInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetSuccessInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetSuccessInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartDIJobRequest : Tea.TeaModel {
    public class RealtimeStartSettings : Tea.TeaModel {
        public class FailoverSettings : Tea.TeaModel {
            public var interval: Int64?

            public var upperLimit: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.upperLimit != nil {
                    map["UpperLimit"] = self.upperLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int64
                }
                if dict.keys.contains("UpperLimit") {
                    self.upperLimit = dict["UpperLimit"] as! Int64
                }
            }
        }
        public var failoverSettings: StartDIJobRequest.RealtimeStartSettings.FailoverSettings?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.failoverSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failoverSettings != nil {
                map["FailoverSettings"] = self.failoverSettings?.toMap()
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailoverSettings") {
                var model = StartDIJobRequest.RealtimeStartSettings.FailoverSettings()
                model.fromMap(dict["FailoverSettings"] as! [String: Any])
                self.failoverSettings = model
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
        }
    }
    public var DIJobId: Int64?

    public var forceToRerun: Bool?

    public var realtimeStartSettings: StartDIJobRequest.RealtimeStartSettings?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.realtimeStartSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.forceToRerun != nil {
            map["ForceToRerun"] = self.forceToRerun!
        }
        if self.realtimeStartSettings != nil {
            map["RealtimeStartSettings"] = self.realtimeStartSettings?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("ForceToRerun") {
            self.forceToRerun = dict["ForceToRerun"] as! Bool
        }
        if dict.keys.contains("RealtimeStartSettings") {
            var model = StartDIJobRequest.RealtimeStartSettings()
            model.fromMap(dict["RealtimeStartSettings"] as! [String: Any])
            self.realtimeStartSettings = model
        }
    }
}

public class StartDIJobShrinkRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var forceToRerun: Bool?

    public var realtimeStartSettingsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.forceToRerun != nil {
            map["ForceToRerun"] = self.forceToRerun!
        }
        if self.realtimeStartSettingsShrink != nil {
            map["RealtimeStartSettings"] = self.realtimeStartSettingsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("ForceToRerun") {
            self.forceToRerun = dict["ForceToRerun"] as! Bool
        }
        if dict.keys.contains("RealtimeStartSettings") {
            self.realtimeStartSettingsShrink = dict["RealtimeStartSettings"] as! String
        }
    }
}

public class StartDIJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartDIJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartDISyncInstanceRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var startParam: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.startParam != nil {
            map["StartParam"] = self.startParam!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("StartParam") {
            self.startParam = dict["StartParam"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class StartDISyncInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: StartDISyncInstanceResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = StartDISyncInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StartDISyncInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartDISyncInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartDISyncInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartMigrationRequest : Tea.TeaModel {
    public var migrationId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationId != nil {
            map["MigrationId"] = self.migrationId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MigrationId") {
            self.migrationId = dict["MigrationId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class StartMigrationResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StartMigrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartMigrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartMigrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopDIJobRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
    }
}

public class StopDIJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopDIJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopDISyncInstanceRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class StopDISyncInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: StopDISyncInstanceResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = StopDISyncInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StopDISyncInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopDISyncInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopDISyncInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopInstanceRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class StopInstanceResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StopInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitDataServiceApiRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class SubmitDataServiceApiResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitDataServiceApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDataServiceApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitDataServiceApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitFileRequest : Tea.TeaModel {
    public var comment: String?

    public var fileId: Int64?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var skipAllDeployFileExtensions: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.skipAllDeployFileExtensions != nil {
            map["SkipAllDeployFileExtensions"] = self.skipAllDeployFileExtensions!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
        if dict.keys.contains("SkipAllDeployFileExtensions") {
            self.skipAllDeployFileExtensions = dict["SkipAllDeployFileExtensions"] as! Bool
        }
    }
}

public class SubmitFileResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendInstanceRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class SuspendInstanceResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SuspendInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SuspendInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TerminateDISyncInstanceRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class TerminateDISyncInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: TerminateDISyncInstanceResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = TerminateDISyncInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class TerminateDISyncInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TerminateDISyncInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TerminateDISyncInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TestDataServiceApiRequest : Tea.TeaModel {
    public class BodyParams : Tea.TeaModel {
        public var paramKey: String?

        public var paramValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.paramKey != nil {
                map["ParamKey"] = self.paramKey!
            }
            if self.paramValue != nil {
                map["ParamValue"] = self.paramValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ParamKey") {
                self.paramKey = dict["ParamKey"] as! String
            }
            if dict.keys.contains("ParamValue") {
                self.paramValue = dict["ParamValue"] as! String
            }
        }
    }
    public class HeadParams : Tea.TeaModel {
        public var paramKey: String?

        public var paramValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.paramKey != nil {
                map["ParamKey"] = self.paramKey!
            }
            if self.paramValue != nil {
                map["ParamValue"] = self.paramValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ParamKey") {
                self.paramKey = dict["ParamKey"] as! String
            }
            if dict.keys.contains("ParamValue") {
                self.paramValue = dict["ParamValue"] as! String
            }
        }
    }
    public class PathParams : Tea.TeaModel {
        public var paramKey: String?

        public var paramValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.paramKey != nil {
                map["ParamKey"] = self.paramKey!
            }
            if self.paramValue != nil {
                map["ParamValue"] = self.paramValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ParamKey") {
                self.paramKey = dict["ParamKey"] as! String
            }
            if dict.keys.contains("ParamValue") {
                self.paramValue = dict["ParamValue"] as! String
            }
        }
    }
    public class QueryParam : Tea.TeaModel {
        public var paramKey: String?

        public var paramValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.paramKey != nil {
                map["ParamKey"] = self.paramKey!
            }
            if self.paramValue != nil {
                map["ParamValue"] = self.paramValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ParamKey") {
                self.paramKey = dict["ParamKey"] as! String
            }
            if dict.keys.contains("ParamValue") {
                self.paramValue = dict["ParamValue"] as! String
            }
        }
    }
    public var apiId: Int64?

    public var bodyContent: String?

    public var bodyParams: [TestDataServiceApiRequest.BodyParams]?

    public var headParams: [TestDataServiceApiRequest.HeadParams]?

    public var pathParams: [TestDataServiceApiRequest.PathParams]?

    public var queryParam: [TestDataServiceApiRequest.QueryParam]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.bodyContent != nil {
            map["BodyContent"] = self.bodyContent!
        }
        if self.bodyParams != nil {
            var tmp : [Any] = []
            for k in self.bodyParams! {
                tmp.append(k.toMap())
            }
            map["BodyParams"] = tmp
        }
        if self.headParams != nil {
            var tmp : [Any] = []
            for k in self.headParams! {
                tmp.append(k.toMap())
            }
            map["HeadParams"] = tmp
        }
        if self.pathParams != nil {
            var tmp : [Any] = []
            for k in self.pathParams! {
                tmp.append(k.toMap())
            }
            map["PathParams"] = tmp
        }
        if self.queryParam != nil {
            var tmp : [Any] = []
            for k in self.queryParam! {
                tmp.append(k.toMap())
            }
            map["QueryParam"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! Int64
        }
        if dict.keys.contains("BodyContent") {
            self.bodyContent = dict["BodyContent"] as! String
        }
        if dict.keys.contains("BodyParams") {
            var tmp : [TestDataServiceApiRequest.BodyParams] = []
            for v in dict["BodyParams"] as! [Any] {
                var model = TestDataServiceApiRequest.BodyParams()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bodyParams = tmp
        }
        if dict.keys.contains("HeadParams") {
            var tmp : [TestDataServiceApiRequest.HeadParams] = []
            for v in dict["HeadParams"] as! [Any] {
                var model = TestDataServiceApiRequest.HeadParams()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.headParams = tmp
        }
        if dict.keys.contains("PathParams") {
            var tmp : [TestDataServiceApiRequest.PathParams] = []
            for v in dict["PathParams"] as! [Any] {
                var model = TestDataServiceApiRequest.PathParams()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.pathParams = tmp
        }
        if dict.keys.contains("QueryParam") {
            var tmp : [TestDataServiceApiRequest.QueryParam] = []
            for v in dict["QueryParam"] as! [Any] {
                var model = TestDataServiceApiRequest.QueryParam()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.queryParam = tmp
        }
    }
}

public class TestDataServiceApiResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var testId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.testId != nil {
                map["TestId"] = self.testId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TestId") {
                self.testId = dict["TestId"] as! String
            }
        }
    }
    public var data: TestDataServiceApiResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = TestDataServiceApiResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TestDataServiceApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TestDataServiceApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TestDataServiceApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TestNetworkConnectionRequest : Tea.TeaModel {
    public var datasourceName: String?

    public var envType: String?

    public var projectId: Int64?

    public var resourceGroup: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasourceName != nil {
            map["DatasourceName"] = self.datasourceName!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceGroup != nil {
            map["ResourceGroup"] = self.resourceGroup!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasourceName") {
            self.datasourceName = dict["DatasourceName"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ResourceGroup") {
            self.resourceGroup = dict["ResourceGroup"] as! String
        }
    }
}

public class TestNetworkConnectionResponseBody : Tea.TeaModel {
    public class TaskList : Tea.TeaModel {
        public var connectMessage: String?

        public var connectStatus: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectMessage != nil {
                map["ConnectMessage"] = self.connectMessage!
            }
            if self.connectStatus != nil {
                map["ConnectStatus"] = self.connectStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConnectMessage") {
                self.connectMessage = dict["ConnectMessage"] as! String
            }
            if dict.keys.contains("ConnectStatus") {
                self.connectStatus = dict["ConnectStatus"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var success: Bool?

    public var taskList: TestNetworkConnectionResponseBody.TaskList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskList != nil {
            map["TaskList"] = self.taskList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TaskList") {
            var model = TestNetworkConnectionResponseBody.TaskList()
            model.fromMap(dict["TaskList"] as! [String: Any])
            self.taskList = model
        }
    }
}

public class TestNetworkConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TestNetworkConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TestNetworkConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TopTenElapsedTimeInstanceRequest : Tea.TeaModel {
    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class TopTenElapsedTimeInstanceResponseBody : Tea.TeaModel {
    public class InstanceConsumeTimeRank : Tea.TeaModel {
        public class ConsumeTimeRank : Tea.TeaModel {
            public var businessDate: Int64?

            public var consumed: Int64?

            public var instanceId: Int64?

            public var nodeId: Int64?

            public var nodeName: String?

            public var owner: String?

            public var programType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessDate != nil {
                    map["BusinessDate"] = self.businessDate!
                }
                if self.consumed != nil {
                    map["Consumed"] = self.consumed!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.programType != nil {
                    map["ProgramType"] = self.programType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessDate") {
                    self.businessDate = dict["BusinessDate"] as! Int64
                }
                if dict.keys.contains("Consumed") {
                    self.consumed = dict["Consumed"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("ProgramType") {
                    self.programType = dict["ProgramType"] as! Int32
                }
            }
        }
        public var consumeTimeRank: [TopTenElapsedTimeInstanceResponseBody.InstanceConsumeTimeRank.ConsumeTimeRank]?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consumeTimeRank != nil {
                var tmp : [Any] = []
                for k in self.consumeTimeRank! {
                    tmp.append(k.toMap())
                }
                map["ConsumeTimeRank"] = tmp
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsumeTimeRank") {
                var tmp : [TopTenElapsedTimeInstanceResponseBody.InstanceConsumeTimeRank.ConsumeTimeRank] = []
                for v in dict["ConsumeTimeRank"] as! [Any] {
                    var model = TopTenElapsedTimeInstanceResponseBody.InstanceConsumeTimeRank.ConsumeTimeRank()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.consumeTimeRank = tmp
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var instanceConsumeTimeRank: TopTenElapsedTimeInstanceResponseBody.InstanceConsumeTimeRank?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceConsumeTimeRank?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceConsumeTimeRank != nil {
            map["InstanceConsumeTimeRank"] = self.instanceConsumeTimeRank?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceConsumeTimeRank") {
            var model = TopTenElapsedTimeInstanceResponseBody.InstanceConsumeTimeRank()
            model.fromMap(dict["InstanceConsumeTimeRank"] as! [String: Any])
            self.instanceConsumeTimeRank = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TopTenElapsedTimeInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TopTenElapsedTimeInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TopTenElapsedTimeInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TopTenErrorTimesInstanceRequest : Tea.TeaModel {
    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class TopTenErrorTimesInstanceResponseBody : Tea.TeaModel {
    public class InstanceErrorRank : Tea.TeaModel {
        public class ErrorRank : Tea.TeaModel {
            public var count: Int32?

            public var nodeId: Int64?

            public var nodeName: String?

            public var owner: String?

            public var programType: Int32?

            public var projectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.programType != nil {
                    map["ProgramType"] = self.programType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("ProgramType") {
                    self.programType = dict["ProgramType"] as! Int32
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
            }
        }
        public var errorRank: [TopTenErrorTimesInstanceResponseBody.InstanceErrorRank.ErrorRank]?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorRank != nil {
                var tmp : [Any] = []
                for k in self.errorRank! {
                    tmp.append(k.toMap())
                }
                map["ErrorRank"] = tmp
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorRank") {
                var tmp : [TopTenErrorTimesInstanceResponseBody.InstanceErrorRank.ErrorRank] = []
                for v in dict["ErrorRank"] as! [Any] {
                    var model = TopTenErrorTimesInstanceResponseBody.InstanceErrorRank.ErrorRank()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.errorRank = tmp
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var instanceErrorRank: TopTenErrorTimesInstanceResponseBody.InstanceErrorRank?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceErrorRank?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceErrorRank != nil {
            map["InstanceErrorRank"] = self.instanceErrorRank?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceErrorRank") {
            var model = TopTenErrorTimesInstanceResponseBody.InstanceErrorRank()
            model.fromMap(dict["InstanceErrorRank"] as! [String: Any])
            self.instanceErrorRank = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TopTenErrorTimesInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TopTenErrorTimesInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TopTenErrorTimesInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateBaselineRequest : Tea.TeaModel {
    public class AlertSettings : Tea.TeaModel {
        public class DingRobots : Tea.TeaModel {
            public var atAll: Bool?

            public var webUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.atAll != nil {
                    map["AtAll"] = self.atAll!
                }
                if self.webUrl != nil {
                    map["WebUrl"] = self.webUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AtAll") {
                    self.atAll = dict["AtAll"] as! Bool
                }
                if dict.keys.contains("WebUrl") {
                    self.webUrl = dict["WebUrl"] as! String
                }
            }
        }
        public var alertInterval: Int32?

        public var alertMaximum: Int32?

        public var alertMethods: [String]?

        public var alertRecipient: String?

        public var alertRecipientType: String?

        public var alertType: String?

        public var baselineAlertEnabled: Bool?

        public var dingRobots: [UpdateBaselineRequest.AlertSettings.DingRobots]?

        public var silenceEndTime: String?

        public var silenceStartTime: String?

        public var topicTypes: [String]?

        public var webhooks: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertInterval != nil {
                map["AlertInterval"] = self.alertInterval!
            }
            if self.alertMaximum != nil {
                map["AlertMaximum"] = self.alertMaximum!
            }
            if self.alertMethods != nil {
                map["AlertMethods"] = self.alertMethods!
            }
            if self.alertRecipient != nil {
                map["AlertRecipient"] = self.alertRecipient!
            }
            if self.alertRecipientType != nil {
                map["AlertRecipientType"] = self.alertRecipientType!
            }
            if self.alertType != nil {
                map["AlertType"] = self.alertType!
            }
            if self.baselineAlertEnabled != nil {
                map["BaselineAlertEnabled"] = self.baselineAlertEnabled!
            }
            if self.dingRobots != nil {
                var tmp : [Any] = []
                for k in self.dingRobots! {
                    tmp.append(k.toMap())
                }
                map["DingRobots"] = tmp
            }
            if self.silenceEndTime != nil {
                map["SilenceEndTime"] = self.silenceEndTime!
            }
            if self.silenceStartTime != nil {
                map["SilenceStartTime"] = self.silenceStartTime!
            }
            if self.topicTypes != nil {
                map["TopicTypes"] = self.topicTypes!
            }
            if self.webhooks != nil {
                map["Webhooks"] = self.webhooks!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertInterval") {
                self.alertInterval = dict["AlertInterval"] as! Int32
            }
            if dict.keys.contains("AlertMaximum") {
                self.alertMaximum = dict["AlertMaximum"] as! Int32
            }
            if dict.keys.contains("AlertMethods") {
                self.alertMethods = dict["AlertMethods"] as! [String]
            }
            if dict.keys.contains("AlertRecipient") {
                self.alertRecipient = dict["AlertRecipient"] as! String
            }
            if dict.keys.contains("AlertRecipientType") {
                self.alertRecipientType = dict["AlertRecipientType"] as! String
            }
            if dict.keys.contains("AlertType") {
                self.alertType = dict["AlertType"] as! String
            }
            if dict.keys.contains("BaselineAlertEnabled") {
                self.baselineAlertEnabled = dict["BaselineAlertEnabled"] as! Bool
            }
            if dict.keys.contains("DingRobots") {
                var tmp : [UpdateBaselineRequest.AlertSettings.DingRobots] = []
                for v in dict["DingRobots"] as! [Any] {
                    var model = UpdateBaselineRequest.AlertSettings.DingRobots()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dingRobots = tmp
            }
            if dict.keys.contains("SilenceEndTime") {
                self.silenceEndTime = dict["SilenceEndTime"] as! String
            }
            if dict.keys.contains("SilenceStartTime") {
                self.silenceStartTime = dict["SilenceStartTime"] as! String
            }
            if dict.keys.contains("TopicTypes") {
                self.topicTypes = dict["TopicTypes"] as! [String]
            }
            if dict.keys.contains("Webhooks") {
                self.webhooks = dict["Webhooks"] as! [String]
            }
        }
    }
    public class OvertimeSettings : Tea.TeaModel {
        public var cycle: Int32?

        public var time: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycle != nil {
                map["Cycle"] = self.cycle!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cycle") {
                self.cycle = dict["Cycle"] as! Int32
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! String
            }
        }
    }
    public var alertEnabled: Bool?

    public var alertMarginThreshold: Int32?

    public var alertSettings: [UpdateBaselineRequest.AlertSettings]?

    public var baselineId: Int64?

    public var baselineName: String?

    public var baselineType: String?

    public var enabled: Bool?

    public var nodeIds: String?

    public var overtimeSettings: [UpdateBaselineRequest.OvertimeSettings]?

    public var owner: String?

    public var priority: Int32?

    public var projectId: Int64?

    public var removeNodeIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertEnabled != nil {
            map["AlertEnabled"] = self.alertEnabled!
        }
        if self.alertMarginThreshold != nil {
            map["AlertMarginThreshold"] = self.alertMarginThreshold!
        }
        if self.alertSettings != nil {
            var tmp : [Any] = []
            for k in self.alertSettings! {
                tmp.append(k.toMap())
            }
            map["AlertSettings"] = tmp
        }
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        if self.baselineName != nil {
            map["BaselineName"] = self.baselineName!
        }
        if self.baselineType != nil {
            map["BaselineType"] = self.baselineType!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.overtimeSettings != nil {
            var tmp : [Any] = []
            for k in self.overtimeSettings! {
                tmp.append(k.toMap())
            }
            map["OvertimeSettings"] = tmp
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.removeNodeIds != nil {
            map["RemoveNodeIds"] = self.removeNodeIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertEnabled") {
            self.alertEnabled = dict["AlertEnabled"] as! Bool
        }
        if dict.keys.contains("AlertMarginThreshold") {
            self.alertMarginThreshold = dict["AlertMarginThreshold"] as! Int32
        }
        if dict.keys.contains("AlertSettings") {
            var tmp : [UpdateBaselineRequest.AlertSettings] = []
            for v in dict["AlertSettings"] as! [Any] {
                var model = UpdateBaselineRequest.AlertSettings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alertSettings = tmp
        }
        if dict.keys.contains("BaselineId") {
            self.baselineId = dict["BaselineId"] as! Int64
        }
        if dict.keys.contains("BaselineName") {
            self.baselineName = dict["BaselineName"] as! String
        }
        if dict.keys.contains("BaselineType") {
            self.baselineType = dict["BaselineType"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("NodeIds") {
            self.nodeIds = dict["NodeIds"] as! String
        }
        if dict.keys.contains("OvertimeSettings") {
            var tmp : [UpdateBaselineRequest.OvertimeSettings] = []
            for v in dict["OvertimeSettings"] as! [Any] {
                var model = UpdateBaselineRequest.OvertimeSettings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.overtimeSettings = tmp
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RemoveNodeIds") {
            self.removeNodeIds = dict["RemoveNodeIds"] as! String
        }
    }
}

public class UpdateBaselineShrinkRequest : Tea.TeaModel {
    public var alertEnabled: Bool?

    public var alertMarginThreshold: Int32?

    public var alertSettingsShrink: String?

    public var baselineId: Int64?

    public var baselineName: String?

    public var baselineType: String?

    public var enabled: Bool?

    public var nodeIds: String?

    public var overtimeSettingsShrink: String?

    public var owner: String?

    public var priority: Int32?

    public var projectId: Int64?

    public var removeNodeIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertEnabled != nil {
            map["AlertEnabled"] = self.alertEnabled!
        }
        if self.alertMarginThreshold != nil {
            map["AlertMarginThreshold"] = self.alertMarginThreshold!
        }
        if self.alertSettingsShrink != nil {
            map["AlertSettings"] = self.alertSettingsShrink!
        }
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        if self.baselineName != nil {
            map["BaselineName"] = self.baselineName!
        }
        if self.baselineType != nil {
            map["BaselineType"] = self.baselineType!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.overtimeSettingsShrink != nil {
            map["OvertimeSettings"] = self.overtimeSettingsShrink!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.removeNodeIds != nil {
            map["RemoveNodeIds"] = self.removeNodeIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertEnabled") {
            self.alertEnabled = dict["AlertEnabled"] as! Bool
        }
        if dict.keys.contains("AlertMarginThreshold") {
            self.alertMarginThreshold = dict["AlertMarginThreshold"] as! Int32
        }
        if dict.keys.contains("AlertSettings") {
            self.alertSettingsShrink = dict["AlertSettings"] as! String
        }
        if dict.keys.contains("BaselineId") {
            self.baselineId = dict["BaselineId"] as! Int64
        }
        if dict.keys.contains("BaselineName") {
            self.baselineName = dict["BaselineName"] as! String
        }
        if dict.keys.contains("BaselineType") {
            self.baselineType = dict["BaselineType"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("NodeIds") {
            self.nodeIds = dict["NodeIds"] as! String
        }
        if dict.keys.contains("OvertimeSettings") {
            self.overtimeSettingsShrink = dict["OvertimeSettings"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RemoveNodeIds") {
            self.removeNodeIds = dict["RemoveNodeIds"] as! String
        }
    }
}

public class UpdateBaselineResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateBaselineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateBaselineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateBaselineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateBusinessRequest : Tea.TeaModel {
    public var businessId: Int64?

    public var businessName: String?

    public var description_: String?

    public var owner: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessId != nil {
            map["BusinessId"] = self.businessId!
        }
        if self.businessName != nil {
            map["BusinessName"] = self.businessName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessId") {
            self.businessId = dict["BusinessId"] as! Int64
        }
        if dict.keys.contains("BusinessName") {
            self.businessName = dict["BusinessName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class UpdateBusinessResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateBusinessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateBusinessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateBusinessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateClusterConfigsRequest : Tea.TeaModel {
    public var clusterId: Int64?

    public var configType: String?

    public var configValues: [ClusterConfig]?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configType != nil {
            map["ConfigType"] = self.configType!
        }
        if self.configValues != nil {
            var tmp : [Any] = []
            for k in self.configValues! {
                tmp.append(k.toMap())
            }
            map["ConfigValues"] = tmp
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! Int64
        }
        if dict.keys.contains("ConfigType") {
            self.configType = dict["ConfigType"] as! String
        }
        if dict.keys.contains("ConfigValues") {
            var tmp : [ClusterConfig] = []
            for v in dict["ConfigValues"] as! [Any] {
                var model = ClusterConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.configValues = tmp
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class UpdateClusterConfigsShrinkRequest : Tea.TeaModel {
    public var clusterId: Int64?

    public var configType: String?

    public var configValuesShrink: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configType != nil {
            map["ConfigType"] = self.configType!
        }
        if self.configValuesShrink != nil {
            map["ConfigValues"] = self.configValuesShrink!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! Int64
        }
        if dict.keys.contains("ConfigType") {
            self.configType = dict["ConfigType"] as! String
        }
        if dict.keys.contains("ConfigValues") {
            self.configValuesShrink = dict["ConfigValues"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class UpdateClusterConfigsResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateClusterConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateClusterConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateClusterConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateConnectionRequest : Tea.TeaModel {
    public var connectionId: Int64?

    public var content: String?

    public var description_: String?

    public var envType: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionId != nil {
            map["ConnectionId"] = self.connectionId!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConnectionId") {
            self.connectionId = dict["ConnectionId"] as! Int64
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class UpdateConnectionResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDIAlarmRuleRequest : Tea.TeaModel {
    public class NotificationSettings : Tea.TeaModel {
        public class NotificationChannels : Tea.TeaModel {
            public var channels: [String]?

            public var severity: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! [String]
                }
                if dict.keys.contains("Severity") {
                    self.severity = dict["Severity"] as! String
                }
            }
        }
        public class NotificationReceivers : Tea.TeaModel {
            public var receiverType: String?

            public var receiverValues: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.receiverType != nil {
                    map["ReceiverType"] = self.receiverType!
                }
                if self.receiverValues != nil {
                    map["ReceiverValues"] = self.receiverValues!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReceiverType") {
                    self.receiverType = dict["ReceiverType"] as! String
                }
                if dict.keys.contains("ReceiverValues") {
                    self.receiverValues = dict["ReceiverValues"] as! [String]
                }
            }
        }
        public var inhibitionInterval: Int32?

        public var notificationChannels: [UpdateDIAlarmRuleRequest.NotificationSettings.NotificationChannels]?

        public var notificationReceivers: [UpdateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inhibitionInterval != nil {
                map["InhibitionInterval"] = self.inhibitionInterval!
            }
            if self.notificationChannels != nil {
                var tmp : [Any] = []
                for k in self.notificationChannels! {
                    tmp.append(k.toMap())
                }
                map["NotificationChannels"] = tmp
            }
            if self.notificationReceivers != nil {
                var tmp : [Any] = []
                for k in self.notificationReceivers! {
                    tmp.append(k.toMap())
                }
                map["NotificationReceivers"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InhibitionInterval") {
                self.inhibitionInterval = dict["InhibitionInterval"] as! Int32
            }
            if dict.keys.contains("NotificationChannels") {
                var tmp : [UpdateDIAlarmRuleRequest.NotificationSettings.NotificationChannels] = []
                for v in dict["NotificationChannels"] as! [Any] {
                    var model = UpdateDIAlarmRuleRequest.NotificationSettings.NotificationChannels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notificationChannels = tmp
            }
            if dict.keys.contains("NotificationReceivers") {
                var tmp : [UpdateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers] = []
                for v in dict["NotificationReceivers"] as! [Any] {
                    var model = UpdateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notificationReceivers = tmp
            }
        }
    }
    public class TriggerConditions : Tea.TeaModel {
        public var duration: Int64?

        public var severity: String?

        public var threshold: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Severity") {
                self.severity = dict["Severity"] as! String
            }
            if dict.keys.contains("Threshold") {
                self.threshold = dict["Threshold"] as! Int64
            }
        }
    }
    public var DIAlarmRuleId: Int64?

    public var description_: String?

    public var enabled: Bool?

    public var metricType: String?

    public var notificationSettings: UpdateDIAlarmRuleRequest.NotificationSettings?

    public var triggerConditions: [UpdateDIAlarmRuleRequest.TriggerConditions]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notificationSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.notificationSettings != nil {
            map["NotificationSettings"] = self.notificationSettings?.toMap()
        }
        if self.triggerConditions != nil {
            var tmp : [Any] = []
            for k in self.triggerConditions! {
                tmp.append(k.toMap())
            }
            map["TriggerConditions"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIAlarmRuleId") {
            self.DIAlarmRuleId = dict["DIAlarmRuleId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("NotificationSettings") {
            var model = UpdateDIAlarmRuleRequest.NotificationSettings()
            model.fromMap(dict["NotificationSettings"] as! [String: Any])
            self.notificationSettings = model
        }
        if dict.keys.contains("TriggerConditions") {
            var tmp : [UpdateDIAlarmRuleRequest.TriggerConditions] = []
            for v in dict["TriggerConditions"] as! [Any] {
                var model = UpdateDIAlarmRuleRequest.TriggerConditions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.triggerConditions = tmp
        }
    }
}

public class UpdateDIAlarmRuleShrinkRequest : Tea.TeaModel {
    public var DIAlarmRuleId: Int64?

    public var description_: String?

    public var enabled: Bool?

    public var metricType: String?

    public var notificationSettingsShrink: String?

    public var triggerConditionsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.notificationSettingsShrink != nil {
            map["NotificationSettings"] = self.notificationSettingsShrink!
        }
        if self.triggerConditionsShrink != nil {
            map["TriggerConditions"] = self.triggerConditionsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIAlarmRuleId") {
            self.DIAlarmRuleId = dict["DIAlarmRuleId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("NotificationSettings") {
            self.notificationSettingsShrink = dict["NotificationSettings"] as! String
        }
        if dict.keys.contains("TriggerConditions") {
            self.triggerConditionsShrink = dict["TriggerConditions"] as! String
        }
    }
}

public class UpdateDIAlarmRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDIAlarmRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDIAlarmRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDIAlarmRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDIJobRequest : Tea.TeaModel {
    public class JobSettings : Tea.TeaModel {
        public class ColumnDataTypeSettings : Tea.TeaModel {
            public var destinationDataType: String?

            public var sourceDataType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.destinationDataType != nil {
                    map["DestinationDataType"] = self.destinationDataType!
                }
                if self.sourceDataType != nil {
                    map["SourceDataType"] = self.sourceDataType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DestinationDataType") {
                    self.destinationDataType = dict["DestinationDataType"] as! String
                }
                if dict.keys.contains("SourceDataType") {
                    self.sourceDataType = dict["SourceDataType"] as! String
                }
            }
        }
        public class CycleScheduleSettings : Tea.TeaModel {
            public var scheduleParameters: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.scheduleParameters != nil {
                    map["ScheduleParameters"] = self.scheduleParameters!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ScheduleParameters") {
                    self.scheduleParameters = dict["ScheduleParameters"] as! String
                }
            }
        }
        public class DdlHandlingSettings : Tea.TeaModel {
            public var action: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class RuntimeSettings : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var channelSettings: String?

        public var columnDataTypeSettings: [UpdateDIJobRequest.JobSettings.ColumnDataTypeSettings]?

        public var cycleScheduleSettings: UpdateDIJobRequest.JobSettings.CycleScheduleSettings?

        public var ddlHandlingSettings: [UpdateDIJobRequest.JobSettings.DdlHandlingSettings]?

        public var runtimeSettings: [UpdateDIJobRequest.JobSettings.RuntimeSettings]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cycleScheduleSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelSettings != nil {
                map["ChannelSettings"] = self.channelSettings!
            }
            if self.columnDataTypeSettings != nil {
                var tmp : [Any] = []
                for k in self.columnDataTypeSettings! {
                    tmp.append(k.toMap())
                }
                map["ColumnDataTypeSettings"] = tmp
            }
            if self.cycleScheduleSettings != nil {
                map["CycleScheduleSettings"] = self.cycleScheduleSettings?.toMap()
            }
            if self.ddlHandlingSettings != nil {
                var tmp : [Any] = []
                for k in self.ddlHandlingSettings! {
                    tmp.append(k.toMap())
                }
                map["DdlHandlingSettings"] = tmp
            }
            if self.runtimeSettings != nil {
                var tmp : [Any] = []
                for k in self.runtimeSettings! {
                    tmp.append(k.toMap())
                }
                map["RuntimeSettings"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelSettings") {
                self.channelSettings = dict["ChannelSettings"] as! String
            }
            if dict.keys.contains("ColumnDataTypeSettings") {
                var tmp : [UpdateDIJobRequest.JobSettings.ColumnDataTypeSettings] = []
                for v in dict["ColumnDataTypeSettings"] as! [Any] {
                    var model = UpdateDIJobRequest.JobSettings.ColumnDataTypeSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.columnDataTypeSettings = tmp
            }
            if dict.keys.contains("CycleScheduleSettings") {
                var model = UpdateDIJobRequest.JobSettings.CycleScheduleSettings()
                model.fromMap(dict["CycleScheduleSettings"] as! [String: Any])
                self.cycleScheduleSettings = model
            }
            if dict.keys.contains("DdlHandlingSettings") {
                var tmp : [UpdateDIJobRequest.JobSettings.DdlHandlingSettings] = []
                for v in dict["DdlHandlingSettings"] as! [Any] {
                    var model = UpdateDIJobRequest.JobSettings.DdlHandlingSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ddlHandlingSettings = tmp
            }
            if dict.keys.contains("RuntimeSettings") {
                var tmp : [UpdateDIJobRequest.JobSettings.RuntimeSettings] = []
                for v in dict["RuntimeSettings"] as! [Any] {
                    var model = UpdateDIJobRequest.JobSettings.RuntimeSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.runtimeSettings = tmp
            }
        }
    }
    public class ResourceSettings : Tea.TeaModel {
        public class OfflineResourceSettings : Tea.TeaModel {
            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceGroupIdentifier") {
                    self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
                }
            }
        }
        public class RealtimeResourceSettings : Tea.TeaModel {
            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceGroupIdentifier") {
                    self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
                }
            }
        }
        public var offlineResourceSettings: UpdateDIJobRequest.ResourceSettings.OfflineResourceSettings?

        public var realtimeResourceSettings: UpdateDIJobRequest.ResourceSettings.RealtimeResourceSettings?

        public var requestedCu: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.offlineResourceSettings?.validate()
            try self.realtimeResourceSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.offlineResourceSettings != nil {
                map["OfflineResourceSettings"] = self.offlineResourceSettings?.toMap()
            }
            if self.realtimeResourceSettings != nil {
                map["RealtimeResourceSettings"] = self.realtimeResourceSettings?.toMap()
            }
            if self.requestedCu != nil {
                map["RequestedCu"] = self.requestedCu!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OfflineResourceSettings") {
                var model = UpdateDIJobRequest.ResourceSettings.OfflineResourceSettings()
                model.fromMap(dict["OfflineResourceSettings"] as! [String: Any])
                self.offlineResourceSettings = model
            }
            if dict.keys.contains("RealtimeResourceSettings") {
                var model = UpdateDIJobRequest.ResourceSettings.RealtimeResourceSettings()
                model.fromMap(dict["RealtimeResourceSettings"] as! [String: Any])
                self.realtimeResourceSettings = model
            }
            if dict.keys.contains("RequestedCu") {
                self.requestedCu = dict["RequestedCu"] as! Double
            }
        }
    }
    public class TableMappings : Tea.TeaModel {
        public class SourceObjectSelectionRules : Tea.TeaModel {
            public var expression: String?

            public var objectType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.objectType != nil {
                    map["ObjectType"] = self.objectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Expression") {
                    self.expression = dict["Expression"] as! String
                }
                if dict.keys.contains("ObjectType") {
                    self.objectType = dict["ObjectType"] as! String
                }
            }
        }
        public class TransformationRules : Tea.TeaModel {
            public var ruleActionType: String?

            public var ruleName: String?

            public var ruleTargetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ruleActionType != nil {
                    map["RuleActionType"] = self.ruleActionType!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.ruleTargetType != nil {
                    map["RuleTargetType"] = self.ruleTargetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RuleActionType") {
                    self.ruleActionType = dict["RuleActionType"] as! String
                }
                if dict.keys.contains("RuleName") {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("RuleTargetType") {
                    self.ruleTargetType = dict["RuleTargetType"] as! String
                }
            }
        }
        public var sourceObjectSelectionRules: [UpdateDIJobRequest.TableMappings.SourceObjectSelectionRules]?

        public var transformationRules: [UpdateDIJobRequest.TableMappings.TransformationRules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sourceObjectSelectionRules != nil {
                var tmp : [Any] = []
                for k in self.sourceObjectSelectionRules! {
                    tmp.append(k.toMap())
                }
                map["SourceObjectSelectionRules"] = tmp
            }
            if self.transformationRules != nil {
                var tmp : [Any] = []
                for k in self.transformationRules! {
                    tmp.append(k.toMap())
                }
                map["TransformationRules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SourceObjectSelectionRules") {
                var tmp : [UpdateDIJobRequest.TableMappings.SourceObjectSelectionRules] = []
                for v in dict["SourceObjectSelectionRules"] as! [Any] {
                    var model = UpdateDIJobRequest.TableMappings.SourceObjectSelectionRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sourceObjectSelectionRules = tmp
            }
            if dict.keys.contains("TransformationRules") {
                var tmp : [UpdateDIJobRequest.TableMappings.TransformationRules] = []
                for v in dict["TransformationRules"] as! [Any] {
                    var model = UpdateDIJobRequest.TableMappings.TransformationRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transformationRules = tmp
            }
        }
    }
    public class TransformationRules : Tea.TeaModel {
        public var ruleActionType: String?

        public var ruleExpression: String?

        public var ruleName: String?

        public var ruleTargetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleActionType != nil {
                map["RuleActionType"] = self.ruleActionType!
            }
            if self.ruleExpression != nil {
                map["RuleExpression"] = self.ruleExpression!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.ruleTargetType != nil {
                map["RuleTargetType"] = self.ruleTargetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RuleActionType") {
                self.ruleActionType = dict["RuleActionType"] as! String
            }
            if dict.keys.contains("RuleExpression") {
                self.ruleExpression = dict["RuleExpression"] as! String
            }
            if dict.keys.contains("RuleName") {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("RuleTargetType") {
                self.ruleTargetType = dict["RuleTargetType"] as! String
            }
        }
    }
    public var DIJobId: Int64?

    public var description_: String?

    public var jobSettings: UpdateDIJobRequest.JobSettings?

    public var resourceSettings: UpdateDIJobRequest.ResourceSettings?

    public var tableMappings: [UpdateDIJobRequest.TableMappings]?

    public var transformationRules: [UpdateDIJobRequest.TransformationRules]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobSettings?.validate()
        try self.resourceSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.jobSettings != nil {
            map["JobSettings"] = self.jobSettings?.toMap()
        }
        if self.resourceSettings != nil {
            map["ResourceSettings"] = self.resourceSettings?.toMap()
        }
        if self.tableMappings != nil {
            var tmp : [Any] = []
            for k in self.tableMappings! {
                tmp.append(k.toMap())
            }
            map["TableMappings"] = tmp
        }
        if self.transformationRules != nil {
            var tmp : [Any] = []
            for k in self.transformationRules! {
                tmp.append(k.toMap())
            }
            map["TransformationRules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("JobSettings") {
            var model = UpdateDIJobRequest.JobSettings()
            model.fromMap(dict["JobSettings"] as! [String: Any])
            self.jobSettings = model
        }
        if dict.keys.contains("ResourceSettings") {
            var model = UpdateDIJobRequest.ResourceSettings()
            model.fromMap(dict["ResourceSettings"] as! [String: Any])
            self.resourceSettings = model
        }
        if dict.keys.contains("TableMappings") {
            var tmp : [UpdateDIJobRequest.TableMappings] = []
            for v in dict["TableMappings"] as! [Any] {
                var model = UpdateDIJobRequest.TableMappings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tableMappings = tmp
        }
        if dict.keys.contains("TransformationRules") {
            var tmp : [UpdateDIJobRequest.TransformationRules] = []
            for v in dict["TransformationRules"] as! [Any] {
                var model = UpdateDIJobRequest.TransformationRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.transformationRules = tmp
        }
    }
}

public class UpdateDIJobShrinkRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var description_: String?

    public var jobSettingsShrink: String?

    public var resourceSettingsShrink: String?

    public var tableMappingsShrink: String?

    public var transformationRulesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.jobSettingsShrink != nil {
            map["JobSettings"] = self.jobSettingsShrink!
        }
        if self.resourceSettingsShrink != nil {
            map["ResourceSettings"] = self.resourceSettingsShrink!
        }
        if self.tableMappingsShrink != nil {
            map["TableMappings"] = self.tableMappingsShrink!
        }
        if self.transformationRulesShrink != nil {
            map["TransformationRules"] = self.transformationRulesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("JobSettings") {
            self.jobSettingsShrink = dict["JobSettings"] as! String
        }
        if dict.keys.contains("ResourceSettings") {
            self.resourceSettingsShrink = dict["ResourceSettings"] as! String
        }
        if dict.keys.contains("TableMappings") {
            self.tableMappingsShrink = dict["TableMappings"] as! String
        }
        if dict.keys.contains("TransformationRules") {
            self.transformationRulesShrink = dict["TransformationRules"] as! String
        }
    }
}

public class UpdateDIJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDIJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDIProjectConfigRequest : Tea.TeaModel {
    public var destinationType: String?

    public var projectConfig: String?

    public var projectId: Int64?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.projectConfig != nil {
            map["ProjectConfig"] = self.projectConfig!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationType") {
            self.destinationType = dict["DestinationType"] as! String
        }
        if dict.keys.contains("ProjectConfig") {
            self.projectConfig = dict["ProjectConfig"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class UpdateDIProjectConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: UpdateDIProjectConfigResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = UpdateDIProjectConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateDIProjectConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDIProjectConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDIProjectConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDISyncTaskRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var taskContent: String?

    public var taskParam: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskContent != nil {
            map["TaskContent"] = self.taskContent!
        }
        if self.taskParam != nil {
            map["TaskParam"] = self.taskParam!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TaskContent") {
            self.taskContent = dict["TaskContent"] as! String
        }
        if dict.keys.contains("TaskParam") {
            self.taskParam = dict["TaskParam"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class UpdateDISyncTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: UpdateDISyncTaskResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = UpdateDISyncTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateDISyncTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDISyncTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDISyncTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDataServiceApiRequest : Tea.TeaModel {
    public var apiDescription: String?

    public var apiId: Int64?

    public var apiPath: String?

    public var projectId: Int64?

    public var protocols: String?

    public var registrationDetails: String?

    public var requestMethod: Int32?

    public var resourceGroupId: Int64?

    public var responseContentType: Int32?

    public var scriptDetails: String?

    public var tenantId: Int64?

    public var timeout: Int32?

    public var visibleRange: Int32?

    public var wizardDetails: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiDescription != nil {
            map["ApiDescription"] = self.apiDescription!
        }
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiPath != nil {
            map["ApiPath"] = self.apiPath!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.protocols != nil {
            map["Protocols"] = self.protocols!
        }
        if self.registrationDetails != nil {
            map["RegistrationDetails"] = self.registrationDetails!
        }
        if self.requestMethod != nil {
            map["RequestMethod"] = self.requestMethod!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.responseContentType != nil {
            map["ResponseContentType"] = self.responseContentType!
        }
        if self.scriptDetails != nil {
            map["ScriptDetails"] = self.scriptDetails!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.visibleRange != nil {
            map["VisibleRange"] = self.visibleRange!
        }
        if self.wizardDetails != nil {
            map["WizardDetails"] = self.wizardDetails!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiDescription") {
            self.apiDescription = dict["ApiDescription"] as! String
        }
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! Int64
        }
        if dict.keys.contains("ApiPath") {
            self.apiPath = dict["ApiPath"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("Protocols") {
            self.protocols = dict["Protocols"] as! String
        }
        if dict.keys.contains("RegistrationDetails") {
            self.registrationDetails = dict["RegistrationDetails"] as! String
        }
        if dict.keys.contains("RequestMethod") {
            self.requestMethod = dict["RequestMethod"] as! Int32
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! Int64
        }
        if dict.keys.contains("ResponseContentType") {
            self.responseContentType = dict["ResponseContentType"] as! Int32
        }
        if dict.keys.contains("ScriptDetails") {
            self.scriptDetails = dict["ScriptDetails"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("VisibleRange") {
            self.visibleRange = dict["VisibleRange"] as! Int32
        }
        if dict.keys.contains("WizardDetails") {
            self.wizardDetails = dict["WizardDetails"] as! String
        }
    }
}

public class UpdateDataServiceApiResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateDataServiceApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataServiceApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDataServiceApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDataSourceRequest : Tea.TeaModel {
    public var content: String?

    public var dataSourceId: Int64?

    public var description_: String?

    public var envType: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class UpdateDataSourceResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateFileRequest : Tea.TeaModel {
    public var advancedSettings: String?

    public var applyScheduleImmediately: Bool?

    public var autoParsing: Bool?

    public var autoRerunIntervalMillis: Int32?

    public var autoRerunTimes: Int32?

    public var connectionName: String?

    public var content: String?

    public var cronExpress: String?

    public var cycleType: String?

    public var dependentNodeIdList: String?

    public var dependentType: String?

    public var endEffectDate: Int64?

    public var fileDescription: String?

    public var fileFolderPath: String?

    public var fileId: Int64?

    public var fileName: String?

    public var ignoreParentSkipRunningProperty: Bool?

    public var imageId: String?

    public var inputList: String?

    public var inputParameters: String?

    public var outputList: String?

    public var outputParameters: String?

    public var owner: String?

    public var paraValue: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var rerunMode: String?

    public var resourceGroupIdentifier: String?

    public var schedulerType: String?

    public var startEffectDate: Int64?

    public var startImmediately: Bool?

    public var stop: Bool?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advancedSettings != nil {
            map["AdvancedSettings"] = self.advancedSettings!
        }
        if self.applyScheduleImmediately != nil {
            map["ApplyScheduleImmediately"] = self.applyScheduleImmediately!
        }
        if self.autoParsing != nil {
            map["AutoParsing"] = self.autoParsing!
        }
        if self.autoRerunIntervalMillis != nil {
            map["AutoRerunIntervalMillis"] = self.autoRerunIntervalMillis!
        }
        if self.autoRerunTimes != nil {
            map["AutoRerunTimes"] = self.autoRerunTimes!
        }
        if self.connectionName != nil {
            map["ConnectionName"] = self.connectionName!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.cronExpress != nil {
            map["CronExpress"] = self.cronExpress!
        }
        if self.cycleType != nil {
            map["CycleType"] = self.cycleType!
        }
        if self.dependentNodeIdList != nil {
            map["DependentNodeIdList"] = self.dependentNodeIdList!
        }
        if self.dependentType != nil {
            map["DependentType"] = self.dependentType!
        }
        if self.endEffectDate != nil {
            map["EndEffectDate"] = self.endEffectDate!
        }
        if self.fileDescription != nil {
            map["FileDescription"] = self.fileDescription!
        }
        if self.fileFolderPath != nil {
            map["FileFolderPath"] = self.fileFolderPath!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.ignoreParentSkipRunningProperty != nil {
            map["IgnoreParentSkipRunningProperty"] = self.ignoreParentSkipRunningProperty!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.inputList != nil {
            map["InputList"] = self.inputList!
        }
        if self.inputParameters != nil {
            map["InputParameters"] = self.inputParameters!
        }
        if self.outputList != nil {
            map["OutputList"] = self.outputList!
        }
        if self.outputParameters != nil {
            map["OutputParameters"] = self.outputParameters!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.paraValue != nil {
            map["ParaValue"] = self.paraValue!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.rerunMode != nil {
            map["RerunMode"] = self.rerunMode!
        }
        if self.resourceGroupIdentifier != nil {
            map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
        }
        if self.schedulerType != nil {
            map["SchedulerType"] = self.schedulerType!
        }
        if self.startEffectDate != nil {
            map["StartEffectDate"] = self.startEffectDate!
        }
        if self.startImmediately != nil {
            map["StartImmediately"] = self.startImmediately!
        }
        if self.stop != nil {
            map["Stop"] = self.stop!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdvancedSettings") {
            self.advancedSettings = dict["AdvancedSettings"] as! String
        }
        if dict.keys.contains("ApplyScheduleImmediately") {
            self.applyScheduleImmediately = dict["ApplyScheduleImmediately"] as! Bool
        }
        if dict.keys.contains("AutoParsing") {
            self.autoParsing = dict["AutoParsing"] as! Bool
        }
        if dict.keys.contains("AutoRerunIntervalMillis") {
            self.autoRerunIntervalMillis = dict["AutoRerunIntervalMillis"] as! Int32
        }
        if dict.keys.contains("AutoRerunTimes") {
            self.autoRerunTimes = dict["AutoRerunTimes"] as! Int32
        }
        if dict.keys.contains("ConnectionName") {
            self.connectionName = dict["ConnectionName"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("CronExpress") {
            self.cronExpress = dict["CronExpress"] as! String
        }
        if dict.keys.contains("CycleType") {
            self.cycleType = dict["CycleType"] as! String
        }
        if dict.keys.contains("DependentNodeIdList") {
            self.dependentNodeIdList = dict["DependentNodeIdList"] as! String
        }
        if dict.keys.contains("DependentType") {
            self.dependentType = dict["DependentType"] as! String
        }
        if dict.keys.contains("EndEffectDate") {
            self.endEffectDate = dict["EndEffectDate"] as! Int64
        }
        if dict.keys.contains("FileDescription") {
            self.fileDescription = dict["FileDescription"] as! String
        }
        if dict.keys.contains("FileFolderPath") {
            self.fileFolderPath = dict["FileFolderPath"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! Int64
        }
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("IgnoreParentSkipRunningProperty") {
            self.ignoreParentSkipRunningProperty = dict["IgnoreParentSkipRunningProperty"] as! Bool
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InputList") {
            self.inputList = dict["InputList"] as! String
        }
        if dict.keys.contains("InputParameters") {
            self.inputParameters = dict["InputParameters"] as! String
        }
        if dict.keys.contains("OutputList") {
            self.outputList = dict["OutputList"] as! String
        }
        if dict.keys.contains("OutputParameters") {
            self.outputParameters = dict["OutputParameters"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("ParaValue") {
            self.paraValue = dict["ParaValue"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
        if dict.keys.contains("RerunMode") {
            self.rerunMode = dict["RerunMode"] as! String
        }
        if dict.keys.contains("ResourceGroupIdentifier") {
            self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
        }
        if dict.keys.contains("SchedulerType") {
            self.schedulerType = dict["SchedulerType"] as! String
        }
        if dict.keys.contains("StartEffectDate") {
            self.startEffectDate = dict["StartEffectDate"] as! Int64
        }
        if dict.keys.contains("StartImmediately") {
            self.startImmediately = dict["StartImmediately"] as! Bool
        }
        if dict.keys.contains("Stop") {
            self.stop = dict["Stop"] as! Bool
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class UpdateFileResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateFolderRequest : Tea.TeaModel {
    public var folderId: String?

    public var folderName: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.folderName != nil {
            map["FolderName"] = self.folderName!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FolderId") {
            self.folderId = dict["FolderId"] as! String
        }
        if dict.keys.contains("FolderName") {
            self.folderName = dict["FolderName"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
    }
}

public class UpdateFolderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateFolderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFolderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateFolderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateIDEEventResultRequest : Tea.TeaModel {
    public var checkResult: String?

    public var checkResultTip: String?

    public var extensionCode: String?

    public var messageId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkResult != nil {
            map["CheckResult"] = self.checkResult!
        }
        if self.checkResultTip != nil {
            map["CheckResultTip"] = self.checkResultTip!
        }
        if self.extensionCode != nil {
            map["ExtensionCode"] = self.extensionCode!
        }
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckResult") {
            self.checkResult = dict["CheckResult"] as! String
        }
        if dict.keys.contains("CheckResultTip") {
            self.checkResultTip = dict["CheckResultTip"] as! String
        }
        if dict.keys.contains("ExtensionCode") {
            self.extensionCode = dict["ExtensionCode"] as! String
        }
        if dict.keys.contains("MessageId") {
            self.messageId = dict["MessageId"] as! String
        }
    }
}

public class UpdateIDEEventResultResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateIDEEventResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIDEEventResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateIDEEventResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMetaCategoryRequest : Tea.TeaModel {
    public var categoryId: Int64?

    public var comment: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryId") {
            self.categoryId = dict["CategoryId"] as! Int64
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class UpdateMetaCategoryResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateMetaCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMetaCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMetaCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMetaCollectionRequest : Tea.TeaModel {
    public var comment: String?

    public var name: String?

    public var qualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("QualifiedName") {
            self.qualifiedName = dict["QualifiedName"] as! String
        }
    }
}

public class UpdateMetaCollectionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var status: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateMetaCollectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMetaCollectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMetaCollectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMetaTableRequest : Tea.TeaModel {
    public var addedLabels: String?

    public var caption: String?

    public var categoryId: Int64?

    public var envType: Int32?

    public var newOwnerId: String?

    public var projectId: Int64?

    public var removedLabels: String?

    public var schema: String?

    public var tableGuid: String?

    public var tableName: String?

    public var visibility: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addedLabels != nil {
            map["AddedLabels"] = self.addedLabels!
        }
        if self.caption != nil {
            map["Caption"] = self.caption!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.newOwnerId != nil {
            map["NewOwnerId"] = self.newOwnerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.removedLabels != nil {
            map["RemovedLabels"] = self.removedLabels!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddedLabels") {
            self.addedLabels = dict["AddedLabels"] as! String
        }
        if dict.keys.contains("Caption") {
            self.caption = dict["Caption"] as! String
        }
        if dict.keys.contains("CategoryId") {
            self.categoryId = dict["CategoryId"] as! Int64
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! Int32
        }
        if dict.keys.contains("NewOwnerId") {
            self.newOwnerId = dict["NewOwnerId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RemovedLabels") {
            self.removedLabels = dict["RemovedLabels"] as! String
        }
        if dict.keys.contains("Schema") {
            self.schema = dict["Schema"] as! String
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! Int32
        }
    }
}

public class UpdateMetaTableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var updateResult: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.updateResult != nil {
            map["UpdateResult"] = self.updateResult!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UpdateResult") {
            self.updateResult = dict["UpdateResult"] as! Bool
        }
    }
}

public class UpdateMetaTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMetaTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMetaTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMetaTableIntroWikiRequest : Tea.TeaModel {
    public var content: String?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
    }
}

public class UpdateMetaTableIntroWikiResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var updateResult: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.updateResult != nil {
            map["UpdateResult"] = self.updateResult!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UpdateResult") {
            self.updateResult = dict["UpdateResult"] as! Bool
        }
    }
}

public class UpdateMetaTableIntroWikiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMetaTableIntroWikiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMetaTableIntroWikiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNodeOwnerRequest : Tea.TeaModel {
    public var nodeId: Int64?

    public var projectEnv: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class UpdateNodeOwnerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateNodeOwnerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNodeOwnerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateNodeOwnerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNodeRunModeRequest : Tea.TeaModel {
    public var nodeId: Int64?

    public var projectEnv: String?

    public var schedulerType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.schedulerType != nil {
            map["SchedulerType"] = self.schedulerType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("SchedulerType") {
            self.schedulerType = dict["SchedulerType"] as! Int32
        }
    }
}

public class UpdateNodeRunModeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateNodeRunModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNodeRunModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateNodeRunModeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateQualityFollowerRequest : Tea.TeaModel {
    public var alarmMode: Int32?

    public var follower: String?

    public var followerId: Int64?

    public var projectId: Int64?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmMode != nil {
            map["AlarmMode"] = self.alarmMode!
        }
        if self.follower != nil {
            map["Follower"] = self.follower!
        }
        if self.followerId != nil {
            map["FollowerId"] = self.followerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmMode") {
            self.alarmMode = dict["AlarmMode"] as! Int32
        }
        if dict.keys.contains("Follower") {
            self.follower = dict["Follower"] as! String
        }
        if dict.keys.contains("FollowerId") {
            self.followerId = dict["FollowerId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
    }
}

public class UpdateQualityFollowerResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateQualityFollowerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateQualityFollowerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateQualityFollowerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateQualityRuleRequest : Tea.TeaModel {
    public var blockType: Int32?

    public var checker: Int32?

    public var comment: String?

    public var criticalThreshold: String?

    public var entityId: Int64?

    public var expectValue: String?

    public var id: Int64?

    public var methodName: String?

    public var openSwitch: Bool?

    public var operator_: String?

    public var predictType: Int32?

    public var projectId: Int64?

    public var projectName: String?

    public var property: String?

    public var propertyType: String?

    public var ruleName: String?

    public var ruleType: Int32?

    public var taskSetting: String?

    public var templateId: Int32?

    public var trend: String?

    public var warningThreshold: String?

    public var whereCondition: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.blockType != nil {
            map["BlockType"] = self.blockType!
        }
        if self.checker != nil {
            map["Checker"] = self.checker!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.criticalThreshold != nil {
            map["CriticalThreshold"] = self.criticalThreshold!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.expectValue != nil {
            map["ExpectValue"] = self.expectValue!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.methodName != nil {
            map["MethodName"] = self.methodName!
        }
        if self.openSwitch != nil {
            map["OpenSwitch"] = self.openSwitch!
        }
        if self.operator_ != nil {
            map["Operator"] = self.operator_!
        }
        if self.predictType != nil {
            map["PredictType"] = self.predictType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.property != nil {
            map["Property"] = self.property!
        }
        if self.propertyType != nil {
            map["PropertyType"] = self.propertyType!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        if self.taskSetting != nil {
            map["TaskSetting"] = self.taskSetting!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.trend != nil {
            map["Trend"] = self.trend!
        }
        if self.warningThreshold != nil {
            map["WarningThreshold"] = self.warningThreshold!
        }
        if self.whereCondition != nil {
            map["WhereCondition"] = self.whereCondition!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BlockType") {
            self.blockType = dict["BlockType"] as! Int32
        }
        if dict.keys.contains("Checker") {
            self.checker = dict["Checker"] as! Int32
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("CriticalThreshold") {
            self.criticalThreshold = dict["CriticalThreshold"] as! String
        }
        if dict.keys.contains("EntityId") {
            self.entityId = dict["EntityId"] as! Int64
        }
        if dict.keys.contains("ExpectValue") {
            self.expectValue = dict["ExpectValue"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MethodName") {
            self.methodName = dict["MethodName"] as! String
        }
        if dict.keys.contains("OpenSwitch") {
            self.openSwitch = dict["OpenSwitch"] as! Bool
        }
        if dict.keys.contains("Operator") {
            self.operator_ = dict["Operator"] as! String
        }
        if dict.keys.contains("PredictType") {
            self.predictType = dict["PredictType"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("Property") {
            self.property = dict["Property"] as! String
        }
        if dict.keys.contains("PropertyType") {
            self.propertyType = dict["PropertyType"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("RuleType") {
            self.ruleType = dict["RuleType"] as! Int32
        }
        if dict.keys.contains("TaskSetting") {
            self.taskSetting = dict["TaskSetting"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! Int32
        }
        if dict.keys.contains("Trend") {
            self.trend = dict["Trend"] as! String
        }
        if dict.keys.contains("WarningThreshold") {
            self.warningThreshold = dict["WarningThreshold"] as! String
        }
        if dict.keys.contains("WhereCondition") {
            self.whereCondition = dict["WhereCondition"] as! String
        }
    }
}

public class UpdateQualityRuleResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateQualityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateQualityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateQualityRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateRemindRequest : Tea.TeaModel {
    public var alertInterval: Int32?

    public var alertMethods: String?

    public var alertTargets: String?

    public var alertUnit: String?

    public var baselineIds: String?

    public var bizProcessIds: String?

    public var detail: String?

    public var dndEnd: String?

    public var maxAlertTimes: Int32?

    public var nodeIds: String?

    public var projectId: Int64?

    public var remindId: Int64?

    public var remindName: String?

    public var remindType: String?

    public var remindUnit: String?

    public var robotUrls: String?

    public var useFlag: Bool?

    public var webhooks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertInterval != nil {
            map["AlertInterval"] = self.alertInterval!
        }
        if self.alertMethods != nil {
            map["AlertMethods"] = self.alertMethods!
        }
        if self.alertTargets != nil {
            map["AlertTargets"] = self.alertTargets!
        }
        if self.alertUnit != nil {
            map["AlertUnit"] = self.alertUnit!
        }
        if self.baselineIds != nil {
            map["BaselineIds"] = self.baselineIds!
        }
        if self.bizProcessIds != nil {
            map["BizProcessIds"] = self.bizProcessIds!
        }
        if self.detail != nil {
            map["Detail"] = self.detail!
        }
        if self.dndEnd != nil {
            map["DndEnd"] = self.dndEnd!
        }
        if self.maxAlertTimes != nil {
            map["MaxAlertTimes"] = self.maxAlertTimes!
        }
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.remindId != nil {
            map["RemindId"] = self.remindId!
        }
        if self.remindName != nil {
            map["RemindName"] = self.remindName!
        }
        if self.remindType != nil {
            map["RemindType"] = self.remindType!
        }
        if self.remindUnit != nil {
            map["RemindUnit"] = self.remindUnit!
        }
        if self.robotUrls != nil {
            map["RobotUrls"] = self.robotUrls!
        }
        if self.useFlag != nil {
            map["UseFlag"] = self.useFlag!
        }
        if self.webhooks != nil {
            map["Webhooks"] = self.webhooks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertInterval") {
            self.alertInterval = dict["AlertInterval"] as! Int32
        }
        if dict.keys.contains("AlertMethods") {
            self.alertMethods = dict["AlertMethods"] as! String
        }
        if dict.keys.contains("AlertTargets") {
            self.alertTargets = dict["AlertTargets"] as! String
        }
        if dict.keys.contains("AlertUnit") {
            self.alertUnit = dict["AlertUnit"] as! String
        }
        if dict.keys.contains("BaselineIds") {
            self.baselineIds = dict["BaselineIds"] as! String
        }
        if dict.keys.contains("BizProcessIds") {
            self.bizProcessIds = dict["BizProcessIds"] as! String
        }
        if dict.keys.contains("Detail") {
            self.detail = dict["Detail"] as! String
        }
        if dict.keys.contains("DndEnd") {
            self.dndEnd = dict["DndEnd"] as! String
        }
        if dict.keys.contains("MaxAlertTimes") {
            self.maxAlertTimes = dict["MaxAlertTimes"] as! Int32
        }
        if dict.keys.contains("NodeIds") {
            self.nodeIds = dict["NodeIds"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RemindId") {
            self.remindId = dict["RemindId"] as! Int64
        }
        if dict.keys.contains("RemindName") {
            self.remindName = dict["RemindName"] as! String
        }
        if dict.keys.contains("RemindType") {
            self.remindType = dict["RemindType"] as! String
        }
        if dict.keys.contains("RemindUnit") {
            self.remindUnit = dict["RemindUnit"] as! String
        }
        if dict.keys.contains("RobotUrls") {
            self.robotUrls = dict["RobotUrls"] as! String
        }
        if dict.keys.contains("UseFlag") {
            self.useFlag = dict["UseFlag"] as! Bool
        }
        if dict.keys.contains("Webhooks") {
            self.webhooks = dict["Webhooks"] as! String
        }
    }
}

public class UpdateRemindResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateRemindResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRemindResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateRemindResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTableRequest : Tea.TeaModel {
    public class Columns : Tea.TeaModel {
        public var columnName: String?

        public var columnNameCn: String?

        public var columnType: String?

        public var comment: String?

        public var isPartitionCol: Bool?

        public var length: Int32?

        public var seqNumber: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columnName != nil {
                map["ColumnName"] = self.columnName!
            }
            if self.columnNameCn != nil {
                map["ColumnNameCn"] = self.columnNameCn!
            }
            if self.columnType != nil {
                map["ColumnType"] = self.columnType!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.isPartitionCol != nil {
                map["IsPartitionCol"] = self.isPartitionCol!
            }
            if self.length != nil {
                map["Length"] = self.length!
            }
            if self.seqNumber != nil {
                map["SeqNumber"] = self.seqNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ColumnName") {
                self.columnName = dict["ColumnName"] as! String
            }
            if dict.keys.contains("ColumnNameCn") {
                self.columnNameCn = dict["ColumnNameCn"] as! String
            }
            if dict.keys.contains("ColumnType") {
                self.columnType = dict["ColumnType"] as! String
            }
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("IsPartitionCol") {
                self.isPartitionCol = dict["IsPartitionCol"] as! Bool
            }
            if dict.keys.contains("Length") {
                self.length = dict["Length"] as! Int32
            }
            if dict.keys.contains("SeqNumber") {
                self.seqNumber = dict["SeqNumber"] as! Int32
            }
        }
    }
    public class Themes : Tea.TeaModel {
        public var themeId: Int64?

        public var themeLevel: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.themeId != nil {
                map["ThemeId"] = self.themeId!
            }
            if self.themeLevel != nil {
                map["ThemeLevel"] = self.themeLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ThemeId") {
                self.themeId = dict["ThemeId"] as! Int64
            }
            if dict.keys.contains("ThemeLevel") {
                self.themeLevel = dict["ThemeLevel"] as! Int32
            }
        }
    }
    public var appGuid: String?

    public var categoryId: Int64?

    public var columns: [UpdateTableRequest.Columns]?

    public var comment: String?

    public var createIfNotExists: Bool?

    public var endpoint: String?

    public var envType: Int32?

    public var externalTableType: String?

    public var hasPart: Int32?

    public var isView: Int32?

    public var lifeCycle: Int32?

    public var location: String?

    public var logicalLevelId: Int64?

    public var ownerId: String?

    public var physicsLevelId: Int64?

    public var projectId: Int64?

    public var schema: String?

    public var tableName: String?

    public var themes: [UpdateTableRequest.Themes]?

    public var visibility: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGuid != nil {
            map["AppGuid"] = self.appGuid!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.columns != nil {
            var tmp : [Any] = []
            for k in self.columns! {
                tmp.append(k.toMap())
            }
            map["Columns"] = tmp
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.createIfNotExists != nil {
            map["CreateIfNotExists"] = self.createIfNotExists!
        }
        if self.endpoint != nil {
            map["Endpoint"] = self.endpoint!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.externalTableType != nil {
            map["ExternalTableType"] = self.externalTableType!
        }
        if self.hasPart != nil {
            map["HasPart"] = self.hasPart!
        }
        if self.isView != nil {
            map["IsView"] = self.isView!
        }
        if self.lifeCycle != nil {
            map["LifeCycle"] = self.lifeCycle!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.logicalLevelId != nil {
            map["LogicalLevelId"] = self.logicalLevelId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicsLevelId != nil {
            map["PhysicsLevelId"] = self.physicsLevelId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.themes != nil {
            var tmp : [Any] = []
            for k in self.themes! {
                tmp.append(k.toMap())
            }
            map["Themes"] = tmp
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppGuid") {
            self.appGuid = dict["AppGuid"] as! String
        }
        if dict.keys.contains("CategoryId") {
            self.categoryId = dict["CategoryId"] as! Int64
        }
        if dict.keys.contains("Columns") {
            var tmp : [UpdateTableRequest.Columns] = []
            for v in dict["Columns"] as! [Any] {
                var model = UpdateTableRequest.Columns()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.columns = tmp
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("CreateIfNotExists") {
            self.createIfNotExists = dict["CreateIfNotExists"] as! Bool
        }
        if dict.keys.contains("Endpoint") {
            self.endpoint = dict["Endpoint"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! Int32
        }
        if dict.keys.contains("ExternalTableType") {
            self.externalTableType = dict["ExternalTableType"] as! String
        }
        if dict.keys.contains("HasPart") {
            self.hasPart = dict["HasPart"] as! Int32
        }
        if dict.keys.contains("IsView") {
            self.isView = dict["IsView"] as! Int32
        }
        if dict.keys.contains("LifeCycle") {
            self.lifeCycle = dict["LifeCycle"] as! Int32
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("LogicalLevelId") {
            self.logicalLevelId = dict["LogicalLevelId"] as! Int64
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PhysicsLevelId") {
            self.physicsLevelId = dict["PhysicsLevelId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("Schema") {
            self.schema = dict["Schema"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Themes") {
            var tmp : [UpdateTableRequest.Themes] = []
            for v in dict["Themes"] as! [Any] {
                var model = UpdateTableRequest.Themes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.themes = tmp
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! Int32
        }
    }
}

public class UpdateTableResponseBody : Tea.TeaModel {
    public class TaskInfo : Tea.TeaModel {
        public var content: String?

        public var nextTaskId: String?

        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.nextTaskId != nil {
                map["NextTaskId"] = self.nextTaskId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("NextTaskId") {
                self.nextTaskId = dict["NextTaskId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
        }
    }
    public var requestId: String?

    public var taskInfo: UpdateTableResponseBody.TaskInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskInfo != nil {
            map["TaskInfo"] = self.taskInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskInfo") {
            var model = UpdateTableResponseBody.TaskInfo()
            model.fromMap(dict["TaskInfo"] as! [String: Any])
            self.taskInfo = model
        }
    }
}

public class UpdateTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTableAddColumnRequest : Tea.TeaModel {
    public class Column : Tea.TeaModel {
        public var columnName: String?

        public var columnNameCn: String?

        public var columnType: String?

        public var comment: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columnName != nil {
                map["ColumnName"] = self.columnName!
            }
            if self.columnNameCn != nil {
                map["ColumnNameCn"] = self.columnNameCn!
            }
            if self.columnType != nil {
                map["ColumnType"] = self.columnType!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ColumnName") {
                self.columnName = dict["ColumnName"] as! String
            }
            if dict.keys.contains("ColumnNameCn") {
                self.columnNameCn = dict["ColumnNameCn"] as! String
            }
            if dict.keys.contains("ColumnType") {
                self.columnType = dict["ColumnType"] as! String
            }
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
        }
    }
    public var column: [UpdateTableAddColumnRequest.Column]?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            var tmp : [Any] = []
            for k in self.column! {
                tmp.append(k.toMap())
            }
            map["Column"] = tmp
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") {
            var tmp : [UpdateTableAddColumnRequest.Column] = []
            for v in dict["Column"] as! [Any] {
                var model = UpdateTableAddColumnRequest.Column()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.column = tmp
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
    }
}

public class UpdateTableAddColumnResponseBody : Tea.TeaModel {
    public class TaskInfo : Tea.TeaModel {
        public var content: String?

        public var nextTaskId: String?

        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.nextTaskId != nil {
                map["NextTaskId"] = self.nextTaskId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("NextTaskId") {
                self.nextTaskId = dict["NextTaskId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
        }
    }
    public var requestId: String?

    public var taskInfo: UpdateTableAddColumnResponseBody.TaskInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskInfo != nil {
            map["TaskInfo"] = self.taskInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskInfo") {
            var model = UpdateTableAddColumnResponseBody.TaskInfo()
            model.fromMap(dict["TaskInfo"] as! [String: Any])
            self.taskInfo = model
        }
    }
}

public class UpdateTableAddColumnResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTableAddColumnResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTableAddColumnResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTableLevelRequest : Tea.TeaModel {
    public var description_: String?

    public var levelId: Int64?

    public var levelType: Int32?

    public var name: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.levelId != nil {
            map["LevelId"] = self.levelId!
        }
        if self.levelType != nil {
            map["LevelType"] = self.levelType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("LevelId") {
            self.levelId = dict["LevelId"] as! Int64
        }
        if dict.keys.contains("LevelType") {
            self.levelType = dict["LevelType"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class UpdateTableLevelResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public var updateResult: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.updateResult != nil {
            map["UpdateResult"] = self.updateResult!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("UpdateResult") {
            self.updateResult = dict["UpdateResult"] as! Bool
        }
    }
}

public class UpdateTableLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTableLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTableLevelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTableModelInfoRequest : Tea.TeaModel {
    public var firstLevelThemeId: Int64?

    public var levelId: Int64?

    public var levelType: Int32?

    public var secondLevelThemeId: Int64?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.firstLevelThemeId != nil {
            map["FirstLevelThemeId"] = self.firstLevelThemeId!
        }
        if self.levelId != nil {
            map["LevelId"] = self.levelId!
        }
        if self.levelType != nil {
            map["LevelType"] = self.levelType!
        }
        if self.secondLevelThemeId != nil {
            map["SecondLevelThemeId"] = self.secondLevelThemeId!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FirstLevelThemeId") {
            self.firstLevelThemeId = dict["FirstLevelThemeId"] as! Int64
        }
        if dict.keys.contains("LevelId") {
            self.levelId = dict["LevelId"] as! Int64
        }
        if dict.keys.contains("LevelType") {
            self.levelType = dict["LevelType"] as! Int32
        }
        if dict.keys.contains("SecondLevelThemeId") {
            self.secondLevelThemeId = dict["SecondLevelThemeId"] as! Int64
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
    }
}

public class UpdateTableModelInfoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var updateResult: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.updateResult != nil {
            map["UpdateResult"] = self.updateResult!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UpdateResult") {
            self.updateResult = dict["UpdateResult"] as! Bool
        }
    }
}

public class UpdateTableModelInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTableModelInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTableModelInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTableThemeRequest : Tea.TeaModel {
    public var name: String?

    public var projectId: Int64?

    public var themeId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.themeId != nil {
            map["ThemeId"] = self.themeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ThemeId") {
            self.themeId = dict["ThemeId"] as! Int64
        }
    }
}

public class UpdateTableThemeResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public var updateResult: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.updateResult != nil {
            map["UpdateResult"] = self.updateResult!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("UpdateResult") {
            self.updateResult = dict["UpdateResult"] as! Bool
        }
    }
}

public class UpdateTableThemeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTableThemeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTableThemeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateUdfFileRequest : Tea.TeaModel {
    public var className: String?

    public var cmdDescription: String?

    public var example: String?

    public var fileFolderPath: String?

    public var fileId: String?

    public var functionType: String?

    public var parameterDescription: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var resources: String?

    public var returnValue: String?

    public var udfDescription: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.className != nil {
            map["ClassName"] = self.className!
        }
        if self.cmdDescription != nil {
            map["CmdDescription"] = self.cmdDescription!
        }
        if self.example != nil {
            map["Example"] = self.example!
        }
        if self.fileFolderPath != nil {
            map["FileFolderPath"] = self.fileFolderPath!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.functionType != nil {
            map["FunctionType"] = self.functionType!
        }
        if self.parameterDescription != nil {
            map["ParameterDescription"] = self.parameterDescription!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.resources != nil {
            map["Resources"] = self.resources!
        }
        if self.returnValue != nil {
            map["ReturnValue"] = self.returnValue!
        }
        if self.udfDescription != nil {
            map["UdfDescription"] = self.udfDescription!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClassName") {
            self.className = dict["ClassName"] as! String
        }
        if dict.keys.contains("CmdDescription") {
            self.cmdDescription = dict["CmdDescription"] as! String
        }
        if dict.keys.contains("Example") {
            self.example = dict["Example"] as! String
        }
        if dict.keys.contains("FileFolderPath") {
            self.fileFolderPath = dict["FileFolderPath"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! String
        }
        if dict.keys.contains("FunctionType") {
            self.functionType = dict["FunctionType"] as! String
        }
        if dict.keys.contains("ParameterDescription") {
            self.parameterDescription = dict["ParameterDescription"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ProjectIdentifier") {
            self.projectIdentifier = dict["ProjectIdentifier"] as! String
        }
        if dict.keys.contains("Resources") {
            self.resources = dict["Resources"] as! String
        }
        if dict.keys.contains("ReturnValue") {
            self.returnValue = dict["ReturnValue"] as! String
        }
        if dict.keys.contains("UdfDescription") {
            self.udfDescription = dict["UdfDescription"] as! String
        }
    }
}

public class UpdateUdfFileResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateUdfFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateUdfFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateUdfFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWorkbenchEventResultRequest : Tea.TeaModel {
    public var checkResult: String?

    public var checkResultTip: String?

    public var extensionCode: String?

    public var messageId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkResult != nil {
            map["CheckResult"] = self.checkResult!
        }
        if self.checkResultTip != nil {
            map["CheckResultTip"] = self.checkResultTip!
        }
        if self.extensionCode != nil {
            map["ExtensionCode"] = self.extensionCode!
        }
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckResult") {
            self.checkResult = dict["CheckResult"] as! String
        }
        if dict.keys.contains("CheckResultTip") {
            self.checkResultTip = dict["CheckResultTip"] as! String
        }
        if dict.keys.contains("ExtensionCode") {
            self.extensionCode = dict["ExtensionCode"] as! String
        }
        if dict.keys.contains("MessageId") {
            self.messageId = dict["MessageId"] as! String
        }
    }
}

public class UpdateWorkbenchEventResultResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateWorkbenchEventResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkbenchEventResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateWorkbenchEventResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
