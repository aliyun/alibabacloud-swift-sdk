import Foundation
import Tea
import TeaUtils
import DarabonbaXML
import AlibabaCloudCredentials
import TeaFileForm
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class Cluster : Tea.TeaModel {
    public var clusterBizId: String?

    public var clusterId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterBizId != nil {
            map["ClusterBizId"] = self.clusterBizId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterBizId"] as? String {
            self.clusterBizId = value
        }
        if let value = dict["ClusterId"] as? Int64 {
            self.clusterId = value
        }
    }
}

public class ClusterConfig : Tea.TeaModel {
    public var configValue: String?

    public var enableOverwrite: Bool?

    public var moduleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configValue != nil {
            map["ConfigValue"] = self.configValue!
        }
        if self.enableOverwrite != nil {
            map["EnableOverwrite"] = self.enableOverwrite!
        }
        if self.moduleName != nil {
            map["ModuleName"] = self.moduleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigValue"] as? String {
            self.configValue = value
        }
        if let value = dict["EnableOverwrite"] as? Bool {
            self.enableOverwrite = value
        }
        if let value = dict["ModuleName"] as? String {
            self.moduleName = value
        }
    }
}

public class Collection : Tea.TeaModel {
    public var collectionType: String?

    public var comment: String?

    public var createTime: Int64?

    public var level: Int32?

    public var name: String?

    public var ownerId: String?

    public var ownerName: String?

    public var qualifiedName: String?

    public var updateTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectionType != nil {
            map["CollectionType"] = self.collectionType!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ownerName != nil {
            map["OwnerName"] = self.ownerName!
        }
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CollectionType"] as? String {
            self.collectionType = value
        }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["Level"] as? Int32 {
            self.level = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["OwnerName"] as? String {
            self.ownerName = value
        }
        if let value = dict["QualifiedName"] as? String {
            self.qualifiedName = value
        }
        if let value = dict["UpdateTime"] as? Int64 {
            self.updateTime = value
        }
    }
}

public class Entity : Tea.TeaModel {
    public var entityContent: [String: Any]?

    public var qualifiedName: String?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityContent != nil {
            map["EntityContent"] = self.entityContent!
        }
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EntityContent"] as? [String: Any] {
            self.entityContent = value
        }
        if let value = dict["QualifiedName"] as? String {
            self.qualifiedName = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class LineageEntityVO : Tea.TeaModel {
    public var attributes: [String: String]?

    public var detailUrl: String?

    public var entityType: String?

    public var name: String?

    public var owner: String?

    public var parentName: String?

    public var qualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributes != nil {
            map["Attributes"] = self.attributes!
        }
        if self.detailUrl != nil {
            map["DetailUrl"] = self.detailUrl!
        }
        if self.entityType != nil {
            map["EntityType"] = self.entityType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.parentName != nil {
            map["ParentName"] = self.parentName!
        }
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Attributes"] as? [String: String] {
            self.attributes = value
        }
        if let value = dict["DetailUrl"] as? String {
            self.detailUrl = value
        }
        if let value = dict["EntityType"] as? String {
            self.entityType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["ParentName"] as? String {
            self.parentName = value
        }
        if let value = dict["QualifiedName"] as? String {
            self.qualifiedName = value
        }
    }
}

public class LineageRelationRegisterBulkVO : Tea.TeaModel {
    public var createTimestamp: Int64?

    public var destEntities: [LineageEntityVO]?

    public var relationship: RelationshipVO?

    public var srcEntities: [LineageEntityVO]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.relationship?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.destEntities != nil {
            var tmp : [Any] = []
            for k in self.destEntities! {
                tmp.append(k.toMap())
            }
            map["DestEntities"] = tmp
        }
        if self.relationship != nil {
            map["Relationship"] = self.relationship?.toMap()
        }
        if self.srcEntities != nil {
            var tmp : [Any] = []
            for k in self.srcEntities! {
                tmp.append(k.toMap())
            }
            map["SrcEntities"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["DestEntities"] as? [Any?] {
            var tmp : [LineageEntityVO] = []
            for v in value {
                if v != nil {
                    var model = LineageEntityVO()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.destEntities = tmp
        }
        if let value = dict["Relationship"] as? [String: Any?] {
            var model = RelationshipVO()
            model.fromMap(value)
            self.relationship = model
        }
        if let value = dict["SrcEntities"] as? [Any?] {
            var tmp : [LineageEntityVO] = []
            for v in value {
                if v != nil {
                    var model = LineageEntityVO()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.srcEntities = tmp
        }
    }
}

public class LineageRelationRegisterTaskVO : Tea.TeaModel {
    public var attributes: [String: String]?

    public var createTimestamp: Int64?

    public var inputEntities: [LineageEntityVO]?

    public var name: String?

    public var outputEntities: [LineageEntityVO]?

    public var qualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributes != nil {
            map["Attributes"] = self.attributes!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.inputEntities != nil {
            var tmp : [Any] = []
            for k in self.inputEntities! {
                tmp.append(k.toMap())
            }
            map["InputEntities"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputEntities != nil {
            var tmp : [Any] = []
            for k in self.outputEntities! {
                tmp.append(k.toMap())
            }
            map["OutputEntities"] = tmp
        }
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Attributes"] as? [String: String] {
            self.attributes = value
        }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["InputEntities"] as? [Any?] {
            var tmp : [LineageEntityVO] = []
            for v in value {
                if v != nil {
                    var model = LineageEntityVO()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.inputEntities = tmp
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OutputEntities"] as? [Any?] {
            var tmp : [LineageEntityVO] = []
            for v in value {
                if v != nil {
                    var model = LineageEntityVO()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.outputEntities = tmp
        }
        if let value = dict["QualifiedName"] as? String {
            self.qualifiedName = value
        }
    }
}

public class LineageRelationRegisterVO : Tea.TeaModel {
    public var createTimestamp: Int64?

    public var destEntity: LineageEntityVO?

    public var relationship: RelationshipVO?

    public var srcEntity: LineageEntityVO?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.destEntity?.validate()
        try self.relationship?.validate()
        try self.srcEntity?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.destEntity != nil {
            map["DestEntity"] = self.destEntity?.toMap()
        }
        if self.relationship != nil {
            map["Relationship"] = self.relationship?.toMap()
        }
        if self.srcEntity != nil {
            map["SrcEntity"] = self.srcEntity?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["DestEntity"] as? [String: Any?] {
            var model = LineageEntityVO()
            model.fromMap(value)
            self.destEntity = model
        }
        if let value = dict["Relationship"] as? [String: Any?] {
            var model = RelationshipVO()
            model.fromMap(value)
            self.relationship = model
        }
        if let value = dict["SrcEntity"] as? [String: Any?] {
            var model = LineageEntityVO()
            model.fromMap(value)
            self.srcEntity = model
        }
    }
}

public class RelationshipVO : Tea.TeaModel {
    public var attributes: [String: String]?

    public var relationshipGuid: String?

    public var relationshipType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributes != nil {
            map["Attributes"] = self.attributes!
        }
        if self.relationshipGuid != nil {
            map["RelationshipGuid"] = self.relationshipGuid!
        }
        if self.relationshipType != nil {
            map["RelationshipType"] = self.relationshipType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Attributes"] as? [String: String] {
            self.attributes = value
        }
        if let value = dict["RelationshipGuid"] as? String {
            self.relationshipGuid = value
        }
        if let value = dict["RelationshipType"] as? String {
            self.relationshipType = value
        }
    }
}

public class UserEntityTag : Tea.TeaModel {
    public var tagKey: String?

    public var tagValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        if self.tagValue != nil {
            map["TagValue"] = self.tagValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TagKey"] as? String {
            self.tagKey = value
        }
        if let value = dict["TagValue"] as? String {
            self.tagValue = value
        }
    }
}

public class DataDesensPlanTemplateValue : Tea.TeaModel {
    public var name: String?

    public var supportWaterMark: Bool?

    public var extParamTemplate: [Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.supportWaterMark != nil {
            map["SupportWaterMark"] = self.supportWaterMark!
        }
        if self.extParamTemplate != nil {
            map["ExtParamTemplate"] = self.extParamTemplate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["SupportWaterMark"] as? Bool {
            self.supportWaterMark = value
        }
        if let value = dict["ExtParamTemplate"] as? [Any] {
            self.extParamTemplate = value
        }
    }
}

public class AbolishDataServiceApiRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiId"] as? Int64 {
            self.apiId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class AbolishDataServiceApiResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class AbolishDataServiceApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AbolishDataServiceApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AbolishDataServiceApiResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddMetaCollectionEntityRequest : Tea.TeaModel {
    public var collectionQualifiedName: String?

    public var entityQualifiedName: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectionQualifiedName != nil {
            map["CollectionQualifiedName"] = self.collectionQualifiedName!
        }
        if self.entityQualifiedName != nil {
            map["EntityQualifiedName"] = self.entityQualifiedName!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CollectionQualifiedName"] as? String {
            self.collectionQualifiedName = value
        }
        if let value = dict["EntityQualifiedName"] as? String {
            self.entityQualifiedName = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
    }
}

public class AddMetaCollectionEntityResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var status: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? Bool {
            self.status = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class AddMetaCollectionEntityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMetaCollectionEntityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddMetaCollectionEntityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddProjectMemberToRoleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var projectId: Int64?

    public var roleCode: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCode != nil {
            map["RoleCode"] = self.roleCode!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RoleCode"] as? String {
            self.roleCode = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class AddProjectMemberToRoleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddProjectMemberToRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddProjectMemberToRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddProjectMemberToRoleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddRecognizeRuleRequest : Tea.TeaModel {
    public var accountName: String?

    public var colExclude: String?

    public var colScan: String?

    public var commentScan: String?

    public var contentScan: String?

    public var hitThreshold: Int32?

    public var level: String?

    public var levelName: String?

    public var nodeId: String?

    public var nodeParent: String?

    public var operationType: Int32?

    public var recognizeRules: String?

    public var recognizeRulesType: String?

    public var sensitiveDescription: String?

    public var sensitiveName: String?

    public var status: Int32?

    public var templateId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.colExclude != nil {
            map["ColExclude"] = self.colExclude!
        }
        if self.colScan != nil {
            map["ColScan"] = self.colScan!
        }
        if self.commentScan != nil {
            map["CommentScan"] = self.commentScan!
        }
        if self.contentScan != nil {
            map["ContentScan"] = self.contentScan!
        }
        if self.hitThreshold != nil {
            map["HitThreshold"] = self.hitThreshold!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.levelName != nil {
            map["LevelName"] = self.levelName!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeParent != nil {
            map["NodeParent"] = self.nodeParent!
        }
        if self.operationType != nil {
            map["OperationType"] = self.operationType!
        }
        if self.recognizeRules != nil {
            map["RecognizeRules"] = self.recognizeRules!
        }
        if self.recognizeRulesType != nil {
            map["RecognizeRulesType"] = self.recognizeRulesType!
        }
        if self.sensitiveDescription != nil {
            map["SensitiveDescription"] = self.sensitiveDescription!
        }
        if self.sensitiveName != nil {
            map["SensitiveName"] = self.sensitiveName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["ColExclude"] as? String {
            self.colExclude = value
        }
        if let value = dict["ColScan"] as? String {
            self.colScan = value
        }
        if let value = dict["CommentScan"] as? String {
            self.commentScan = value
        }
        if let value = dict["ContentScan"] as? String {
            self.contentScan = value
        }
        if let value = dict["HitThreshold"] as? Int32 {
            self.hitThreshold = value
        }
        if let value = dict["Level"] as? String {
            self.level = value
        }
        if let value = dict["LevelName"] as? String {
            self.levelName = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["NodeParent"] as? String {
            self.nodeParent = value
        }
        if let value = dict["OperationType"] as? Int32 {
            self.operationType = value
        }
        if let value = dict["RecognizeRules"] as? String {
            self.recognizeRules = value
        }
        if let value = dict["RecognizeRulesType"] as? String {
            self.recognizeRulesType = value
        }
        if let value = dict["SensitiveDescription"] as? String {
            self.sensitiveDescription = value
        }
        if let value = dict["SensitiveName"] as? String {
            self.sensitiveName = value
        }
        if let value = dict["Status"] as? Int32 {
            self.status = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
        if let value = dict["TenantId"] as? String {
            self.tenantId = value
        }
    }
}

public class AddRecognizeRuleResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Any {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class AddRecognizeRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddRecognizeRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddRecognizeRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddToMetaCategoryRequest : Tea.TeaModel {
    public var categoryId: Int64?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CategoryId"] as? Int64 {
            self.categoryId = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
    }
}

public class AddToMetaCategoryResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class AddToMetaCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddToMetaCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddToMetaCategoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ApprovePermissionApplyOrderRequest : Tea.TeaModel {
    public var approveAction: Int32?

    public var approveComment: String?

    public var flowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.approveAction != nil {
            map["ApproveAction"] = self.approveAction!
        }
        if self.approveComment != nil {
            map["ApproveComment"] = self.approveComment!
        }
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApproveAction"] as? Int32 {
            self.approveAction = value
        }
        if let value = dict["ApproveComment"] as? String {
            self.approveComment = value
        }
        if let value = dict["FlowId"] as? String {
            self.flowId = value
        }
    }
}

public class ApprovePermissionApplyOrderResponseBody : Tea.TeaModel {
    public var approveSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.approveSuccess != nil {
            map["ApproveSuccess"] = self.approveSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApproveSuccess"] as? Bool {
            self.approveSuccess = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ApprovePermissionApplyOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApprovePermissionApplyOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ApprovePermissionApplyOrderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CallbackExtensionRequest : Tea.TeaModel {
    public var checkMessage: String?

    public var checkResult: String?

    public var extensionCode: String?

    public var messageId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkMessage != nil {
            map["CheckMessage"] = self.checkMessage!
        }
        if self.checkResult != nil {
            map["CheckResult"] = self.checkResult!
        }
        if self.extensionCode != nil {
            map["ExtensionCode"] = self.extensionCode!
        }
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CheckMessage"] as? String {
            self.checkMessage = value
        }
        if let value = dict["CheckResult"] as? String {
            self.checkResult = value
        }
        if let value = dict["ExtensionCode"] as? String {
            self.extensionCode = value
        }
        if let value = dict["MessageId"] as? String {
            self.messageId = value
        }
    }
}

public class CallbackExtensionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class CallbackExtensionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CallbackExtensionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CallbackExtensionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ChangeResourceManagerResourceGroupRequest : Tea.TeaModel {
    public var resourceId: String?

    public var resourceManagerResourceGroupId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceManagerResourceGroupId != nil {
            map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceManagerResourceGroupId"] as? String {
            self.resourceManagerResourceGroupId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class ChangeResourceManagerResourceGroupResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ChangeResourceManagerResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeResourceManagerResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ChangeResourceManagerResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CheckFileDeploymentRequest : Tea.TeaModel {
    public var checkDetailUrl: String?

    public var checkerInstanceId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkDetailUrl != nil {
            map["CheckDetailUrl"] = self.checkDetailUrl!
        }
        if self.checkerInstanceId != nil {
            map["CheckerInstanceId"] = self.checkerInstanceId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CheckDetailUrl"] as? String {
            self.checkDetailUrl = value
        }
        if let value = dict["CheckerInstanceId"] as? String {
            self.checkerInstanceId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class CheckFileDeploymentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CheckFileDeploymentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckFileDeploymentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CheckFileDeploymentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CheckMetaPartitionRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var partition: String?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.partition != nil {
            map["Partition"] = self.partition!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["DatabaseName"] as? String {
            self.databaseName = value
        }
        if let value = dict["Partition"] as? String {
            self.partition = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class CheckMetaPartitionResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CheckMetaPartitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckMetaPartitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CheckMetaPartitionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CheckMetaTableRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["DatabaseName"] as? String {
            self.databaseName = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class CheckMetaTableResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CheckMetaTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckMetaTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CheckMetaTableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateBaselineRequest : Tea.TeaModel {
    public class OvertimeSettings : Tea.TeaModel {
        public var cycle: Int32?

        public var time: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycle != nil {
                map["Cycle"] = self.cycle!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cycle"] as? Int32 {
                self.cycle = value
            }
            if let value = dict["Time"] as? String {
                self.time = value
            }
        }
    }
    public var alertMarginThreshold: Int32?

    public var baselineName: String?

    public var baselineType: String?

    public var nodeIds: String?

    public var overtimeSettings: [CreateBaselineRequest.OvertimeSettings]?

    public var owner: String?

    public var priority: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertMarginThreshold != nil {
            map["AlertMarginThreshold"] = self.alertMarginThreshold!
        }
        if self.baselineName != nil {
            map["BaselineName"] = self.baselineName!
        }
        if self.baselineType != nil {
            map["BaselineType"] = self.baselineType!
        }
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.overtimeSettings != nil {
            var tmp : [Any] = []
            for k in self.overtimeSettings! {
                tmp.append(k.toMap())
            }
            map["OvertimeSettings"] = tmp
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlertMarginThreshold"] as? Int32 {
            self.alertMarginThreshold = value
        }
        if let value = dict["BaselineName"] as? String {
            self.baselineName = value
        }
        if let value = dict["BaselineType"] as? String {
            self.baselineType = value
        }
        if let value = dict["NodeIds"] as? String {
            self.nodeIds = value
        }
        if let value = dict["OvertimeSettings"] as? [Any?] {
            var tmp : [CreateBaselineRequest.OvertimeSettings] = []
            for v in value {
                if v != nil {
                    var model = CreateBaselineRequest.OvertimeSettings()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.overtimeSettings = tmp
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class CreateBaselineResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int64 {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateBaselineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBaselineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateBaselineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateBusinessRequest : Tea.TeaModel {
    public var businessName: String?

    public var description_: String?

    public var owner: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var useType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessName != nil {
            map["BusinessName"] = self.businessName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.useType != nil {
            map["UseType"] = self.useType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BusinessName"] as? String {
            self.businessName = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
        if let value = dict["UseType"] as? String {
            self.useType = value
        }
    }
}

public class CreateBusinessResponseBody : Tea.TeaModel {
    public var businessId: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessId != nil {
            map["BusinessId"] = self.businessId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BusinessId"] as? Int64 {
            self.businessId = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateBusinessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBusinessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateBusinessResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateConnectionRequest : Tea.TeaModel {
    public var connectionType: String?

    public var content: String?

    public var description_: String?

    public var envType: Int32?

    public var name: String?

    public var projectId: Int64?

    public var subType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionType != nil {
            map["ConnectionType"] = self.connectionType!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.subType != nil {
            map["SubType"] = self.subType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionType"] as? String {
            self.connectionType = value
        }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnvType"] as? Int32 {
            self.envType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SubType"] as? String {
            self.subType = value
        }
    }
}

public class CreateConnectionResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int64 {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? String {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDIAlarmRuleRequest : Tea.TeaModel {
    public class NotificationSettings : Tea.TeaModel {
        public class NotificationChannels : Tea.TeaModel {
            public var channels: [String]?

            public var severity: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Channels"] as? [String] {
                    self.channels = value
                }
                if let value = dict["Severity"] as? String {
                    self.severity = value
                }
            }
        }
        public class NotificationReceivers : Tea.TeaModel {
            public var receiverType: String?

            public var receiverValues: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.receiverType != nil {
                    map["ReceiverType"] = self.receiverType!
                }
                if self.receiverValues != nil {
                    map["ReceiverValues"] = self.receiverValues!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ReceiverType"] as? String {
                    self.receiverType = value
                }
                if let value = dict["ReceiverValues"] as? [String] {
                    self.receiverValues = value
                }
            }
        }
        public var inhibitionInterval: Int32?

        public var notificationChannels: [CreateDIAlarmRuleRequest.NotificationSettings.NotificationChannels]?

        public var notificationReceivers: [CreateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inhibitionInterval != nil {
                map["InhibitionInterval"] = self.inhibitionInterval!
            }
            if self.notificationChannels != nil {
                var tmp : [Any] = []
                for k in self.notificationChannels! {
                    tmp.append(k.toMap())
                }
                map["NotificationChannels"] = tmp
            }
            if self.notificationReceivers != nil {
                var tmp : [Any] = []
                for k in self.notificationReceivers! {
                    tmp.append(k.toMap())
                }
                map["NotificationReceivers"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InhibitionInterval"] as? Int32 {
                self.inhibitionInterval = value
            }
            if let value = dict["NotificationChannels"] as? [Any?] {
                var tmp : [CreateDIAlarmRuleRequest.NotificationSettings.NotificationChannels] = []
                for v in value {
                    if v != nil {
                        var model = CreateDIAlarmRuleRequest.NotificationSettings.NotificationChannels()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.notificationChannels = tmp
            }
            if let value = dict["NotificationReceivers"] as? [Any?] {
                var tmp : [CreateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers] = []
                for v in value {
                    if v != nil {
                        var model = CreateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.notificationReceivers = tmp
            }
        }
    }
    public class TriggerConditions : Tea.TeaModel {
        public var duration: Int64?

        public var severity: String?

        public var threshold: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Duration"] as? Int64 {
                self.duration = value
            }
            if let value = dict["Severity"] as? String {
                self.severity = value
            }
            if let value = dict["Threshold"] as? Int64 {
                self.threshold = value
            }
        }
    }
    public var DIJobId: Int64?

    public var description_: String?

    public var enabled: Bool?

    public var metricType: String?

    public var notificationSettings: CreateDIAlarmRuleRequest.NotificationSettings?

    public var triggerConditions: [CreateDIAlarmRuleRequest.TriggerConditions]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notificationSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.notificationSettings != nil {
            map["NotificationSettings"] = self.notificationSettings?.toMap()
        }
        if self.triggerConditions != nil {
            var tmp : [Any] = []
            for k in self.triggerConditions! {
                tmp.append(k.toMap())
            }
            map["TriggerConditions"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["MetricType"] as? String {
            self.metricType = value
        }
        if let value = dict["NotificationSettings"] as? [String: Any?] {
            var model = CreateDIAlarmRuleRequest.NotificationSettings()
            model.fromMap(value)
            self.notificationSettings = model
        }
        if let value = dict["TriggerConditions"] as? [Any?] {
            var tmp : [CreateDIAlarmRuleRequest.TriggerConditions] = []
            for v in value {
                if v != nil {
                    var model = CreateDIAlarmRuleRequest.TriggerConditions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.triggerConditions = tmp
        }
    }
}

public class CreateDIAlarmRuleShrinkRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var description_: String?

    public var enabled: Bool?

    public var metricType: String?

    public var notificationSettingsShrink: String?

    public var triggerConditionsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.notificationSettingsShrink != nil {
            map["NotificationSettings"] = self.notificationSettingsShrink!
        }
        if self.triggerConditionsShrink != nil {
            map["TriggerConditions"] = self.triggerConditionsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["MetricType"] as? String {
            self.metricType = value
        }
        if let value = dict["NotificationSettings"] as? String {
            self.notificationSettingsShrink = value
        }
        if let value = dict["TriggerConditions"] as? String {
            self.triggerConditionsShrink = value
        }
    }
}

public class CreateDIAlarmRuleResponseBody : Tea.TeaModel {
    public var DIAlarmRuleId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIAlarmRuleId"] as? Int64 {
            self.DIAlarmRuleId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDIAlarmRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDIAlarmRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDIAlarmRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDIJobRequest : Tea.TeaModel {
    public class DestinationDataSourceSettings : Tea.TeaModel {
        public var dataSourceName: String?

        public var dataSourceProperties: [String: String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceName != nil {
                map["DataSourceName"] = self.dataSourceName!
            }
            if self.dataSourceProperties != nil {
                map["DataSourceProperties"] = self.dataSourceProperties!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataSourceName"] as? String {
                self.dataSourceName = value
            }
            if let value = dict["DataSourceProperties"] as? [String: String] {
                self.dataSourceProperties = value
            }
        }
    }
    public class JobSettings : Tea.TeaModel {
        public class ColumnDataTypeSettings : Tea.TeaModel {
            public var destinationDataType: String?

            public var sourceDataType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.destinationDataType != nil {
                    map["DestinationDataType"] = self.destinationDataType!
                }
                if self.sourceDataType != nil {
                    map["SourceDataType"] = self.sourceDataType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DestinationDataType"] as? String {
                    self.destinationDataType = value
                }
                if let value = dict["SourceDataType"] as? String {
                    self.sourceDataType = value
                }
            }
        }
        public class CycleScheduleSettings : Tea.TeaModel {
            public var cycleMigrationType: String?

            public var scheduleParameters: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleMigrationType != nil {
                    map["CycleMigrationType"] = self.cycleMigrationType!
                }
                if self.scheduleParameters != nil {
                    map["ScheduleParameters"] = self.scheduleParameters!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CycleMigrationType"] as? String {
                    self.cycleMigrationType = value
                }
                if let value = dict["ScheduleParameters"] as? String {
                    self.scheduleParameters = value
                }
            }
        }
        public class DdlHandlingSettings : Tea.TeaModel {
            public var action: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Action"] as? String {
                    self.action = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class ImportRuleSettings : Tea.TeaModel {
            public var fileId: String?

            public var source: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FileId"] as? String {
                    self.fileId = value
                }
                if let value = dict["Source"] as? String {
                    self.source = value
                }
            }
        }
        public class RuntimeSettings : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var channelSettings: String?

        public var columnDataTypeSettings: [CreateDIJobRequest.JobSettings.ColumnDataTypeSettings]?

        public var cycleScheduleSettings: CreateDIJobRequest.JobSettings.CycleScheduleSettings?

        public var ddlHandlingSettings: [CreateDIJobRequest.JobSettings.DdlHandlingSettings]?

        public var importRuleSettings: CreateDIJobRequest.JobSettings.ImportRuleSettings?

        public var runtimeSettings: [CreateDIJobRequest.JobSettings.RuntimeSettings]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cycleScheduleSettings?.validate()
            try self.importRuleSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelSettings != nil {
                map["ChannelSettings"] = self.channelSettings!
            }
            if self.columnDataTypeSettings != nil {
                var tmp : [Any] = []
                for k in self.columnDataTypeSettings! {
                    tmp.append(k.toMap())
                }
                map["ColumnDataTypeSettings"] = tmp
            }
            if self.cycleScheduleSettings != nil {
                map["CycleScheduleSettings"] = self.cycleScheduleSettings?.toMap()
            }
            if self.ddlHandlingSettings != nil {
                var tmp : [Any] = []
                for k in self.ddlHandlingSettings! {
                    tmp.append(k.toMap())
                }
                map["DdlHandlingSettings"] = tmp
            }
            if self.importRuleSettings != nil {
                map["ImportRuleSettings"] = self.importRuleSettings?.toMap()
            }
            if self.runtimeSettings != nil {
                var tmp : [Any] = []
                for k in self.runtimeSettings! {
                    tmp.append(k.toMap())
                }
                map["RuntimeSettings"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChannelSettings"] as? String {
                self.channelSettings = value
            }
            if let value = dict["ColumnDataTypeSettings"] as? [Any?] {
                var tmp : [CreateDIJobRequest.JobSettings.ColumnDataTypeSettings] = []
                for v in value {
                    if v != nil {
                        var model = CreateDIJobRequest.JobSettings.ColumnDataTypeSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.columnDataTypeSettings = tmp
            }
            if let value = dict["CycleScheduleSettings"] as? [String: Any?] {
                var model = CreateDIJobRequest.JobSettings.CycleScheduleSettings()
                model.fromMap(value)
                self.cycleScheduleSettings = model
            }
            if let value = dict["DdlHandlingSettings"] as? [Any?] {
                var tmp : [CreateDIJobRequest.JobSettings.DdlHandlingSettings] = []
                for v in value {
                    if v != nil {
                        var model = CreateDIJobRequest.JobSettings.DdlHandlingSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ddlHandlingSettings = tmp
            }
            if let value = dict["ImportRuleSettings"] as? [String: Any?] {
                var model = CreateDIJobRequest.JobSettings.ImportRuleSettings()
                model.fromMap(value)
                self.importRuleSettings = model
            }
            if let value = dict["RuntimeSettings"] as? [Any?] {
                var tmp : [CreateDIJobRequest.JobSettings.RuntimeSettings] = []
                for v in value {
                    if v != nil {
                        var model = CreateDIJobRequest.JobSettings.RuntimeSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.runtimeSettings = tmp
            }
        }
    }
    public class ResourceSettings : Tea.TeaModel {
        public class OfflineResourceSettings : Tea.TeaModel {
            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceGroupIdentifier"] as? String {
                    self.resourceGroupIdentifier = value
                }
            }
        }
        public class RealtimeResourceSettings : Tea.TeaModel {
            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceGroupIdentifier"] as? String {
                    self.resourceGroupIdentifier = value
                }
            }
        }
        public var offlineResourceSettings: CreateDIJobRequest.ResourceSettings.OfflineResourceSettings?

        public var realtimeResourceSettings: CreateDIJobRequest.ResourceSettings.RealtimeResourceSettings?

        public var requestedCu: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.offlineResourceSettings?.validate()
            try self.realtimeResourceSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.offlineResourceSettings != nil {
                map["OfflineResourceSettings"] = self.offlineResourceSettings?.toMap()
            }
            if self.realtimeResourceSettings != nil {
                map["RealtimeResourceSettings"] = self.realtimeResourceSettings?.toMap()
            }
            if self.requestedCu != nil {
                map["RequestedCu"] = self.requestedCu!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OfflineResourceSettings"] as? [String: Any?] {
                var model = CreateDIJobRequest.ResourceSettings.OfflineResourceSettings()
                model.fromMap(value)
                self.offlineResourceSettings = model
            }
            if let value = dict["RealtimeResourceSettings"] as? [String: Any?] {
                var model = CreateDIJobRequest.ResourceSettings.RealtimeResourceSettings()
                model.fromMap(value)
                self.realtimeResourceSettings = model
            }
            if let value = dict["RequestedCu"] as? Double {
                self.requestedCu = value
            }
        }
    }
    public class SourceDataSourceSettings : Tea.TeaModel {
        public var dataSourceName: String?

        public var dataSourceProperties: [String: String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceName != nil {
                map["DataSourceName"] = self.dataSourceName!
            }
            if self.dataSourceProperties != nil {
                map["DataSourceProperties"] = self.dataSourceProperties!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataSourceName"] as? String {
                self.dataSourceName = value
            }
            if let value = dict["DataSourceProperties"] as? [String: String] {
                self.dataSourceProperties = value
            }
        }
    }
    public class TableMappings : Tea.TeaModel {
        public class SourceObjectSelectionRules : Tea.TeaModel {
            public var expression: String?

            public var objectType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.objectType != nil {
                    map["ObjectType"] = self.objectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Expression"] as? String {
                    self.expression = value
                }
                if let value = dict["ObjectType"] as? String {
                    self.objectType = value
                }
            }
        }
        public class TransformationRules : Tea.TeaModel {
            public var ruleActionType: String?

            public var ruleName: String?

            public var ruleTargetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ruleActionType != nil {
                    map["RuleActionType"] = self.ruleActionType!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.ruleTargetType != nil {
                    map["RuleTargetType"] = self.ruleTargetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RuleActionType"] as? String {
                    self.ruleActionType = value
                }
                if let value = dict["RuleName"] as? String {
                    self.ruleName = value
                }
                if let value = dict["RuleTargetType"] as? String {
                    self.ruleTargetType = value
                }
            }
        }
        public var sourceObjectSelectionRules: [CreateDIJobRequest.TableMappings.SourceObjectSelectionRules]?

        public var transformationRules: [CreateDIJobRequest.TableMappings.TransformationRules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sourceObjectSelectionRules != nil {
                var tmp : [Any] = []
                for k in self.sourceObjectSelectionRules! {
                    tmp.append(k.toMap())
                }
                map["SourceObjectSelectionRules"] = tmp
            }
            if self.transformationRules != nil {
                var tmp : [Any] = []
                for k in self.transformationRules! {
                    tmp.append(k.toMap())
                }
                map["TransformationRules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SourceObjectSelectionRules"] as? [Any?] {
                var tmp : [CreateDIJobRequest.TableMappings.SourceObjectSelectionRules] = []
                for v in value {
                    if v != nil {
                        var model = CreateDIJobRequest.TableMappings.SourceObjectSelectionRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sourceObjectSelectionRules = tmp
            }
            if let value = dict["TransformationRules"] as? [Any?] {
                var tmp : [CreateDIJobRequest.TableMappings.TransformationRules] = []
                for v in value {
                    if v != nil {
                        var model = CreateDIJobRequest.TableMappings.TransformationRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.transformationRules = tmp
            }
        }
    }
    public class TransformationRules : Tea.TeaModel {
        public var ruleActionType: String?

        public var ruleExpression: String?

        public var ruleName: String?

        public var ruleTargetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleActionType != nil {
                map["RuleActionType"] = self.ruleActionType!
            }
            if self.ruleExpression != nil {
                map["RuleExpression"] = self.ruleExpression!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.ruleTargetType != nil {
                map["RuleTargetType"] = self.ruleTargetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RuleActionType"] as? String {
                self.ruleActionType = value
            }
            if let value = dict["RuleExpression"] as? String {
                self.ruleExpression = value
            }
            if let value = dict["RuleName"] as? String {
                self.ruleName = value
            }
            if let value = dict["RuleTargetType"] as? String {
                self.ruleTargetType = value
            }
        }
    }
    public var description_: String?

    public var destinationDataSourceSettings: [CreateDIJobRequest.DestinationDataSourceSettings]?

    public var destinationDataSourceType: String?

    public var jobName: String?

    public var jobSettings: CreateDIJobRequest.JobSettings?

    public var migrationType: String?

    public var projectId: Int64?

    public var resourceSettings: CreateDIJobRequest.ResourceSettings?

    public var sourceDataSourceSettings: [CreateDIJobRequest.SourceDataSourceSettings]?

    public var sourceDataSourceType: String?

    public var systemDebug: String?

    public var tableMappings: [CreateDIJobRequest.TableMappings]?

    public var transformationRules: [CreateDIJobRequest.TransformationRules]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobSettings?.validate()
        try self.resourceSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationDataSourceSettings != nil {
            var tmp : [Any] = []
            for k in self.destinationDataSourceSettings! {
                tmp.append(k.toMap())
            }
            map["DestinationDataSourceSettings"] = tmp
        }
        if self.destinationDataSourceType != nil {
            map["DestinationDataSourceType"] = self.destinationDataSourceType!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.jobSettings != nil {
            map["JobSettings"] = self.jobSettings?.toMap()
        }
        if self.migrationType != nil {
            map["MigrationType"] = self.migrationType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceSettings != nil {
            map["ResourceSettings"] = self.resourceSettings?.toMap()
        }
        if self.sourceDataSourceSettings != nil {
            var tmp : [Any] = []
            for k in self.sourceDataSourceSettings! {
                tmp.append(k.toMap())
            }
            map["SourceDataSourceSettings"] = tmp
        }
        if self.sourceDataSourceType != nil {
            map["SourceDataSourceType"] = self.sourceDataSourceType!
        }
        if self.systemDebug != nil {
            map["SystemDebug"] = self.systemDebug!
        }
        if self.tableMappings != nil {
            var tmp : [Any] = []
            for k in self.tableMappings! {
                tmp.append(k.toMap())
            }
            map["TableMappings"] = tmp
        }
        if self.transformationRules != nil {
            var tmp : [Any] = []
            for k in self.transformationRules! {
                tmp.append(k.toMap())
            }
            map["TransformationRules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DestinationDataSourceSettings"] as? [Any?] {
            var tmp : [CreateDIJobRequest.DestinationDataSourceSettings] = []
            for v in value {
                if v != nil {
                    var model = CreateDIJobRequest.DestinationDataSourceSettings()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.destinationDataSourceSettings = tmp
        }
        if let value = dict["DestinationDataSourceType"] as? String {
            self.destinationDataSourceType = value
        }
        if let value = dict["JobName"] as? String {
            self.jobName = value
        }
        if let value = dict["JobSettings"] as? [String: Any?] {
            var model = CreateDIJobRequest.JobSettings()
            model.fromMap(value)
            self.jobSettings = model
        }
        if let value = dict["MigrationType"] as? String {
            self.migrationType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceSettings"] as? [String: Any?] {
            var model = CreateDIJobRequest.ResourceSettings()
            model.fromMap(value)
            self.resourceSettings = model
        }
        if let value = dict["SourceDataSourceSettings"] as? [Any?] {
            var tmp : [CreateDIJobRequest.SourceDataSourceSettings] = []
            for v in value {
                if v != nil {
                    var model = CreateDIJobRequest.SourceDataSourceSettings()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.sourceDataSourceSettings = tmp
        }
        if let value = dict["SourceDataSourceType"] as? String {
            self.sourceDataSourceType = value
        }
        if let value = dict["SystemDebug"] as? String {
            self.systemDebug = value
        }
        if let value = dict["TableMappings"] as? [Any?] {
            var tmp : [CreateDIJobRequest.TableMappings] = []
            for v in value {
                if v != nil {
                    var model = CreateDIJobRequest.TableMappings()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tableMappings = tmp
        }
        if let value = dict["TransformationRules"] as? [Any?] {
            var tmp : [CreateDIJobRequest.TransformationRules] = []
            for v in value {
                if v != nil {
                    var model = CreateDIJobRequest.TransformationRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.transformationRules = tmp
        }
    }
}

public class CreateDIJobShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var destinationDataSourceSettingsShrink: String?

    public var destinationDataSourceType: String?

    public var jobName: String?

    public var jobSettingsShrink: String?

    public var migrationType: String?

    public var projectId: Int64?

    public var resourceSettingsShrink: String?

    public var sourceDataSourceSettingsShrink: String?

    public var sourceDataSourceType: String?

    public var systemDebug: String?

    public var tableMappingsShrink: String?

    public var transformationRulesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationDataSourceSettingsShrink != nil {
            map["DestinationDataSourceSettings"] = self.destinationDataSourceSettingsShrink!
        }
        if self.destinationDataSourceType != nil {
            map["DestinationDataSourceType"] = self.destinationDataSourceType!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.jobSettingsShrink != nil {
            map["JobSettings"] = self.jobSettingsShrink!
        }
        if self.migrationType != nil {
            map["MigrationType"] = self.migrationType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceSettingsShrink != nil {
            map["ResourceSettings"] = self.resourceSettingsShrink!
        }
        if self.sourceDataSourceSettingsShrink != nil {
            map["SourceDataSourceSettings"] = self.sourceDataSourceSettingsShrink!
        }
        if self.sourceDataSourceType != nil {
            map["SourceDataSourceType"] = self.sourceDataSourceType!
        }
        if self.systemDebug != nil {
            map["SystemDebug"] = self.systemDebug!
        }
        if self.tableMappingsShrink != nil {
            map["TableMappings"] = self.tableMappingsShrink!
        }
        if self.transformationRulesShrink != nil {
            map["TransformationRules"] = self.transformationRulesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DestinationDataSourceSettings"] as? String {
            self.destinationDataSourceSettingsShrink = value
        }
        if let value = dict["DestinationDataSourceType"] as? String {
            self.destinationDataSourceType = value
        }
        if let value = dict["JobName"] as? String {
            self.jobName = value
        }
        if let value = dict["JobSettings"] as? String {
            self.jobSettingsShrink = value
        }
        if let value = dict["MigrationType"] as? String {
            self.migrationType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceSettings"] as? String {
            self.resourceSettingsShrink = value
        }
        if let value = dict["SourceDataSourceSettings"] as? String {
            self.sourceDataSourceSettingsShrink = value
        }
        if let value = dict["SourceDataSourceType"] as? String {
            self.sourceDataSourceType = value
        }
        if let value = dict["SystemDebug"] as? String {
            self.systemDebug = value
        }
        if let value = dict["TableMappings"] as? String {
            self.tableMappingsShrink = value
        }
        if let value = dict["TransformationRules"] as? String {
            self.transformationRulesShrink = value
        }
    }
}

public class CreateDIJobResponseBody : Tea.TeaModel {
    public var DIJobId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDIJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDISyncTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public var projectId: Int64?

    public var taskContent: String?

    public var taskName: String?

    public var taskParam: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskContent != nil {
            map["TaskContent"] = self.taskContent!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskParam != nil {
            map["TaskParam"] = self.taskParam!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TaskContent"] as? String {
            self.taskContent = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
        if let value = dict["TaskParam"] as? String {
            self.taskParam = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
    }
}

public class CreateDISyncTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var fileId: Int64?

        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileId != nil {
                map["FileId"] = self.fileId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FileId"] as? Int64 {
                self.fileId = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: CreateDISyncTaskResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateDISyncTaskResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateDISyncTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDISyncTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDISyncTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDagComplementRequest : Tea.TeaModel {
    public var bizBeginTime: String?

    public var bizEndTime: String?

    public var endBizDate: String?

    public var excludeNodeIds: String?

    public var includeNodeIds: String?

    public var name: String?

    public var nodeParams: String?

    public var parallelism: Bool?

    public var projectEnv: String?

    public var rootNodeId: Int64?

    public var startBizDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizBeginTime != nil {
            map["BizBeginTime"] = self.bizBeginTime!
        }
        if self.bizEndTime != nil {
            map["BizEndTime"] = self.bizEndTime!
        }
        if self.endBizDate != nil {
            map["EndBizDate"] = self.endBizDate!
        }
        if self.excludeNodeIds != nil {
            map["ExcludeNodeIds"] = self.excludeNodeIds!
        }
        if self.includeNodeIds != nil {
            map["IncludeNodeIds"] = self.includeNodeIds!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nodeParams != nil {
            map["NodeParams"] = self.nodeParams!
        }
        if self.parallelism != nil {
            map["Parallelism"] = self.parallelism!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.rootNodeId != nil {
            map["RootNodeId"] = self.rootNodeId!
        }
        if self.startBizDate != nil {
            map["StartBizDate"] = self.startBizDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BizBeginTime"] as? String {
            self.bizBeginTime = value
        }
        if let value = dict["BizEndTime"] as? String {
            self.bizEndTime = value
        }
        if let value = dict["EndBizDate"] as? String {
            self.endBizDate = value
        }
        if let value = dict["ExcludeNodeIds"] as? String {
            self.excludeNodeIds = value
        }
        if let value = dict["IncludeNodeIds"] as? String {
            self.includeNodeIds = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NodeParams"] as? String {
            self.nodeParams = value
        }
        if let value = dict["Parallelism"] as? Bool {
            self.parallelism = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["RootNodeId"] as? Int64 {
            self.rootNodeId = value
        }
        if let value = dict["StartBizDate"] as? String {
            self.startBizDate = value
        }
    }
}

public class CreateDagComplementResponseBody : Tea.TeaModel {
    public var data: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Int64] {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateDagComplementResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDagComplementResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDagComplementResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDagTestRequest : Tea.TeaModel {
    public var bizdate: String?

    public var name: String?

    public var nodeId: Int64?

    public var nodeParams: String?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeParams != nil {
            map["NodeParams"] = self.nodeParams!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bizdate"] as? String {
            self.bizdate = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["NodeParams"] as? String {
            self.nodeParams = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class CreateDagTestResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int64 {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateDagTestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDagTestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDagTestResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDataServiceApiRequest : Tea.TeaModel {
    public var apiDescription: String?

    public var apiMode: Int32?

    public var apiName: String?

    public var apiPath: String?

    public var folderId: Int64?

    public var groupId: String?

    public var projectId: Int64?

    public var protocols: String?

    public var registrationDetails: String?

    public var requestContentType: Int32?

    public var requestMethod: Int32?

    public var resourceGroupId: Int64?

    public var responseContentType: Int32?

    public var scriptDetails: String?

    public var sqlMode: Int64?

    public var tenantId: Int64?

    public var timeout: Int32?

    public var visibleRange: Int32?

    public var wizardDetails: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiDescription != nil {
            map["ApiDescription"] = self.apiDescription!
        }
        if self.apiMode != nil {
            map["ApiMode"] = self.apiMode!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.apiPath != nil {
            map["ApiPath"] = self.apiPath!
        }
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.protocols != nil {
            map["Protocols"] = self.protocols!
        }
        if self.registrationDetails != nil {
            map["RegistrationDetails"] = self.registrationDetails!
        }
        if self.requestContentType != nil {
            map["RequestContentType"] = self.requestContentType!
        }
        if self.requestMethod != nil {
            map["RequestMethod"] = self.requestMethod!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.responseContentType != nil {
            map["ResponseContentType"] = self.responseContentType!
        }
        if self.scriptDetails != nil {
            map["ScriptDetails"] = self.scriptDetails!
        }
        if self.sqlMode != nil {
            map["SqlMode"] = self.sqlMode!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.visibleRange != nil {
            map["VisibleRange"] = self.visibleRange!
        }
        if self.wizardDetails != nil {
            map["WizardDetails"] = self.wizardDetails!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiDescription"] as? String {
            self.apiDescription = value
        }
        if let value = dict["ApiMode"] as? Int32 {
            self.apiMode = value
        }
        if let value = dict["ApiName"] as? String {
            self.apiName = value
        }
        if let value = dict["ApiPath"] as? String {
            self.apiPath = value
        }
        if let value = dict["FolderId"] as? Int64 {
            self.folderId = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Protocols"] as? String {
            self.protocols = value
        }
        if let value = dict["RegistrationDetails"] as? String {
            self.registrationDetails = value
        }
        if let value = dict["RequestContentType"] as? Int32 {
            self.requestContentType = value
        }
        if let value = dict["RequestMethod"] as? Int32 {
            self.requestMethod = value
        }
        if let value = dict["ResourceGroupId"] as? Int64 {
            self.resourceGroupId = value
        }
        if let value = dict["ResponseContentType"] as? Int32 {
            self.responseContentType = value
        }
        if let value = dict["ScriptDetails"] as? String {
            self.scriptDetails = value
        }
        if let value = dict["SqlMode"] as? Int64 {
            self.sqlMode = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
        if let value = dict["VisibleRange"] as? Int32 {
            self.visibleRange = value
        }
        if let value = dict["WizardDetails"] as? String {
            self.wizardDetails = value
        }
    }
}

public class CreateDataServiceApiResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int64 {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateDataServiceApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataServiceApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDataServiceApiResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDataServiceApiAuthorityRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var authorizedProjectId: Int64?

    public var endTime: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.authorizedProjectId != nil {
            map["AuthorizedProjectId"] = self.authorizedProjectId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiId"] as? Int64 {
            self.apiId = value
        }
        if let value = dict["AuthorizedProjectId"] as? Int64 {
            self.authorizedProjectId = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class CreateDataServiceApiAuthorityResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateDataServiceApiAuthorityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataServiceApiAuthorityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDataServiceApiAuthorityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDataServiceFolderRequest : Tea.TeaModel {
    public var folderName: String?

    public var groupId: String?

    public var parentId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderName != nil {
            map["FolderName"] = self.folderName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FolderName"] as? String {
            self.folderName = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["ParentId"] as? Int64 {
            self.parentId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class CreateDataServiceFolderResponseBody : Tea.TeaModel {
    public var folderId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FolderId"] as? Int64 {
            self.folderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDataServiceFolderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataServiceFolderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDataServiceFolderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDataServiceGroupRequest : Tea.TeaModel {
    public var apiGatewayGroupId: String?

    public var description_: String?

    public var groupName: String?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiGatewayGroupId != nil {
            map["ApiGatewayGroupId"] = self.apiGatewayGroupId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiGatewayGroupId"] as? String {
            self.apiGatewayGroupId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class CreateDataServiceGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDataServiceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataServiceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDataServiceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDataSourceRequest : Tea.TeaModel {
    public var content: String?

    public var dataSourceType: String?

    public var description_: String?

    public var envType: Int32?

    public var name: String?

    public var projectId: Int64?

    public var subType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.subType != nil {
            map["SubType"] = self.subType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnvType"] as? Int32 {
            self.envType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SubType"] as? String {
            self.subType = value
        }
    }
}

public class CreateDataSourceResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int64 {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? String {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDataSourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateExportMigrationRequest : Tea.TeaModel {
    public var description_: String?

    public var exportMode: String?

    public var exportObjectStatus: String?

    public var incrementalSince: Int64?

    public var name: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.exportMode != nil {
            map["ExportMode"] = self.exportMode!
        }
        if self.exportObjectStatus != nil {
            map["ExportObjectStatus"] = self.exportObjectStatus!
        }
        if self.incrementalSince != nil {
            map["IncrementalSince"] = self.incrementalSince!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExportMode"] as? String {
            self.exportMode = value
        }
        if let value = dict["ExportObjectStatus"] as? String {
            self.exportObjectStatus = value
        }
        if let value = dict["IncrementalSince"] as? Int64 {
            self.incrementalSince = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class CreateExportMigrationResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int64 {
            self.data = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateExportMigrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateExportMigrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateExportMigrationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateFileRequest : Tea.TeaModel {
    public var advancedSettings: String?

    public var applyScheduleImmediately: Bool?

    public var autoParsing: Bool?

    public var autoRerunIntervalMillis: Int32?

    public var autoRerunTimes: Int32?

    public var connectionName: String?

    public var content: String?

    public var createFolderIfNotExists: Bool?

    public var cronExpress: String?

    public var cycleType: String?

    public var dependentNodeIdList: String?

    public var dependentType: String?

    public var endEffectDate: Int64?

    public var fileDescription: String?

    public var fileFolderPath: String?

    public var fileName: String?

    public var fileType: Int32?

    public var ignoreParentSkipRunningProperty: Bool?

    public var imageId: String?

    public var inputList: String?

    public var inputParameters: String?

    public var outputParameters: String?

    public var owner: String?

    public var paraValue: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var rerunMode: String?

    public var resourceGroupId: Int64?

    public var resourceGroupIdentifier: String?

    public var schedulerType: String?

    public var startEffectDate: Int64?

    public var startImmediately: Bool?

    public var stop: Bool?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advancedSettings != nil {
            map["AdvancedSettings"] = self.advancedSettings!
        }
        if self.applyScheduleImmediately != nil {
            map["ApplyScheduleImmediately"] = self.applyScheduleImmediately!
        }
        if self.autoParsing != nil {
            map["AutoParsing"] = self.autoParsing!
        }
        if self.autoRerunIntervalMillis != nil {
            map["AutoRerunIntervalMillis"] = self.autoRerunIntervalMillis!
        }
        if self.autoRerunTimes != nil {
            map["AutoRerunTimes"] = self.autoRerunTimes!
        }
        if self.connectionName != nil {
            map["ConnectionName"] = self.connectionName!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.createFolderIfNotExists != nil {
            map["CreateFolderIfNotExists"] = self.createFolderIfNotExists!
        }
        if self.cronExpress != nil {
            map["CronExpress"] = self.cronExpress!
        }
        if self.cycleType != nil {
            map["CycleType"] = self.cycleType!
        }
        if self.dependentNodeIdList != nil {
            map["DependentNodeIdList"] = self.dependentNodeIdList!
        }
        if self.dependentType != nil {
            map["DependentType"] = self.dependentType!
        }
        if self.endEffectDate != nil {
            map["EndEffectDate"] = self.endEffectDate!
        }
        if self.fileDescription != nil {
            map["FileDescription"] = self.fileDescription!
        }
        if self.fileFolderPath != nil {
            map["FileFolderPath"] = self.fileFolderPath!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileType != nil {
            map["FileType"] = self.fileType!
        }
        if self.ignoreParentSkipRunningProperty != nil {
            map["IgnoreParentSkipRunningProperty"] = self.ignoreParentSkipRunningProperty!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.inputList != nil {
            map["InputList"] = self.inputList!
        }
        if self.inputParameters != nil {
            map["InputParameters"] = self.inputParameters!
        }
        if self.outputParameters != nil {
            map["OutputParameters"] = self.outputParameters!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.paraValue != nil {
            map["ParaValue"] = self.paraValue!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.rerunMode != nil {
            map["RerunMode"] = self.rerunMode!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceGroupIdentifier != nil {
            map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
        }
        if self.schedulerType != nil {
            map["SchedulerType"] = self.schedulerType!
        }
        if self.startEffectDate != nil {
            map["StartEffectDate"] = self.startEffectDate!
        }
        if self.startImmediately != nil {
            map["StartImmediately"] = self.startImmediately!
        }
        if self.stop != nil {
            map["Stop"] = self.stop!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AdvancedSettings"] as? String {
            self.advancedSettings = value
        }
        if let value = dict["ApplyScheduleImmediately"] as? Bool {
            self.applyScheduleImmediately = value
        }
        if let value = dict["AutoParsing"] as? Bool {
            self.autoParsing = value
        }
        if let value = dict["AutoRerunIntervalMillis"] as? Int32 {
            self.autoRerunIntervalMillis = value
        }
        if let value = dict["AutoRerunTimes"] as? Int32 {
            self.autoRerunTimes = value
        }
        if let value = dict["ConnectionName"] as? String {
            self.connectionName = value
        }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["CreateFolderIfNotExists"] as? Bool {
            self.createFolderIfNotExists = value
        }
        if let value = dict["CronExpress"] as? String {
            self.cronExpress = value
        }
        if let value = dict["CycleType"] as? String {
            self.cycleType = value
        }
        if let value = dict["DependentNodeIdList"] as? String {
            self.dependentNodeIdList = value
        }
        if let value = dict["DependentType"] as? String {
            self.dependentType = value
        }
        if let value = dict["EndEffectDate"] as? Int64 {
            self.endEffectDate = value
        }
        if let value = dict["FileDescription"] as? String {
            self.fileDescription = value
        }
        if let value = dict["FileFolderPath"] as? String {
            self.fileFolderPath = value
        }
        if let value = dict["FileName"] as? String {
            self.fileName = value
        }
        if let value = dict["FileType"] as? Int32 {
            self.fileType = value
        }
        if let value = dict["IgnoreParentSkipRunningProperty"] as? Bool {
            self.ignoreParentSkipRunningProperty = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["InputList"] as? String {
            self.inputList = value
        }
        if let value = dict["InputParameters"] as? String {
            self.inputParameters = value
        }
        if let value = dict["OutputParameters"] as? String {
            self.outputParameters = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["ParaValue"] as? String {
            self.paraValue = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
        if let value = dict["RerunMode"] as? String {
            self.rerunMode = value
        }
        if let value = dict["ResourceGroupId"] as? Int64 {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceGroupIdentifier"] as? String {
            self.resourceGroupIdentifier = value
        }
        if let value = dict["SchedulerType"] as? String {
            self.schedulerType = value
        }
        if let value = dict["StartEffectDate"] as? Int64 {
            self.startEffectDate = value
        }
        if let value = dict["StartImmediately"] as? Bool {
            self.startImmediately = value
        }
        if let value = dict["Stop"] as? Bool {
            self.stop = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
    }
}

public class CreateFileResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int64 {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateFolderRequest : Tea.TeaModel {
    public var folderPath: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderPath != nil {
            map["FolderPath"] = self.folderPath!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FolderPath"] as? String {
            self.folderPath = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class CreateFolderResponseBody : Tea.TeaModel {
    public var data: String?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateFolderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFolderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateFolderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateImportMigrationRequest : Tea.TeaModel {
    public var calculateEngineMap: String?

    public var commitRule: String?

    public var description_: String?

    public var name: String?

    public var packageFile: String?

    public var packageType: String?

    public var projectId: Int64?

    public var resourceGroupMap: String?

    public var workspaceMap: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calculateEngineMap != nil {
            map["CalculateEngineMap"] = self.calculateEngineMap!
        }
        if self.commitRule != nil {
            map["CommitRule"] = self.commitRule!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.packageFile != nil {
            map["PackageFile"] = self.packageFile!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceGroupMap != nil {
            map["ResourceGroupMap"] = self.resourceGroupMap!
        }
        if self.workspaceMap != nil {
            map["WorkspaceMap"] = self.workspaceMap!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CalculateEngineMap"] as? String {
            self.calculateEngineMap = value
        }
        if let value = dict["CommitRule"] as? String {
            self.commitRule = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PackageFile"] as? String {
            self.packageFile = value
        }
        if let value = dict["PackageType"] as? String {
            self.packageType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceGroupMap"] as? String {
            self.resourceGroupMap = value
        }
        if let value = dict["WorkspaceMap"] as? String {
            self.workspaceMap = value
        }
    }
}

public class CreateImportMigrationAdvanceRequest : Tea.TeaModel {
    public var calculateEngineMap: String?

    public var commitRule: String?

    public var description_: String?

    public var name: String?

    public var packageFileObject: InputStream?

    public var packageType: String?

    public var projectId: Int64?

    public var resourceGroupMap: String?

    public var workspaceMap: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calculateEngineMap != nil {
            map["CalculateEngineMap"] = self.calculateEngineMap!
        }
        if self.commitRule != nil {
            map["CommitRule"] = self.commitRule!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.packageFileObject != nil {
            map["PackageFile"] = self.packageFileObject!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceGroupMap != nil {
            map["ResourceGroupMap"] = self.resourceGroupMap!
        }
        if self.workspaceMap != nil {
            map["WorkspaceMap"] = self.workspaceMap!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CalculateEngineMap"] as? String {
            self.calculateEngineMap = value
        }
        if let value = dict["CommitRule"] as? String {
            self.commitRule = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PackageFile"] as? InputStream {
            self.packageFileObject = value
        }
        if let value = dict["PackageType"] as? String {
            self.packageType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceGroupMap"] as? String {
            self.resourceGroupMap = value
        }
        if let value = dict["WorkspaceMap"] as? String {
            self.workspaceMap = value
        }
    }
}

public class CreateImportMigrationResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int64 {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateImportMigrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateImportMigrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateImportMigrationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateManualDagRequest : Tea.TeaModel {
    public var bizDate: String?

    public var dagParameters: String?

    public var excludeNodeIds: String?

    public var flowName: String?

    public var includeNodeIds: String?

    public var nodeParameters: String?

    public var projectEnv: String?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizDate != nil {
            map["BizDate"] = self.bizDate!
        }
        if self.dagParameters != nil {
            map["DagParameters"] = self.dagParameters!
        }
        if self.excludeNodeIds != nil {
            map["ExcludeNodeIds"] = self.excludeNodeIds!
        }
        if self.flowName != nil {
            map["FlowName"] = self.flowName!
        }
        if self.includeNodeIds != nil {
            map["IncludeNodeIds"] = self.includeNodeIds!
        }
        if self.nodeParameters != nil {
            map["NodeParameters"] = self.nodeParameters!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BizDate"] as? String {
            self.bizDate = value
        }
        if let value = dict["DagParameters"] as? String {
            self.dagParameters = value
        }
        if let value = dict["ExcludeNodeIds"] as? String {
            self.excludeNodeIds = value
        }
        if let value = dict["FlowName"] as? String {
            self.flowName = value
        }
        if let value = dict["IncludeNodeIds"] as? String {
            self.includeNodeIds = value
        }
        if let value = dict["NodeParameters"] as? String {
            self.nodeParameters = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
    }
}

public class CreateManualDagResponseBody : Tea.TeaModel {
    public var dagId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DagId"] as? Int64 {
            self.dagId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateManualDagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateManualDagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateManualDagResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateMetaCategoryRequest : Tea.TeaModel {
    public var comment: String?

    public var name: String?

    public var parentId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ParentId"] as? Int64 {
            self.parentId = value
        }
    }
}

public class CreateMetaCategoryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var categoryId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.categoryId != nil {
                map["CategoryId"] = self.categoryId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CategoryId"] as? Int64 {
                self.categoryId = value
            }
        }
    }
    public var data: CreateMetaCategoryResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateMetaCategoryResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateMetaCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMetaCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateMetaCategoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateMetaCollectionRequest : Tea.TeaModel {
    public var collectionType: String?

    public var comment: String?

    public var name: String?

    public var parentQualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectionType != nil {
            map["CollectionType"] = self.collectionType!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentQualifiedName != nil {
            map["ParentQualifiedName"] = self.parentQualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CollectionType"] as? String {
            self.collectionType = value
        }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ParentQualifiedName"] as? String {
            self.parentQualifiedName = value
        }
    }
}

public class CreateMetaCollectionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: String?

    public var qualifiedName: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? String {
            self.httpStatusCode = value
        }
        if let value = dict["QualifiedName"] as? String {
            self.qualifiedName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class CreateMetaCollectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMetaCollectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateMetaCollectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePermissionApplyOrderRequest : Tea.TeaModel {
    public class ApplyObject : Tea.TeaModel {
        public class ColumnMetaList : Tea.TeaModel {
            public var actions: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actions != nil {
                    map["Actions"] = self.actions!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Actions"] as? String {
                    self.actions = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public var actions: String?

        public var columnMetaList: [CreatePermissionApplyOrderRequest.ApplyObject.ColumnMetaList]?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actions != nil {
                map["Actions"] = self.actions!
            }
            if self.columnMetaList != nil {
                var tmp : [Any] = []
                for k in self.columnMetaList! {
                    tmp.append(k.toMap())
                }
                map["ColumnMetaList"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Actions"] as? String {
                self.actions = value
            }
            if let value = dict["ColumnMetaList"] as? [Any?] {
                var tmp : [CreatePermissionApplyOrderRequest.ApplyObject.ColumnMetaList] = []
                for v in value {
                    if v != nil {
                        var model = CreatePermissionApplyOrderRequest.ApplyObject.ColumnMetaList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.columnMetaList = tmp
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
        }
    }
    public var applyObject: [CreatePermissionApplyOrderRequest.ApplyObject]?

    public var applyReason: String?

    public var applyType: String?

    public var applyUserIds: String?

    public var catalogName: String?

    public var deadline: Int64?

    public var engineType: String?

    public var maxComputeProjectName: String?

    public var orderType: Int32?

    public var workspaceId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applyObject != nil {
            var tmp : [Any] = []
            for k in self.applyObject! {
                tmp.append(k.toMap())
            }
            map["ApplyObject"] = tmp
        }
        if self.applyReason != nil {
            map["ApplyReason"] = self.applyReason!
        }
        if self.applyType != nil {
            map["ApplyType"] = self.applyType!
        }
        if self.applyUserIds != nil {
            map["ApplyUserIds"] = self.applyUserIds!
        }
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.deadline != nil {
            map["Deadline"] = self.deadline!
        }
        if self.engineType != nil {
            map["EngineType"] = self.engineType!
        }
        if self.maxComputeProjectName != nil {
            map["MaxComputeProjectName"] = self.maxComputeProjectName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplyObject"] as? [Any?] {
            var tmp : [CreatePermissionApplyOrderRequest.ApplyObject] = []
            for v in value {
                if v != nil {
                    var model = CreatePermissionApplyOrderRequest.ApplyObject()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.applyObject = tmp
        }
        if let value = dict["ApplyReason"] as? String {
            self.applyReason = value
        }
        if let value = dict["ApplyType"] as? String {
            self.applyType = value
        }
        if let value = dict["ApplyUserIds"] as? String {
            self.applyUserIds = value
        }
        if let value = dict["CatalogName"] as? String {
            self.catalogName = value
        }
        if let value = dict["Deadline"] as? Int64 {
            self.deadline = value
        }
        if let value = dict["EngineType"] as? String {
            self.engineType = value
        }
        if let value = dict["MaxComputeProjectName"] as? String {
            self.maxComputeProjectName = value
        }
        if let value = dict["OrderType"] as? Int32 {
            self.orderType = value
        }
        if let value = dict["WorkspaceId"] as? Int32 {
            self.workspaceId = value
        }
    }
}

public class CreatePermissionApplyOrderResponseBody : Tea.TeaModel {
    public var flowId: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FlowId"] as? [String] {
            self.flowId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreatePermissionApplyOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePermissionApplyOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePermissionApplyOrderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateProjectRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var disableDevelopment: Bool?

    public var isAllowDownload: Int32?

    public var projectDescription: String?

    public var projectIdentifier: String?

    public var projectMode: Int32?

    public var projectName: String?

    public var resourceManagerResourceGroupId: String?

    public var tags: [CreateProjectRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.disableDevelopment != nil {
            map["DisableDevelopment"] = self.disableDevelopment!
        }
        if self.isAllowDownload != nil {
            map["IsAllowDownload"] = self.isAllowDownload!
        }
        if self.projectDescription != nil {
            map["ProjectDescription"] = self.projectDescription!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.projectMode != nil {
            map["ProjectMode"] = self.projectMode!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.resourceManagerResourceGroupId != nil {
            map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DisableDevelopment"] as? Bool {
            self.disableDevelopment = value
        }
        if let value = dict["IsAllowDownload"] as? Int32 {
            self.isAllowDownload = value
        }
        if let value = dict["ProjectDescription"] as? String {
            self.projectDescription = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
        if let value = dict["ProjectMode"] as? Int32 {
            self.projectMode = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
        if let value = dict["ResourceManagerResourceGroupId"] as? String {
            self.resourceManagerResourceGroupId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [CreateProjectRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = CreateProjectRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class CreateProjectShrinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var disableDevelopment: Bool?

    public var isAllowDownload: Int32?

    public var projectDescription: String?

    public var projectIdentifier: String?

    public var projectMode: Int32?

    public var projectName: String?

    public var resourceManagerResourceGroupId: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.disableDevelopment != nil {
            map["DisableDevelopment"] = self.disableDevelopment!
        }
        if self.isAllowDownload != nil {
            map["IsAllowDownload"] = self.isAllowDownload!
        }
        if self.projectDescription != nil {
            map["ProjectDescription"] = self.projectDescription!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.projectMode != nil {
            map["ProjectMode"] = self.projectMode!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.resourceManagerResourceGroupId != nil {
            map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DisableDevelopment"] as? Bool {
            self.disableDevelopment = value
        }
        if let value = dict["IsAllowDownload"] as? Int32 {
            self.isAllowDownload = value
        }
        if let value = dict["ProjectDescription"] as? String {
            self.projectDescription = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
        if let value = dict["ProjectMode"] as? Int32 {
            self.projectMode = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
        if let value = dict["ResourceManagerResourceGroupId"] as? String {
            self.resourceManagerResourceGroupId = value
        }
        if let value = dict["Tags"] as? String {
            self.tagsShrink = value
        }
    }
}

public class CreateProjectResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int64 {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateProjectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateProjectMemberRequest : Tea.TeaModel {
    public var clientToken: String?

    public var projectId: Int64?

    public var roleCode: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCode != nil {
            map["RoleCode"] = self.roleCode!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RoleCode"] as? String {
            self.roleCode = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class CreateProjectMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateProjectMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProjectMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateProjectMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateQualityEntityRequest : Tea.TeaModel {
    public var entityLevel: Int32?

    public var envType: String?

    public var matchExpression: String?

    public var projectId: Int64?

    public var projectName: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityLevel != nil {
            map["EntityLevel"] = self.entityLevel!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.matchExpression != nil {
            map["MatchExpression"] = self.matchExpression!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EntityLevel"] as? Int32 {
            self.entityLevel = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["MatchExpression"] as? String {
            self.matchExpression = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class CreateQualityEntityResponseBody : Tea.TeaModel {
    public var data: Int32?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int32 {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateQualityEntityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateQualityEntityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateQualityEntityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateQualityFollowerRequest : Tea.TeaModel {
    public var alarmMode: Int32?

    public var entityId: Int64?

    public var follower: String?

    public var projectId: Int64?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmMode != nil {
            map["AlarmMode"] = self.alarmMode!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.follower != nil {
            map["Follower"] = self.follower!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlarmMode"] as? Int32 {
            self.alarmMode = value
        }
        if let value = dict["EntityId"] as? Int64 {
            self.entityId = value
        }
        if let value = dict["Follower"] as? String {
            self.follower = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
    }
}

public class CreateQualityFollowerResponseBody : Tea.TeaModel {
    public var data: Int32?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int32 {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateQualityFollowerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateQualityFollowerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateQualityFollowerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateQualityRelativeNodeRequest : Tea.TeaModel {
    public var envType: String?

    public var matchExpression: String?

    public var nodeId: Int64?

    public var projectId: Int64?

    public var projectName: String?

    public var tableName: String?

    public var targetNodeProjectId: Int64?

    public var targetNodeProjectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.matchExpression != nil {
            map["MatchExpression"] = self.matchExpression!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.targetNodeProjectId != nil {
            map["TargetNodeProjectId"] = self.targetNodeProjectId!
        }
        if self.targetNodeProjectName != nil {
            map["TargetNodeProjectName"] = self.targetNodeProjectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["MatchExpression"] as? String {
            self.matchExpression = value
        }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["TargetNodeProjectId"] as? Int64 {
            self.targetNodeProjectId = value
        }
        if let value = dict["TargetNodeProjectName"] as? String {
            self.targetNodeProjectName = value
        }
    }
}

public class CreateQualityRelativeNodeResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateQualityRelativeNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateQualityRelativeNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateQualityRelativeNodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateQualityRuleRequest : Tea.TeaModel {
    public var blockType: Int32?

    public var checker: Int32?

    public var comment: String?

    public var criticalThreshold: String?

    public var entityId: Int64?

    public var expectValue: String?

    public var methodName: String?

    public var operator_: String?

    public var predictType: Int32?

    public var projectId: Int64?

    public var projectName: String?

    public var property: String?

    public var propertyType: String?

    public var ruleName: String?

    public var ruleType: Int32?

    public var taskSetting: String?

    public var templateId: Int32?

    public var trend: String?

    public var warningThreshold: String?

    public var whereCondition: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.blockType != nil {
            map["BlockType"] = self.blockType!
        }
        if self.checker != nil {
            map["Checker"] = self.checker!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.criticalThreshold != nil {
            map["CriticalThreshold"] = self.criticalThreshold!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.expectValue != nil {
            map["ExpectValue"] = self.expectValue!
        }
        if self.methodName != nil {
            map["MethodName"] = self.methodName!
        }
        if self.operator_ != nil {
            map["Operator"] = self.operator_!
        }
        if self.predictType != nil {
            map["PredictType"] = self.predictType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.property != nil {
            map["Property"] = self.property!
        }
        if self.propertyType != nil {
            map["PropertyType"] = self.propertyType!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        if self.taskSetting != nil {
            map["TaskSetting"] = self.taskSetting!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.trend != nil {
            map["Trend"] = self.trend!
        }
        if self.warningThreshold != nil {
            map["WarningThreshold"] = self.warningThreshold!
        }
        if self.whereCondition != nil {
            map["WhereCondition"] = self.whereCondition!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BlockType"] as? Int32 {
            self.blockType = value
        }
        if let value = dict["Checker"] as? Int32 {
            self.checker = value
        }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["CriticalThreshold"] as? String {
            self.criticalThreshold = value
        }
        if let value = dict["EntityId"] as? Int64 {
            self.entityId = value
        }
        if let value = dict["ExpectValue"] as? String {
            self.expectValue = value
        }
        if let value = dict["MethodName"] as? String {
            self.methodName = value
        }
        if let value = dict["Operator"] as? String {
            self.operator_ = value
        }
        if let value = dict["PredictType"] as? Int32 {
            self.predictType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
        if let value = dict["Property"] as? String {
            self.property = value
        }
        if let value = dict["PropertyType"] as? String {
            self.propertyType = value
        }
        if let value = dict["RuleName"] as? String {
            self.ruleName = value
        }
        if let value = dict["RuleType"] as? Int32 {
            self.ruleType = value
        }
        if let value = dict["TaskSetting"] as? String {
            self.taskSetting = value
        }
        if let value = dict["TemplateId"] as? Int32 {
            self.templateId = value
        }
        if let value = dict["Trend"] as? String {
            self.trend = value
        }
        if let value = dict["WarningThreshold"] as? String {
            self.warningThreshold = value
        }
        if let value = dict["WhereCondition"] as? String {
            self.whereCondition = value
        }
    }
}

public class CreateQualityRuleResponseBody : Tea.TeaModel {
    public var data: String?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateQualityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateQualityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateQualityRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRemindRequest : Tea.TeaModel {
    public var alertInterval: Int32?

    public var alertMethods: String?

    public var alertTargets: String?

    public var alertUnit: String?

    public var baselineIds: String?

    public var bizProcessIds: String?

    public var detail: String?

    public var dndEnd: String?

    public var maxAlertTimes: Int32?

    public var nodeIds: String?

    public var projectId: Int64?

    public var remindName: String?

    public var remindType: String?

    public var remindUnit: String?

    public var robotUrls: String?

    public var webhooks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertInterval != nil {
            map["AlertInterval"] = self.alertInterval!
        }
        if self.alertMethods != nil {
            map["AlertMethods"] = self.alertMethods!
        }
        if self.alertTargets != nil {
            map["AlertTargets"] = self.alertTargets!
        }
        if self.alertUnit != nil {
            map["AlertUnit"] = self.alertUnit!
        }
        if self.baselineIds != nil {
            map["BaselineIds"] = self.baselineIds!
        }
        if self.bizProcessIds != nil {
            map["BizProcessIds"] = self.bizProcessIds!
        }
        if self.detail != nil {
            map["Detail"] = self.detail!
        }
        if self.dndEnd != nil {
            map["DndEnd"] = self.dndEnd!
        }
        if self.maxAlertTimes != nil {
            map["MaxAlertTimes"] = self.maxAlertTimes!
        }
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.remindName != nil {
            map["RemindName"] = self.remindName!
        }
        if self.remindType != nil {
            map["RemindType"] = self.remindType!
        }
        if self.remindUnit != nil {
            map["RemindUnit"] = self.remindUnit!
        }
        if self.robotUrls != nil {
            map["RobotUrls"] = self.robotUrls!
        }
        if self.webhooks != nil {
            map["Webhooks"] = self.webhooks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlertInterval"] as? Int32 {
            self.alertInterval = value
        }
        if let value = dict["AlertMethods"] as? String {
            self.alertMethods = value
        }
        if let value = dict["AlertTargets"] as? String {
            self.alertTargets = value
        }
        if let value = dict["AlertUnit"] as? String {
            self.alertUnit = value
        }
        if let value = dict["BaselineIds"] as? String {
            self.baselineIds = value
        }
        if let value = dict["BizProcessIds"] as? String {
            self.bizProcessIds = value
        }
        if let value = dict["Detail"] as? String {
            self.detail = value
        }
        if let value = dict["DndEnd"] as? String {
            self.dndEnd = value
        }
        if let value = dict["MaxAlertTimes"] as? Int32 {
            self.maxAlertTimes = value
        }
        if let value = dict["NodeIds"] as? String {
            self.nodeIds = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RemindName"] as? String {
            self.remindName = value
        }
        if let value = dict["RemindType"] as? String {
            self.remindType = value
        }
        if let value = dict["RemindUnit"] as? String {
            self.remindUnit = value
        }
        if let value = dict["RobotUrls"] as? String {
            self.robotUrls = value
        }
        if let value = dict["Webhooks"] as? String {
            self.webhooks = value
        }
    }
}

public class CreateRemindResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int64 {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateRemindResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRemindResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRemindResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateResourceFileRequest : Tea.TeaModel {
    public var content: String?

    public var fileDescription: String?

    public var fileFolderPath: String?

    public var fileName: String?

    public var fileType: Int32?

    public var originResourceName: String?

    public var owner: String?

    public var projectId: Int64?

    public var registerToCalcEngine: Bool?

    public var resourceFile: String?

    public var storageURL: String?

    public var uploadMode: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.fileDescription != nil {
            map["FileDescription"] = self.fileDescription!
        }
        if self.fileFolderPath != nil {
            map["FileFolderPath"] = self.fileFolderPath!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileType != nil {
            map["FileType"] = self.fileType!
        }
        if self.originResourceName != nil {
            map["OriginResourceName"] = self.originResourceName!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.registerToCalcEngine != nil {
            map["RegisterToCalcEngine"] = self.registerToCalcEngine!
        }
        if self.resourceFile != nil {
            map["ResourceFile"] = self.resourceFile!
        }
        if self.storageURL != nil {
            map["StorageURL"] = self.storageURL!
        }
        if self.uploadMode != nil {
            map["UploadMode"] = self.uploadMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["FileDescription"] as? String {
            self.fileDescription = value
        }
        if let value = dict["FileFolderPath"] as? String {
            self.fileFolderPath = value
        }
        if let value = dict["FileName"] as? String {
            self.fileName = value
        }
        if let value = dict["FileType"] as? Int32 {
            self.fileType = value
        }
        if let value = dict["OriginResourceName"] as? String {
            self.originResourceName = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RegisterToCalcEngine"] as? Bool {
            self.registerToCalcEngine = value
        }
        if let value = dict["ResourceFile"] as? String {
            self.resourceFile = value
        }
        if let value = dict["StorageURL"] as? String {
            self.storageURL = value
        }
        if let value = dict["UploadMode"] as? Bool {
            self.uploadMode = value
        }
    }
}

public class CreateResourceFileAdvanceRequest : Tea.TeaModel {
    public var content: String?

    public var fileDescription: String?

    public var fileFolderPath: String?

    public var fileName: String?

    public var fileType: Int32?

    public var originResourceName: String?

    public var owner: String?

    public var projectId: Int64?

    public var registerToCalcEngine: Bool?

    public var resourceFileObject: InputStream?

    public var storageURL: String?

    public var uploadMode: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.fileDescription != nil {
            map["FileDescription"] = self.fileDescription!
        }
        if self.fileFolderPath != nil {
            map["FileFolderPath"] = self.fileFolderPath!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileType != nil {
            map["FileType"] = self.fileType!
        }
        if self.originResourceName != nil {
            map["OriginResourceName"] = self.originResourceName!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.registerToCalcEngine != nil {
            map["RegisterToCalcEngine"] = self.registerToCalcEngine!
        }
        if self.resourceFileObject != nil {
            map["ResourceFile"] = self.resourceFileObject!
        }
        if self.storageURL != nil {
            map["StorageURL"] = self.storageURL!
        }
        if self.uploadMode != nil {
            map["UploadMode"] = self.uploadMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["FileDescription"] as? String {
            self.fileDescription = value
        }
        if let value = dict["FileFolderPath"] as? String {
            self.fileFolderPath = value
        }
        if let value = dict["FileName"] as? String {
            self.fileName = value
        }
        if let value = dict["FileType"] as? Int32 {
            self.fileType = value
        }
        if let value = dict["OriginResourceName"] as? String {
            self.originResourceName = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RegisterToCalcEngine"] as? Bool {
            self.registerToCalcEngine = value
        }
        if let value = dict["ResourceFile"] as? InputStream {
            self.resourceFileObject = value
        }
        if let value = dict["StorageURL"] as? String {
            self.storageURL = value
        }
        if let value = dict["UploadMode"] as? Bool {
            self.uploadMode = value
        }
    }
}

public class CreateResourceFileResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int64 {
            self.data = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateResourceFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateResourceFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateResourceFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateTableRequest : Tea.TeaModel {
    public class Columns : Tea.TeaModel {
        public var columnName: String?

        public var columnNameCn: String?

        public var columnType: String?

        public var comment: String?

        public var isPartitionCol: Bool?

        public var length: Int32?

        public var seqNumber: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columnName != nil {
                map["ColumnName"] = self.columnName!
            }
            if self.columnNameCn != nil {
                map["ColumnNameCn"] = self.columnNameCn!
            }
            if self.columnType != nil {
                map["ColumnType"] = self.columnType!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.isPartitionCol != nil {
                map["IsPartitionCol"] = self.isPartitionCol!
            }
            if self.length != nil {
                map["Length"] = self.length!
            }
            if self.seqNumber != nil {
                map["SeqNumber"] = self.seqNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ColumnName"] as? String {
                self.columnName = value
            }
            if let value = dict["ColumnNameCn"] as? String {
                self.columnNameCn = value
            }
            if let value = dict["ColumnType"] as? String {
                self.columnType = value
            }
            if let value = dict["Comment"] as? String {
                self.comment = value
            }
            if let value = dict["IsPartitionCol"] as? Bool {
                self.isPartitionCol = value
            }
            if let value = dict["Length"] as? Int32 {
                self.length = value
            }
            if let value = dict["SeqNumber"] as? Int32 {
                self.seqNumber = value
            }
        }
    }
    public class Themes : Tea.TeaModel {
        public var themeId: Int64?

        public var themeLevel: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.themeId != nil {
                map["ThemeId"] = self.themeId!
            }
            if self.themeLevel != nil {
                map["ThemeLevel"] = self.themeLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ThemeId"] as? Int64 {
                self.themeId = value
            }
            if let value = dict["ThemeLevel"] as? Int32 {
                self.themeLevel = value
            }
        }
    }
    public var appGuid: String?

    public var categoryId: Int64?

    public var clientToken: String?

    public var columns: [CreateTableRequest.Columns]?

    public var comment: String?

    public var endpoint: String?

    public var envType: Int32?

    public var externalTableType: String?

    public var hasPart: Int32?

    public var isView: Int32?

    public var lifeCycle: Int32?

    public var location: String?

    public var logicalLevelId: Int64?

    public var ownerId: String?

    public var physicsLevelId: Int64?

    public var projectId: Int64?

    public var schema: String?

    public var tableName: String?

    public var themes: [CreateTableRequest.Themes]?

    public var visibility: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGuid != nil {
            map["AppGuid"] = self.appGuid!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.columns != nil {
            var tmp : [Any] = []
            for k in self.columns! {
                tmp.append(k.toMap())
            }
            map["Columns"] = tmp
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.endpoint != nil {
            map["Endpoint"] = self.endpoint!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.externalTableType != nil {
            map["ExternalTableType"] = self.externalTableType!
        }
        if self.hasPart != nil {
            map["HasPart"] = self.hasPart!
        }
        if self.isView != nil {
            map["IsView"] = self.isView!
        }
        if self.lifeCycle != nil {
            map["LifeCycle"] = self.lifeCycle!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.logicalLevelId != nil {
            map["LogicalLevelId"] = self.logicalLevelId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicsLevelId != nil {
            map["PhysicsLevelId"] = self.physicsLevelId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.themes != nil {
            var tmp : [Any] = []
            for k in self.themes! {
                tmp.append(k.toMap())
            }
            map["Themes"] = tmp
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppGuid"] as? String {
            self.appGuid = value
        }
        if let value = dict["CategoryId"] as? Int64 {
            self.categoryId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Columns"] as? [Any?] {
            var tmp : [CreateTableRequest.Columns] = []
            for v in value {
                if v != nil {
                    var model = CreateTableRequest.Columns()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.columns = tmp
        }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Endpoint"] as? String {
            self.endpoint = value
        }
        if let value = dict["EnvType"] as? Int32 {
            self.envType = value
        }
        if let value = dict["ExternalTableType"] as? String {
            self.externalTableType = value
        }
        if let value = dict["HasPart"] as? Int32 {
            self.hasPart = value
        }
        if let value = dict["IsView"] as? Int32 {
            self.isView = value
        }
        if let value = dict["LifeCycle"] as? Int32 {
            self.lifeCycle = value
        }
        if let value = dict["Location"] as? String {
            self.location = value
        }
        if let value = dict["LogicalLevelId"] as? Int64 {
            self.logicalLevelId = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["PhysicsLevelId"] as? Int64 {
            self.physicsLevelId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Schema"] as? String {
            self.schema = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["Themes"] as? [Any?] {
            var tmp : [CreateTableRequest.Themes] = []
            for v in value {
                if v != nil {
                    var model = CreateTableRequest.Themes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.themes = tmp
        }
        if let value = dict["Visibility"] as? Int32 {
            self.visibility = value
        }
    }
}

public class CreateTableResponseBody : Tea.TeaModel {
    public class TaskInfo : Tea.TeaModel {
        public var content: String?

        public var nextTaskId: String?

        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.nextTaskId != nil {
                map["NextTaskId"] = self.nextTaskId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Content"] as? String {
                self.content = value
            }
            if let value = dict["NextTaskId"] as? String {
                self.nextTaskId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
        }
    }
    public var requestId: String?

    public var taskInfo: CreateTableResponseBody.TaskInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskInfo != nil {
            map["TaskInfo"] = self.taskInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskInfo"] as? [String: Any?] {
            var model = CreateTableResponseBody.TaskInfo()
            model.fromMap(value)
            self.taskInfo = model
        }
    }
}

public class CreateTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateTableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateTableLevelRequest : Tea.TeaModel {
    public var description_: String?

    public var levelType: Int32?

    public var name: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.levelType != nil {
            map["LevelType"] = self.levelType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["LevelType"] as? Int32 {
            self.levelType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class CreateTableLevelResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var levelId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.levelId != nil {
            map["LevelId"] = self.levelId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["LevelId"] as? Int64 {
            self.levelId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateTableLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTableLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateTableLevelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateTableThemeRequest : Tea.TeaModel {
    public var level: Int32?

    public var name: String?

    public var parentId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Level"] as? Int32 {
            self.level = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ParentId"] as? Int64 {
            self.parentId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class CreateTableThemeResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public var themeId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.themeId != nil {
            map["ThemeId"] = self.themeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["ThemeId"] as? Int64 {
            self.themeId = value
        }
    }
}

public class CreateTableThemeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTableThemeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateTableThemeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateUdfFileRequest : Tea.TeaModel {
    public var className: String?

    public var cmdDescription: String?

    public var createFolderIfNotExists: Bool?

    public var example: String?

    public var fileFolderPath: String?

    public var fileName: String?

    public var functionType: String?

    public var parameterDescription: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var resources: String?

    public var returnValue: String?

    public var udfDescription: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.className != nil {
            map["ClassName"] = self.className!
        }
        if self.cmdDescription != nil {
            map["CmdDescription"] = self.cmdDescription!
        }
        if self.createFolderIfNotExists != nil {
            map["CreateFolderIfNotExists"] = self.createFolderIfNotExists!
        }
        if self.example != nil {
            map["Example"] = self.example!
        }
        if self.fileFolderPath != nil {
            map["FileFolderPath"] = self.fileFolderPath!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.functionType != nil {
            map["FunctionType"] = self.functionType!
        }
        if self.parameterDescription != nil {
            map["ParameterDescription"] = self.parameterDescription!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.resources != nil {
            map["Resources"] = self.resources!
        }
        if self.returnValue != nil {
            map["ReturnValue"] = self.returnValue!
        }
        if self.udfDescription != nil {
            map["UdfDescription"] = self.udfDescription!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClassName"] as? String {
            self.className = value
        }
        if let value = dict["CmdDescription"] as? String {
            self.cmdDescription = value
        }
        if let value = dict["CreateFolderIfNotExists"] as? Bool {
            self.createFolderIfNotExists = value
        }
        if let value = dict["Example"] as? String {
            self.example = value
        }
        if let value = dict["FileFolderPath"] as? String {
            self.fileFolderPath = value
        }
        if let value = dict["FileName"] as? String {
            self.fileName = value
        }
        if let value = dict["FunctionType"] as? String {
            self.functionType = value
        }
        if let value = dict["ParameterDescription"] as? String {
            self.parameterDescription = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
        if let value = dict["Resources"] as? String {
            self.resources = value
        }
        if let value = dict["ReturnValue"] as? String {
            self.returnValue = value
        }
        if let value = dict["UdfDescription"] as? String {
            self.udfDescription = value
        }
    }
}

public class CreateUdfFileResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int64 {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateUdfFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUdfFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateUdfFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteBaselineRequest : Tea.TeaModel {
    public var baselineId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BaselineId"] as? Int64 {
            self.baselineId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class DeleteBaselineResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteBaselineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBaselineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteBaselineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteBusinessRequest : Tea.TeaModel {
    public var businessId: Int64?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessId != nil {
            map["BusinessId"] = self.businessId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BusinessId"] as? Int64 {
            self.businessId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class DeleteBusinessResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteBusinessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBusinessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteBusinessResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteConnectionRequest : Tea.TeaModel {
    public var connectionId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionId != nil {
            map["ConnectionId"] = self.connectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionId"] as? Int64 {
            self.connectionId = value
        }
    }
}

public class DeleteConnectionResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? String {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDIAlarmRuleRequest : Tea.TeaModel {
    public var DIAlarmRuleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIAlarmRuleId"] as? Int64 {
            self.DIAlarmRuleId = value
        }
    }
}

public class DeleteDIAlarmRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDIAlarmRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDIAlarmRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDIAlarmRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDIJobRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
    }
}

public class DeleteDIJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDIJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDISyncTaskRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FileId"] as? Int64 {
            self.fileId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
    }
}

public class DeleteDISyncTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: DeleteDISyncTaskResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DeleteDISyncTaskResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteDISyncTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDISyncTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDISyncTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDataServiceApiRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiId"] as? Int64 {
            self.apiId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class DeleteDataServiceApiResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteDataServiceApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataServiceApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDataServiceApiResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDataServiceApiAuthorityRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var authorizedProjectId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.authorizedProjectId != nil {
            map["AuthorizedProjectId"] = self.authorizedProjectId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiId"] as? Int64 {
            self.apiId = value
        }
        if let value = dict["AuthorizedProjectId"] as? Int64 {
            self.authorizedProjectId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class DeleteDataServiceApiAuthorityResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteDataServiceApiAuthorityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataServiceApiAuthorityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDataServiceApiAuthorityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDataSourceRequest : Tea.TeaModel {
    public var dataSourceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataSourceId"] as? Int64 {
            self.dataSourceId = value
        }
    }
}

public class DeleteDataSourceResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? String {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDataSourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteFileRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FileId"] as? Int64 {
            self.fileId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class DeleteFileResponseBody : Tea.TeaModel {
    public var deploymentId: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentId != nil {
            map["DeploymentId"] = self.deploymentId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeploymentId"] as? Int64 {
            self.deploymentId = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteFolderRequest : Tea.TeaModel {
    public var folderId: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FolderId"] as? String {
            self.folderId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class DeleteFolderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteFolderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFolderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteFolderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteFromMetaCategoryRequest : Tea.TeaModel {
    public var categoryId: Int64?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CategoryId"] as? Int64 {
            self.categoryId = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
    }
}

public class DeleteFromMetaCategoryResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteFromMetaCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFromMetaCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteFromMetaCategoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLineageRelationRequest : Tea.TeaModel {
    public var destEntityQualifiedName: String?

    public var relationshipGuid: String?

    public var relationshipType: String?

    public var srcEntityQualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destEntityQualifiedName != nil {
            map["DestEntityQualifiedName"] = self.destEntityQualifiedName!
        }
        if self.relationshipGuid != nil {
            map["RelationshipGuid"] = self.relationshipGuid!
        }
        if self.relationshipType != nil {
            map["RelationshipType"] = self.relationshipType!
        }
        if self.srcEntityQualifiedName != nil {
            map["SrcEntityQualifiedName"] = self.srcEntityQualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DestEntityQualifiedName"] as? String {
            self.destEntityQualifiedName = value
        }
        if let value = dict["RelationshipGuid"] as? String {
            self.relationshipGuid = value
        }
        if let value = dict["RelationshipType"] as? String {
            self.relationshipType = value
        }
        if let value = dict["SrcEntityQualifiedName"] as? String {
            self.srcEntityQualifiedName = value
        }
    }
}

public class DeleteLineageRelationResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var status: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? Bool {
            self.status = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteLineageRelationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLineageRelationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLineageRelationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteMetaCategoryRequest : Tea.TeaModel {
    public var categoryId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CategoryId"] as? Int64 {
            self.categoryId = value
        }
    }
}

public class DeleteMetaCategoryResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteMetaCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMetaCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteMetaCategoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteMetaCollectionRequest : Tea.TeaModel {
    public var qualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["QualifiedName"] as? String {
            self.qualifiedName = value
        }
    }
}

public class DeleteMetaCollectionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var status: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? Bool {
            self.status = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteMetaCollectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMetaCollectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteMetaCollectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteMetaCollectionEntityRequest : Tea.TeaModel {
    public var collectionQualifiedName: String?

    public var entityQualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectionQualifiedName != nil {
            map["CollectionQualifiedName"] = self.collectionQualifiedName!
        }
        if self.entityQualifiedName != nil {
            map["EntityQualifiedName"] = self.entityQualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CollectionQualifiedName"] as? String {
            self.collectionQualifiedName = value
        }
        if let value = dict["EntityQualifiedName"] as? String {
            self.entityQualifiedName = value
        }
    }
}

public class DeleteMetaCollectionEntityResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var status: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? Bool {
            self.status = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteMetaCollectionEntityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMetaCollectionEntityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteMetaCollectionEntityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteProjectMemberRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class DeleteProjectMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteProjectMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProjectMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteProjectMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteQualityEntityRequest : Tea.TeaModel {
    public var entityId: Int64?

    public var envType: String?

    public var projectId: Int64?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EntityId"] as? Int64 {
            self.entityId = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
    }
}

public class DeleteQualityEntityResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteQualityEntityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteQualityEntityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteQualityEntityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteQualityFollowerRequest : Tea.TeaModel {
    public var followerId: Int64?

    public var projectId: Int64?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.followerId != nil {
            map["FollowerId"] = self.followerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FollowerId"] as? Int64 {
            self.followerId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
    }
}

public class DeleteQualityFollowerResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteQualityFollowerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteQualityFollowerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteQualityFollowerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteQualityRelativeNodeRequest : Tea.TeaModel {
    public var envType: String?

    public var matchExpression: String?

    public var nodeId: Int64?

    public var projectId: Int64?

    public var projectName: String?

    public var tableName: String?

    public var targetNodeProjectId: Int64?

    public var targetNodeProjectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.matchExpression != nil {
            map["MatchExpression"] = self.matchExpression!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.targetNodeProjectId != nil {
            map["TargetNodeProjectId"] = self.targetNodeProjectId!
        }
        if self.targetNodeProjectName != nil {
            map["TargetNodeProjectName"] = self.targetNodeProjectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["MatchExpression"] as? String {
            self.matchExpression = value
        }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["TargetNodeProjectId"] as? Int64 {
            self.targetNodeProjectId = value
        }
        if let value = dict["TargetNodeProjectName"] as? String {
            self.targetNodeProjectName = value
        }
    }
}

public class DeleteQualityRelativeNodeResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteQualityRelativeNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteQualityRelativeNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteQualityRelativeNodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteQualityRuleRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var projectName: String?

    public var ruleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
        if let value = dict["RuleId"] as? Int64 {
            self.ruleId = value
        }
    }
}

public class DeleteQualityRuleResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteQualityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteQualityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteQualityRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRecognizeRuleRequest : Tea.TeaModel {
    public var sensitiveId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sensitiveId != nil {
            map["SensitiveId"] = self.sensitiveId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["SensitiveId"] as? String {
            self.sensitiveId = value
        }
        if let value = dict["TenantId"] as? String {
            self.tenantId = value
        }
    }
}

public class DeleteRecognizeRuleResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Any {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteRecognizeRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRecognizeRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRecognizeRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRemindRequest : Tea.TeaModel {
    public var remindId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remindId != nil {
            map["RemindId"] = self.remindId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RemindId"] as? Int64 {
            self.remindId = value
        }
    }
}

public class DeleteRemindResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteRemindResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRemindResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRemindResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteTableRequest : Tea.TeaModel {
    public var appGuid: String?

    public var envType: Int32?

    public var projectId: Int64?

    public var schema: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGuid != nil {
            map["AppGuid"] = self.appGuid!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppGuid"] as? String {
            self.appGuid = value
        }
        if let value = dict["EnvType"] as? Int32 {
            self.envType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Schema"] as? String {
            self.schema = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class DeleteTableResponseBody : Tea.TeaModel {
    public class TaskInfo : Tea.TeaModel {
        public var content: String?

        public var nextTaskId: String?

        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.nextTaskId != nil {
                map["NextTaskId"] = self.nextTaskId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Content"] as? String {
                self.content = value
            }
            if let value = dict["NextTaskId"] as? String {
                self.nextTaskId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
        }
    }
    public var requestId: String?

    public var taskInfo: DeleteTableResponseBody.TaskInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskInfo != nil {
            map["TaskInfo"] = self.taskInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskInfo"] as? [String: Any?] {
            var model = DeleteTableResponseBody.TaskInfo()
            model.fromMap(value)
            self.taskInfo = model
        }
    }
}

public class DeleteTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteTableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteTableLevelRequest : Tea.TeaModel {
    public var levelId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.levelId != nil {
            map["LevelId"] = self.levelId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LevelId"] as? Int64 {
            self.levelId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class DeleteTableLevelResponseBody : Tea.TeaModel {
    public var deleteResult: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteResult != nil {
            map["DeleteResult"] = self.deleteResult!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeleteResult"] as? Bool {
            self.deleteResult = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteTableLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTableLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteTableLevelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteTableThemeRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var themeId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.themeId != nil {
            map["ThemeId"] = self.themeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ThemeId"] as? Int64 {
            self.themeId = value
        }
    }
}

public class DeleteTableThemeResponseBody : Tea.TeaModel {
    public var deleteResult: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteResult != nil {
            map["DeleteResult"] = self.deleteResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeleteResult"] as? Bool {
            self.deleteResult = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteTableThemeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTableThemeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteTableThemeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeployDISyncTaskRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FileId"] as? Int64 {
            self.fileId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
    }
}

public class DeployDISyncTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: DeployDISyncTaskResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DeployDISyncTaskResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeployDISyncTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeployDISyncTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeployDISyncTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeployFileRequest : Tea.TeaModel {
    public var comment: String?

    public var fileId: Int64?

    public var nodeId: Int64?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["FileId"] as? Int64 {
            self.fileId = value
        }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class DeployFileResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int64 {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeployFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeployFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeployFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DesensitizeDataRequest : Tea.TeaModel {
    public var data: String?

    public var sceneCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.sceneCode != nil {
            map["SceneCode"] = self.sceneCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["SceneCode"] as? String {
            self.sceneCode = value
        }
    }
}

public class DesensitizeDataResponseBody : Tea.TeaModel {
    public var desensitizeData: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desensitizeData != nil {
            map["DesensitizeData"] = self.desensitizeData!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DesensitizeData"] as? String {
            self.desensitizeData = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DesensitizeDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DesensitizeDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DesensitizeDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgDesensPlanAddOrUpdateRequest : Tea.TeaModel {
    public class DesensRules : Tea.TeaModel {
        public class DesensPlan : Tea.TeaModel {
            public var desensPlanType: String?

            public var extParam: [String: Any]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.desensPlanType != nil {
                    map["DesensPlanType"] = self.desensPlanType!
                }
                if self.extParam != nil {
                    map["ExtParam"] = self.extParam!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DesensPlanType"] as? String {
                    self.desensPlanType = value
                }
                if let value = dict["ExtParam"] as? [String: Any] {
                    self.extParam = value
                }
            }
        }
        public var checkWatermark: Bool?

        public var dataType: String?

        public var desensPlan: DsgDesensPlanAddOrUpdateRequest.DesensRules.DesensPlan?

        public var id: Int32?

        public var owner: String?

        public var ruleName: String?

        public var sceneIds: [Int32]?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.desensPlan?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkWatermark != nil {
                map["CheckWatermark"] = self.checkWatermark!
            }
            if self.dataType != nil {
                map["DataType"] = self.dataType!
            }
            if self.desensPlan != nil {
                map["DesensPlan"] = self.desensPlan?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.sceneIds != nil {
                map["SceneIds"] = self.sceneIds!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CheckWatermark"] as? Bool {
                self.checkWatermark = value
            }
            if let value = dict["DataType"] as? String {
                self.dataType = value
            }
            if let value = dict["DesensPlan"] as? [String: Any?] {
                var model = DsgDesensPlanAddOrUpdateRequest.DesensRules.DesensPlan()
                model.fromMap(value)
                self.desensPlan = model
            }
            if let value = dict["Id"] as? Int32 {
                self.id = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["RuleName"] as? String {
                self.ruleName = value
            }
            if let value = dict["SceneIds"] as? [Int32] {
                self.sceneIds = value
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
        }
    }
    public var desensRules: [DsgDesensPlanAddOrUpdateRequest.DesensRules]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desensRules != nil {
            var tmp : [Any] = []
            for k in self.desensRules! {
                tmp.append(k.toMap())
            }
            map["DesensRules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DesensRules"] as? [Any?] {
            var tmp : [DsgDesensPlanAddOrUpdateRequest.DesensRules] = []
            for v in value {
                if v != nil {
                    var model = DsgDesensPlanAddOrUpdateRequest.DesensRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.desensRules = tmp
        }
    }
}

public class DsgDesensPlanAddOrUpdateShrinkRequest : Tea.TeaModel {
    public var desensRulesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desensRulesShrink != nil {
            map["DesensRules"] = self.desensRulesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DesensRules"] as? String {
            self.desensRulesShrink = value
        }
    }
}

public class DsgDesensPlanAddOrUpdateResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgDesensPlanAddOrUpdateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgDesensPlanAddOrUpdateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgDesensPlanAddOrUpdateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgDesensPlanDeleteRequest : Tea.TeaModel {
    public var ids: [Int32]?

    public var sceneCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.sceneCode != nil {
            map["SceneCode"] = self.sceneCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ids"] as? [Int32] {
            self.ids = value
        }
        if let value = dict["SceneCode"] as? String {
            self.sceneCode = value
        }
    }
}

public class DsgDesensPlanDeleteShrinkRequest : Tea.TeaModel {
    public var idsShrink: String?

    public var sceneCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        if self.sceneCode != nil {
            map["SceneCode"] = self.sceneCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
        if let value = dict["SceneCode"] as? String {
            self.sceneCode = value
        }
    }
}

public class DsgDesensPlanDeleteResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgDesensPlanDeleteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgDesensPlanDeleteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgDesensPlanDeleteResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgDesensPlanQueryListRequest : Tea.TeaModel {
    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var ruleName: String?

    public var sceneId: Int32?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RuleName"] as? String {
            self.ruleName = value
        }
        if let value = dict["SceneId"] as? Int32 {
            self.sceneId = value
        }
        if let value = dict["Status"] as? Int32 {
            self.status = value
        }
    }
}

public class DsgDesensPlanQueryListResponseBody : Tea.TeaModel {
    public class PageData : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class DesensPlan : Tea.TeaModel {
                public var desensPlanType: String?

                public var extParam: [String: Any]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.desensPlanType != nil {
                        map["DesensPlanType"] = self.desensPlanType!
                    }
                    if self.extParam != nil {
                        map["ExtParam"] = self.extParam!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DesensPlanType"] as? String {
                        self.desensPlanType = value
                    }
                    if let value = dict["ExtParam"] as? [String: Any] {
                        self.extParam = value
                    }
                }
            }
            public var checkWatermark: Bool?

            public var dataType: String?

            public var desenMode: String?

            public var desensPlan: DsgDesensPlanQueryListResponseBody.PageData.Data.DesensPlan?

            public var desensRule: String?

            public var desensWay: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var owner: String?

            public var ruleName: String?

            public var sceneCode: String?

            public var sceneName: String?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.desensPlan?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkWatermark != nil {
                    map["CheckWatermark"] = self.checkWatermark!
                }
                if self.dataType != nil {
                    map["DataType"] = self.dataType!
                }
                if self.desenMode != nil {
                    map["DesenMode"] = self.desenMode!
                }
                if self.desensPlan != nil {
                    map["DesensPlan"] = self.desensPlan?.toMap()
                }
                if self.desensRule != nil {
                    map["DesensRule"] = self.desensRule!
                }
                if self.desensWay != nil {
                    map["DesensWay"] = self.desensWay!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.sceneCode != nil {
                    map["SceneCode"] = self.sceneCode!
                }
                if self.sceneName != nil {
                    map["SceneName"] = self.sceneName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CheckWatermark"] as? Bool {
                    self.checkWatermark = value
                }
                if let value = dict["DataType"] as? String {
                    self.dataType = value
                }
                if let value = dict["DesenMode"] as? String {
                    self.desenMode = value
                }
                if let value = dict["DesensPlan"] as? [String: Any?] {
                    var model = DsgDesensPlanQueryListResponseBody.PageData.Data.DesensPlan()
                    model.fromMap(value)
                    self.desensPlan = model
                }
                if let value = dict["DesensRule"] as? String {
                    self.desensRule = value
                }
                if let value = dict["DesensWay"] as? String {
                    self.desensWay = value
                }
                if let value = dict["GmtCreate"] as? String {
                    self.gmtCreate = value
                }
                if let value = dict["GmtModified"] as? String {
                    self.gmtModified = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["RuleName"] as? String {
                    self.ruleName = value
                }
                if let value = dict["SceneCode"] as? String {
                    self.sceneCode = value
                }
                if let value = dict["SceneName"] as? String {
                    self.sceneName = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
            }
        }
        public var data: [DsgDesensPlanQueryListResponseBody.PageData.Data]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                var tmp : [Any] = []
                for k in self.data! {
                    tmp.append(k.toMap())
                }
                map["Data"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Data"] as? [Any?] {
                var tmp : [DsgDesensPlanQueryListResponseBody.PageData.Data] = []
                for v in value {
                    if v != nil {
                        var model = DsgDesensPlanQueryListResponseBody.PageData.Data()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.data = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var pageData: DsgDesensPlanQueryListResponseBody.PageData?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.pageData != nil {
            map["PageData"] = self.pageData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["PageData"] as? [String: Any?] {
            var model = DsgDesensPlanQueryListResponseBody.PageData()
            model.fromMap(value)
            self.pageData = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgDesensPlanQueryListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgDesensPlanQueryListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgDesensPlanQueryListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgDesensPlanUpdateStatusRequest : Tea.TeaModel {
    public var ids: [Int32]?

    public var sceneCode: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.sceneCode != nil {
            map["SceneCode"] = self.sceneCode!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ids"] as? [Int32] {
            self.ids = value
        }
        if let value = dict["SceneCode"] as? String {
            self.sceneCode = value
        }
        if let value = dict["Status"] as? Int32 {
            self.status = value
        }
    }
}

public class DsgDesensPlanUpdateStatusShrinkRequest : Tea.TeaModel {
    public var idsShrink: String?

    public var sceneCode: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        if self.sceneCode != nil {
            map["SceneCode"] = self.sceneCode!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
        if let value = dict["SceneCode"] as? String {
            self.sceneCode = value
        }
        if let value = dict["Status"] as? Int32 {
            self.status = value
        }
    }
}

public class DsgDesensPlanUpdateStatusResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgDesensPlanUpdateStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgDesensPlanUpdateStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgDesensPlanUpdateStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgPlatformQueryProjectsAndSchemaFromMetaRequest : Tea.TeaModel {
    public var engineName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engineName != nil {
            map["EngineName"] = self.engineName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EngineName"] as? String {
            self.engineName = value
        }
    }
}

public class DsgPlatformQueryProjectsAndSchemaFromMetaResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterId: String?

        public var project: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.project != nil {
                map["Project"] = self.project!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["Project"] as? String {
                self.project = value
            }
        }
    }
    public var data: [DsgPlatformQueryProjectsAndSchemaFromMetaResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DsgPlatformQueryProjectsAndSchemaFromMetaResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DsgPlatformQueryProjectsAndSchemaFromMetaResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgPlatformQueryProjectsAndSchemaFromMetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgPlatformQueryProjectsAndSchemaFromMetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgPlatformQueryProjectsAndSchemaFromMetaResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgQueryDefaultTemplatesRequest : Tea.TeaModel {
    public var sceneId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["SceneId"] as? Int32 {
            self.sceneId = value
        }
    }
}

public class DsgQueryDefaultTemplatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dataType: String?

        public var desensPlanTemplate: [String: [DataDesensPlanTemplateValue]]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataType != nil {
                map["DataType"] = self.dataType!
            }
            if self.desensPlanTemplate != nil {
                var tmp : [String: Any] = [:]
                for (k, v) in self.desensPlanTemplate! {
                    var l1 : [Any] = []
                    for k1 in v {
                        l1.append(k1.toMap())
                    }
                    tmp[k] = l1
                }
                map["DesensPlanTemplate"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataType"] as? String {
                self.dataType = value
            }
            if let value = dict["DesensPlanTemplate"] as? [String: Any?] {
                var tmp : [String: [DataDesensPlanTemplateValue]] = [:]
                for (k, v) in value {
                    var l1 : [DataDesensPlanTemplateValue] = []
                    for v1 in v as! [Any?] {
                        if v1 != nil {
                            var model = DataDesensPlanTemplateValue()
                            if v1 != nil {
                                model.fromMap(v1 as? [String: Any?])
                            }
                            l1.append(model)
                        }
                    }
                    tmp[k] = l1
                }
                self.desensPlanTemplate = tmp
            }
        }
    }
    public var data: [DsgQueryDefaultTemplatesResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DsgQueryDefaultTemplatesResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DsgQueryDefaultTemplatesResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgQueryDefaultTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgQueryDefaultTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgQueryDefaultTemplatesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgQuerySensResultRequest : Tea.TeaModel {
    public var col: String?

    public var dbType: String?

    public var level: String?

    public var nodeName: String?

    public var order: String?

    public var orderField: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var projectName: String?

    public var schemaName: String?

    public var sensStatus: String?

    public var sensitiveId: String?

    public var sensitiveName: String?

    public var table: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.col != nil {
            map["Col"] = self.col!
        }
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.orderField != nil {
            map["OrderField"] = self.orderField!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.sensStatus != nil {
            map["SensStatus"] = self.sensStatus!
        }
        if self.sensitiveId != nil {
            map["SensitiveId"] = self.sensitiveId!
        }
        if self.sensitiveName != nil {
            map["SensitiveName"] = self.sensitiveName!
        }
        if self.table != nil {
            map["Table"] = self.table!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Col"] as? String {
            self.col = value
        }
        if let value = dict["DbType"] as? String {
            self.dbType = value
        }
        if let value = dict["Level"] as? String {
            self.level = value
        }
        if let value = dict["NodeName"] as? String {
            self.nodeName = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["OrderField"] as? String {
            self.orderField = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
        if let value = dict["SensStatus"] as? String {
            self.sensStatus = value
        }
        if let value = dict["SensitiveId"] as? String {
            self.sensitiveId = value
        }
        if let value = dict["SensitiveName"] as? String {
            self.sensitiveName = value
        }
        if let value = dict["Table"] as? String {
            self.table = value
        }
        if let value = dict["TenantId"] as? String {
            self.tenantId = value
        }
    }
}

public class DsgQuerySensResultResponseBody : Tea.TeaModel {
    public var data: Any?

    public var dynamicErrorCode: String?

    public var dynamicErrorMessage: String?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicErrorCode != nil {
            map["DynamicErrorCode"] = self.dynamicErrorCode!
        }
        if self.dynamicErrorMessage != nil {
            map["DynamicErrorMessage"] = self.dynamicErrorMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Any {
            self.data = value
        }
        if let value = dict["DynamicErrorCode"] as? String {
            self.dynamicErrorCode = value
        }
        if let value = dict["DynamicErrorMessage"] as? String {
            self.dynamicErrorMessage = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgQuerySensResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgQuerySensResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgQuerySensResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgRunSensIdentifyRequest : Tea.TeaModel {
    public class EsMetaParams : Tea.TeaModel {
        public var clusterId: String?

        public var dbType: String?

        public var instanceId: Int64?

        public var projectName: String?

        public var schemaName: String?

        public var tableName: String?

        public var tableNameList: [String]?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.tableNameList != nil {
                map["TableNameList"] = self.tableNameList!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["DbType"] as? String {
                self.dbType = value
            }
            if let value = dict["InstanceId"] as? Int64 {
                self.instanceId = value
            }
            if let value = dict["ProjectName"] as? String {
                self.projectName = value
            }
            if let value = dict["SchemaName"] as? String {
                self.schemaName = value
            }
            if let value = dict["TableName"] as? String {
                self.tableName = value
            }
            if let value = dict["TableNameList"] as? [String] {
                self.tableNameList = value
            }
            if let value = dict["User"] as? String {
                self.user = value
            }
        }
    }
    public var esMetaParams: [DsgRunSensIdentifyRequest.EsMetaParams]?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.esMetaParams != nil {
            var tmp : [Any] = []
            for k in self.esMetaParams! {
                tmp.append(k.toMap())
            }
            map["EsMetaParams"] = tmp
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EsMetaParams"] as? [Any?] {
            var tmp : [DsgRunSensIdentifyRequest.EsMetaParams] = []
            for v in value {
                if v != nil {
                    var model = DsgRunSensIdentifyRequest.EsMetaParams()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.esMetaParams = tmp
        }
        if let value = dict["TenantId"] as? String {
            self.tenantId = value
        }
    }
}

public class DsgRunSensIdentifyShrinkRequest : Tea.TeaModel {
    public var esMetaParamsShrink: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.esMetaParamsShrink != nil {
            map["EsMetaParams"] = self.esMetaParamsShrink!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EsMetaParams"] as? String {
            self.esMetaParamsShrink = value
        }
        if let value = dict["TenantId"] as? String {
            self.tenantId = value
        }
    }
}

public class DsgRunSensIdentifyResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Any {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgRunSensIdentifyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgRunSensIdentifyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgRunSensIdentifyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgSceneAddOrUpdateSceneRequest : Tea.TeaModel {
    public class Scenes : Tea.TeaModel {
        public class Projects : Tea.TeaModel {
            public var clusterId: String?

            public var dbType: String?

            public var projectName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["clusterId"] = self.clusterId!
                }
                if self.dbType != nil {
                    map["dbType"] = self.dbType!
                }
                if self.projectName != nil {
                    map["projectName"] = self.projectName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["clusterId"] as? String {
                    self.clusterId = value
                }
                if let value = dict["dbType"] as? String {
                    self.dbType = value
                }
                if let value = dict["projectName"] as? String {
                    self.projectName = value
                }
            }
        }
        public var desc: String?

        public var id: String?

        public var projects: [DsgSceneAddOrUpdateSceneRequest.Scenes.Projects]?

        public var sceneCode: String?

        public var sceneName: String?

        public var userGroupIds: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desc != nil {
                map["desc"] = self.desc!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.projects != nil {
                var tmp : [Any] = []
                for k in self.projects! {
                    tmp.append(k.toMap())
                }
                map["projects"] = tmp
            }
            if self.sceneCode != nil {
                map["sceneCode"] = self.sceneCode!
            }
            if self.sceneName != nil {
                map["sceneName"] = self.sceneName!
            }
            if self.userGroupIds != nil {
                map["userGroupIds"] = self.userGroupIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["desc"] as? String {
                self.desc = value
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["projects"] as? [Any?] {
                var tmp : [DsgSceneAddOrUpdateSceneRequest.Scenes.Projects] = []
                for v in value {
                    if v != nil {
                        var model = DsgSceneAddOrUpdateSceneRequest.Scenes.Projects()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.projects = tmp
            }
            if let value = dict["sceneCode"] as? String {
                self.sceneCode = value
            }
            if let value = dict["sceneName"] as? String {
                self.sceneName = value
            }
            if let value = dict["userGroupIds"] as? [Int64] {
                self.userGroupIds = value
            }
        }
    }
    public var scenes: [DsgSceneAddOrUpdateSceneRequest.Scenes]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scenes != nil {
            var tmp : [Any] = []
            for k in self.scenes! {
                tmp.append(k.toMap())
            }
            map["scenes"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["scenes"] as? [Any?] {
            var tmp : [DsgSceneAddOrUpdateSceneRequest.Scenes] = []
            for v in value {
                if v != nil {
                    var model = DsgSceneAddOrUpdateSceneRequest.Scenes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.scenes = tmp
        }
    }
}

public class DsgSceneAddOrUpdateSceneShrinkRequest : Tea.TeaModel {
    public var scenesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scenesShrink != nil {
            map["scenes"] = self.scenesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["scenes"] as? String {
            self.scenesShrink = value
        }
    }
}

public class DsgSceneAddOrUpdateSceneResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgSceneAddOrUpdateSceneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgSceneAddOrUpdateSceneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgSceneAddOrUpdateSceneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgSceneQuerySceneListByNameRequest : Tea.TeaModel {
    public var sceneName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sceneName != nil {
            map["SceneName"] = self.sceneName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["SceneName"] as? String {
            self.sceneName = value
        }
    }
}

public class DsgSceneQuerySceneListByNameResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Projects : Tea.TeaModel {
            public var clusterId: String?

            public var dbType: String?

            public var projectName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ClusterId"] as? String {
                    self.clusterId = value
                }
                if let value = dict["DbType"] as? String {
                    self.dbType = value
                }
                if let value = dict["ProjectName"] as? String {
                    self.projectName = value
                }
            }
        }
        public var children: [Any]?

        public var desc: String?

        public var id: Int64?

        public var projects: [DsgSceneQuerySceneListByNameResponseBody.Data.Projects]?

        public var sceneCode: String?

        public var sceneLevel: Int32?

        public var sceneName: String?

        public var userGroups: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.children != nil {
                map["Children"] = self.children!
            }
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.projects != nil {
                var tmp : [Any] = []
                for k in self.projects! {
                    tmp.append(k.toMap())
                }
                map["Projects"] = tmp
            }
            if self.sceneCode != nil {
                map["SceneCode"] = self.sceneCode!
            }
            if self.sceneLevel != nil {
                map["SceneLevel"] = self.sceneLevel!
            }
            if self.sceneName != nil {
                map["SceneName"] = self.sceneName!
            }
            if self.userGroups != nil {
                map["UserGroups"] = self.userGroups!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Children"] as? [Any] {
                self.children = value
            }
            if let value = dict["Desc"] as? String {
                self.desc = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Projects"] as? [Any?] {
                var tmp : [DsgSceneQuerySceneListByNameResponseBody.Data.Projects] = []
                for v in value {
                    if v != nil {
                        var model = DsgSceneQuerySceneListByNameResponseBody.Data.Projects()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.projects = tmp
            }
            if let value = dict["SceneCode"] as? String {
                self.sceneCode = value
            }
            if let value = dict["SceneLevel"] as? Int32 {
                self.sceneLevel = value
            }
            if let value = dict["SceneName"] as? String {
                self.sceneName = value
            }
            if let value = dict["UserGroups"] as? String {
                self.userGroups = value
            }
        }
    }
    public var data: [DsgSceneQuerySceneListByNameResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DsgSceneQuerySceneListByNameResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DsgSceneQuerySceneListByNameResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgSceneQuerySceneListByNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgSceneQuerySceneListByNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgSceneQuerySceneListByNameResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgScenedDeleteSceneRequest : Tea.TeaModel {
    public var ids: [Int32]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ids"] as? [Int32] {
            self.ids = value
        }
    }
}

public class DsgScenedDeleteSceneShrinkRequest : Tea.TeaModel {
    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
    }
}

public class DsgScenedDeleteSceneResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgScenedDeleteSceneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgScenedDeleteSceneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgScenedDeleteSceneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgStopSensIdentifyRequest : Tea.TeaModel {
    public var jobId: Int64?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["JobId"] as? Int64 {
            self.jobId = value
        }
        if let value = dict["TenantId"] as? String {
            self.tenantId = value
        }
    }
}

public class DsgStopSensIdentifyResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Any {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgStopSensIdentifyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgStopSensIdentifyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgStopSensIdentifyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgUserGroupAddOrUpdateRequest : Tea.TeaModel {
    public class UserGroups : Tea.TeaModel {
        public var accounts: [String]?

        public var id: Int64?

        public var name: String?

        public var owner: String?

        public var projectName: String?

        public var userGroupType: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accounts != nil {
                map["Accounts"] = self.accounts!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.userGroupType != nil {
                map["UserGroupType"] = self.userGroupType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Accounts"] as? [String] {
                self.accounts = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["ProjectName"] as? String {
                self.projectName = value
            }
            if let value = dict["UserGroupType"] as? Int32 {
                self.userGroupType = value
            }
        }
    }
    public var userGroups: [DsgUserGroupAddOrUpdateRequest.UserGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.userGroups != nil {
            var tmp : [Any] = []
            for k in self.userGroups! {
                tmp.append(k.toMap())
            }
            map["UserGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["UserGroups"] as? [Any?] {
            var tmp : [DsgUserGroupAddOrUpdateRequest.UserGroups] = []
            for v in value {
                if v != nil {
                    var model = DsgUserGroupAddOrUpdateRequest.UserGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.userGroups = tmp
        }
    }
}

public class DsgUserGroupAddOrUpdateShrinkRequest : Tea.TeaModel {
    public var userGroupsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.userGroupsShrink != nil {
            map["UserGroups"] = self.userGroupsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["UserGroups"] as? String {
            self.userGroupsShrink = value
        }
    }
}

public class DsgUserGroupAddOrUpdateResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgUserGroupAddOrUpdateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgUserGroupAddOrUpdateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgUserGroupAddOrUpdateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgUserGroupDeleteRequest : Tea.TeaModel {
    public var ids: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ids"] as? [Int64] {
            self.ids = value
        }
    }
}

public class DsgUserGroupDeleteShrinkRequest : Tea.TeaModel {
    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
    }
}

public class DsgUserGroupDeleteResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgUserGroupDeleteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgUserGroupDeleteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgUserGroupDeleteResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgUserGroupGetOdpsRoleGroupsRequest : Tea.TeaModel {
    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
    }
}

public class DsgUserGroupGetOdpsRoleGroupsResponseBody : Tea.TeaModel {
    public var data: [String]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String] {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgUserGroupGetOdpsRoleGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgUserGroupGetOdpsRoleGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgUserGroupGetOdpsRoleGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgUserGroupQueryListRequest : Tea.TeaModel {
    public var name: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
    }
}

public class DsgUserGroupQueryListResponseBody : Tea.TeaModel {
    public class PageData : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public var accounts: [String]?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int32?

            public var name: String?

            public var owner: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accounts != nil {
                    map["Accounts"] = self.accounts!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Accounts"] as? [String] {
                    self.accounts = value
                }
                if let value = dict["GmtCreate"] as? String {
                    self.gmtCreate = value
                }
                if let value = dict["GmtModified"] as? String {
                    self.gmtModified = value
                }
                if let value = dict["Id"] as? Int32 {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
            }
        }
        public var data: [DsgUserGroupQueryListResponseBody.PageData.Data]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                var tmp : [Any] = []
                for k in self.data! {
                    tmp.append(k.toMap())
                }
                map["Data"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Data"] as? [Any?] {
                var tmp : [DsgUserGroupQueryListResponseBody.PageData.Data] = []
                for v in value {
                    if v != nil {
                        var model = DsgUserGroupQueryListResponseBody.PageData.Data()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.data = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var pageData: DsgUserGroupQueryListResponseBody.PageData?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.pageData != nil {
            map["PageData"] = self.pageData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["PageData"] as? [String: Any?] {
            var model = DsgUserGroupQueryListResponseBody.PageData()
            model.fromMap(value)
            self.pageData = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgUserGroupQueryListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgUserGroupQueryListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgUserGroupQueryListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgUserGroupQueryUserListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accountName: String?

        public var accountType: Int32?

        public var baseId: String?

        public var parentAccountId: String?

        public var yunAccount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountName != nil {
                map["AccountName"] = self.accountName!
            }
            if self.accountType != nil {
                map["AccountType"] = self.accountType!
            }
            if self.baseId != nil {
                map["BaseId"] = self.baseId!
            }
            if self.parentAccountId != nil {
                map["ParentAccountId"] = self.parentAccountId!
            }
            if self.yunAccount != nil {
                map["YunAccount"] = self.yunAccount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountName"] as? String {
                self.accountName = value
            }
            if let value = dict["AccountType"] as? Int32 {
                self.accountType = value
            }
            if let value = dict["BaseId"] as? String {
                self.baseId = value
            }
            if let value = dict["ParentAccountId"] as? String {
                self.parentAccountId = value
            }
            if let value = dict["YunAccount"] as? String {
                self.yunAccount = value
            }
        }
    }
    public var data: [DsgUserGroupQueryUserListResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DsgUserGroupQueryUserListResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DsgUserGroupQueryUserListResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgUserGroupQueryUserListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgUserGroupQueryUserListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgUserGroupQueryUserListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgWhiteListAddOrUpdateRequest : Tea.TeaModel {
    public class WhiteLists : Tea.TeaModel {
        public var endTime: String?

        public var id: Int32?

        public var ruleId: Int32?

        public var startTime: String?

        public var userGroupIds: [Int32]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.userGroupIds != nil {
                map["UserGroupIds"] = self.userGroupIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["Id"] as? Int32 {
                self.id = value
            }
            if let value = dict["RuleId"] as? Int32 {
                self.ruleId = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["UserGroupIds"] as? [Int32] {
                self.userGroupIds = value
            }
        }
    }
    public var whiteLists: [DsgWhiteListAddOrUpdateRequest.WhiteLists]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.whiteLists != nil {
            var tmp : [Any] = []
            for k in self.whiteLists! {
                tmp.append(k.toMap())
            }
            map["WhiteLists"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["WhiteLists"] as? [Any?] {
            var tmp : [DsgWhiteListAddOrUpdateRequest.WhiteLists] = []
            for v in value {
                if v != nil {
                    var model = DsgWhiteListAddOrUpdateRequest.WhiteLists()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.whiteLists = tmp
        }
    }
}

public class DsgWhiteListAddOrUpdateShrinkRequest : Tea.TeaModel {
    public var whiteListsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.whiteListsShrink != nil {
            map["WhiteLists"] = self.whiteListsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["WhiteLists"] as? String {
            self.whiteListsShrink = value
        }
    }
}

public class DsgWhiteListAddOrUpdateResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgWhiteListAddOrUpdateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgWhiteListAddOrUpdateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgWhiteListAddOrUpdateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgWhiteListDeleteListRequest : Tea.TeaModel {
    public var ids: [Int32]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ids"] as? [Int32] {
            self.ids = value
        }
    }
}

public class DsgWhiteListDeleteListShrinkRequest : Tea.TeaModel {
    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
    }
}

public class DsgWhiteListDeleteListResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgWhiteListDeleteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgWhiteListDeleteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgWhiteListDeleteListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DsgWhiteListQueryListRequest : Tea.TeaModel {
    public var dataType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var sceneId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataType != nil {
            map["DataType"] = self.dataType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataType"] as? String {
            self.dataType = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SceneId"] as? Int64 {
            self.sceneId = value
        }
    }
}

public class DsgWhiteListQueryListResponseBody : Tea.TeaModel {
    public class PageData : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public var endTime: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var ruleId: Int64?

            public var sceneId: Int64?

            public var startTime: String?

            public var type: String?

            public var userGroups: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.sceneId != nil {
                    map["SceneId"] = self.sceneId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.userGroups != nil {
                    map["UserGroups"] = self.userGroups!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["GmtCreate"] as? String {
                    self.gmtCreate = value
                }
                if let value = dict["GmtModified"] as? String {
                    self.gmtModified = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["RuleId"] as? Int64 {
                    self.ruleId = value
                }
                if let value = dict["SceneId"] as? Int64 {
                    self.sceneId = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["UserGroups"] as? [String] {
                    self.userGroups = value
                }
            }
        }
        public var data: [DsgWhiteListQueryListResponseBody.PageData.Data]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                var tmp : [Any] = []
                for k in self.data! {
                    tmp.append(k.toMap())
                }
                map["Data"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Data"] as? [Any?] {
                var tmp : [DsgWhiteListQueryListResponseBody.PageData.Data] = []
                for v in value {
                    if v != nil {
                        var model = DsgWhiteListQueryListResponseBody.PageData.Data()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.data = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var pageData: DsgWhiteListQueryListResponseBody.PageData?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.pageData != nil {
            map["PageData"] = self.pageData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["PageData"] as? [String: Any?] {
            var model = DsgWhiteListQueryListResponseBody.PageData()
            model.fromMap(value)
            self.pageData = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DsgWhiteListQueryListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DsgWhiteListQueryListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DsgWhiteListQueryListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EditRecognizeRuleRequest : Tea.TeaModel {
    public var accountName: String?

    public var colExclude: String?

    public var colScan: String?

    public var commentScan: String?

    public var contentScan: String?

    public var hitThreshold: Int32?

    public var levelName: String?

    public var nodeId: String?

    public var nodeParent: String?

    public var operationType: Int32?

    public var recognizeRules: String?

    public var recognizeRulesType: String?

    public var sensitiveDescription: String?

    public var sensitiveId: String?

    public var sensitiveName: String?

    public var status: Int32?

    public var templateId: String?

    public var tenantId: String?

    public var level: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.colExclude != nil {
            map["ColExclude"] = self.colExclude!
        }
        if self.colScan != nil {
            map["ColScan"] = self.colScan!
        }
        if self.commentScan != nil {
            map["CommentScan"] = self.commentScan!
        }
        if self.contentScan != nil {
            map["ContentScan"] = self.contentScan!
        }
        if self.hitThreshold != nil {
            map["HitThreshold"] = self.hitThreshold!
        }
        if self.levelName != nil {
            map["LevelName"] = self.levelName!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeParent != nil {
            map["NodeParent"] = self.nodeParent!
        }
        if self.operationType != nil {
            map["OperationType"] = self.operationType!
        }
        if self.recognizeRules != nil {
            map["RecognizeRules"] = self.recognizeRules!
        }
        if self.recognizeRulesType != nil {
            map["RecognizeRulesType"] = self.recognizeRulesType!
        }
        if self.sensitiveDescription != nil {
            map["SensitiveDescription"] = self.sensitiveDescription!
        }
        if self.sensitiveId != nil {
            map["SensitiveId"] = self.sensitiveId!
        }
        if self.sensitiveName != nil {
            map["SensitiveName"] = self.sensitiveName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.level != nil {
            map["level"] = self.level!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["ColExclude"] as? String {
            self.colExclude = value
        }
        if let value = dict["ColScan"] as? String {
            self.colScan = value
        }
        if let value = dict["CommentScan"] as? String {
            self.commentScan = value
        }
        if let value = dict["ContentScan"] as? String {
            self.contentScan = value
        }
        if let value = dict["HitThreshold"] as? Int32 {
            self.hitThreshold = value
        }
        if let value = dict["LevelName"] as? String {
            self.levelName = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["NodeParent"] as? String {
            self.nodeParent = value
        }
        if let value = dict["OperationType"] as? Int32 {
            self.operationType = value
        }
        if let value = dict["RecognizeRules"] as? String {
            self.recognizeRules = value
        }
        if let value = dict["RecognizeRulesType"] as? String {
            self.recognizeRulesType = value
        }
        if let value = dict["SensitiveDescription"] as? String {
            self.sensitiveDescription = value
        }
        if let value = dict["SensitiveId"] as? String {
            self.sensitiveId = value
        }
        if let value = dict["SensitiveName"] as? String {
            self.sensitiveName = value
        }
        if let value = dict["Status"] as? Int32 {
            self.status = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
        if let value = dict["TenantId"] as? String {
            self.tenantId = value
        }
        if let value = dict["level"] as? String {
            self.level = value
        }
    }
}

public class EditRecognizeRuleResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Any {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class EditRecognizeRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EditRecognizeRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EditRecognizeRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EstablishRelationTableToBusinessRequest : Tea.TeaModel {
    public var businessId: String?

    public var folderId: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessId != nil {
            map["BusinessId"] = self.businessId!
        }
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BusinessId"] as? String {
            self.businessId = value
        }
        if let value = dict["FolderId"] as? String {
            self.folderId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
    }
}

public class EstablishRelationTableToBusinessResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class EstablishRelationTableToBusinessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EstablishRelationTableToBusinessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EstablishRelationTableToBusinessResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExportDataSourcesRequest : Tea.TeaModel {
    public var dataSourceType: String?

    public var envType: Int32?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var subType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.subType != nil {
            map["SubType"] = self.subType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["EnvType"] as? Int32 {
            self.envType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SubType"] as? String {
            self.subType = value
        }
    }
}

public class ExportDataSourcesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataSources : Tea.TeaModel {
            public var bindingCalcEngineId: Int32?

            public var connectStatus: Int32?

            public var content: String?

            public var dataSourceType: String?

            public var defaultEngine: Bool?

            public var description_: String?

            public var envType: Int32?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int32?

            public var name: String?

            public var operator_: String?

            public var projectId: Int32?

            public var sequence: Int32?

            public var shared: Bool?

            public var status: Int32?

            public var subType: String?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindingCalcEngineId != nil {
                    map["BindingCalcEngineId"] = self.bindingCalcEngineId!
                }
                if self.connectStatus != nil {
                    map["ConnectStatus"] = self.connectStatus!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.dataSourceType != nil {
                    map["DataSourceType"] = self.dataSourceType!
                }
                if self.defaultEngine != nil {
                    map["DefaultEngine"] = self.defaultEngine!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.sequence != nil {
                    map["Sequence"] = self.sequence!
                }
                if self.shared != nil {
                    map["Shared"] = self.shared!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.subType != nil {
                    map["SubType"] = self.subType!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BindingCalcEngineId"] as? Int32 {
                    self.bindingCalcEngineId = value
                }
                if let value = dict["ConnectStatus"] as? Int32 {
                    self.connectStatus = value
                }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["DataSourceType"] as? String {
                    self.dataSourceType = value
                }
                if let value = dict["DefaultEngine"] as? Bool {
                    self.defaultEngine = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EnvType"] as? Int32 {
                    self.envType = value
                }
                if let value = dict["GmtCreate"] as? String {
                    self.gmtCreate = value
                }
                if let value = dict["GmtModified"] as? String {
                    self.gmtModified = value
                }
                if let value = dict["Id"] as? Int32 {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Operator"] as? String {
                    self.operator_ = value
                }
                if let value = dict["ProjectId"] as? Int32 {
                    self.projectId = value
                }
                if let value = dict["Sequence"] as? Int32 {
                    self.sequence = value
                }
                if let value = dict["Shared"] as? Bool {
                    self.shared = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
                if let value = dict["SubType"] as? String {
                    self.subType = value
                }
                if let value = dict["TenantId"] as? Int64 {
                    self.tenantId = value
                }
            }
        }
        public var dataSources: [ExportDataSourcesResponseBody.Data.DataSources]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSources != nil {
                var tmp : [Any] = []
                for k in self.dataSources! {
                    tmp.append(k.toMap())
                }
                map["DataSources"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataSources"] as? [Any?] {
                var tmp : [ExportDataSourcesResponseBody.Data.DataSources] = []
                for v in value {
                    if v != nil {
                        var model = ExportDataSourcesResponseBody.Data.DataSources()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataSources = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ExportDataSourcesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ExportDataSourcesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ExportDataSourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportDataSourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExportDataSourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GenerateDISyncTaskConfigForCreatingRequest : Tea.TeaModel {
    public var clientToken: String?

    public var projectId: Int64?

    public var taskParam: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskParam != nil {
            map["TaskParam"] = self.taskParam!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TaskParam"] as? String {
            self.taskParam = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
    }
}

public class GenerateDISyncTaskConfigForCreatingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var processId: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.processId != nil {
                map["ProcessId"] = self.processId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["ProcessId"] as? Int64 {
                self.processId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: GenerateDISyncTaskConfigForCreatingResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GenerateDISyncTaskConfigForCreatingResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GenerateDISyncTaskConfigForCreatingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateDISyncTaskConfigForCreatingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GenerateDISyncTaskConfigForCreatingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GenerateDISyncTaskConfigForUpdatingRequest : Tea.TeaModel {
    public var clientToken: String?

    public var projectId: Int64?

    public var taskId: Int64?

    public var taskParam: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskParam != nil {
            map["TaskParam"] = self.taskParam!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
        if let value = dict["TaskParam"] as? String {
            self.taskParam = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
    }
}

public class GenerateDISyncTaskConfigForUpdatingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var processId: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.processId != nil {
                map["ProcessId"] = self.processId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["ProcessId"] as? Int64 {
                self.processId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: GenerateDISyncTaskConfigForUpdatingResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GenerateDISyncTaskConfigForUpdatingResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GenerateDISyncTaskConfigForUpdatingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateDISyncTaskConfigForUpdatingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GenerateDISyncTaskConfigForUpdatingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAlertMessageRequest : Tea.TeaModel {
    public var alertId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlertId"] as? String {
            self.alertId = value
        }
    }
}

public class GetAlertMessageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Instances : Tea.TeaModel {
            public var instanceId: Int64?

            public var nodeId: Int64?

            public var nodeName: String?

            public var projectId: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceId"] as? Int64 {
                    self.instanceId = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public class Nodes : Tea.TeaModel {
            public var nodeId: Int64?

            public var nodeName: String?

            public var owner: String?

            public var projectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
            }
        }
        public class SlaAlert : Tea.TeaModel {
            public var baselineId: Int64?

            public var baselineName: String?

            public var baselineOwner: String?

            public var bizdate: Int64?

            public var inGroupId: Int32?

            public var projectId: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.baselineName != nil {
                    map["BaselineName"] = self.baselineName!
                }
                if self.baselineOwner != nil {
                    map["BaselineOwner"] = self.baselineOwner!
                }
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.inGroupId != nil {
                    map["InGroupId"] = self.inGroupId!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["BaselineName"] as? String {
                    self.baselineName = value
                }
                if let value = dict["BaselineOwner"] as? String {
                    self.baselineOwner = value
                }
                if let value = dict["Bizdate"] as? Int64 {
                    self.bizdate = value
                }
                if let value = dict["InGroupId"] as? Int32 {
                    self.inGroupId = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public class Topics : Tea.TeaModel {
            public var instanceId: Int64?

            public var nodeId: Int64?

            public var topicId: Int64?

            public var topicName: String?

            public var topicOwner: String?

            public var topicStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.topicId != nil {
                    map["TopicId"] = self.topicId!
                }
                if self.topicName != nil {
                    map["TopicName"] = self.topicName!
                }
                if self.topicOwner != nil {
                    map["TopicOwner"] = self.topicOwner!
                }
                if self.topicStatus != nil {
                    map["TopicStatus"] = self.topicStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceId"] as? Int64 {
                    self.instanceId = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["TopicId"] as? Int64 {
                    self.topicId = value
                }
                if let value = dict["TopicName"] as? String {
                    self.topicName = value
                }
                if let value = dict["TopicOwner"] as? String {
                    self.topicOwner = value
                }
                if let value = dict["TopicStatus"] as? String {
                    self.topicStatus = value
                }
            }
        }
        public var alertId: Int64?

        public var alertMessageStatus: String?

        public var alertMethod: String?

        public var alertTime: Int64?

        public var alertUser: String?

        public var content: String?

        public var instances: [GetAlertMessageResponseBody.Data.Instances]?

        public var nodes: [GetAlertMessageResponseBody.Data.Nodes]?

        public var remindId: Int64?

        public var remindName: String?

        public var slaAlert: GetAlertMessageResponseBody.Data.SlaAlert?

        public var source: String?

        public var topics: [GetAlertMessageResponseBody.Data.Topics]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.slaAlert?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertId != nil {
                map["AlertId"] = self.alertId!
            }
            if self.alertMessageStatus != nil {
                map["AlertMessageStatus"] = self.alertMessageStatus!
            }
            if self.alertMethod != nil {
                map["AlertMethod"] = self.alertMethod!
            }
            if self.alertTime != nil {
                map["AlertTime"] = self.alertTime!
            }
            if self.alertUser != nil {
                map["AlertUser"] = self.alertUser!
            }
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.instances != nil {
                var tmp : [Any] = []
                for k in self.instances! {
                    tmp.append(k.toMap())
                }
                map["Instances"] = tmp
            }
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            if self.remindId != nil {
                map["RemindId"] = self.remindId!
            }
            if self.remindName != nil {
                map["RemindName"] = self.remindName!
            }
            if self.slaAlert != nil {
                map["SlaAlert"] = self.slaAlert?.toMap()
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.topics != nil {
                var tmp : [Any] = []
                for k in self.topics! {
                    tmp.append(k.toMap())
                }
                map["Topics"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlertId"] as? Int64 {
                self.alertId = value
            }
            if let value = dict["AlertMessageStatus"] as? String {
                self.alertMessageStatus = value
            }
            if let value = dict["AlertMethod"] as? String {
                self.alertMethod = value
            }
            if let value = dict["AlertTime"] as? Int64 {
                self.alertTime = value
            }
            if let value = dict["AlertUser"] as? String {
                self.alertUser = value
            }
            if let value = dict["Content"] as? String {
                self.content = value
            }
            if let value = dict["Instances"] as? [Any?] {
                var tmp : [GetAlertMessageResponseBody.Data.Instances] = []
                for v in value {
                    if v != nil {
                        var model = GetAlertMessageResponseBody.Data.Instances()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instances = tmp
            }
            if let value = dict["Nodes"] as? [Any?] {
                var tmp : [GetAlertMessageResponseBody.Data.Nodes] = []
                for v in value {
                    if v != nil {
                        var model = GetAlertMessageResponseBody.Data.Nodes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.nodes = tmp
            }
            if let value = dict["RemindId"] as? Int64 {
                self.remindId = value
            }
            if let value = dict["RemindName"] as? String {
                self.remindName = value
            }
            if let value = dict["SlaAlert"] as? [String: Any?] {
                var model = GetAlertMessageResponseBody.Data.SlaAlert()
                model.fromMap(value)
                self.slaAlert = model
            }
            if let value = dict["Source"] as? String {
                self.source = value
            }
            if let value = dict["Topics"] as? [Any?] {
                var tmp : [GetAlertMessageResponseBody.Data.Topics] = []
                for v in value {
                    if v != nil {
                        var model = GetAlertMessageResponseBody.Data.Topics()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.topics = tmp
            }
        }
    }
    public var data: GetAlertMessageResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetAlertMessageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetAlertMessageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAlertMessageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAlertMessageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetBaselineRequest : Tea.TeaModel {
    public var baselineId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BaselineId"] as? Int64 {
            self.baselineId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetBaselineResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AlertSettings : Tea.TeaModel {
            public class DingRobots : Tea.TeaModel {
                public var atAll: Bool?

                public var webUrl: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.atAll != nil {
                        map["AtAll"] = self.atAll!
                    }
                    if self.webUrl != nil {
                        map["WebUrl"] = self.webUrl!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AtAll"] as? Bool {
                        self.atAll = value
                    }
                    if let value = dict["WebUrl"] as? String {
                        self.webUrl = value
                    }
                }
            }
            public var alertInterval: Int32?

            public var alertMaximum: Int32?

            public var alertMethods: [String]?

            public var alertRecipient: String?

            public var alertRecipientType: String?

            public var alertType: String?

            public var baselineAlertEnabled: Bool?

            public var dingRobots: [GetBaselineResponseBody.Data.AlertSettings.DingRobots]?

            public var silenceEndTime: String?

            public var silenceStartTime: String?

            public var topicTypes: [String]?

            public var webhooks: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertInterval != nil {
                    map["AlertInterval"] = self.alertInterval!
                }
                if self.alertMaximum != nil {
                    map["AlertMaximum"] = self.alertMaximum!
                }
                if self.alertMethods != nil {
                    map["AlertMethods"] = self.alertMethods!
                }
                if self.alertRecipient != nil {
                    map["AlertRecipient"] = self.alertRecipient!
                }
                if self.alertRecipientType != nil {
                    map["AlertRecipientType"] = self.alertRecipientType!
                }
                if self.alertType != nil {
                    map["AlertType"] = self.alertType!
                }
                if self.baselineAlertEnabled != nil {
                    map["BaselineAlertEnabled"] = self.baselineAlertEnabled!
                }
                if self.dingRobots != nil {
                    var tmp : [Any] = []
                    for k in self.dingRobots! {
                        tmp.append(k.toMap())
                    }
                    map["DingRobots"] = tmp
                }
                if self.silenceEndTime != nil {
                    map["SilenceEndTime"] = self.silenceEndTime!
                }
                if self.silenceStartTime != nil {
                    map["SilenceStartTime"] = self.silenceStartTime!
                }
                if self.topicTypes != nil {
                    map["TopicTypes"] = self.topicTypes!
                }
                if self.webhooks != nil {
                    map["Webhooks"] = self.webhooks!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AlertInterval"] as? Int32 {
                    self.alertInterval = value
                }
                if let value = dict["AlertMaximum"] as? Int32 {
                    self.alertMaximum = value
                }
                if let value = dict["AlertMethods"] as? [String] {
                    self.alertMethods = value
                }
                if let value = dict["AlertRecipient"] as? String {
                    self.alertRecipient = value
                }
                if let value = dict["AlertRecipientType"] as? String {
                    self.alertRecipientType = value
                }
                if let value = dict["AlertType"] as? String {
                    self.alertType = value
                }
                if let value = dict["BaselineAlertEnabled"] as? Bool {
                    self.baselineAlertEnabled = value
                }
                if let value = dict["DingRobots"] as? [Any?] {
                    var tmp : [GetBaselineResponseBody.Data.AlertSettings.DingRobots] = []
                    for v in value {
                        if v != nil {
                            var model = GetBaselineResponseBody.Data.AlertSettings.DingRobots()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.dingRobots = tmp
                }
                if let value = dict["SilenceEndTime"] as? String {
                    self.silenceEndTime = value
                }
                if let value = dict["SilenceStartTime"] as? String {
                    self.silenceStartTime = value
                }
                if let value = dict["TopicTypes"] as? [String] {
                    self.topicTypes = value
                }
                if let value = dict["Webhooks"] as? [String] {
                    self.webhooks = value
                }
            }
        }
        public class OverTimeSettings : Tea.TeaModel {
            public var cycle: Int32?

            public var time: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycle != nil {
                    map["Cycle"] = self.cycle!
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cycle"] as? Int32 {
                    self.cycle = value
                }
                if let value = dict["Time"] as? String {
                    self.time = value
                }
            }
        }
        public var alertEnabled: Bool?

        public var alertMarginThreshold: Int32?

        public var alertSettings: [GetBaselineResponseBody.Data.AlertSettings]?

        public var baselineId: Int64?

        public var baselineName: String?

        public var baselineType: String?

        public var enabled: Bool?

        public var nodeIds: [Int64]?

        public var overTimeSettings: [GetBaselineResponseBody.Data.OverTimeSettings]?

        public var owner: String?

        public var priority: Int32?

        public var projectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertEnabled != nil {
                map["AlertEnabled"] = self.alertEnabled!
            }
            if self.alertMarginThreshold != nil {
                map["AlertMarginThreshold"] = self.alertMarginThreshold!
            }
            if self.alertSettings != nil {
                var tmp : [Any] = []
                for k in self.alertSettings! {
                    tmp.append(k.toMap())
                }
                map["AlertSettings"] = tmp
            }
            if self.baselineId != nil {
                map["BaselineId"] = self.baselineId!
            }
            if self.baselineName != nil {
                map["BaselineName"] = self.baselineName!
            }
            if self.baselineType != nil {
                map["BaselineType"] = self.baselineType!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.nodeIds != nil {
                map["NodeIds"] = self.nodeIds!
            }
            if self.overTimeSettings != nil {
                var tmp : [Any] = []
                for k in self.overTimeSettings! {
                    tmp.append(k.toMap())
                }
                map["OverTimeSettings"] = tmp
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlertEnabled"] as? Bool {
                self.alertEnabled = value
            }
            if let value = dict["AlertMarginThreshold"] as? Int32 {
                self.alertMarginThreshold = value
            }
            if let value = dict["AlertSettings"] as? [Any?] {
                var tmp : [GetBaselineResponseBody.Data.AlertSettings] = []
                for v in value {
                    if v != nil {
                        var model = GetBaselineResponseBody.Data.AlertSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.alertSettings = tmp
            }
            if let value = dict["BaselineId"] as? Int64 {
                self.baselineId = value
            }
            if let value = dict["BaselineName"] as? String {
                self.baselineName = value
            }
            if let value = dict["BaselineType"] as? String {
                self.baselineType = value
            }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
            if let value = dict["NodeIds"] as? [Int64] {
                self.nodeIds = value
            }
            if let value = dict["OverTimeSettings"] as? [Any?] {
                var tmp : [GetBaselineResponseBody.Data.OverTimeSettings] = []
                for v in value {
                    if v != nil {
                        var model = GetBaselineResponseBody.Data.OverTimeSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.overTimeSettings = tmp
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
        }
    }
    public var data: GetBaselineResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetBaselineResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetBaselineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBaselineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetBaselineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetBaselineConfigRequest : Tea.TeaModel {
    public var baselineId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BaselineId"] as? Int64 {
            self.baselineId = value
        }
    }
}

public class GetBaselineConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var baselineId: Int64?

        public var baselineName: String?

        public var baselineType: String?

        public var expHour: Int32?

        public var expMinu: Int32?

        public var hourExpDetail: String?

        public var hourSlaDetail: String?

        public var isDefault: Bool?

        public var owner: String?

        public var priority: Int32?

        public var projectId: Int64?

        public var slaHour: Int32?

        public var slaMinu: Int32?

        public var useFlag: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineId != nil {
                map["BaselineId"] = self.baselineId!
            }
            if self.baselineName != nil {
                map["BaselineName"] = self.baselineName!
            }
            if self.baselineType != nil {
                map["BaselineType"] = self.baselineType!
            }
            if self.expHour != nil {
                map["ExpHour"] = self.expHour!
            }
            if self.expMinu != nil {
                map["ExpMinu"] = self.expMinu!
            }
            if self.hourExpDetail != nil {
                map["HourExpDetail"] = self.hourExpDetail!
            }
            if self.hourSlaDetail != nil {
                map["HourSlaDetail"] = self.hourSlaDetail!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.slaHour != nil {
                map["SlaHour"] = self.slaHour!
            }
            if self.slaMinu != nil {
                map["SlaMinu"] = self.slaMinu!
            }
            if self.useFlag != nil {
                map["UseFlag"] = self.useFlag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BaselineId"] as? Int64 {
                self.baselineId = value
            }
            if let value = dict["BaselineName"] as? String {
                self.baselineName = value
            }
            if let value = dict["BaselineType"] as? String {
                self.baselineType = value
            }
            if let value = dict["ExpHour"] as? Int32 {
                self.expHour = value
            }
            if let value = dict["ExpMinu"] as? Int32 {
                self.expMinu = value
            }
            if let value = dict["HourExpDetail"] as? String {
                self.hourExpDetail = value
            }
            if let value = dict["HourSlaDetail"] as? String {
                self.hourSlaDetail = value
            }
            if let value = dict["IsDefault"] as? Bool {
                self.isDefault = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["SlaHour"] as? Int32 {
                self.slaHour = value
            }
            if let value = dict["SlaMinu"] as? Int32 {
                self.slaMinu = value
            }
            if let value = dict["UseFlag"] as? Bool {
                self.useFlag = value
            }
        }
    }
    public var data: GetBaselineConfigResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetBaselineConfigResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetBaselineConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBaselineConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetBaselineConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetBaselineKeyPathRequest : Tea.TeaModel {
    public var baselineId: Int64?

    public var bizdate: String?

    public var inGroupId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.inGroupId != nil {
            map["InGroupId"] = self.inGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BaselineId"] as? Int64 {
            self.baselineId = value
        }
        if let value = dict["Bizdate"] as? String {
            self.bizdate = value
        }
        if let value = dict["InGroupId"] as? Int32 {
            self.inGroupId = value
        }
    }
}

public class GetBaselineKeyPathResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Runs : Tea.TeaModel {
            public var absTime: Int64?

            public var beginCast: Int64?

            public var beginRunningTime: Int64?

            public var beginWaitResTime: Int64?

            public var beginWaitTimeTime: Int64?

            public var endCast: Int64?

            public var finishTime: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.absTime != nil {
                    map["AbsTime"] = self.absTime!
                }
                if self.beginCast != nil {
                    map["BeginCast"] = self.beginCast!
                }
                if self.beginRunningTime != nil {
                    map["BeginRunningTime"] = self.beginRunningTime!
                }
                if self.beginWaitResTime != nil {
                    map["BeginWaitResTime"] = self.beginWaitResTime!
                }
                if self.beginWaitTimeTime != nil {
                    map["BeginWaitTimeTime"] = self.beginWaitTimeTime!
                }
                if self.endCast != nil {
                    map["EndCast"] = self.endCast!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AbsTime"] as? Int64 {
                    self.absTime = value
                }
                if let value = dict["BeginCast"] as? Int64 {
                    self.beginCast = value
                }
                if let value = dict["BeginRunningTime"] as? Int64 {
                    self.beginRunningTime = value
                }
                if let value = dict["BeginWaitResTime"] as? Int64 {
                    self.beginWaitResTime = value
                }
                if let value = dict["BeginWaitTimeTime"] as? Int64 {
                    self.beginWaitTimeTime = value
                }
                if let value = dict["EndCast"] as? Int64 {
                    self.endCast = value
                }
                if let value = dict["FinishTime"] as? Int64 {
                    self.finishTime = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public class Topics : Tea.TeaModel {
            public var addTime: Int64?

            public var instanceId: Int64?

            public var topicId: Int64?

            public var topicName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addTime != nil {
                    map["AddTime"] = self.addTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.topicId != nil {
                    map["TopicId"] = self.topicId!
                }
                if self.topicName != nil {
                    map["TopicName"] = self.topicName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddTime"] as? Int64 {
                    self.addTime = value
                }
                if let value = dict["InstanceId"] as? Int64 {
                    self.instanceId = value
                }
                if let value = dict["TopicId"] as? Int64 {
                    self.topicId = value
                }
                if let value = dict["TopicName"] as? String {
                    self.topicName = value
                }
            }
        }
        public var bizdate: Int64?

        public var inGroupId: Int32?

        public var instanceId: Int64?

        public var nodeId: Int64?

        public var nodeName: String?

        public var owner: String?

        public var prgType: Int32?

        public var projectId: Int64?

        public var runs: [GetBaselineKeyPathResponseBody.Data.Runs]?

        public var topics: [GetBaselineKeyPathResponseBody.Data.Topics]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizdate != nil {
                map["Bizdate"] = self.bizdate!
            }
            if self.inGroupId != nil {
                map["InGroupId"] = self.inGroupId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.prgType != nil {
                map["PrgType"] = self.prgType!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.runs != nil {
                var tmp : [Any] = []
                for k in self.runs! {
                    tmp.append(k.toMap())
                }
                map["Runs"] = tmp
            }
            if self.topics != nil {
                var tmp : [Any] = []
                for k in self.topics! {
                    tmp.append(k.toMap())
                }
                map["Topics"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Bizdate"] as? Int64 {
                self.bizdate = value
            }
            if let value = dict["InGroupId"] as? Int32 {
                self.inGroupId = value
            }
            if let value = dict["InstanceId"] as? Int64 {
                self.instanceId = value
            }
            if let value = dict["NodeId"] as? Int64 {
                self.nodeId = value
            }
            if let value = dict["NodeName"] as? String {
                self.nodeName = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["PrgType"] as? Int32 {
                self.prgType = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["Runs"] as? [Any?] {
                var tmp : [GetBaselineKeyPathResponseBody.Data.Runs] = []
                for v in value {
                    if v != nil {
                        var model = GetBaselineKeyPathResponseBody.Data.Runs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.runs = tmp
            }
            if let value = dict["Topics"] as? [Any?] {
                var tmp : [GetBaselineKeyPathResponseBody.Data.Topics] = []
                for v in value {
                    if v != nil {
                        var model = GetBaselineKeyPathResponseBody.Data.Topics()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.topics = tmp
            }
        }
    }
    public var data: [GetBaselineKeyPathResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [GetBaselineKeyPathResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = GetBaselineKeyPathResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetBaselineKeyPathResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBaselineKeyPathResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetBaselineKeyPathResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetBaselineStatusRequest : Tea.TeaModel {
    public var baselineId: Int64?

    public var bizdate: String?

    public var inGroupId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.inGroupId != nil {
            map["InGroupId"] = self.inGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BaselineId"] as? Int64 {
            self.baselineId = value
        }
        if let value = dict["Bizdate"] as? String {
            self.bizdate = value
        }
        if let value = dict["InGroupId"] as? Int32 {
            self.inGroupId = value
        }
    }
}

public class GetBaselineStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BlockInstance : Tea.TeaModel {
            public var endCast: Int64?

            public var finishTime: Int64?

            public var instanceId: Int64?

            public var nodeId: Int64?

            public var nodeName: String?

            public var owner: String?

            public var projectId: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endCast != nil {
                    map["EndCast"] = self.endCast!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EndCast"] as? Int64 {
                    self.endCast = value
                }
                if let value = dict["FinishTime"] as? Int64 {
                    self.finishTime = value
                }
                if let value = dict["InstanceId"] as? Int64 {
                    self.instanceId = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public class LastInstance : Tea.TeaModel {
            public var endCast: Int64?

            public var finishTime: Int64?

            public var instanceId: Int64?

            public var nodeId: Int64?

            public var nodeName: String?

            public var owner: String?

            public var projectId: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endCast != nil {
                    map["EndCast"] = self.endCast!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EndCast"] as? Int64 {
                    self.endCast = value
                }
                if let value = dict["FinishTime"] as? Int64 {
                    self.finishTime = value
                }
                if let value = dict["InstanceId"] as? Int64 {
                    self.instanceId = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var baselineId: Int64?

        public var baselineName: String?

        public var bizdate: Int64?

        public var blockInstance: GetBaselineStatusResponseBody.Data.BlockInstance?

        public var buffer: Double?

        public var endCast: Int64?

        public var expTime: Int64?

        public var finishStatus: String?

        public var finishTime: Int64?

        public var inGroupId: Int32?

        public var lastInstance: GetBaselineStatusResponseBody.Data.LastInstance?

        public var owner: String?

        public var priority: Int32?

        public var projectId: Int64?

        public var slaTime: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.blockInstance?.validate()
            try self.lastInstance?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineId != nil {
                map["BaselineId"] = self.baselineId!
            }
            if self.baselineName != nil {
                map["BaselineName"] = self.baselineName!
            }
            if self.bizdate != nil {
                map["Bizdate"] = self.bizdate!
            }
            if self.blockInstance != nil {
                map["BlockInstance"] = self.blockInstance?.toMap()
            }
            if self.buffer != nil {
                map["Buffer"] = self.buffer!
            }
            if self.endCast != nil {
                map["EndCast"] = self.endCast!
            }
            if self.expTime != nil {
                map["ExpTime"] = self.expTime!
            }
            if self.finishStatus != nil {
                map["FinishStatus"] = self.finishStatus!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.inGroupId != nil {
                map["InGroupId"] = self.inGroupId!
            }
            if self.lastInstance != nil {
                map["LastInstance"] = self.lastInstance?.toMap()
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.slaTime != nil {
                map["SlaTime"] = self.slaTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BaselineId"] as? Int64 {
                self.baselineId = value
            }
            if let value = dict["BaselineName"] as? String {
                self.baselineName = value
            }
            if let value = dict["Bizdate"] as? Int64 {
                self.bizdate = value
            }
            if let value = dict["BlockInstance"] as? [String: Any?] {
                var model = GetBaselineStatusResponseBody.Data.BlockInstance()
                model.fromMap(value)
                self.blockInstance = model
            }
            if let value = dict["Buffer"] as? Double {
                self.buffer = value
            }
            if let value = dict["EndCast"] as? Int64 {
                self.endCast = value
            }
            if let value = dict["ExpTime"] as? Int64 {
                self.expTime = value
            }
            if let value = dict["FinishStatus"] as? String {
                self.finishStatus = value
            }
            if let value = dict["FinishTime"] as? Int64 {
                self.finishTime = value
            }
            if let value = dict["InGroupId"] as? Int32 {
                self.inGroupId = value
            }
            if let value = dict["LastInstance"] as? [String: Any?] {
                var model = GetBaselineStatusResponseBody.Data.LastInstance()
                model.fromMap(value)
                self.lastInstance = model
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["SlaTime"] as? Int64 {
                self.slaTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: GetBaselineStatusResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetBaselineStatusResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetBaselineStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBaselineStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetBaselineStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetBusinessRequest : Tea.TeaModel {
    public var businessId: Int64?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessId != nil {
            map["BusinessId"] = self.businessId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BusinessId"] as? Int64 {
            self.businessId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class GetBusinessResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var businessId: Int64?

        public var businessName: String?

        public var description_: String?

        public var owner: String?

        public var projectId: String?

        public var useType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessId != nil {
                map["BusinessId"] = self.businessId!
            }
            if self.businessName != nil {
                map["BusinessName"] = self.businessName!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.useType != nil {
                map["UseType"] = self.useType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BusinessId"] as? Int64 {
                self.businessId = value
            }
            if let value = dict["BusinessName"] as? String {
                self.businessName = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["ProjectId"] as? String {
                self.projectId = value
            }
            if let value = dict["UseType"] as? String {
                self.useType = value
            }
        }
    }
    public var data: GetBusinessResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetBusinessResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetBusinessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBusinessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetBusinessResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDDLJobStatusRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class GetDDLJobStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var content: String?

        public var nextTaskId: String?

        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.nextTaskId != nil {
                map["NextTaskId"] = self.nextTaskId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Content"] as? String {
                self.content = value
            }
            if let value = dict["NextTaskId"] as? String {
                self.nextTaskId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
        }
    }
    public var data: GetDDLJobStatusResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDDLJobStatusResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDDLJobStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDDLJobStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDDLJobStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDIAlarmRuleRequest : Tea.TeaModel {
    public var DIAlarmRuleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIAlarmRuleId"] as? Int64 {
            self.DIAlarmRuleId = value
        }
    }
}

public class GetDIAlarmRuleResponseBody : Tea.TeaModel {
    public class DIAlarmRule : Tea.TeaModel {
        public class NotificationSettings : Tea.TeaModel {
            public class NotificationChannels : Tea.TeaModel {
                public var channels: [String]?

                public var severity: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.severity != nil {
                        map["Severity"] = self.severity!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Channels"] as? [String] {
                        self.channels = value
                    }
                    if let value = dict["Severity"] as? String {
                        self.severity = value
                    }
                }
            }
            public class NotificationReceivers : Tea.TeaModel {
                public var receiverType: String?

                public var receiverValues: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.receiverType != nil {
                        map["ReceiverType"] = self.receiverType!
                    }
                    if self.receiverValues != nil {
                        map["ReceiverValues"] = self.receiverValues!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ReceiverType"] as? String {
                        self.receiverType = value
                    }
                    if let value = dict["ReceiverValues"] as? [String] {
                        self.receiverValues = value
                    }
                }
            }
            public var inhibitionInterval: Int32?

            public var notificationChannels: [GetDIAlarmRuleResponseBody.DIAlarmRule.NotificationSettings.NotificationChannels]?

            public var notificationReceivers: [GetDIAlarmRuleResponseBody.DIAlarmRule.NotificationSettings.NotificationReceivers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inhibitionInterval != nil {
                    map["InhibitionInterval"] = self.inhibitionInterval!
                }
                if self.notificationChannels != nil {
                    var tmp : [Any] = []
                    for k in self.notificationChannels! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationChannels"] = tmp
                }
                if self.notificationReceivers != nil {
                    var tmp : [Any] = []
                    for k in self.notificationReceivers! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationReceivers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InhibitionInterval"] as? Int32 {
                    self.inhibitionInterval = value
                }
                if let value = dict["NotificationChannels"] as? [Any?] {
                    var tmp : [GetDIAlarmRuleResponseBody.DIAlarmRule.NotificationSettings.NotificationChannels] = []
                    for v in value {
                        if v != nil {
                            var model = GetDIAlarmRuleResponseBody.DIAlarmRule.NotificationSettings.NotificationChannels()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.notificationChannels = tmp
                }
                if let value = dict["NotificationReceivers"] as? [Any?] {
                    var tmp : [GetDIAlarmRuleResponseBody.DIAlarmRule.NotificationSettings.NotificationReceivers] = []
                    for v in value {
                        if v != nil {
                            var model = GetDIAlarmRuleResponseBody.DIAlarmRule.NotificationSettings.NotificationReceivers()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.notificationReceivers = tmp
                }
            }
        }
        public class TriggerConditions : Tea.TeaModel {
            public var duration: Int64?

            public var severity: String?

            public var threshold: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Duration"] as? Int64 {
                    self.duration = value
                }
                if let value = dict["Severity"] as? String {
                    self.severity = value
                }
                if let value = dict["Threshold"] as? Int64 {
                    self.threshold = value
                }
            }
        }
        public var createdTime: Int64?

        public var createdUid: String?

        public var DIAlarmRuleId: Int64?

        public var DIJobId: Int64?

        public var description_: String?

        public var enabled: Bool?

        public var metricType: String?

        public var notificationSettings: GetDIAlarmRuleResponseBody.DIAlarmRule.NotificationSettings?

        public var triggerConditions: [GetDIAlarmRuleResponseBody.DIAlarmRule.TriggerConditions]?

        public var updatedTime: Int64?

        public var updatedUid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.notificationSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.createdUid != nil {
                map["CreatedUid"] = self.createdUid!
            }
            if self.DIAlarmRuleId != nil {
                map["DIAlarmRuleId"] = self.DIAlarmRuleId!
            }
            if self.DIJobId != nil {
                map["DIJobId"] = self.DIJobId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.metricType != nil {
                map["MetricType"] = self.metricType!
            }
            if self.notificationSettings != nil {
                map["NotificationSettings"] = self.notificationSettings?.toMap()
            }
            if self.triggerConditions != nil {
                var tmp : [Any] = []
                for k in self.triggerConditions! {
                    tmp.append(k.toMap())
                }
                map["TriggerConditions"] = tmp
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            if self.updatedUid != nil {
                map["UpdatedUid"] = self.updatedUid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreatedTime"] as? Int64 {
                self.createdTime = value
            }
            if let value = dict["CreatedUid"] as? String {
                self.createdUid = value
            }
            if let value = dict["DIAlarmRuleId"] as? Int64 {
                self.DIAlarmRuleId = value
            }
            if let value = dict["DIJobId"] as? Int64 {
                self.DIJobId = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
            if let value = dict["MetricType"] as? String {
                self.metricType = value
            }
            if let value = dict["NotificationSettings"] as? [String: Any?] {
                var model = GetDIAlarmRuleResponseBody.DIAlarmRule.NotificationSettings()
                model.fromMap(value)
                self.notificationSettings = model
            }
            if let value = dict["TriggerConditions"] as? [Any?] {
                var tmp : [GetDIAlarmRuleResponseBody.DIAlarmRule.TriggerConditions] = []
                for v in value {
                    if v != nil {
                        var model = GetDIAlarmRuleResponseBody.DIAlarmRule.TriggerConditions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.triggerConditions = tmp
            }
            if let value = dict["UpdatedTime"] as? Int64 {
                self.updatedTime = value
            }
            if let value = dict["UpdatedUid"] as? String {
                self.updatedUid = value
            }
        }
    }
    public var DIAlarmRule: GetDIAlarmRuleResponseBody.DIAlarmRule?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DIAlarmRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRule != nil {
            map["DIAlarmRule"] = self.DIAlarmRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIAlarmRule"] as? [String: Any?] {
            var model = GetDIAlarmRuleResponseBody.DIAlarmRule()
            model.fromMap(value)
            self.DIAlarmRule = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDIAlarmRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDIAlarmRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDIAlarmRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDIJobRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var withDetails: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.withDetails != nil {
            map["WithDetails"] = self.withDetails!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["WithDetails"] as? Bool {
            self.withDetails = value
        }
    }
}

public class GetDIJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DestinationDataSourceSettings : Tea.TeaModel {
            public var dataSourceName: String?

            public var dataSourceProperties: [String: String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSourceName != nil {
                    map["DataSourceName"] = self.dataSourceName!
                }
                if self.dataSourceProperties != nil {
                    map["DataSourceProperties"] = self.dataSourceProperties!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DataSourceName"] as? String {
                    self.dataSourceName = value
                }
                if let value = dict["DataSourceProperties"] as? [String: String] {
                    self.dataSourceProperties = value
                }
            }
        }
        public class JobSettings : Tea.TeaModel {
            public class ColumnDataTypeSettings : Tea.TeaModel {
                public var destinationDataType: String?

                public var sourceDataType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.destinationDataType != nil {
                        map["DestinationDataType"] = self.destinationDataType!
                    }
                    if self.sourceDataType != nil {
                        map["SourceDataType"] = self.sourceDataType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DestinationDataType"] as? String {
                        self.destinationDataType = value
                    }
                    if let value = dict["SourceDataType"] as? String {
                        self.sourceDataType = value
                    }
                }
            }
            public class CycleScheduleSettings : Tea.TeaModel {
                public var cycleMigrationType: String?

                public var scheduleParameters: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cycleMigrationType != nil {
                        map["CycleMigrationType"] = self.cycleMigrationType!
                    }
                    if self.scheduleParameters != nil {
                        map["ScheduleParameters"] = self.scheduleParameters!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CycleMigrationType"] as? String {
                        self.cycleMigrationType = value
                    }
                    if let value = dict["ScheduleParameters"] as? String {
                        self.scheduleParameters = value
                    }
                }
            }
            public class DdlHandlingSettings : Tea.TeaModel {
                public var action: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.action != nil {
                        map["Action"] = self.action!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Action"] as? String {
                        self.action = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public class RuntimeSettings : Tea.TeaModel {
                public var name: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var channelSettings: String?

            public var columnDataTypeSettings: [GetDIJobResponseBody.Data.JobSettings.ColumnDataTypeSettings]?

            public var cycleScheduleSettings: GetDIJobResponseBody.Data.JobSettings.CycleScheduleSettings?

            public var ddlHandlingSettings: [GetDIJobResponseBody.Data.JobSettings.DdlHandlingSettings]?

            public var runtimeSettings: [GetDIJobResponseBody.Data.JobSettings.RuntimeSettings]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cycleScheduleSettings?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelSettings != nil {
                    map["ChannelSettings"] = self.channelSettings!
                }
                if self.columnDataTypeSettings != nil {
                    var tmp : [Any] = []
                    for k in self.columnDataTypeSettings! {
                        tmp.append(k.toMap())
                    }
                    map["ColumnDataTypeSettings"] = tmp
                }
                if self.cycleScheduleSettings != nil {
                    map["CycleScheduleSettings"] = self.cycleScheduleSettings?.toMap()
                }
                if self.ddlHandlingSettings != nil {
                    var tmp : [Any] = []
                    for k in self.ddlHandlingSettings! {
                        tmp.append(k.toMap())
                    }
                    map["DdlHandlingSettings"] = tmp
                }
                if self.runtimeSettings != nil {
                    var tmp : [Any] = []
                    for k in self.runtimeSettings! {
                        tmp.append(k.toMap())
                    }
                    map["RuntimeSettings"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ChannelSettings"] as? String {
                    self.channelSettings = value
                }
                if let value = dict["ColumnDataTypeSettings"] as? [Any?] {
                    var tmp : [GetDIJobResponseBody.Data.JobSettings.ColumnDataTypeSettings] = []
                    for v in value {
                        if v != nil {
                            var model = GetDIJobResponseBody.Data.JobSettings.ColumnDataTypeSettings()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.columnDataTypeSettings = tmp
                }
                if let value = dict["CycleScheduleSettings"] as? [String: Any?] {
                    var model = GetDIJobResponseBody.Data.JobSettings.CycleScheduleSettings()
                    model.fromMap(value)
                    self.cycleScheduleSettings = model
                }
                if let value = dict["DdlHandlingSettings"] as? [Any?] {
                    var tmp : [GetDIJobResponseBody.Data.JobSettings.DdlHandlingSettings] = []
                    for v in value {
                        if v != nil {
                            var model = GetDIJobResponseBody.Data.JobSettings.DdlHandlingSettings()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.ddlHandlingSettings = tmp
                }
                if let value = dict["RuntimeSettings"] as? [Any?] {
                    var tmp : [GetDIJobResponseBody.Data.JobSettings.RuntimeSettings] = []
                    for v in value {
                        if v != nil {
                            var model = GetDIJobResponseBody.Data.JobSettings.RuntimeSettings()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.runtimeSettings = tmp
                }
            }
        }
        public class ResourceSettings : Tea.TeaModel {
            public class OfflineResourceSettings : Tea.TeaModel {
                public var resourceGroupIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceGroupIdentifier != nil {
                        map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ResourceGroupIdentifier"] as? String {
                        self.resourceGroupIdentifier = value
                    }
                }
            }
            public class RealtimeResourceSettings : Tea.TeaModel {
                public var resourceGroupIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceGroupIdentifier != nil {
                        map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ResourceGroupIdentifier"] as? String {
                        self.resourceGroupIdentifier = value
                    }
                }
            }
            public var offlineResourceSettings: GetDIJobResponseBody.Data.ResourceSettings.OfflineResourceSettings?

            public var realtimeResourceSettings: GetDIJobResponseBody.Data.ResourceSettings.RealtimeResourceSettings?

            public var requestedCu: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.offlineResourceSettings?.validate()
                try self.realtimeResourceSettings?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.offlineResourceSettings != nil {
                    map["OfflineResourceSettings"] = self.offlineResourceSettings?.toMap()
                }
                if self.realtimeResourceSettings != nil {
                    map["RealtimeResourceSettings"] = self.realtimeResourceSettings?.toMap()
                }
                if self.requestedCu != nil {
                    map["RequestedCu"] = self.requestedCu!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["OfflineResourceSettings"] as? [String: Any?] {
                    var model = GetDIJobResponseBody.Data.ResourceSettings.OfflineResourceSettings()
                    model.fromMap(value)
                    self.offlineResourceSettings = model
                }
                if let value = dict["RealtimeResourceSettings"] as? [String: Any?] {
                    var model = GetDIJobResponseBody.Data.ResourceSettings.RealtimeResourceSettings()
                    model.fromMap(value)
                    self.realtimeResourceSettings = model
                }
                if let value = dict["RequestedCu"] as? Double {
                    self.requestedCu = value
                }
            }
        }
        public class SourceDataSourceSettings : Tea.TeaModel {
            public var dataSourceName: String?

            public var dataSourceProperties: [String: String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSourceName != nil {
                    map["DataSourceName"] = self.dataSourceName!
                }
                if self.dataSourceProperties != nil {
                    map["DataSourceProperties"] = self.dataSourceProperties!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DataSourceName"] as? String {
                    self.dataSourceName = value
                }
                if let value = dict["DataSourceProperties"] as? [String: String] {
                    self.dataSourceProperties = value
                }
            }
        }
        public class TableMappings : Tea.TeaModel {
            public class SourceObjectSelectionRules : Tea.TeaModel {
                public var expression: String?

                public var objectType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.objectType != nil {
                        map["ObjectType"] = self.objectType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Expression"] as? String {
                        self.expression = value
                    }
                    if let value = dict["ObjectType"] as? String {
                        self.objectType = value
                    }
                }
            }
            public class TransformationRules : Tea.TeaModel {
                public var ruleActionType: String?

                public var ruleName: String?

                public var ruleTargetType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ruleActionType != nil {
                        map["RuleActionType"] = self.ruleActionType!
                    }
                    if self.ruleName != nil {
                        map["RuleName"] = self.ruleName!
                    }
                    if self.ruleTargetType != nil {
                        map["RuleTargetType"] = self.ruleTargetType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RuleActionType"] as? String {
                        self.ruleActionType = value
                    }
                    if let value = dict["RuleName"] as? String {
                        self.ruleName = value
                    }
                    if let value = dict["RuleTargetType"] as? String {
                        self.ruleTargetType = value
                    }
                }
            }
            public var sourceObjectSelectionRules: [GetDIJobResponseBody.Data.TableMappings.SourceObjectSelectionRules]?

            public var transformationRules: [GetDIJobResponseBody.Data.TableMappings.TransformationRules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sourceObjectSelectionRules != nil {
                    var tmp : [Any] = []
                    for k in self.sourceObjectSelectionRules! {
                        tmp.append(k.toMap())
                    }
                    map["SourceObjectSelectionRules"] = tmp
                }
                if self.transformationRules != nil {
                    var tmp : [Any] = []
                    for k in self.transformationRules! {
                        tmp.append(k.toMap())
                    }
                    map["TransformationRules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["SourceObjectSelectionRules"] as? [Any?] {
                    var tmp : [GetDIJobResponseBody.Data.TableMappings.SourceObjectSelectionRules] = []
                    for v in value {
                        if v != nil {
                            var model = GetDIJobResponseBody.Data.TableMappings.SourceObjectSelectionRules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.sourceObjectSelectionRules = tmp
                }
                if let value = dict["TransformationRules"] as? [Any?] {
                    var tmp : [GetDIJobResponseBody.Data.TableMappings.TransformationRules] = []
                    for v in value {
                        if v != nil {
                            var model = GetDIJobResponseBody.Data.TableMappings.TransformationRules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.transformationRules = tmp
                }
            }
        }
        public class TransformationRules : Tea.TeaModel {
            public var ruleActionType: String?

            public var ruleExpression: String?

            public var ruleName: String?

            public var ruleTargetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ruleActionType != nil {
                    map["RuleActionType"] = self.ruleActionType!
                }
                if self.ruleExpression != nil {
                    map["RuleExpression"] = self.ruleExpression!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.ruleTargetType != nil {
                    map["RuleTargetType"] = self.ruleTargetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RuleActionType"] as? String {
                    self.ruleActionType = value
                }
                if let value = dict["RuleExpression"] as? String {
                    self.ruleExpression = value
                }
                if let value = dict["RuleName"] as? String {
                    self.ruleName = value
                }
                if let value = dict["RuleTargetType"] as? String {
                    self.ruleTargetType = value
                }
            }
        }
        public var createdTime: Int64?

        public var createdUid: String?

        public var DIJobId: Int64?

        public var description_: String?

        public var destinationDataSourceSettings: [GetDIJobResponseBody.Data.DestinationDataSourceSettings]?

        public var destinationDataSourceType: String?

        public var errorMessage: String?

        public var jobName: String?

        public var jobSettings: GetDIJobResponseBody.Data.JobSettings?

        public var jobStatus: String?

        public var migrationType: String?

        public var projectId: Int64?

        public var resourceSettings: GetDIJobResponseBody.Data.ResourceSettings?

        public var runStats: [String: String]?

        public var sourceDataSourceSettings: [GetDIJobResponseBody.Data.SourceDataSourceSettings]?

        public var sourceDataSourceType: String?

        public var startedTime: Int64?

        public var startedUid: String?

        public var tableMappings: [GetDIJobResponseBody.Data.TableMappings]?

        public var transformationRules: [GetDIJobResponseBody.Data.TransformationRules]?

        public var updatedTime: Int64?

        public var updatedUid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.jobSettings?.validate()
            try self.resourceSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.createdUid != nil {
                map["CreatedUid"] = self.createdUid!
            }
            if self.DIJobId != nil {
                map["DIJobId"] = self.DIJobId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destinationDataSourceSettings != nil {
                var tmp : [Any] = []
                for k in self.destinationDataSourceSettings! {
                    tmp.append(k.toMap())
                }
                map["DestinationDataSourceSettings"] = tmp
            }
            if self.destinationDataSourceType != nil {
                map["DestinationDataSourceType"] = self.destinationDataSourceType!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.jobName != nil {
                map["JobName"] = self.jobName!
            }
            if self.jobSettings != nil {
                map["JobSettings"] = self.jobSettings?.toMap()
            }
            if self.jobStatus != nil {
                map["JobStatus"] = self.jobStatus!
            }
            if self.migrationType != nil {
                map["MigrationType"] = self.migrationType!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.resourceSettings != nil {
                map["ResourceSettings"] = self.resourceSettings?.toMap()
            }
            if self.runStats != nil {
                map["RunStats"] = self.runStats!
            }
            if self.sourceDataSourceSettings != nil {
                var tmp : [Any] = []
                for k in self.sourceDataSourceSettings! {
                    tmp.append(k.toMap())
                }
                map["SourceDataSourceSettings"] = tmp
            }
            if self.sourceDataSourceType != nil {
                map["SourceDataSourceType"] = self.sourceDataSourceType!
            }
            if self.startedTime != nil {
                map["StartedTime"] = self.startedTime!
            }
            if self.startedUid != nil {
                map["StartedUid"] = self.startedUid!
            }
            if self.tableMappings != nil {
                var tmp : [Any] = []
                for k in self.tableMappings! {
                    tmp.append(k.toMap())
                }
                map["TableMappings"] = tmp
            }
            if self.transformationRules != nil {
                var tmp : [Any] = []
                for k in self.transformationRules! {
                    tmp.append(k.toMap())
                }
                map["TransformationRules"] = tmp
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            if self.updatedUid != nil {
                map["UpdatedUid"] = self.updatedUid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreatedTime"] as? Int64 {
                self.createdTime = value
            }
            if let value = dict["CreatedUid"] as? String {
                self.createdUid = value
            }
            if let value = dict["DIJobId"] as? Int64 {
                self.DIJobId = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DestinationDataSourceSettings"] as? [Any?] {
                var tmp : [GetDIJobResponseBody.Data.DestinationDataSourceSettings] = []
                for v in value {
                    if v != nil {
                        var model = GetDIJobResponseBody.Data.DestinationDataSourceSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.destinationDataSourceSettings = tmp
            }
            if let value = dict["DestinationDataSourceType"] as? String {
                self.destinationDataSourceType = value
            }
            if let value = dict["ErrorMessage"] as? String {
                self.errorMessage = value
            }
            if let value = dict["JobName"] as? String {
                self.jobName = value
            }
            if let value = dict["JobSettings"] as? [String: Any?] {
                var model = GetDIJobResponseBody.Data.JobSettings()
                model.fromMap(value)
                self.jobSettings = model
            }
            if let value = dict["JobStatus"] as? String {
                self.jobStatus = value
            }
            if let value = dict["MigrationType"] as? String {
                self.migrationType = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["ResourceSettings"] as? [String: Any?] {
                var model = GetDIJobResponseBody.Data.ResourceSettings()
                model.fromMap(value)
                self.resourceSettings = model
            }
            if let value = dict["RunStats"] as? [String: String] {
                self.runStats = value
            }
            if let value = dict["SourceDataSourceSettings"] as? [Any?] {
                var tmp : [GetDIJobResponseBody.Data.SourceDataSourceSettings] = []
                for v in value {
                    if v != nil {
                        var model = GetDIJobResponseBody.Data.SourceDataSourceSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sourceDataSourceSettings = tmp
            }
            if let value = dict["SourceDataSourceType"] as? String {
                self.sourceDataSourceType = value
            }
            if let value = dict["StartedTime"] as? Int64 {
                self.startedTime = value
            }
            if let value = dict["StartedUid"] as? String {
                self.startedUid = value
            }
            if let value = dict["TableMappings"] as? [Any?] {
                var tmp : [GetDIJobResponseBody.Data.TableMappings] = []
                for v in value {
                    if v != nil {
                        var model = GetDIJobResponseBody.Data.TableMappings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tableMappings = tmp
            }
            if let value = dict["TransformationRules"] as? [Any?] {
                var tmp : [GetDIJobResponseBody.Data.TransformationRules] = []
                for v in value {
                    if v != nil {
                        var model = GetDIJobResponseBody.Data.TransformationRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.transformationRules = tmp
            }
            if let value = dict["UpdatedTime"] as? Int64 {
                self.updatedTime = value
            }
            if let value = dict["UpdatedUid"] as? String {
                self.updatedUid = value
            }
        }
    }
    public var data: GetDIJobResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDIJobResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDIJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDISyncInstanceInfoRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FileId"] as? Int64 {
            self.fileId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
    }
}

public class GetDISyncInstanceInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SolutionInfo : Tea.TeaModel {
            public class StepDetail : Tea.TeaModel {
                public var info: String?

                public var status: String?

                public var stepId: Int64?

                public var stepName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.info != nil {
                        map["Info"] = self.info!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.stepId != nil {
                        map["StepId"] = self.stepId!
                    }
                    if self.stepName != nil {
                        map["StepName"] = self.stepName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Info"] as? String {
                        self.info = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                    if let value = dict["StepId"] as? Int64 {
                        self.stepId = value
                    }
                    if let value = dict["StepName"] as? String {
                        self.stepName = value
                    }
                }
            }
            public var creatorName: String?

            public var id: Int64?

            public var status: String?

            public var stepDetail: [GetDISyncInstanceInfoResponseBody.Data.SolutionInfo.StepDetail]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creatorName != nil {
                    map["CreatorName"] = self.creatorName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.stepDetail != nil {
                    var tmp : [Any] = []
                    for k in self.stepDetail! {
                        tmp.append(k.toMap())
                    }
                    map["StepDetail"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreatorName"] as? String {
                    self.creatorName = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["StepDetail"] as? [Any?] {
                    var tmp : [GetDISyncInstanceInfoResponseBody.Data.SolutionInfo.StepDetail] = []
                    for v in value {
                        if v != nil {
                            var model = GetDISyncInstanceInfoResponseBody.Data.SolutionInfo.StepDetail()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.stepDetail = tmp
                }
            }
        }
        public var message: String?

        public var name: String?

        public var solutionInfo: GetDISyncInstanceInfoResponseBody.Data.SolutionInfo?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.solutionInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.solutionInfo != nil {
                map["SolutionInfo"] = self.solutionInfo?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["SolutionInfo"] as? [String: Any?] {
                var model = GetDISyncInstanceInfoResponseBody.Data.SolutionInfo()
                model.fromMap(value)
                self.solutionInfo = model
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: GetDISyncInstanceInfoResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDISyncInstanceInfoResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetDISyncInstanceInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDISyncInstanceInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDISyncInstanceInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDISyncTaskRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FileId"] as? Int64 {
            self.fileId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
    }
}

public class GetDISyncTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AlarmList : Tea.TeaModel {
            public class AlarmRuleList : Tea.TeaModel {
                public var aggregator: String?

                public var comparator: String?

                public var duration: Int64?

                public var level: String?

                public var threshold: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aggregator != nil {
                        map["Aggregator"] = self.aggregator!
                    }
                    if self.comparator != nil {
                        map["Comparator"] = self.comparator!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Aggregator"] as? String {
                        self.aggregator = value
                    }
                    if let value = dict["Comparator"] as? String {
                        self.comparator = value
                    }
                    if let value = dict["Duration"] as? Int64 {
                        self.duration = value
                    }
                    if let value = dict["Level"] as? String {
                        self.level = value
                    }
                    if let value = dict["Threshold"] as? Int64 {
                        self.threshold = value
                    }
                }
            }
            public class NotifyRule : Tea.TeaModel {
                public var critical: [String]?

                public var interval: Int64?

                public var warning: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.critical != nil {
                        map["Critical"] = self.critical!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.warning != nil {
                        map["Warning"] = self.warning!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Critical"] as? [String] {
                        self.critical = value
                    }
                    if let value = dict["Interval"] as? Int64 {
                        self.interval = value
                    }
                    if let value = dict["Warning"] as? [String] {
                        self.warning = value
                    }
                }
            }
            public var alarmRuleList: [GetDISyncTaskResponseBody.Data.AlarmList.AlarmRuleList]?

            public var description_: String?

            public var enabled: Bool?

            public var id: Int64?

            public var metric: String?

            public var notifyRule: GetDISyncTaskResponseBody.Data.AlarmList.NotifyRule?

            public var ruleName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.notifyRule?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alarmRuleList != nil {
                    var tmp : [Any] = []
                    for k in self.alarmRuleList! {
                        tmp.append(k.toMap())
                    }
                    map["AlarmRuleList"] = tmp
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.metric != nil {
                    map["Metric"] = self.metric!
                }
                if self.notifyRule != nil {
                    map["NotifyRule"] = self.notifyRule?.toMap()
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AlarmRuleList"] as? [Any?] {
                    var tmp : [GetDISyncTaskResponseBody.Data.AlarmList.AlarmRuleList] = []
                    for v in value {
                        if v != nil {
                            var model = GetDISyncTaskResponseBody.Data.AlarmList.AlarmRuleList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.alarmRuleList = tmp
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Enabled"] as? Bool {
                    self.enabled = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Metric"] as? String {
                    self.metric = value
                }
                if let value = dict["NotifyRule"] as? [String: Any?] {
                    var model = GetDISyncTaskResponseBody.Data.AlarmList.NotifyRule()
                    model.fromMap(value)
                    self.notifyRule = model
                }
                if let value = dict["RuleName"] as? String {
                    self.ruleName = value
                }
            }
        }
        public class SolutionDetail : Tea.TeaModel {
            public var creatorName: String?

            public var id: Int64?

            public var name: String?

            public var processContent: String?

            public var processExtra: String?

            public var projectId: Int64?

            public var sourceType: String?

            public var startTime: String?

            public var status: String?

            public var submitTime: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creatorName != nil {
                    map["CreatorName"] = self.creatorName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.processContent != nil {
                    map["ProcessContent"] = self.processContent!
                }
                if self.processExtra != nil {
                    map["ProcessExtra"] = self.processExtra!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreatorName"] as? String {
                    self.creatorName = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ProcessContent"] as? String {
                    self.processContent = value
                }
                if let value = dict["ProcessExtra"] as? String {
                    self.processExtra = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["SourceType"] as? String {
                    self.sourceType = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["SubmitTime"] as? String {
                    self.submitTime = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var alarmList: [GetDISyncTaskResponseBody.Data.AlarmList]?

        public var code: String?

        public var message: String?

        public var solutionDetail: GetDISyncTaskResponseBody.Data.SolutionDetail?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.solutionDetail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmList != nil {
                var tmp : [Any] = []
                for k in self.alarmList! {
                    tmp.append(k.toMap())
                }
                map["AlarmList"] = tmp
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.solutionDetail != nil {
                map["SolutionDetail"] = self.solutionDetail?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlarmList"] as? [Any?] {
                var tmp : [GetDISyncTaskResponseBody.Data.AlarmList] = []
                for v in value {
                    if v != nil {
                        var model = GetDISyncTaskResponseBody.Data.AlarmList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.alarmList = tmp
            }
            if let value = dict["Code"] as? String {
                self.code = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["SolutionDetail"] as? [String: Any?] {
                var model = GetDISyncTaskResponseBody.Data.SolutionDetail()
                model.fromMap(value)
                self.solutionDetail = model
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: GetDISyncTaskResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDISyncTaskResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetDISyncTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDISyncTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDISyncTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDagRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DagId"] as? Int64 {
            self.dagId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class GetDagResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var bizdate: Int64?

        public var createTime: Int64?

        public var createUser: String?

        public var dagId: Int64?

        public var finishTime: Int64?

        public var gmtdate: Int64?

        public var modifyTime: Int64?

        public var name: String?

        public var opSeq: Int64?

        public var projectId: Int64?

        public var startTime: Int64?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizdate != nil {
                map["Bizdate"] = self.bizdate!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.dagId != nil {
                map["DagId"] = self.dagId!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.gmtdate != nil {
                map["Gmtdate"] = self.gmtdate!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.opSeq != nil {
                map["OpSeq"] = self.opSeq!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Bizdate"] as? Int64 {
                self.bizdate = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CreateUser"] as? String {
                self.createUser = value
            }
            if let value = dict["DagId"] as? Int64 {
                self.dagId = value
            }
            if let value = dict["FinishTime"] as? Int64 {
                self.finishTime = value
            }
            if let value = dict["Gmtdate"] as? Int64 {
                self.gmtdate = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["OpSeq"] as? Int64 {
                self.opSeq = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["StartTime"] as? Int64 {
                self.startTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var data: GetDagResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDagResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetDagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDagResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDataServiceApiRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiId"] as? Int64 {
            self.apiId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class GetDataServiceApiResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RegistrationDetails : Tea.TeaModel {
            public class RegistrationErrorCodes : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var errorSolution: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.errorSolution != nil {
                        map["ErrorSolution"] = self.errorSolution!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ErrorCode"] as? String {
                        self.errorCode = value
                    }
                    if let value = dict["ErrorMessage"] as? String {
                        self.errorMessage = value
                    }
                    if let value = dict["ErrorSolution"] as? String {
                        self.errorSolution = value
                    }
                }
            }
            public class RegistrationRequestParameters : Tea.TeaModel {
                public var columnName: String?

                public var defaultValue: String?

                public var exampleValue: String?

                public var isRequiredParameter: Bool?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public var parameterOperator: Int32?

                public var parameterPosition: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columnName != nil {
                        map["ColumnName"] = self.columnName!
                    }
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.isRequiredParameter != nil {
                        map["IsRequiredParameter"] = self.isRequiredParameter!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.parameterOperator != nil {
                        map["ParameterOperator"] = self.parameterOperator!
                    }
                    if self.parameterPosition != nil {
                        map["ParameterPosition"] = self.parameterPosition!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ColumnName"] as? String {
                        self.columnName = value
                    }
                    if let value = dict["DefaultValue"] as? String {
                        self.defaultValue = value
                    }
                    if let value = dict["ExampleValue"] as? String {
                        self.exampleValue = value
                    }
                    if let value = dict["IsRequiredParameter"] as? Bool {
                        self.isRequiredParameter = value
                    }
                    if let value = dict["ParameterDataType"] as? Int32 {
                        self.parameterDataType = value
                    }
                    if let value = dict["ParameterDescription"] as? String {
                        self.parameterDescription = value
                    }
                    if let value = dict["ParameterName"] as? String {
                        self.parameterName = value
                    }
                    if let value = dict["ParameterOperator"] as? Int32 {
                        self.parameterOperator = value
                    }
                    if let value = dict["ParameterPosition"] as? Int32 {
                        self.parameterPosition = value
                    }
                }
            }
            public var failedResultSample: String?

            public var registrationErrorCodes: [GetDataServiceApiResponseBody.Data.RegistrationDetails.RegistrationErrorCodes]?

            public var registrationRequestParameters: [GetDataServiceApiResponseBody.Data.RegistrationDetails.RegistrationRequestParameters]?

            public var serviceContentType: Int32?

            public var serviceHost: String?

            public var servicePath: String?

            public var serviceRequestBodyDescription: String?

            public var successfulResultSample: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedResultSample != nil {
                    map["FailedResultSample"] = self.failedResultSample!
                }
                if self.registrationErrorCodes != nil {
                    var tmp : [Any] = []
                    for k in self.registrationErrorCodes! {
                        tmp.append(k.toMap())
                    }
                    map["RegistrationErrorCodes"] = tmp
                }
                if self.registrationRequestParameters != nil {
                    var tmp : [Any] = []
                    for k in self.registrationRequestParameters! {
                        tmp.append(k.toMap())
                    }
                    map["RegistrationRequestParameters"] = tmp
                }
                if self.serviceContentType != nil {
                    map["ServiceContentType"] = self.serviceContentType!
                }
                if self.serviceHost != nil {
                    map["ServiceHost"] = self.serviceHost!
                }
                if self.servicePath != nil {
                    map["ServicePath"] = self.servicePath!
                }
                if self.serviceRequestBodyDescription != nil {
                    map["ServiceRequestBodyDescription"] = self.serviceRequestBodyDescription!
                }
                if self.successfulResultSample != nil {
                    map["SuccessfulResultSample"] = self.successfulResultSample!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FailedResultSample"] as? String {
                    self.failedResultSample = value
                }
                if let value = dict["RegistrationErrorCodes"] as? [Any?] {
                    var tmp : [GetDataServiceApiResponseBody.Data.RegistrationDetails.RegistrationErrorCodes] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataServiceApiResponseBody.Data.RegistrationDetails.RegistrationErrorCodes()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.registrationErrorCodes = tmp
                }
                if let value = dict["RegistrationRequestParameters"] as? [Any?] {
                    var tmp : [GetDataServiceApiResponseBody.Data.RegistrationDetails.RegistrationRequestParameters] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataServiceApiResponseBody.Data.RegistrationDetails.RegistrationRequestParameters()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.registrationRequestParameters = tmp
                }
                if let value = dict["ServiceContentType"] as? Int32 {
                    self.serviceContentType = value
                }
                if let value = dict["ServiceHost"] as? String {
                    self.serviceHost = value
                }
                if let value = dict["ServicePath"] as? String {
                    self.servicePath = value
                }
                if let value = dict["ServiceRequestBodyDescription"] as? String {
                    self.serviceRequestBodyDescription = value
                }
                if let value = dict["SuccessfulResultSample"] as? String {
                    self.successfulResultSample = value
                }
            }
        }
        public class ScriptDetails : Tea.TeaModel {
            public class ScriptConnection : Tea.TeaModel {
                public var connectionId: Int64?

                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connectionId != nil {
                        map["ConnectionId"] = self.connectionId!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ConnectionId"] as? Int64 {
                        self.connectionId = value
                    }
                    if let value = dict["TableName"] as? String {
                        self.tableName = value
                    }
                }
            }
            public class ScriptRequestParameters : Tea.TeaModel {
                public var columnName: String?

                public var defaultValue: String?

                public var exampleValue: String?

                public var isRequiredParameter: Bool?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public var parameterOperator: Int32?

                public var parameterPosition: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columnName != nil {
                        map["ColumnName"] = self.columnName!
                    }
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.isRequiredParameter != nil {
                        map["IsRequiredParameter"] = self.isRequiredParameter!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.parameterOperator != nil {
                        map["ParameterOperator"] = self.parameterOperator!
                    }
                    if self.parameterPosition != nil {
                        map["ParameterPosition"] = self.parameterPosition!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ColumnName"] as? String {
                        self.columnName = value
                    }
                    if let value = dict["DefaultValue"] as? String {
                        self.defaultValue = value
                    }
                    if let value = dict["ExampleValue"] as? String {
                        self.exampleValue = value
                    }
                    if let value = dict["IsRequiredParameter"] as? Bool {
                        self.isRequiredParameter = value
                    }
                    if let value = dict["ParameterDataType"] as? Int32 {
                        self.parameterDataType = value
                    }
                    if let value = dict["ParameterDescription"] as? String {
                        self.parameterDescription = value
                    }
                    if let value = dict["ParameterName"] as? String {
                        self.parameterName = value
                    }
                    if let value = dict["ParameterOperator"] as? Int32 {
                        self.parameterOperator = value
                    }
                    if let value = dict["ParameterPosition"] as? Int32 {
                        self.parameterPosition = value
                    }
                }
            }
            public class ScriptResponseParameters : Tea.TeaModel {
                public var columnName: String?

                public var exampleValue: String?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columnName != nil {
                        map["ColumnName"] = self.columnName!
                    }
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ColumnName"] as? String {
                        self.columnName = value
                    }
                    if let value = dict["ExampleValue"] as? String {
                        self.exampleValue = value
                    }
                    if let value = dict["ParameterDataType"] as? Int32 {
                        self.parameterDataType = value
                    }
                    if let value = dict["ParameterDescription"] as? String {
                        self.parameterDescription = value
                    }
                    if let value = dict["ParameterName"] as? String {
                        self.parameterName = value
                    }
                }
            }
            public var isPagedResponse: Bool?

            public var script: String?

            public var scriptConnection: GetDataServiceApiResponseBody.Data.ScriptDetails.ScriptConnection?

            public var scriptRequestParameters: [GetDataServiceApiResponseBody.Data.ScriptDetails.ScriptRequestParameters]?

            public var scriptResponseParameters: [GetDataServiceApiResponseBody.Data.ScriptDetails.ScriptResponseParameters]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.scriptConnection?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isPagedResponse != nil {
                    map["IsPagedResponse"] = self.isPagedResponse!
                }
                if self.script != nil {
                    map["Script"] = self.script!
                }
                if self.scriptConnection != nil {
                    map["ScriptConnection"] = self.scriptConnection?.toMap()
                }
                if self.scriptRequestParameters != nil {
                    var tmp : [Any] = []
                    for k in self.scriptRequestParameters! {
                        tmp.append(k.toMap())
                    }
                    map["ScriptRequestParameters"] = tmp
                }
                if self.scriptResponseParameters != nil {
                    var tmp : [Any] = []
                    for k in self.scriptResponseParameters! {
                        tmp.append(k.toMap())
                    }
                    map["ScriptResponseParameters"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IsPagedResponse"] as? Bool {
                    self.isPagedResponse = value
                }
                if let value = dict["Script"] as? String {
                    self.script = value
                }
                if let value = dict["ScriptConnection"] as? [String: Any?] {
                    var model = GetDataServiceApiResponseBody.Data.ScriptDetails.ScriptConnection()
                    model.fromMap(value)
                    self.scriptConnection = model
                }
                if let value = dict["ScriptRequestParameters"] as? [Any?] {
                    var tmp : [GetDataServiceApiResponseBody.Data.ScriptDetails.ScriptRequestParameters] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataServiceApiResponseBody.Data.ScriptDetails.ScriptRequestParameters()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.scriptRequestParameters = tmp
                }
                if let value = dict["ScriptResponseParameters"] as? [Any?] {
                    var tmp : [GetDataServiceApiResponseBody.Data.ScriptDetails.ScriptResponseParameters] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataServiceApiResponseBody.Data.ScriptDetails.ScriptResponseParameters()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.scriptResponseParameters = tmp
                }
            }
        }
        public class WizardDetails : Tea.TeaModel {
            public class WizardConnection : Tea.TeaModel {
                public var connectionId: Int64?

                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connectionId != nil {
                        map["ConnectionId"] = self.connectionId!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ConnectionId"] as? Int64 {
                        self.connectionId = value
                    }
                    if let value = dict["TableName"] as? String {
                        self.tableName = value
                    }
                }
            }
            public class WizardRequestParameters : Tea.TeaModel {
                public var columnName: String?

                public var defaultValue: String?

                public var exampleValue: String?

                public var isRequiredParameter: Bool?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public var parameterOperator: Int32?

                public var parameterPosition: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columnName != nil {
                        map["ColumnName"] = self.columnName!
                    }
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.isRequiredParameter != nil {
                        map["IsRequiredParameter"] = self.isRequiredParameter!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.parameterOperator != nil {
                        map["ParameterOperator"] = self.parameterOperator!
                    }
                    if self.parameterPosition != nil {
                        map["ParameterPosition"] = self.parameterPosition!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ColumnName"] as? String {
                        self.columnName = value
                    }
                    if let value = dict["DefaultValue"] as? String {
                        self.defaultValue = value
                    }
                    if let value = dict["ExampleValue"] as? String {
                        self.exampleValue = value
                    }
                    if let value = dict["IsRequiredParameter"] as? Bool {
                        self.isRequiredParameter = value
                    }
                    if let value = dict["ParameterDataType"] as? Int32 {
                        self.parameterDataType = value
                    }
                    if let value = dict["ParameterDescription"] as? String {
                        self.parameterDescription = value
                    }
                    if let value = dict["ParameterName"] as? String {
                        self.parameterName = value
                    }
                    if let value = dict["ParameterOperator"] as? Int32 {
                        self.parameterOperator = value
                    }
                    if let value = dict["ParameterPosition"] as? Int32 {
                        self.parameterPosition = value
                    }
                }
            }
            public class WizardResponseParameters : Tea.TeaModel {
                public var columnName: String?

                public var exampleValue: String?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columnName != nil {
                        map["ColumnName"] = self.columnName!
                    }
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ColumnName"] as? String {
                        self.columnName = value
                    }
                    if let value = dict["ExampleValue"] as? String {
                        self.exampleValue = value
                    }
                    if let value = dict["ParameterDataType"] as? Int32 {
                        self.parameterDataType = value
                    }
                    if let value = dict["ParameterDescription"] as? String {
                        self.parameterDescription = value
                    }
                    if let value = dict["ParameterName"] as? String {
                        self.parameterName = value
                    }
                }
            }
            public var isPagedResponse: Bool?

            public var wizardConnection: GetDataServiceApiResponseBody.Data.WizardDetails.WizardConnection?

            public var wizardRequestParameters: [GetDataServiceApiResponseBody.Data.WizardDetails.WizardRequestParameters]?

            public var wizardResponseParameters: [GetDataServiceApiResponseBody.Data.WizardDetails.WizardResponseParameters]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.wizardConnection?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isPagedResponse != nil {
                    map["IsPagedResponse"] = self.isPagedResponse!
                }
                if self.wizardConnection != nil {
                    map["WizardConnection"] = self.wizardConnection?.toMap()
                }
                if self.wizardRequestParameters != nil {
                    var tmp : [Any] = []
                    for k in self.wizardRequestParameters! {
                        tmp.append(k.toMap())
                    }
                    map["WizardRequestParameters"] = tmp
                }
                if self.wizardResponseParameters != nil {
                    var tmp : [Any] = []
                    for k in self.wizardResponseParameters! {
                        tmp.append(k.toMap())
                    }
                    map["WizardResponseParameters"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IsPagedResponse"] as? Bool {
                    self.isPagedResponse = value
                }
                if let value = dict["WizardConnection"] as? [String: Any?] {
                    var model = GetDataServiceApiResponseBody.Data.WizardDetails.WizardConnection()
                    model.fromMap(value)
                    self.wizardConnection = model
                }
                if let value = dict["WizardRequestParameters"] as? [Any?] {
                    var tmp : [GetDataServiceApiResponseBody.Data.WizardDetails.WizardRequestParameters] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataServiceApiResponseBody.Data.WizardDetails.WizardRequestParameters()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.wizardRequestParameters = tmp
                }
                if let value = dict["WizardResponseParameters"] as? [Any?] {
                    var tmp : [GetDataServiceApiResponseBody.Data.WizardDetails.WizardResponseParameters] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataServiceApiResponseBody.Data.WizardDetails.WizardResponseParameters()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.wizardResponseParameters = tmp
                }
            }
        }
        public var apiId: Int64?

        public var apiMode: Int32?

        public var apiName: String?

        public var apiPath: String?

        public var createdTime: String?

        public var creatorId: String?

        public var description_: String?

        public var folderId: Int64?

        public var groupId: String?

        public var modifiedTime: String?

        public var operatorId: String?

        public var projectId: Int64?

        public var protocols: [Int32]?

        public var registrationDetails: GetDataServiceApiResponseBody.Data.RegistrationDetails?

        public var requestMethod: Int32?

        public var responseContentType: Int32?

        public var scriptDetails: GetDataServiceApiResponseBody.Data.ScriptDetails?

        public var status: Int32?

        public var tenantId: Int64?

        public var timeout: Int32?

        public var visibleRange: Int32?

        public var wizardDetails: GetDataServiceApiResponseBody.Data.WizardDetails?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.registrationDetails?.validate()
            try self.scriptDetails?.validate()
            try self.wizardDetails?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiId != nil {
                map["ApiId"] = self.apiId!
            }
            if self.apiMode != nil {
                map["ApiMode"] = self.apiMode!
            }
            if self.apiName != nil {
                map["ApiName"] = self.apiName!
            }
            if self.apiPath != nil {
                map["ApiPath"] = self.apiPath!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.folderId != nil {
                map["FolderId"] = self.folderId!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.operatorId != nil {
                map["OperatorId"] = self.operatorId!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.protocols != nil {
                map["Protocols"] = self.protocols!
            }
            if self.registrationDetails != nil {
                map["RegistrationDetails"] = self.registrationDetails?.toMap()
            }
            if self.requestMethod != nil {
                map["RequestMethod"] = self.requestMethod!
            }
            if self.responseContentType != nil {
                map["ResponseContentType"] = self.responseContentType!
            }
            if self.scriptDetails != nil {
                map["ScriptDetails"] = self.scriptDetails?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout!
            }
            if self.visibleRange != nil {
                map["VisibleRange"] = self.visibleRange!
            }
            if self.wizardDetails != nil {
                map["WizardDetails"] = self.wizardDetails?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApiId"] as? Int64 {
                self.apiId = value
            }
            if let value = dict["ApiMode"] as? Int32 {
                self.apiMode = value
            }
            if let value = dict["ApiName"] as? String {
                self.apiName = value
            }
            if let value = dict["ApiPath"] as? String {
                self.apiPath = value
            }
            if let value = dict["CreatedTime"] as? String {
                self.createdTime = value
            }
            if let value = dict["CreatorId"] as? String {
                self.creatorId = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["FolderId"] as? Int64 {
                self.folderId = value
            }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
            if let value = dict["ModifiedTime"] as? String {
                self.modifiedTime = value
            }
            if let value = dict["OperatorId"] as? String {
                self.operatorId = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["Protocols"] as? [Int32] {
                self.protocols = value
            }
            if let value = dict["RegistrationDetails"] as? [String: Any?] {
                var model = GetDataServiceApiResponseBody.Data.RegistrationDetails()
                model.fromMap(value)
                self.registrationDetails = model
            }
            if let value = dict["RequestMethod"] as? Int32 {
                self.requestMethod = value
            }
            if let value = dict["ResponseContentType"] as? Int32 {
                self.responseContentType = value
            }
            if let value = dict["ScriptDetails"] as? [String: Any?] {
                var model = GetDataServiceApiResponseBody.Data.ScriptDetails()
                model.fromMap(value)
                self.scriptDetails = model
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
            if let value = dict["TenantId"] as? Int64 {
                self.tenantId = value
            }
            if let value = dict["Timeout"] as? Int32 {
                self.timeout = value
            }
            if let value = dict["VisibleRange"] as? Int32 {
                self.visibleRange = value
            }
            if let value = dict["WizardDetails"] as? [String: Any?] {
                var model = GetDataServiceApiResponseBody.Data.WizardDetails()
                model.fromMap(value)
                self.wizardDetails = model
            }
        }
    }
    public var data: GetDataServiceApiResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDataServiceApiResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetDataServiceApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataServiceApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDataServiceApiResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDataServiceApiTestRequest : Tea.TeaModel {
    public var testId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.testId != nil {
            map["TestId"] = self.testId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TestId"] as? Int64 {
            self.testId = value
        }
    }
}

public class GetDataServiceApiTestResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var apiId: Int64?

        public var costTime: String?

        public var debugInfo: String?

        public var nodesDebugInfo: String?

        public var paramMap: String?

        public var retCode: Int64?

        public var retResult: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiId != nil {
                map["ApiId"] = self.apiId!
            }
            if self.costTime != nil {
                map["CostTime"] = self.costTime!
            }
            if self.debugInfo != nil {
                map["DebugInfo"] = self.debugInfo!
            }
            if self.nodesDebugInfo != nil {
                map["NodesDebugInfo"] = self.nodesDebugInfo!
            }
            if self.paramMap != nil {
                map["ParamMap"] = self.paramMap!
            }
            if self.retCode != nil {
                map["RetCode"] = self.retCode!
            }
            if self.retResult != nil {
                map["RetResult"] = self.retResult!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApiId"] as? Int64 {
                self.apiId = value
            }
            if let value = dict["CostTime"] as? String {
                self.costTime = value
            }
            if let value = dict["DebugInfo"] as? String {
                self.debugInfo = value
            }
            if let value = dict["NodesDebugInfo"] as? String {
                self.nodesDebugInfo = value
            }
            if let value = dict["ParamMap"] as? String {
                self.paramMap = value
            }
            if let value = dict["RetCode"] as? Int64 {
                self.retCode = value
            }
            if let value = dict["RetResult"] as? String {
                self.retResult = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: GetDataServiceApiTestResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDataServiceApiTestResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDataServiceApiTestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataServiceApiTestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDataServiceApiTestResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDataServiceApplicationRequest : Tea.TeaModel {
    public var applicationId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? Int64 {
            self.applicationId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class GetDataServiceApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var applicationCode: String?

        public var applicationId: Int64?

        public var applicationKey: String?

        public var applicationName: String?

        public var applicationSecret: String?

        public var projectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationCode != nil {
                map["ApplicationCode"] = self.applicationCode!
            }
            if self.applicationId != nil {
                map["ApplicationId"] = self.applicationId!
            }
            if self.applicationKey != nil {
                map["ApplicationKey"] = self.applicationKey!
            }
            if self.applicationName != nil {
                map["ApplicationName"] = self.applicationName!
            }
            if self.applicationSecret != nil {
                map["ApplicationSecret"] = self.applicationSecret!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApplicationCode"] as? String {
                self.applicationCode = value
            }
            if let value = dict["ApplicationId"] as? Int64 {
                self.applicationId = value
            }
            if let value = dict["ApplicationKey"] as? String {
                self.applicationKey = value
            }
            if let value = dict["ApplicationName"] as? String {
                self.applicationName = value
            }
            if let value = dict["ApplicationSecret"] as? String {
                self.applicationSecret = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
        }
    }
    public var data: GetDataServiceApplicationResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDataServiceApplicationResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetDataServiceApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataServiceApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDataServiceApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDataServiceFolderRequest : Tea.TeaModel {
    public var folderId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FolderId"] as? Int64 {
            self.folderId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class GetDataServiceFolderResponseBody : Tea.TeaModel {
    public class Folder : Tea.TeaModel {
        public var createdTime: String?

        public var folderId: Int64?

        public var folderName: String?

        public var groupId: String?

        public var modifiedTime: String?

        public var parentId: Int64?

        public var projectId: Int64?

        public var tenantId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.folderId != nil {
                map["FolderId"] = self.folderId!
            }
            if self.folderName != nil {
                map["FolderName"] = self.folderName!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreatedTime"] as? String {
                self.createdTime = value
            }
            if let value = dict["FolderId"] as? Int64 {
                self.folderId = value
            }
            if let value = dict["FolderName"] as? String {
                self.folderName = value
            }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
            if let value = dict["ModifiedTime"] as? String {
                self.modifiedTime = value
            }
            if let value = dict["ParentId"] as? Int64 {
                self.parentId = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["TenantId"] as? Int64 {
                self.tenantId = value
            }
        }
    }
    public var folder: GetDataServiceFolderResponseBody.Folder?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.folder?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folder != nil {
            map["Folder"] = self.folder?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Folder"] as? [String: Any?] {
            var model = GetDataServiceFolderResponseBody.Folder()
            model.fromMap(value)
            self.folder = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDataServiceFolderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataServiceFolderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDataServiceFolderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDataServiceGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class GetDataServiceGroupResponseBody : Tea.TeaModel {
    public class Group : Tea.TeaModel {
        public var apiGatewayGroupId: String?

        public var createdTime: String?

        public var creatorId: String?

        public var description_: String?

        public var groupId: String?

        public var groupName: String?

        public var modifiedTime: String?

        public var projectId: Int64?

        public var tenantId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiGatewayGroupId != nil {
                map["ApiGatewayGroupId"] = self.apiGatewayGroupId!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApiGatewayGroupId"] as? String {
                self.apiGatewayGroupId = value
            }
            if let value = dict["CreatedTime"] as? String {
                self.createdTime = value
            }
            if let value = dict["CreatorId"] as? String {
                self.creatorId = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
            if let value = dict["ModifiedTime"] as? String {
                self.modifiedTime = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["TenantId"] as? Int64 {
                self.tenantId = value
            }
        }
    }
    public var group: GetDataServiceGroupResponseBody.Group?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.group?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.group != nil {
            map["Group"] = self.group?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Group"] as? [String: Any?] {
            var model = GetDataServiceGroupResponseBody.Group()
            model.fromMap(value)
            self.group = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDataServiceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataServiceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDataServiceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDataServicePublishedApiRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiId"] as? Int64 {
            self.apiId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class GetDataServicePublishedApiResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RegistrationDetails : Tea.TeaModel {
            public class RegistrationErrorCodes : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var errorSolution: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.errorSolution != nil {
                        map["ErrorSolution"] = self.errorSolution!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ErrorCode"] as? String {
                        self.errorCode = value
                    }
                    if let value = dict["ErrorMessage"] as? String {
                        self.errorMessage = value
                    }
                    if let value = dict["ErrorSolution"] as? String {
                        self.errorSolution = value
                    }
                }
            }
            public class RegistrationRequestParameters : Tea.TeaModel {
                public var defaultValue: String?

                public var exampleValue: String?

                public var isRequiredParameter: Bool?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public var parameterOperator: Int32?

                public var parameterPosition: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.isRequiredParameter != nil {
                        map["IsRequiredParameter"] = self.isRequiredParameter!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.parameterOperator != nil {
                        map["ParameterOperator"] = self.parameterOperator!
                    }
                    if self.parameterPosition != nil {
                        map["ParameterPosition"] = self.parameterPosition!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DefaultValue"] as? String {
                        self.defaultValue = value
                    }
                    if let value = dict["ExampleValue"] as? String {
                        self.exampleValue = value
                    }
                    if let value = dict["IsRequiredParameter"] as? Bool {
                        self.isRequiredParameter = value
                    }
                    if let value = dict["ParameterDataType"] as? Int32 {
                        self.parameterDataType = value
                    }
                    if let value = dict["ParameterDescription"] as? String {
                        self.parameterDescription = value
                    }
                    if let value = dict["ParameterName"] as? String {
                        self.parameterName = value
                    }
                    if let value = dict["ParameterOperator"] as? Int32 {
                        self.parameterOperator = value
                    }
                    if let value = dict["ParameterPosition"] as? Int32 {
                        self.parameterPosition = value
                    }
                }
            }
            public var failedResultSample: String?

            public var registrationErrorCodes: [GetDataServicePublishedApiResponseBody.Data.RegistrationDetails.RegistrationErrorCodes]?

            public var registrationRequestParameters: [GetDataServicePublishedApiResponseBody.Data.RegistrationDetails.RegistrationRequestParameters]?

            public var serviceContentType: Int32?

            public var serviceHost: String?

            public var servicePath: String?

            public var serviceRequestBodyDescription: String?

            public var successfulResultSample: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedResultSample != nil {
                    map["FailedResultSample"] = self.failedResultSample!
                }
                if self.registrationErrorCodes != nil {
                    var tmp : [Any] = []
                    for k in self.registrationErrorCodes! {
                        tmp.append(k.toMap())
                    }
                    map["RegistrationErrorCodes"] = tmp
                }
                if self.registrationRequestParameters != nil {
                    var tmp : [Any] = []
                    for k in self.registrationRequestParameters! {
                        tmp.append(k.toMap())
                    }
                    map["RegistrationRequestParameters"] = tmp
                }
                if self.serviceContentType != nil {
                    map["ServiceContentType"] = self.serviceContentType!
                }
                if self.serviceHost != nil {
                    map["ServiceHost"] = self.serviceHost!
                }
                if self.servicePath != nil {
                    map["ServicePath"] = self.servicePath!
                }
                if self.serviceRequestBodyDescription != nil {
                    map["ServiceRequestBodyDescription"] = self.serviceRequestBodyDescription!
                }
                if self.successfulResultSample != nil {
                    map["SuccessfulResultSample"] = self.successfulResultSample!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FailedResultSample"] as? String {
                    self.failedResultSample = value
                }
                if let value = dict["RegistrationErrorCodes"] as? [Any?] {
                    var tmp : [GetDataServicePublishedApiResponseBody.Data.RegistrationDetails.RegistrationErrorCodes] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataServicePublishedApiResponseBody.Data.RegistrationDetails.RegistrationErrorCodes()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.registrationErrorCodes = tmp
                }
                if let value = dict["RegistrationRequestParameters"] as? [Any?] {
                    var tmp : [GetDataServicePublishedApiResponseBody.Data.RegistrationDetails.RegistrationRequestParameters] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataServicePublishedApiResponseBody.Data.RegistrationDetails.RegistrationRequestParameters()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.registrationRequestParameters = tmp
                }
                if let value = dict["ServiceContentType"] as? Int32 {
                    self.serviceContentType = value
                }
                if let value = dict["ServiceHost"] as? String {
                    self.serviceHost = value
                }
                if let value = dict["ServicePath"] as? String {
                    self.servicePath = value
                }
                if let value = dict["ServiceRequestBodyDescription"] as? String {
                    self.serviceRequestBodyDescription = value
                }
                if let value = dict["SuccessfulResultSample"] as? String {
                    self.successfulResultSample = value
                }
            }
        }
        public class ScriptDetails : Tea.TeaModel {
            public class ScriptConnection : Tea.TeaModel {
                public var connectionId: Int64?

                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connectionId != nil {
                        map["ConnectionId"] = self.connectionId!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ConnectionId"] as? Int64 {
                        self.connectionId = value
                    }
                    if let value = dict["TableName"] as? String {
                        self.tableName = value
                    }
                }
            }
            public class ScriptErrorCodes : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var errorSolution: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.errorSolution != nil {
                        map["ErrorSolution"] = self.errorSolution!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ErrorCode"] as? String {
                        self.errorCode = value
                    }
                    if let value = dict["ErrorMessage"] as? String {
                        self.errorMessage = value
                    }
                    if let value = dict["ErrorSolution"] as? String {
                        self.errorSolution = value
                    }
                }
            }
            public class ScriptRequestParameters : Tea.TeaModel {
                public var defaultValue: String?

                public var exampleValue: String?

                public var isRequiredParameter: Bool?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public var parameterOperator: Int32?

                public var parameterPosition: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.isRequiredParameter != nil {
                        map["IsRequiredParameter"] = self.isRequiredParameter!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.parameterOperator != nil {
                        map["ParameterOperator"] = self.parameterOperator!
                    }
                    if self.parameterPosition != nil {
                        map["ParameterPosition"] = self.parameterPosition!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DefaultValue"] as? String {
                        self.defaultValue = value
                    }
                    if let value = dict["ExampleValue"] as? String {
                        self.exampleValue = value
                    }
                    if let value = dict["IsRequiredParameter"] as? Bool {
                        self.isRequiredParameter = value
                    }
                    if let value = dict["ParameterDataType"] as? Int32 {
                        self.parameterDataType = value
                    }
                    if let value = dict["ParameterDescription"] as? String {
                        self.parameterDescription = value
                    }
                    if let value = dict["ParameterName"] as? String {
                        self.parameterName = value
                    }
                    if let value = dict["ParameterOperator"] as? Int32 {
                        self.parameterOperator = value
                    }
                    if let value = dict["ParameterPosition"] as? Int32 {
                        self.parameterPosition = value
                    }
                }
            }
            public class ScriptResponseParameters : Tea.TeaModel {
                public var exampleValue: String?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ExampleValue"] as? String {
                        self.exampleValue = value
                    }
                    if let value = dict["ParameterDataType"] as? Int32 {
                        self.parameterDataType = value
                    }
                    if let value = dict["ParameterDescription"] as? String {
                        self.parameterDescription = value
                    }
                    if let value = dict["ParameterName"] as? String {
                        self.parameterName = value
                    }
                }
            }
            public var failedResultSample: String?

            public var isPagedResponse: Bool?

            public var script: String?

            public var scriptConnection: GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptConnection?

            public var scriptErrorCodes: [GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptErrorCodes]?

            public var scriptRequestParameters: [GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptRequestParameters]?

            public var scriptResponseParameters: [GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptResponseParameters]?

            public var successfulResultSample: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.scriptConnection?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedResultSample != nil {
                    map["FailedResultSample"] = self.failedResultSample!
                }
                if self.isPagedResponse != nil {
                    map["IsPagedResponse"] = self.isPagedResponse!
                }
                if self.script != nil {
                    map["Script"] = self.script!
                }
                if self.scriptConnection != nil {
                    map["ScriptConnection"] = self.scriptConnection?.toMap()
                }
                if self.scriptErrorCodes != nil {
                    var tmp : [Any] = []
                    for k in self.scriptErrorCodes! {
                        tmp.append(k.toMap())
                    }
                    map["ScriptErrorCodes"] = tmp
                }
                if self.scriptRequestParameters != nil {
                    var tmp : [Any] = []
                    for k in self.scriptRequestParameters! {
                        tmp.append(k.toMap())
                    }
                    map["ScriptRequestParameters"] = tmp
                }
                if self.scriptResponseParameters != nil {
                    var tmp : [Any] = []
                    for k in self.scriptResponseParameters! {
                        tmp.append(k.toMap())
                    }
                    map["ScriptResponseParameters"] = tmp
                }
                if self.successfulResultSample != nil {
                    map["SuccessfulResultSample"] = self.successfulResultSample!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FailedResultSample"] as? String {
                    self.failedResultSample = value
                }
                if let value = dict["IsPagedResponse"] as? Bool {
                    self.isPagedResponse = value
                }
                if let value = dict["Script"] as? String {
                    self.script = value
                }
                if let value = dict["ScriptConnection"] as? [String: Any?] {
                    var model = GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptConnection()
                    model.fromMap(value)
                    self.scriptConnection = model
                }
                if let value = dict["ScriptErrorCodes"] as? [Any?] {
                    var tmp : [GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptErrorCodes] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptErrorCodes()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.scriptErrorCodes = tmp
                }
                if let value = dict["ScriptRequestParameters"] as? [Any?] {
                    var tmp : [GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptRequestParameters] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptRequestParameters()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.scriptRequestParameters = tmp
                }
                if let value = dict["ScriptResponseParameters"] as? [Any?] {
                    var tmp : [GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptResponseParameters] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataServicePublishedApiResponseBody.Data.ScriptDetails.ScriptResponseParameters()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.scriptResponseParameters = tmp
                }
                if let value = dict["SuccessfulResultSample"] as? String {
                    self.successfulResultSample = value
                }
            }
        }
        public class WizardDetails : Tea.TeaModel {
            public class WizardConnection : Tea.TeaModel {
                public var connectionId: Int64?

                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connectionId != nil {
                        map["ConnectionId"] = self.connectionId!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ConnectionId"] as? Int64 {
                        self.connectionId = value
                    }
                    if let value = dict["TableName"] as? String {
                        self.tableName = value
                    }
                }
            }
            public class WizardErrorCodes : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var errorSolution: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.errorSolution != nil {
                        map["ErrorSolution"] = self.errorSolution!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ErrorCode"] as? String {
                        self.errorCode = value
                    }
                    if let value = dict["ErrorMessage"] as? String {
                        self.errorMessage = value
                    }
                    if let value = dict["ErrorSolution"] as? String {
                        self.errorSolution = value
                    }
                }
            }
            public class WizardRequestParameters : Tea.TeaModel {
                public var defaultValue: String?

                public var exampleValue: String?

                public var isRequiredParameter: Bool?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public var parameterOperator: Int32?

                public var parameterPosition: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.isRequiredParameter != nil {
                        map["IsRequiredParameter"] = self.isRequiredParameter!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.parameterOperator != nil {
                        map["ParameterOperator"] = self.parameterOperator!
                    }
                    if self.parameterPosition != nil {
                        map["ParameterPosition"] = self.parameterPosition!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DefaultValue"] as? String {
                        self.defaultValue = value
                    }
                    if let value = dict["ExampleValue"] as? String {
                        self.exampleValue = value
                    }
                    if let value = dict["IsRequiredParameter"] as? Bool {
                        self.isRequiredParameter = value
                    }
                    if let value = dict["ParameterDataType"] as? Int32 {
                        self.parameterDataType = value
                    }
                    if let value = dict["ParameterDescription"] as? String {
                        self.parameterDescription = value
                    }
                    if let value = dict["ParameterName"] as? String {
                        self.parameterName = value
                    }
                    if let value = dict["ParameterOperator"] as? Int32 {
                        self.parameterOperator = value
                    }
                    if let value = dict["ParameterPosition"] as? Int32 {
                        self.parameterPosition = value
                    }
                }
            }
            public class WizardResponseParameters : Tea.TeaModel {
                public var exampleValue: String?

                public var parameterDataType: Int32?

                public var parameterDescription: String?

                public var parameterName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.exampleValue != nil {
                        map["ExampleValue"] = self.exampleValue!
                    }
                    if self.parameterDataType != nil {
                        map["ParameterDataType"] = self.parameterDataType!
                    }
                    if self.parameterDescription != nil {
                        map["ParameterDescription"] = self.parameterDescription!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ExampleValue"] as? String {
                        self.exampleValue = value
                    }
                    if let value = dict["ParameterDataType"] as? Int32 {
                        self.parameterDataType = value
                    }
                    if let value = dict["ParameterDescription"] as? String {
                        self.parameterDescription = value
                    }
                    if let value = dict["ParameterName"] as? String {
                        self.parameterName = value
                    }
                }
            }
            public var failedResultSample: String?

            public var isPagedResponse: Bool?

            public var successfulResultSample: String?

            public var wizardConnection: GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardConnection?

            public var wizardErrorCodes: [GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardErrorCodes]?

            public var wizardRequestParameters: [GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardRequestParameters]?

            public var wizardResponseParameters: [GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardResponseParameters]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.wizardConnection?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedResultSample != nil {
                    map["FailedResultSample"] = self.failedResultSample!
                }
                if self.isPagedResponse != nil {
                    map["IsPagedResponse"] = self.isPagedResponse!
                }
                if self.successfulResultSample != nil {
                    map["SuccessfulResultSample"] = self.successfulResultSample!
                }
                if self.wizardConnection != nil {
                    map["WizardConnection"] = self.wizardConnection?.toMap()
                }
                if self.wizardErrorCodes != nil {
                    var tmp : [Any] = []
                    for k in self.wizardErrorCodes! {
                        tmp.append(k.toMap())
                    }
                    map["WizardErrorCodes"] = tmp
                }
                if self.wizardRequestParameters != nil {
                    var tmp : [Any] = []
                    for k in self.wizardRequestParameters! {
                        tmp.append(k.toMap())
                    }
                    map["WizardRequestParameters"] = tmp
                }
                if self.wizardResponseParameters != nil {
                    var tmp : [Any] = []
                    for k in self.wizardResponseParameters! {
                        tmp.append(k.toMap())
                    }
                    map["WizardResponseParameters"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FailedResultSample"] as? String {
                    self.failedResultSample = value
                }
                if let value = dict["IsPagedResponse"] as? Bool {
                    self.isPagedResponse = value
                }
                if let value = dict["SuccessfulResultSample"] as? String {
                    self.successfulResultSample = value
                }
                if let value = dict["WizardConnection"] as? [String: Any?] {
                    var model = GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardConnection()
                    model.fromMap(value)
                    self.wizardConnection = model
                }
                if let value = dict["WizardErrorCodes"] as? [Any?] {
                    var tmp : [GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardErrorCodes] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardErrorCodes()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.wizardErrorCodes = tmp
                }
                if let value = dict["WizardRequestParameters"] as? [Any?] {
                    var tmp : [GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardRequestParameters] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardRequestParameters()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.wizardRequestParameters = tmp
                }
                if let value = dict["WizardResponseParameters"] as? [Any?] {
                    var tmp : [GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardResponseParameters] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataServicePublishedApiResponseBody.Data.WizardDetails.WizardResponseParameters()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.wizardResponseParameters = tmp
                }
            }
        }
        public var apiId: Int64?

        public var apiMode: Int32?

        public var apiName: String?

        public var apiPath: String?

        public var createdTime: String?

        public var creatorId: String?

        public var description_: String?

        public var groupId: String?

        public var modifiedTime: String?

        public var operatorId: String?

        public var projectId: Int64?

        public var protocols: [Int32]?

        public var registrationDetails: GetDataServicePublishedApiResponseBody.Data.RegistrationDetails?

        public var requestMethod: Int32?

        public var responseContentType: Int32?

        public var scriptDetails: GetDataServicePublishedApiResponseBody.Data.ScriptDetails?

        public var sqlMode: Int32?

        public var status: Int32?

        public var tenantId: Int64?

        public var timeout: Int32?

        public var visibleRange: Int32?

        public var wizardDetails: GetDataServicePublishedApiResponseBody.Data.WizardDetails?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.registrationDetails?.validate()
            try self.scriptDetails?.validate()
            try self.wizardDetails?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiId != nil {
                map["ApiId"] = self.apiId!
            }
            if self.apiMode != nil {
                map["ApiMode"] = self.apiMode!
            }
            if self.apiName != nil {
                map["ApiName"] = self.apiName!
            }
            if self.apiPath != nil {
                map["ApiPath"] = self.apiPath!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.operatorId != nil {
                map["OperatorId"] = self.operatorId!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.protocols != nil {
                map["Protocols"] = self.protocols!
            }
            if self.registrationDetails != nil {
                map["RegistrationDetails"] = self.registrationDetails?.toMap()
            }
            if self.requestMethod != nil {
                map["RequestMethod"] = self.requestMethod!
            }
            if self.responseContentType != nil {
                map["ResponseContentType"] = self.responseContentType!
            }
            if self.scriptDetails != nil {
                map["ScriptDetails"] = self.scriptDetails?.toMap()
            }
            if self.sqlMode != nil {
                map["SqlMode"] = self.sqlMode!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout!
            }
            if self.visibleRange != nil {
                map["VisibleRange"] = self.visibleRange!
            }
            if self.wizardDetails != nil {
                map["WizardDetails"] = self.wizardDetails?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApiId"] as? Int64 {
                self.apiId = value
            }
            if let value = dict["ApiMode"] as? Int32 {
                self.apiMode = value
            }
            if let value = dict["ApiName"] as? String {
                self.apiName = value
            }
            if let value = dict["ApiPath"] as? String {
                self.apiPath = value
            }
            if let value = dict["CreatedTime"] as? String {
                self.createdTime = value
            }
            if let value = dict["CreatorId"] as? String {
                self.creatorId = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
            if let value = dict["ModifiedTime"] as? String {
                self.modifiedTime = value
            }
            if let value = dict["OperatorId"] as? String {
                self.operatorId = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["Protocols"] as? [Int32] {
                self.protocols = value
            }
            if let value = dict["RegistrationDetails"] as? [String: Any?] {
                var model = GetDataServicePublishedApiResponseBody.Data.RegistrationDetails()
                model.fromMap(value)
                self.registrationDetails = model
            }
            if let value = dict["RequestMethod"] as? Int32 {
                self.requestMethod = value
            }
            if let value = dict["ResponseContentType"] as? Int32 {
                self.responseContentType = value
            }
            if let value = dict["ScriptDetails"] as? [String: Any?] {
                var model = GetDataServicePublishedApiResponseBody.Data.ScriptDetails()
                model.fromMap(value)
                self.scriptDetails = model
            }
            if let value = dict["SqlMode"] as? Int32 {
                self.sqlMode = value
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
            if let value = dict["TenantId"] as? Int64 {
                self.tenantId = value
            }
            if let value = dict["Timeout"] as? Int32 {
                self.timeout = value
            }
            if let value = dict["VisibleRange"] as? Int32 {
                self.visibleRange = value
            }
            if let value = dict["WizardDetails"] as? [String: Any?] {
                var model = GetDataServicePublishedApiResponseBody.Data.WizardDetails()
                model.fromMap(value)
                self.wizardDetails = model
            }
        }
    }
    public var data: GetDataServicePublishedApiResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDataServicePublishedApiResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetDataServicePublishedApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataServicePublishedApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDataServicePublishedApiResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDataSourceMetaRequest : Tea.TeaModel {
    public var datasourceName: String?

    public var envType: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasourceName != nil {
            map["DatasourceName"] = self.datasourceName!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DatasourceName"] as? String {
            self.datasourceName = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetDataSourceMetaResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var meta: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.meta != nil {
                map["Meta"] = self.meta!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Meta"] as? String {
                self.meta = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: GetDataSourceMetaResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDataSourceMetaResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetDataSourceMetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataSourceMetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDataSourceMetaResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDeploymentRequest : Tea.TeaModel {
    public var deploymentId: Int64?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentId != nil {
            map["DeploymentId"] = self.deploymentId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeploymentId"] as? Int64 {
            self.deploymentId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class GetDeploymentResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DeployedItems : Tea.TeaModel {
            public var fileId: Int64?

            public var fileVersion: Int64?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.fileVersion != nil {
                    map["FileVersion"] = self.fileVersion!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FileId"] as? Int64 {
                    self.fileId = value
                }
                if let value = dict["FileVersion"] as? Int64 {
                    self.fileVersion = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
            }
        }
        public class Deployment : Tea.TeaModel {
            public var checkingStatus: Int32?

            public var createTime: Int64?

            public var creatorId: String?

            public var errorMessage: String?

            public var executeTime: Int64?

            public var fromEnvironment: Int32?

            public var handlerId: String?

            public var name: String?

            public var status: Int32?

            public var toEnvironment: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkingStatus != nil {
                    map["CheckingStatus"] = self.checkingStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.executeTime != nil {
                    map["ExecuteTime"] = self.executeTime!
                }
                if self.fromEnvironment != nil {
                    map["FromEnvironment"] = self.fromEnvironment!
                }
                if self.handlerId != nil {
                    map["HandlerId"] = self.handlerId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.toEnvironment != nil {
                    map["ToEnvironment"] = self.toEnvironment!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CheckingStatus"] as? Int32 {
                    self.checkingStatus = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreatorId"] as? String {
                    self.creatorId = value
                }
                if let value = dict["ErrorMessage"] as? String {
                    self.errorMessage = value
                }
                if let value = dict["ExecuteTime"] as? Int64 {
                    self.executeTime = value
                }
                if let value = dict["FromEnvironment"] as? Int32 {
                    self.fromEnvironment = value
                }
                if let value = dict["HandlerId"] as? String {
                    self.handlerId = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
                if let value = dict["ToEnvironment"] as? Int32 {
                    self.toEnvironment = value
                }
            }
        }
        public var deployedItems: [GetDeploymentResponseBody.Data.DeployedItems]?

        public var deployment: GetDeploymentResponseBody.Data.Deployment?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.deployment?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deployedItems != nil {
                var tmp : [Any] = []
                for k in self.deployedItems! {
                    tmp.append(k.toMap())
                }
                map["DeployedItems"] = tmp
            }
            if self.deployment != nil {
                map["Deployment"] = self.deployment?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DeployedItems"] as? [Any?] {
                var tmp : [GetDeploymentResponseBody.Data.DeployedItems] = []
                for v in value {
                    if v != nil {
                        var model = GetDeploymentResponseBody.Data.DeployedItems()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.deployedItems = tmp
            }
            if let value = dict["Deployment"] as? [String: Any?] {
                var model = GetDeploymentResponseBody.Data.Deployment()
                model.fromMap(value)
                self.deployment = model
            }
        }
    }
    public var data: GetDeploymentResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDeploymentResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetDeploymentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeploymentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDeploymentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetExtensionRequest : Tea.TeaModel {
    public var extensionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extensionCode != nil {
            map["ExtensionCode"] = self.extensionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ExtensionCode"] as? String {
            self.extensionCode = value
        }
    }
}

public class GetExtensionResponseBody : Tea.TeaModel {
    public class Extension_ : Tea.TeaModel {
        public class BindEventList : Tea.TeaModel {
            public var eventCode: String?

            public var eventName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventCode != nil {
                    map["EventCode"] = self.eventCode!
                }
                if self.eventName != nil {
                    map["EventName"] = self.eventName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EventCode"] as? String {
                    self.eventCode = value
                }
                if let value = dict["EventName"] as? String {
                    self.eventName = value
                }
            }
        }
        public class EventCategoryList : Tea.TeaModel {
            public var categoryCode: String?

            public var categoryName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.categoryCode != nil {
                    map["CategoryCode"] = self.categoryCode!
                }
                if self.categoryName != nil {
                    map["CategoryName"] = self.categoryName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CategoryCode"] as? String {
                    self.categoryCode = value
                }
                if let value = dict["CategoryName"] as? String {
                    self.categoryName = value
                }
            }
        }
        public var bindEventList: [GetExtensionResponseBody.Extension_.BindEventList]?

        public var detailUrl: String?

        public var eventCategoryList: [GetExtensionResponseBody.Extension_.EventCategoryList]?

        public var extensionCode: String?

        public var extensionDesc: String?

        public var extensionName: String?

        public var helpDocUrl: String?

        public var optionSetting: String?

        public var parameterSetting: String?

        public var projectTesting: Int64?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bindEventList != nil {
                var tmp : [Any] = []
                for k in self.bindEventList! {
                    tmp.append(k.toMap())
                }
                map["BindEventList"] = tmp
            }
            if self.detailUrl != nil {
                map["DetailUrl"] = self.detailUrl!
            }
            if self.eventCategoryList != nil {
                var tmp : [Any] = []
                for k in self.eventCategoryList! {
                    tmp.append(k.toMap())
                }
                map["EventCategoryList"] = tmp
            }
            if self.extensionCode != nil {
                map["ExtensionCode"] = self.extensionCode!
            }
            if self.extensionDesc != nil {
                map["ExtensionDesc"] = self.extensionDesc!
            }
            if self.extensionName != nil {
                map["ExtensionName"] = self.extensionName!
            }
            if self.helpDocUrl != nil {
                map["HelpDocUrl"] = self.helpDocUrl!
            }
            if self.optionSetting != nil {
                map["OptionSetting"] = self.optionSetting!
            }
            if self.parameterSetting != nil {
                map["ParameterSetting"] = self.parameterSetting!
            }
            if self.projectTesting != nil {
                map["ProjectTesting"] = self.projectTesting!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BindEventList"] as? [Any?] {
                var tmp : [GetExtensionResponseBody.Extension_.BindEventList] = []
                for v in value {
                    if v != nil {
                        var model = GetExtensionResponseBody.Extension_.BindEventList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.bindEventList = tmp
            }
            if let value = dict["DetailUrl"] as? String {
                self.detailUrl = value
            }
            if let value = dict["EventCategoryList"] as? [Any?] {
                var tmp : [GetExtensionResponseBody.Extension_.EventCategoryList] = []
                for v in value {
                    if v != nil {
                        var model = GetExtensionResponseBody.Extension_.EventCategoryList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.eventCategoryList = tmp
            }
            if let value = dict["ExtensionCode"] as? String {
                self.extensionCode = value
            }
            if let value = dict["ExtensionDesc"] as? String {
                self.extensionDesc = value
            }
            if let value = dict["ExtensionName"] as? String {
                self.extensionName = value
            }
            if let value = dict["HelpDocUrl"] as? String {
                self.helpDocUrl = value
            }
            if let value = dict["OptionSetting"] as? String {
                self.optionSetting = value
            }
            if let value = dict["ParameterSetting"] as? String {
                self.parameterSetting = value
            }
            if let value = dict["ProjectTesting"] as? Int64 {
                self.projectTesting = value
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
        }
    }
    public var extension_: GetExtensionResponseBody.Extension_?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.extension_?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extension_ != nil {
            map["Extension"] = self.extension_?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Extension"] as? [String: Any?] {
            var model = GetExtensionResponseBody.Extension_()
            model.fromMap(value)
            self.extension_ = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetExtensionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetExtensionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetExtensionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetFileRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var nodeId: Int64?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FileId"] as? Int64 {
            self.fileId = value
        }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class GetFileResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class File : Tea.TeaModel {
            public var advancedSettings: String?

            public var autoParsing: Bool?

            public var bizId: Int64?

            public var businessId: Int64?

            public var commitStatus: Int32?

            public var connectionName: String?

            public var content: String?

            public var createTime: Int64?

            public var createUser: String?

            public var currentVersion: Int32?

            public var deletedStatus: String?

            public var fileDescription: String?

            public var fileFolderId: String?

            public var fileId: Int64?

            public var fileName: String?

            public var fileType: Int32?

            public var isMaxCompute: Bool?

            public var lastEditTime: Int64?

            public var lastEditUser: String?

            public var nodeId: Int64?

            public var owner: String?

            public var parentId: Int64?

            public var useType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.advancedSettings != nil {
                    map["AdvancedSettings"] = self.advancedSettings!
                }
                if self.autoParsing != nil {
                    map["AutoParsing"] = self.autoParsing!
                }
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.businessId != nil {
                    map["BusinessId"] = self.businessId!
                }
                if self.commitStatus != nil {
                    map["CommitStatus"] = self.commitStatus!
                }
                if self.connectionName != nil {
                    map["ConnectionName"] = self.connectionName!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.currentVersion != nil {
                    map["CurrentVersion"] = self.currentVersion!
                }
                if self.deletedStatus != nil {
                    map["DeletedStatus"] = self.deletedStatus!
                }
                if self.fileDescription != nil {
                    map["FileDescription"] = self.fileDescription!
                }
                if self.fileFolderId != nil {
                    map["FileFolderId"] = self.fileFolderId!
                }
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.fileType != nil {
                    map["FileType"] = self.fileType!
                }
                if self.isMaxCompute != nil {
                    map["IsMaxCompute"] = self.isMaxCompute!
                }
                if self.lastEditTime != nil {
                    map["LastEditTime"] = self.lastEditTime!
                }
                if self.lastEditUser != nil {
                    map["LastEditUser"] = self.lastEditUser!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.useType != nil {
                    map["UseType"] = self.useType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AdvancedSettings"] as? String {
                    self.advancedSettings = value
                }
                if let value = dict["AutoParsing"] as? Bool {
                    self.autoParsing = value
                }
                if let value = dict["BizId"] as? Int64 {
                    self.bizId = value
                }
                if let value = dict["BusinessId"] as? Int64 {
                    self.businessId = value
                }
                if let value = dict["CommitStatus"] as? Int32 {
                    self.commitStatus = value
                }
                if let value = dict["ConnectionName"] as? String {
                    self.connectionName = value
                }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["CurrentVersion"] as? Int32 {
                    self.currentVersion = value
                }
                if let value = dict["DeletedStatus"] as? String {
                    self.deletedStatus = value
                }
                if let value = dict["FileDescription"] as? String {
                    self.fileDescription = value
                }
                if let value = dict["FileFolderId"] as? String {
                    self.fileFolderId = value
                }
                if let value = dict["FileId"] as? Int64 {
                    self.fileId = value
                }
                if let value = dict["FileName"] as? String {
                    self.fileName = value
                }
                if let value = dict["FileType"] as? Int32 {
                    self.fileType = value
                }
                if let value = dict["IsMaxCompute"] as? Bool {
                    self.isMaxCompute = value
                }
                if let value = dict["LastEditTime"] as? Int64 {
                    self.lastEditTime = value
                }
                if let value = dict["LastEditUser"] as? String {
                    self.lastEditUser = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["ParentId"] as? Int64 {
                    self.parentId = value
                }
                if let value = dict["UseType"] as? String {
                    self.useType = value
                }
            }
        }
        public class NodeConfiguration : Tea.TeaModel {
            public class InputList : Tea.TeaModel {
                public var input: String?

                public var parseType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.input != nil {
                        map["Input"] = self.input!
                    }
                    if self.parseType != nil {
                        map["ParseType"] = self.parseType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Input"] as? String {
                        self.input = value
                    }
                    if let value = dict["ParseType"] as? String {
                        self.parseType = value
                    }
                }
            }
            public class InputParameters : Tea.TeaModel {
                public var parameterName: String?

                public var valueSource: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.valueSource != nil {
                        map["ValueSource"] = self.valueSource!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ParameterName"] as? String {
                        self.parameterName = value
                    }
                    if let value = dict["ValueSource"] as? String {
                        self.valueSource = value
                    }
                }
            }
            public class OutputList : Tea.TeaModel {
                public var output: String?

                public var refTableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.output != nil {
                        map["Output"] = self.output!
                    }
                    if self.refTableName != nil {
                        map["RefTableName"] = self.refTableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Output"] as? String {
                        self.output = value
                    }
                    if let value = dict["RefTableName"] as? String {
                        self.refTableName = value
                    }
                }
            }
            public class OutputParameters : Tea.TeaModel {
                public var description_: String?

                public var parameterName: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["ParameterName"] as? String {
                        self.parameterName = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var applyScheduleImmediately: String?

            public var autoRerunIntervalMillis: Int32?

            public var autoRerunTimes: Int32?

            public var cronExpress: String?

            public var cycleType: String?

            public var dependentNodeIdList: String?

            public var dependentType: String?

            public var endEffectDate: Int64?

            public var ignoreParentSkipRunningProperty: String?

            public var imageId: String?

            public var inputList: [GetFileResponseBody.Data.NodeConfiguration.InputList]?

            public var inputParameters: [GetFileResponseBody.Data.NodeConfiguration.InputParameters]?

            public var outputList: [GetFileResponseBody.Data.NodeConfiguration.OutputList]?

            public var outputParameters: [GetFileResponseBody.Data.NodeConfiguration.OutputParameters]?

            public var paraValue: String?

            public var rerunMode: String?

            public var resourceGroupId: Int64?

            public var schedulerType: String?

            public var startEffectDate: Int64?

            public var startImmediately: Bool?

            public var stop: Bool?

            public var timeout: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applyScheduleImmediately != nil {
                    map["ApplyScheduleImmediately"] = self.applyScheduleImmediately!
                }
                if self.autoRerunIntervalMillis != nil {
                    map["AutoRerunIntervalMillis"] = self.autoRerunIntervalMillis!
                }
                if self.autoRerunTimes != nil {
                    map["AutoRerunTimes"] = self.autoRerunTimes!
                }
                if self.cronExpress != nil {
                    map["CronExpress"] = self.cronExpress!
                }
                if self.cycleType != nil {
                    map["CycleType"] = self.cycleType!
                }
                if self.dependentNodeIdList != nil {
                    map["DependentNodeIdList"] = self.dependentNodeIdList!
                }
                if self.dependentType != nil {
                    map["DependentType"] = self.dependentType!
                }
                if self.endEffectDate != nil {
                    map["EndEffectDate"] = self.endEffectDate!
                }
                if self.ignoreParentSkipRunningProperty != nil {
                    map["IgnoreParentSkipRunningProperty"] = self.ignoreParentSkipRunningProperty!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.inputList != nil {
                    var tmp : [Any] = []
                    for k in self.inputList! {
                        tmp.append(k.toMap())
                    }
                    map["InputList"] = tmp
                }
                if self.inputParameters != nil {
                    var tmp : [Any] = []
                    for k in self.inputParameters! {
                        tmp.append(k.toMap())
                    }
                    map["InputParameters"] = tmp
                }
                if self.outputList != nil {
                    var tmp : [Any] = []
                    for k in self.outputList! {
                        tmp.append(k.toMap())
                    }
                    map["OutputList"] = tmp
                }
                if self.outputParameters != nil {
                    var tmp : [Any] = []
                    for k in self.outputParameters! {
                        tmp.append(k.toMap())
                    }
                    map["OutputParameters"] = tmp
                }
                if self.paraValue != nil {
                    map["ParaValue"] = self.paraValue!
                }
                if self.rerunMode != nil {
                    map["RerunMode"] = self.rerunMode!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.schedulerType != nil {
                    map["SchedulerType"] = self.schedulerType!
                }
                if self.startEffectDate != nil {
                    map["StartEffectDate"] = self.startEffectDate!
                }
                if self.startImmediately != nil {
                    map["StartImmediately"] = self.startImmediately!
                }
                if self.stop != nil {
                    map["Stop"] = self.stop!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ApplyScheduleImmediately"] as? String {
                    self.applyScheduleImmediately = value
                }
                if let value = dict["AutoRerunIntervalMillis"] as? Int32 {
                    self.autoRerunIntervalMillis = value
                }
                if let value = dict["AutoRerunTimes"] as? Int32 {
                    self.autoRerunTimes = value
                }
                if let value = dict["CronExpress"] as? String {
                    self.cronExpress = value
                }
                if let value = dict["CycleType"] as? String {
                    self.cycleType = value
                }
                if let value = dict["DependentNodeIdList"] as? String {
                    self.dependentNodeIdList = value
                }
                if let value = dict["DependentType"] as? String {
                    self.dependentType = value
                }
                if let value = dict["EndEffectDate"] as? Int64 {
                    self.endEffectDate = value
                }
                if let value = dict["IgnoreParentSkipRunningProperty"] as? String {
                    self.ignoreParentSkipRunningProperty = value
                }
                if let value = dict["ImageId"] as? String {
                    self.imageId = value
                }
                if let value = dict["InputList"] as? [Any?] {
                    var tmp : [GetFileResponseBody.Data.NodeConfiguration.InputList] = []
                    for v in value {
                        if v != nil {
                            var model = GetFileResponseBody.Data.NodeConfiguration.InputList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.inputList = tmp
                }
                if let value = dict["InputParameters"] as? [Any?] {
                    var tmp : [GetFileResponseBody.Data.NodeConfiguration.InputParameters] = []
                    for v in value {
                        if v != nil {
                            var model = GetFileResponseBody.Data.NodeConfiguration.InputParameters()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.inputParameters = tmp
                }
                if let value = dict["OutputList"] as? [Any?] {
                    var tmp : [GetFileResponseBody.Data.NodeConfiguration.OutputList] = []
                    for v in value {
                        if v != nil {
                            var model = GetFileResponseBody.Data.NodeConfiguration.OutputList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.outputList = tmp
                }
                if let value = dict["OutputParameters"] as? [Any?] {
                    var tmp : [GetFileResponseBody.Data.NodeConfiguration.OutputParameters] = []
                    for v in value {
                        if v != nil {
                            var model = GetFileResponseBody.Data.NodeConfiguration.OutputParameters()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.outputParameters = tmp
                }
                if let value = dict["ParaValue"] as? String {
                    self.paraValue = value
                }
                if let value = dict["RerunMode"] as? String {
                    self.rerunMode = value
                }
                if let value = dict["ResourceGroupId"] as? Int64 {
                    self.resourceGroupId = value
                }
                if let value = dict["SchedulerType"] as? String {
                    self.schedulerType = value
                }
                if let value = dict["StartEffectDate"] as? Int64 {
                    self.startEffectDate = value
                }
                if let value = dict["StartImmediately"] as? Bool {
                    self.startImmediately = value
                }
                if let value = dict["Stop"] as? Bool {
                    self.stop = value
                }
                if let value = dict["Timeout"] as? Int32 {
                    self.timeout = value
                }
            }
        }
        public class ResourceDownloadLink : Tea.TeaModel {
            public var downloadLink: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.downloadLink != nil {
                    map["downloadLink"] = self.downloadLink!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["downloadLink"] as? String {
                    self.downloadLink = value
                }
            }
        }
        public var file: GetFileResponseBody.Data.File?

        public var nodeConfiguration: GetFileResponseBody.Data.NodeConfiguration?

        public var resourceDownloadLink: GetFileResponseBody.Data.ResourceDownloadLink?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.file?.validate()
            try self.nodeConfiguration?.validate()
            try self.resourceDownloadLink?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.file != nil {
                map["File"] = self.file?.toMap()
            }
            if self.nodeConfiguration != nil {
                map["NodeConfiguration"] = self.nodeConfiguration?.toMap()
            }
            if self.resourceDownloadLink != nil {
                map["ResourceDownloadLink"] = self.resourceDownloadLink?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["File"] as? [String: Any?] {
                var model = GetFileResponseBody.Data.File()
                model.fromMap(value)
                self.file = model
            }
            if let value = dict["NodeConfiguration"] as? [String: Any?] {
                var model = GetFileResponseBody.Data.NodeConfiguration()
                model.fromMap(value)
                self.nodeConfiguration = model
            }
            if let value = dict["ResourceDownloadLink"] as? [String: Any?] {
                var model = GetFileResponseBody.Data.ResourceDownloadLink()
                model.fromMap(value)
                self.resourceDownloadLink = model
            }
        }
    }
    public var data: GetFileResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetFileResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetFileTypeStatisticRequest : Tea.TeaModel {
    public var projectEnv: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetFileTypeStatisticResponseBody : Tea.TeaModel {
    public class ProgramTypeAndCounts : Tea.TeaModel {
        public var count: Int32?

        public var programType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.programType != nil {
                map["ProgramType"] = self.programType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Count"] as? Int32 {
                self.count = value
            }
            if let value = dict["ProgramType"] as? String {
                self.programType = value
            }
        }
    }
    public var programTypeAndCounts: [GetFileTypeStatisticResponseBody.ProgramTypeAndCounts]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.programTypeAndCounts != nil {
            var tmp : [Any] = []
            for k in self.programTypeAndCounts! {
                tmp.append(k.toMap())
            }
            map["ProgramTypeAndCounts"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProgramTypeAndCounts"] as? [Any?] {
            var tmp : [GetFileTypeStatisticResponseBody.ProgramTypeAndCounts] = []
            for v in value {
                if v != nil {
                    var model = GetFileTypeStatisticResponseBody.ProgramTypeAndCounts()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.programTypeAndCounts = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetFileTypeStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileTypeStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetFileTypeStatisticResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetFileVersionRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var fileVersion: Int32?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.fileVersion != nil {
            map["FileVersion"] = self.fileVersion!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FileId"] as? Int64 {
            self.fileId = value
        }
        if let value = dict["FileVersion"] as? Int32 {
            self.fileVersion = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class GetFileVersionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeType: String?

        public var comment: String?

        public var commitTime: Int64?

        public var commitUser: String?

        public var fileContent: String?

        public var fileName: String?

        public var filePropertyContent: String?

        public var fileVersion: Int32?

        public var isCurrentProd: Bool?

        public var nodeContent: String?

        public var nodeId: Int64?

        public var status: String?

        public var useType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeType != nil {
                map["ChangeType"] = self.changeType!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.commitTime != nil {
                map["CommitTime"] = self.commitTime!
            }
            if self.commitUser != nil {
                map["CommitUser"] = self.commitUser!
            }
            if self.fileContent != nil {
                map["FileContent"] = self.fileContent!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.filePropertyContent != nil {
                map["FilePropertyContent"] = self.filePropertyContent!
            }
            if self.fileVersion != nil {
                map["FileVersion"] = self.fileVersion!
            }
            if self.isCurrentProd != nil {
                map["IsCurrentProd"] = self.isCurrentProd!
            }
            if self.nodeContent != nil {
                map["NodeContent"] = self.nodeContent!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.useType != nil {
                map["UseType"] = self.useType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeType"] as? String {
                self.changeType = value
            }
            if let value = dict["Comment"] as? String {
                self.comment = value
            }
            if let value = dict["CommitTime"] as? Int64 {
                self.commitTime = value
            }
            if let value = dict["CommitUser"] as? String {
                self.commitUser = value
            }
            if let value = dict["FileContent"] as? String {
                self.fileContent = value
            }
            if let value = dict["FileName"] as? String {
                self.fileName = value
            }
            if let value = dict["FilePropertyContent"] as? String {
                self.filePropertyContent = value
            }
            if let value = dict["FileVersion"] as? Int32 {
                self.fileVersion = value
            }
            if let value = dict["IsCurrentProd"] as? Bool {
                self.isCurrentProd = value
            }
            if let value = dict["NodeContent"] as? String {
                self.nodeContent = value
            }
            if let value = dict["NodeId"] as? Int64 {
                self.nodeId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["UseType"] as? String {
                self.useType = value
            }
        }
    }
    public var data: GetFileVersionResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetFileVersionResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetFileVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetFileVersionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetFolderRequest : Tea.TeaModel {
    public var folderId: String?

    public var folderPath: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.folderPath != nil {
            map["FolderPath"] = self.folderPath!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FolderId"] as? String {
            self.folderId = value
        }
        if let value = dict["FolderPath"] as? String {
            self.folderPath = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class GetFolderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var folderId: String?

        public var folderPath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.folderId != nil {
                map["FolderId"] = self.folderId!
            }
            if self.folderPath != nil {
                map["FolderPath"] = self.folderPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FolderId"] as? String {
                self.folderId = value
            }
            if let value = dict["FolderPath"] as? String {
                self.folderPath = value
            }
        }
    }
    public var data: GetFolderResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetFolderResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetFolderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFolderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetFolderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetIDEEventDetailRequest : Tea.TeaModel {
    public var messageId: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MessageId"] as? String {
            self.messageId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetIDEEventDetailResponseBody : Tea.TeaModel {
    public class EventDetail : Tea.TeaModel {
        public class CommittedFile : Tea.TeaModel {
            public class FilePropertyContent : Tea.TeaModel {
                public var businessId: Int64?

                public var currentVersion: Int64?

                public var dataSourceName: String?

                public var folderId: String?

                public var owner: String?

                public var parentFileId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.businessId != nil {
                        map["BusinessId"] = self.businessId!
                    }
                    if self.currentVersion != nil {
                        map["CurrentVersion"] = self.currentVersion!
                    }
                    if self.dataSourceName != nil {
                        map["DataSourceName"] = self.dataSourceName!
                    }
                    if self.folderId != nil {
                        map["FolderId"] = self.folderId!
                    }
                    if self.owner != nil {
                        map["Owner"] = self.owner!
                    }
                    if self.parentFileId != nil {
                        map["ParentFileId"] = self.parentFileId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BusinessId"] as? Int64 {
                        self.businessId = value
                    }
                    if let value = dict["CurrentVersion"] as? Int64 {
                        self.currentVersion = value
                    }
                    if let value = dict["DataSourceName"] as? String {
                        self.dataSourceName = value
                    }
                    if let value = dict["FolderId"] as? String {
                        self.folderId = value
                    }
                    if let value = dict["Owner"] as? String {
                        self.owner = value
                    }
                    if let value = dict["ParentFileId"] as? Int64 {
                        self.parentFileId = value
                    }
                }
            }
            public class NodeConfiguration : Tea.TeaModel {
                public class InputList : Tea.TeaModel {
                    public var input: String?

                    public var parseType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.input != nil {
                            map["Input"] = self.input!
                        }
                        if self.parseType != nil {
                            map["ParseType"] = self.parseType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Input"] as? String {
                            self.input = value
                        }
                        if let value = dict["ParseType"] as? String {
                            self.parseType = value
                        }
                    }
                }
                public class OutputList : Tea.TeaModel {
                    public var output: String?

                    public var refTableName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.output != nil {
                            map["Output"] = self.output!
                        }
                        if self.refTableName != nil {
                            map["RefTableName"] = self.refTableName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Output"] as? String {
                            self.output = value
                        }
                        if let value = dict["RefTableName"] as? String {
                            self.refTableName = value
                        }
                    }
                }
                public var autoRerunIntervalMillis: Int64?

                public var autoRerunTimes: Int64?

                public var cronExpress: String?

                public var cycleType: String?

                public var dependentNodeIdList: String?

                public var dependentType: String?

                public var inputList: [GetIDEEventDetailResponseBody.EventDetail.CommittedFile.NodeConfiguration.InputList]?

                public var outputList: [GetIDEEventDetailResponseBody.EventDetail.CommittedFile.NodeConfiguration.OutputList]?

                public var paraValue: String?

                public var rerunMode: String?

                public var resourceGroupId: Int64?

                public var schedulerType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.autoRerunIntervalMillis != nil {
                        map["AutoRerunIntervalMillis"] = self.autoRerunIntervalMillis!
                    }
                    if self.autoRerunTimes != nil {
                        map["AutoRerunTimes"] = self.autoRerunTimes!
                    }
                    if self.cronExpress != nil {
                        map["CronExpress"] = self.cronExpress!
                    }
                    if self.cycleType != nil {
                        map["CycleType"] = self.cycleType!
                    }
                    if self.dependentNodeIdList != nil {
                        map["DependentNodeIdList"] = self.dependentNodeIdList!
                    }
                    if self.dependentType != nil {
                        map["DependentType"] = self.dependentType!
                    }
                    if self.inputList != nil {
                        var tmp : [Any] = []
                        for k in self.inputList! {
                            tmp.append(k.toMap())
                        }
                        map["InputList"] = tmp
                    }
                    if self.outputList != nil {
                        var tmp : [Any] = []
                        for k in self.outputList! {
                            tmp.append(k.toMap())
                        }
                        map["OutputList"] = tmp
                    }
                    if self.paraValue != nil {
                        map["ParaValue"] = self.paraValue!
                    }
                    if self.rerunMode != nil {
                        map["RerunMode"] = self.rerunMode!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    if self.schedulerType != nil {
                        map["SchedulerType"] = self.schedulerType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AutoRerunIntervalMillis"] as? Int64 {
                        self.autoRerunIntervalMillis = value
                    }
                    if let value = dict["AutoRerunTimes"] as? Int64 {
                        self.autoRerunTimes = value
                    }
                    if let value = dict["CronExpress"] as? String {
                        self.cronExpress = value
                    }
                    if let value = dict["CycleType"] as? String {
                        self.cycleType = value
                    }
                    if let value = dict["DependentNodeIdList"] as? String {
                        self.dependentNodeIdList = value
                    }
                    if let value = dict["DependentType"] as? String {
                        self.dependentType = value
                    }
                    if let value = dict["InputList"] as? [Any?] {
                        var tmp : [GetIDEEventDetailResponseBody.EventDetail.CommittedFile.NodeConfiguration.InputList] = []
                        for v in value {
                            if v != nil {
                                var model = GetIDEEventDetailResponseBody.EventDetail.CommittedFile.NodeConfiguration.InputList()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.inputList = tmp
                    }
                    if let value = dict["OutputList"] as? [Any?] {
                        var tmp : [GetIDEEventDetailResponseBody.EventDetail.CommittedFile.NodeConfiguration.OutputList] = []
                        for v in value {
                            if v != nil {
                                var model = GetIDEEventDetailResponseBody.EventDetail.CommittedFile.NodeConfiguration.OutputList()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.outputList = tmp
                    }
                    if let value = dict["ParaValue"] as? String {
                        self.paraValue = value
                    }
                    if let value = dict["RerunMode"] as? String {
                        self.rerunMode = value
                    }
                    if let value = dict["ResourceGroupId"] as? Int64 {
                        self.resourceGroupId = value
                    }
                    if let value = dict["SchedulerType"] as? String {
                        self.schedulerType = value
                    }
                }
            }
            public var changeType: String?

            public var comment: String?

            public var committor: String?

            public var content: String?

            public var fileId: Int64?

            public var fileName: String?

            public var filePropertyContent: GetIDEEventDetailResponseBody.EventDetail.CommittedFile.FilePropertyContent?

            public var fileType: Int64?

            public var nodeConfiguration: GetIDEEventDetailResponseBody.EventDetail.CommittedFile.NodeConfiguration?

            public var nodeId: Int64?

            public var useType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.filePropertyContent?.validate()
                try self.nodeConfiguration?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.changeType != nil {
                    map["ChangeType"] = self.changeType!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.committor != nil {
                    map["Committor"] = self.committor!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.filePropertyContent != nil {
                    map["FilePropertyContent"] = self.filePropertyContent?.toMap()
                }
                if self.fileType != nil {
                    map["FileType"] = self.fileType!
                }
                if self.nodeConfiguration != nil {
                    map["NodeConfiguration"] = self.nodeConfiguration?.toMap()
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.useType != nil {
                    map["UseType"] = self.useType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ChangeType"] as? String {
                    self.changeType = value
                }
                if let value = dict["Comment"] as? String {
                    self.comment = value
                }
                if let value = dict["Committor"] as? String {
                    self.committor = value
                }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["FileId"] as? Int64 {
                    self.fileId = value
                }
                if let value = dict["FileName"] as? String {
                    self.fileName = value
                }
                if let value = dict["FilePropertyContent"] as? [String: Any?] {
                    var model = GetIDEEventDetailResponseBody.EventDetail.CommittedFile.FilePropertyContent()
                    model.fromMap(value)
                    self.filePropertyContent = model
                }
                if let value = dict["FileType"] as? Int64 {
                    self.fileType = value
                }
                if let value = dict["NodeConfiguration"] as? [String: Any?] {
                    var model = GetIDEEventDetailResponseBody.EventDetail.CommittedFile.NodeConfiguration()
                    model.fromMap(value)
                    self.nodeConfiguration = model
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["UseType"] as? String {
                    self.useType = value
                }
            }
        }
        public class DeletedFile : Tea.TeaModel {
            public var businessId: Int64?

            public var content: String?

            public var currentVersion: Int64?

            public var dataSourceName: String?

            public var fileId: Int64?

            public var fileName: String?

            public var fileType: Int64?

            public var folderId: String?

            public var nodeId: Int64?

            public var owner: String?

            public var parentFileId: Int64?

            public var useType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessId != nil {
                    map["BusinessId"] = self.businessId!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.currentVersion != nil {
                    map["CurrentVersion"] = self.currentVersion!
                }
                if self.dataSourceName != nil {
                    map["DataSourceName"] = self.dataSourceName!
                }
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.fileType != nil {
                    map["FileType"] = self.fileType!
                }
                if self.folderId != nil {
                    map["FolderId"] = self.folderId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.parentFileId != nil {
                    map["ParentFileId"] = self.parentFileId!
                }
                if self.useType != nil {
                    map["UseType"] = self.useType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BusinessId"] as? Int64 {
                    self.businessId = value
                }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["CurrentVersion"] as? Int64 {
                    self.currentVersion = value
                }
                if let value = dict["DataSourceName"] as? String {
                    self.dataSourceName = value
                }
                if let value = dict["FileId"] as? Int64 {
                    self.fileId = value
                }
                if let value = dict["FileName"] as? String {
                    self.fileName = value
                }
                if let value = dict["FileType"] as? Int64 {
                    self.fileType = value
                }
                if let value = dict["FolderId"] as? String {
                    self.folderId = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["ParentFileId"] as? Int64 {
                    self.parentFileId = value
                }
                if let value = dict["UseType"] as? String {
                    self.useType = value
                }
            }
        }
        public class FileExecutionCommand : Tea.TeaModel {
            public var content: String?

            public var dataSourceName: String?

            public var fileId: Int64?

            public var fileType: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.dataSourceName != nil {
                    map["DataSourceName"] = self.dataSourceName!
                }
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.fileType != nil {
                    map["FileType"] = self.fileType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["DataSourceName"] as? String {
                    self.dataSourceName = value
                }
                if let value = dict["FileId"] as? Int64 {
                    self.fileId = value
                }
                if let value = dict["FileType"] as? Int64 {
                    self.fileType = value
                }
            }
        }
        public class TableModel : Tea.TeaModel {
            public class Columns : Tea.TeaModel {
                public var columnName: String?

                public var columnType: String?

                public var comment: String?

                public var isPartitionColumn: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columnName != nil {
                        map["ColumnName"] = self.columnName!
                    }
                    if self.columnType != nil {
                        map["ColumnType"] = self.columnType!
                    }
                    if self.comment != nil {
                        map["Comment"] = self.comment!
                    }
                    if self.isPartitionColumn != nil {
                        map["IsPartitionColumn"] = self.isPartitionColumn!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ColumnName"] as? String {
                        self.columnName = value
                    }
                    if let value = dict["ColumnType"] as? String {
                        self.columnType = value
                    }
                    if let value = dict["Comment"] as? String {
                        self.comment = value
                    }
                    if let value = dict["IsPartitionColumn"] as? Bool {
                        self.isPartitionColumn = value
                    }
                }
            }
            public var columns: [GetIDEEventDetailResponseBody.EventDetail.TableModel.Columns]?

            public var comment: String?

            public var dataSourceName: String?

            public var env: String?

            public var lifeCycle: Int64?

            public var location: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columns != nil {
                    var tmp : [Any] = []
                    for k in self.columns! {
                        tmp.append(k.toMap())
                    }
                    map["Columns"] = tmp
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.dataSourceName != nil {
                    map["DataSourceName"] = self.dataSourceName!
                }
                if self.env != nil {
                    map["Env"] = self.env!
                }
                if self.lifeCycle != nil {
                    map["LifeCycle"] = self.lifeCycle!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Columns"] as? [Any?] {
                    var tmp : [GetIDEEventDetailResponseBody.EventDetail.TableModel.Columns] = []
                    for v in value {
                        if v != nil {
                            var model = GetIDEEventDetailResponseBody.EventDetail.TableModel.Columns()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.columns = tmp
                }
                if let value = dict["Comment"] as? String {
                    self.comment = value
                }
                if let value = dict["DataSourceName"] as? String {
                    self.dataSourceName = value
                }
                if let value = dict["Env"] as? String {
                    self.env = value
                }
                if let value = dict["LifeCycle"] as? Int64 {
                    self.lifeCycle = value
                }
                if let value = dict["Location"] as? String {
                    self.location = value
                }
                if let value = dict["TableName"] as? String {
                    self.tableName = value
                }
            }
        }
        public var committedFile: GetIDEEventDetailResponseBody.EventDetail.CommittedFile?

        public var deletedFile: GetIDEEventDetailResponseBody.EventDetail.DeletedFile?

        public var fileExecutionCommand: GetIDEEventDetailResponseBody.EventDetail.FileExecutionCommand?

        public var tableModel: GetIDEEventDetailResponseBody.EventDetail.TableModel?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.committedFile?.validate()
            try self.deletedFile?.validate()
            try self.fileExecutionCommand?.validate()
            try self.tableModel?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.committedFile != nil {
                map["CommittedFile"] = self.committedFile?.toMap()
            }
            if self.deletedFile != nil {
                map["DeletedFile"] = self.deletedFile?.toMap()
            }
            if self.fileExecutionCommand != nil {
                map["FileExecutionCommand"] = self.fileExecutionCommand?.toMap()
            }
            if self.tableModel != nil {
                map["TableModel"] = self.tableModel?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CommittedFile"] as? [String: Any?] {
                var model = GetIDEEventDetailResponseBody.EventDetail.CommittedFile()
                model.fromMap(value)
                self.committedFile = model
            }
            if let value = dict["DeletedFile"] as? [String: Any?] {
                var model = GetIDEEventDetailResponseBody.EventDetail.DeletedFile()
                model.fromMap(value)
                self.deletedFile = model
            }
            if let value = dict["FileExecutionCommand"] as? [String: Any?] {
                var model = GetIDEEventDetailResponseBody.EventDetail.FileExecutionCommand()
                model.fromMap(value)
                self.fileExecutionCommand = model
            }
            if let value = dict["TableModel"] as? [String: Any?] {
                var model = GetIDEEventDetailResponseBody.EventDetail.TableModel()
                model.fromMap(value)
                self.tableModel = model
            }
        }
    }
    public var eventDetail: GetIDEEventDetailResponseBody.EventDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventDetail != nil {
            map["EventDetail"] = self.eventDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EventDetail"] as? [String: Any?] {
            var model = GetIDEEventDetailResponseBody.EventDetail()
            model.fromMap(value)
            self.eventDetail = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetIDEEventDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIDEEventDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetIDEEventDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetInstanceRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? Int64 {
            self.instanceId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class GetInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var baselineId: Int64?

        public var beginRunningTime: Int64?

        public var beginWaitResTime: Int64?

        public var beginWaitTimeTime: Int64?

        public var bizdate: Int64?

        public var businessId: Int64?

        public var connection: String?

        public var createTime: Int64?

        public var createUser: String?

        public var cycTime: Int64?

        public var dagId: Int64?

        public var dagType: String?

        public var dqcDescription: String?

        public var dqcType: Int32?

        public var finishTime: Int64?

        public var instanceId: Int64?

        public var modifyTime: Int64?

        public var nodeId: Int64?

        public var nodeName: String?

        public var owner: String?

        public var paramValues: String?

        public var periodNumber: Int32?

        public var priority: Int32?

        public var relatedFlowId: Int64?

        public var repeatInterval: Int64?

        public var repeatability: Bool?

        public var status: String?

        public var taskRerunTime: Int32?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineId != nil {
                map["BaselineId"] = self.baselineId!
            }
            if self.beginRunningTime != nil {
                map["BeginRunningTime"] = self.beginRunningTime!
            }
            if self.beginWaitResTime != nil {
                map["BeginWaitResTime"] = self.beginWaitResTime!
            }
            if self.beginWaitTimeTime != nil {
                map["BeginWaitTimeTime"] = self.beginWaitTimeTime!
            }
            if self.bizdate != nil {
                map["Bizdate"] = self.bizdate!
            }
            if self.businessId != nil {
                map["BusinessId"] = self.businessId!
            }
            if self.connection != nil {
                map["Connection"] = self.connection!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.cycTime != nil {
                map["CycTime"] = self.cycTime!
            }
            if self.dagId != nil {
                map["DagId"] = self.dagId!
            }
            if self.dagType != nil {
                map["DagType"] = self.dagType!
            }
            if self.dqcDescription != nil {
                map["DqcDescription"] = self.dqcDescription!
            }
            if self.dqcType != nil {
                map["DqcType"] = self.dqcType!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.paramValues != nil {
                map["ParamValues"] = self.paramValues!
            }
            if self.periodNumber != nil {
                map["PeriodNumber"] = self.periodNumber!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.relatedFlowId != nil {
                map["RelatedFlowId"] = self.relatedFlowId!
            }
            if self.repeatInterval != nil {
                map["RepeatInterval"] = self.repeatInterval!
            }
            if self.repeatability != nil {
                map["Repeatability"] = self.repeatability!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskRerunTime != nil {
                map["TaskRerunTime"] = self.taskRerunTime!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BaselineId"] as? Int64 {
                self.baselineId = value
            }
            if let value = dict["BeginRunningTime"] as? Int64 {
                self.beginRunningTime = value
            }
            if let value = dict["BeginWaitResTime"] as? Int64 {
                self.beginWaitResTime = value
            }
            if let value = dict["BeginWaitTimeTime"] as? Int64 {
                self.beginWaitTimeTime = value
            }
            if let value = dict["Bizdate"] as? Int64 {
                self.bizdate = value
            }
            if let value = dict["BusinessId"] as? Int64 {
                self.businessId = value
            }
            if let value = dict["Connection"] as? String {
                self.connection = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CreateUser"] as? String {
                self.createUser = value
            }
            if let value = dict["CycTime"] as? Int64 {
                self.cycTime = value
            }
            if let value = dict["DagId"] as? Int64 {
                self.dagId = value
            }
            if let value = dict["DagType"] as? String {
                self.dagType = value
            }
            if let value = dict["DqcDescription"] as? String {
                self.dqcDescription = value
            }
            if let value = dict["DqcType"] as? Int32 {
                self.dqcType = value
            }
            if let value = dict["FinishTime"] as? Int64 {
                self.finishTime = value
            }
            if let value = dict["InstanceId"] as? Int64 {
                self.instanceId = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["NodeId"] as? Int64 {
                self.nodeId = value
            }
            if let value = dict["NodeName"] as? String {
                self.nodeName = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["ParamValues"] as? String {
                self.paramValues = value
            }
            if let value = dict["PeriodNumber"] as? Int32 {
                self.periodNumber = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["RelatedFlowId"] as? Int64 {
                self.relatedFlowId = value
            }
            if let value = dict["RepeatInterval"] as? Int64 {
                self.repeatInterval = value
            }
            if let value = dict["Repeatability"] as? Bool {
                self.repeatability = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TaskRerunTime"] as? Int32 {
                self.taskRerunTime = value
            }
            if let value = dict["TaskType"] as? String {
                self.taskType = value
            }
        }
    }
    public var data: GetInstanceResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetInstanceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetInstanceConsumeTimeRankRequest : Tea.TeaModel {
    public var bizdate: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bizdate"] as? String {
            self.bizdate = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetInstanceConsumeTimeRankResponseBody : Tea.TeaModel {
    public class InstanceConsumeTimeRank : Tea.TeaModel {
        public class ConsumeTimeRank : Tea.TeaModel {
            public var bizdate: Int64?

            public var consumed: Int64?

            public var instanceId: Int64?

            public var nodeId: Int64?

            public var nodeName: String?

            public var owner: String?

            public var prgType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.consumed != nil {
                    map["Consumed"] = self.consumed!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.prgType != nil {
                    map["PrgType"] = self.prgType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Bizdate"] as? Int64 {
                    self.bizdate = value
                }
                if let value = dict["Consumed"] as? Int64 {
                    self.consumed = value
                }
                if let value = dict["InstanceId"] as? Int64 {
                    self.instanceId = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["PrgType"] as? Int32 {
                    self.prgType = value
                }
            }
        }
        public var consumeTimeRank: [GetInstanceConsumeTimeRankResponseBody.InstanceConsumeTimeRank.ConsumeTimeRank]?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consumeTimeRank != nil {
                var tmp : [Any] = []
                for k in self.consumeTimeRank! {
                    tmp.append(k.toMap())
                }
                map["ConsumeTimeRank"] = tmp
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConsumeTimeRank"] as? [Any?] {
                var tmp : [GetInstanceConsumeTimeRankResponseBody.InstanceConsumeTimeRank.ConsumeTimeRank] = []
                for v in value {
                    if v != nil {
                        var model = GetInstanceConsumeTimeRankResponseBody.InstanceConsumeTimeRank.ConsumeTimeRank()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.consumeTimeRank = tmp
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var instanceConsumeTimeRank: GetInstanceConsumeTimeRankResponseBody.InstanceConsumeTimeRank?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceConsumeTimeRank?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceConsumeTimeRank != nil {
            map["InstanceConsumeTimeRank"] = self.instanceConsumeTimeRank?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceConsumeTimeRank"] as? [String: Any?] {
            var model = GetInstanceConsumeTimeRankResponseBody.InstanceConsumeTimeRank()
            model.fromMap(value)
            self.instanceConsumeTimeRank = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetInstanceConsumeTimeRankResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceConsumeTimeRankResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetInstanceConsumeTimeRankResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetInstanceCountTrendRequest : Tea.TeaModel {
    public var beginDate: String?

    public var endDate: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginDate != nil {
            map["BeginDate"] = self.beginDate!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BeginDate"] as? String {
            self.beginDate = value
        }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetInstanceCountTrendResponseBody : Tea.TeaModel {
    public class InstanceCounts : Tea.TeaModel {
        public var count: Int32?

        public var date: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.date != nil {
                map["Date"] = self.date!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Count"] as? Int32 {
                self.count = value
            }
            if let value = dict["Date"] as? Int64 {
                self.date = value
            }
        }
    }
    public var instanceCounts: [GetInstanceCountTrendResponseBody.InstanceCounts]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceCounts != nil {
            var tmp : [Any] = []
            for k in self.instanceCounts! {
                tmp.append(k.toMap())
            }
            map["InstanceCounts"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceCounts"] as? [Any?] {
            var tmp : [GetInstanceCountTrendResponseBody.InstanceCounts] = []
            for v in value {
                if v != nil {
                    var model = GetInstanceCountTrendResponseBody.InstanceCounts()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instanceCounts = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetInstanceCountTrendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceCountTrendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetInstanceCountTrendResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetInstanceErrorRankRequest : Tea.TeaModel {
    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetInstanceErrorRankResponseBody : Tea.TeaModel {
    public class InstanceErrorRank : Tea.TeaModel {
        public class ErrorRank : Tea.TeaModel {
            public var count: Int32?

            public var nodeId: Int64?

            public var nodeName: String?

            public var owner: String?

            public var prgType: Int32?

            public var projectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.prgType != nil {
                    map["PrgType"] = self.prgType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int32 {
                    self.count = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["PrgType"] as? Int32 {
                    self.prgType = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
            }
        }
        public var errorRank: [GetInstanceErrorRankResponseBody.InstanceErrorRank.ErrorRank]?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorRank != nil {
                var tmp : [Any] = []
                for k in self.errorRank! {
                    tmp.append(k.toMap())
                }
                map["ErrorRank"] = tmp
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ErrorRank"] as? [Any?] {
                var tmp : [GetInstanceErrorRankResponseBody.InstanceErrorRank.ErrorRank] = []
                for v in value {
                    if v != nil {
                        var model = GetInstanceErrorRankResponseBody.InstanceErrorRank.ErrorRank()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.errorRank = tmp
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var instanceErrorRank: GetInstanceErrorRankResponseBody.InstanceErrorRank?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceErrorRank?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceErrorRank != nil {
            map["InstanceErrorRank"] = self.instanceErrorRank?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceErrorRank"] as? [String: Any?] {
            var model = GetInstanceErrorRankResponseBody.InstanceErrorRank()
            model.fromMap(value)
            self.instanceErrorRank = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetInstanceErrorRankResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceErrorRankResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetInstanceErrorRankResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetInstanceLogRequest : Tea.TeaModel {
    public var instanceHistoryId: Int64?

    public var instanceId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceHistoryId != nil {
            map["InstanceHistoryId"] = self.instanceHistoryId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceHistoryId"] as? Int64 {
            self.instanceHistoryId = value
        }
        if let value = dict["InstanceId"] as? Int64 {
            self.instanceId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class GetInstanceLogResponseBody : Tea.TeaModel {
    public var data: String?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetInstanceLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetInstanceLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetInstanceStatusCountRequest : Tea.TeaModel {
    public var bizDate: String?

    public var projectEnv: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizDate != nil {
            map["BizDate"] = self.bizDate!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BizDate"] as? String {
            self.bizDate = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetInstanceStatusCountResponseBody : Tea.TeaModel {
    public class StatusCount : Tea.TeaModel {
        public var failureCount: Int32?

        public var notRunCount: Int32?

        public var runningCount: Int32?

        public var successCount: Int32?

        public var totalCount: Int32?

        public var waitResCount: Int32?

        public var waitTimeCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failureCount != nil {
                map["FailureCount"] = self.failureCount!
            }
            if self.notRunCount != nil {
                map["NotRunCount"] = self.notRunCount!
            }
            if self.runningCount != nil {
                map["RunningCount"] = self.runningCount!
            }
            if self.successCount != nil {
                map["SuccessCount"] = self.successCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.waitResCount != nil {
                map["WaitResCount"] = self.waitResCount!
            }
            if self.waitTimeCount != nil {
                map["WaitTimeCount"] = self.waitTimeCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FailureCount"] as? Int32 {
                self.failureCount = value
            }
            if let value = dict["NotRunCount"] as? Int32 {
                self.notRunCount = value
            }
            if let value = dict["RunningCount"] as? Int32 {
                self.runningCount = value
            }
            if let value = dict["SuccessCount"] as? Int32 {
                self.successCount = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
            if let value = dict["WaitResCount"] as? Int32 {
                self.waitResCount = value
            }
            if let value = dict["WaitTimeCount"] as? Int32 {
                self.waitTimeCount = value
            }
        }
    }
    public var requestId: String?

    public var statusCount: GetInstanceStatusCountResponseBody.StatusCount?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statusCount?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCount != nil {
            map["StatusCount"] = self.statusCount?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StatusCount"] as? [String: Any?] {
            var model = GetInstanceStatusCountResponseBody.StatusCount()
            model.fromMap(value)
            self.statusCount = model
        }
    }
}

public class GetInstanceStatusCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceStatusCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetInstanceStatusCountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetInstanceStatusStatisticRequest : Tea.TeaModel {
    public var bizDate: String?

    public var dagType: String?

    public var projectEnv: String?

    public var projectId: Int64?

    public var schedulerPeriod: String?

    public var schedulerType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizDate != nil {
            map["BizDate"] = self.bizDate!
        }
        if self.dagType != nil {
            map["DagType"] = self.dagType!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.schedulerPeriod != nil {
            map["SchedulerPeriod"] = self.schedulerPeriod!
        }
        if self.schedulerType != nil {
            map["SchedulerType"] = self.schedulerType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BizDate"] as? String {
            self.bizDate = value
        }
        if let value = dict["DagType"] as? String {
            self.dagType = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SchedulerPeriod"] as? String {
            self.schedulerPeriod = value
        }
        if let value = dict["SchedulerType"] as? String {
            self.schedulerType = value
        }
    }
}

public class GetInstanceStatusStatisticResponseBody : Tea.TeaModel {
    public class StatusCount : Tea.TeaModel {
        public var failureCount: Int32?

        public var notRunCount: Int32?

        public var runningCount: Int32?

        public var successCount: Int32?

        public var totalCount: Int32?

        public var waitResCount: Int32?

        public var waitTimeCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failureCount != nil {
                map["FailureCount"] = self.failureCount!
            }
            if self.notRunCount != nil {
                map["NotRunCount"] = self.notRunCount!
            }
            if self.runningCount != nil {
                map["RunningCount"] = self.runningCount!
            }
            if self.successCount != nil {
                map["SuccessCount"] = self.successCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.waitResCount != nil {
                map["WaitResCount"] = self.waitResCount!
            }
            if self.waitTimeCount != nil {
                map["WaitTimeCount"] = self.waitTimeCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FailureCount"] as? Int32 {
                self.failureCount = value
            }
            if let value = dict["NotRunCount"] as? Int32 {
                self.notRunCount = value
            }
            if let value = dict["RunningCount"] as? Int32 {
                self.runningCount = value
            }
            if let value = dict["SuccessCount"] as? Int32 {
                self.successCount = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
            if let value = dict["WaitResCount"] as? Int32 {
                self.waitResCount = value
            }
            if let value = dict["WaitTimeCount"] as? Int32 {
                self.waitTimeCount = value
            }
        }
    }
    public var requestId: String?

    public var statusCount: GetInstanceStatusStatisticResponseBody.StatusCount?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statusCount?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCount != nil {
            map["StatusCount"] = self.statusCount?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StatusCount"] as? [String: Any?] {
            var model = GetInstanceStatusStatisticResponseBody.StatusCount()
            model.fromMap(value)
            self.statusCount = model
        }
    }
}

public class GetInstanceStatusStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceStatusStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetInstanceStatusStatisticResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetManualDagInstancesRequest : Tea.TeaModel {
    public var dagId: String?

    public var projectEnv: String?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DagId"] as? String {
            self.dagId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
    }
}

public class GetManualDagInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public var beginRunningTime: Int64?

        public var beginWaitResTime: Int64?

        public var beginWaitTimeTime: Int64?

        public var bizDate: Int64?

        public var createTime: Int64?

        public var createUser: String?

        public var cycTime: Int64?

        public var dagId: Int64?

        public var dagType: String?

        public var finishTime: Int64?

        public var instanceId: Int64?

        public var modifyTime: Int64?

        public var nodeId: Int64?

        public var nodeName: String?

        public var paramValues: String?

        public var status: String?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.beginRunningTime != nil {
                map["BeginRunningTime"] = self.beginRunningTime!
            }
            if self.beginWaitResTime != nil {
                map["BeginWaitResTime"] = self.beginWaitResTime!
            }
            if self.beginWaitTimeTime != nil {
                map["BeginWaitTimeTime"] = self.beginWaitTimeTime!
            }
            if self.bizDate != nil {
                map["BizDate"] = self.bizDate!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.cycTime != nil {
                map["CycTime"] = self.cycTime!
            }
            if self.dagId != nil {
                map["DagId"] = self.dagId!
            }
            if self.dagType != nil {
                map["DagType"] = self.dagType!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.paramValues != nil {
                map["ParamValues"] = self.paramValues!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BeginRunningTime"] as? Int64 {
                self.beginRunningTime = value
            }
            if let value = dict["BeginWaitResTime"] as? Int64 {
                self.beginWaitResTime = value
            }
            if let value = dict["BeginWaitTimeTime"] as? Int64 {
                self.beginWaitTimeTime = value
            }
            if let value = dict["BizDate"] as? Int64 {
                self.bizDate = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CreateUser"] as? String {
                self.createUser = value
            }
            if let value = dict["CycTime"] as? Int64 {
                self.cycTime = value
            }
            if let value = dict["DagId"] as? Int64 {
                self.dagId = value
            }
            if let value = dict["DagType"] as? String {
                self.dagType = value
            }
            if let value = dict["FinishTime"] as? Int64 {
                self.finishTime = value
            }
            if let value = dict["InstanceId"] as? Int64 {
                self.instanceId = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["NodeId"] as? Int64 {
                self.nodeId = value
            }
            if let value = dict["NodeName"] as? String {
                self.nodeName = value
            }
            if let value = dict["ParamValues"] as? String {
                self.paramValues = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TaskType"] as? String {
                self.taskType = value
            }
        }
    }
    public var instances: [GetManualDagInstancesResponseBody.Instances]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Instances"] as? [Any?] {
            var tmp : [GetManualDagInstancesResponseBody.Instances] = []
            for v in value {
                if v != nil {
                    var model = GetManualDagInstancesResponseBody.Instances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instances = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetManualDagInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetManualDagInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetManualDagInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaCategoryRequest : Tea.TeaModel {
    public var pageNum: Int32?

    public var pageSize: Int32?

    public var parentCategoryId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentCategoryId != nil {
            map["ParentCategoryId"] = self.parentCategoryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ParentCategoryId"] as? Int64 {
            self.parentCategoryId = value
        }
    }
}

public class GetMetaCategoryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataEntityList : Tea.TeaModel {
            public var categoryId: Int64?

            public var comment: String?

            public var createTime: Int64?

            public var depth: Int32?

            public var lastOperatorId: String?

            public var modifiedTime: Int64?

            public var name: String?

            public var ownerId: String?

            public var parentCategoryId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.categoryId != nil {
                    map["CategoryId"] = self.categoryId!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.depth != nil {
                    map["Depth"] = self.depth!
                }
                if self.lastOperatorId != nil {
                    map["LastOperatorId"] = self.lastOperatorId!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.parentCategoryId != nil {
                    map["ParentCategoryId"] = self.parentCategoryId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CategoryId"] as? Int64 {
                    self.categoryId = value
                }
                if let value = dict["Comment"] as? String {
                    self.comment = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["Depth"] as? Int32 {
                    self.depth = value
                }
                if let value = dict["LastOperatorId"] as? String {
                    self.lastOperatorId = value
                }
                if let value = dict["ModifiedTime"] as? Int64 {
                    self.modifiedTime = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["OwnerId"] as? String {
                    self.ownerId = value
                }
                if let value = dict["ParentCategoryId"] as? Int64 {
                    self.parentCategoryId = value
                }
            }
        }
        public var dataEntityList: [GetMetaCategoryResponseBody.Data.DataEntityList]?

        public var pageNum: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataEntityList != nil {
                var tmp : [Any] = []
                for k in self.dataEntityList! {
                    tmp.append(k.toMap())
                }
                map["DataEntityList"] = tmp
            }
            if self.pageNum != nil {
                map["PageNum"] = self.pageNum!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataEntityList"] as? [Any?] {
                var tmp : [GetMetaCategoryResponseBody.Data.DataEntityList] = []
                for v in value {
                    if v != nil {
                        var model = GetMetaCategoryResponseBody.Data.DataEntityList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataEntityList = tmp
            }
            if let value = dict["PageNum"] as? Int32 {
                self.pageNum = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: GetMetaCategoryResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetMetaCategoryResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMetaCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaCategoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaCollectionDetailRequest : Tea.TeaModel {
    public var qualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["QualifiedName"] as? String {
            self.qualifiedName = value
        }
    }
}

public class GetMetaCollectionDetailResponseBody : Tea.TeaModel {
    public var collection: Collection?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.collection?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collection != nil {
            map["Collection"] = self.collection?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Collection"] as? [String: Any?] {
            var model = Collection()
            model.fromMap(value)
            self.collection = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMetaCollectionDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaCollectionDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaCollectionDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaColumnLineageRequest : Tea.TeaModel {
    public var clusterId: String?

    public var columnGuid: String?

    public var columnName: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var direction: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.columnGuid != nil {
            map["ColumnGuid"] = self.columnGuid!
        }
        if self.columnName != nil {
            map["ColumnName"] = self.columnName!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["ColumnGuid"] as? String {
            self.columnGuid = value
        }
        if let value = dict["ColumnName"] as? String {
            self.columnName = value
        }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["DatabaseName"] as? String {
            self.databaseName = value
        }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class GetMetaColumnLineageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataEntityList : Tea.TeaModel {
            public var clusterId: String?

            public var columnGuid: String?

            public var columnName: String?

            public var databaseName: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.columnGuid != nil {
                    map["ColumnGuid"] = self.columnGuid!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ClusterId"] as? String {
                    self.clusterId = value
                }
                if let value = dict["ColumnGuid"] as? String {
                    self.columnGuid = value
                }
                if let value = dict["ColumnName"] as? String {
                    self.columnName = value
                }
                if let value = dict["DatabaseName"] as? String {
                    self.databaseName = value
                }
                if let value = dict["TableName"] as? String {
                    self.tableName = value
                }
            }
        }
        public var dataEntityList: [GetMetaColumnLineageResponseBody.Data.DataEntityList]?

        public var pageNum: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataEntityList != nil {
                var tmp : [Any] = []
                for k in self.dataEntityList! {
                    tmp.append(k.toMap())
                }
                map["DataEntityList"] = tmp
            }
            if self.pageNum != nil {
                map["PageNum"] = self.pageNum!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataEntityList"] as? [Any?] {
                var tmp : [GetMetaColumnLineageResponseBody.Data.DataEntityList] = []
                for v in value {
                    if v != nil {
                        var model = GetMetaColumnLineageResponseBody.Data.DataEntityList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataEntityList = tmp
            }
            if let value = dict["PageNum"] as? Int32 {
                self.pageNum = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: GetMetaColumnLineageResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetMetaColumnLineageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMetaColumnLineageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaColumnLineageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaColumnLineageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaDBInfoRequest : Tea.TeaModel {
    public var appGuid: String?

    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGuid != nil {
            map["AppGuid"] = self.appGuid!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppGuid"] as? String {
            self.appGuid = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["DatabaseName"] as? String {
            self.databaseName = value
        }
    }
}

public class GetMetaDBInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appGuid: String?

        public var clusterBizId: String?

        public var comment: String?

        public var createTime: Int64?

        public var endpoint: String?

        public var envType: Int32?

        public var location: String?

        public var modifyTime: Int64?

        public var name: String?

        public var ownerId: String?

        public var ownerName: String?

        public var projectId: Int64?

        public var projectName: String?

        public var projectNameCn: String?

        public var tenantId: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appGuid != nil {
                map["AppGuid"] = self.appGuid!
            }
            if self.clusterBizId != nil {
                map["ClusterBizId"] = self.clusterBizId!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.location != nil {
                map["Location"] = self.location!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.projectNameCn != nil {
                map["ProjectNameCn"] = self.projectNameCn!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppGuid"] as? String {
                self.appGuid = value
            }
            if let value = dict["ClusterBizId"] as? String {
                self.clusterBizId = value
            }
            if let value = dict["Comment"] as? String {
                self.comment = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Endpoint"] as? String {
                self.endpoint = value
            }
            if let value = dict["EnvType"] as? Int32 {
                self.envType = value
            }
            if let value = dict["Location"] as? String {
                self.location = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["OwnerId"] as? String {
                self.ownerId = value
            }
            if let value = dict["OwnerName"] as? String {
                self.ownerName = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["ProjectName"] as? String {
                self.projectName = value
            }
            if let value = dict["ProjectNameCn"] as? String {
                self.projectNameCn = value
            }
            if let value = dict["TenantId"] as? Int64 {
                self.tenantId = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var data: GetMetaDBInfoResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetMetaDBInfoResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetMetaDBInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaDBInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaDBInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaDBTableListRequest : Tea.TeaModel {
    public var appGuid: String?

    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGuid != nil {
            map["AppGuid"] = self.appGuid!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppGuid"] as? String {
            self.appGuid = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["DatabaseName"] as? String {
            self.databaseName = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class GetMetaDBTableListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TableEntityList : Tea.TeaModel {
            public var databaseName: String?

            public var tableGuid: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DatabaseName"] as? String {
                    self.databaseName = value
                }
                if let value = dict["TableGuid"] as? String {
                    self.tableGuid = value
                }
                if let value = dict["TableName"] as? String {
                    self.tableName = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var tableEntityList: [GetMetaDBTableListResponseBody.Data.TableEntityList]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.tableEntityList != nil {
                var tmp : [Any] = []
                for k in self.tableEntityList! {
                    tmp.append(k.toMap())
                }
                map["TableEntityList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TableEntityList"] as? [Any?] {
                var tmp : [GetMetaDBTableListResponseBody.Data.TableEntityList] = []
                for v in value {
                    if v != nil {
                        var model = GetMetaDBTableListResponseBody.Data.TableEntityList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tableEntityList = tmp
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: GetMetaDBTableListResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetMetaDBTableListResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetMetaDBTableListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaDBTableListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaDBTableListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaTableBasicInfoRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var extension_: Bool?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.extension_ != nil {
            map["Extension"] = self.extension_!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["DatabaseName"] as? String {
            self.databaseName = value
        }
        if let value = dict["Extension"] as? Bool {
            self.extension_ = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class GetMetaTableBasicInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var caption: String?

        public var clusterId: String?

        public var columnCount: Int32?

        public var comment: String?

        public var createTime: Int64?

        public var dataSize: Int64?

        public var databaseName: String?

        public var envType: Int32?

        public var favoriteCount: Int64?

        public var isPartitionTable: Bool?

        public var isView: Bool?

        public var isVisible: Int32?

        public var lastAccessTime: Int64?

        public var lastDdlTime: Int64?

        public var lastModifyTime: Int64?

        public var lifeCycle: Int32?

        public var location: String?

        public var ownerId: String?

        public var partitionKeys: String?

        public var projectId: Int64?

        public var projectName: String?

        public var readCount: Int64?

        public var schema: String?

        public var tableGuid: String?

        public var tableName: String?

        public var tenantId: Int64?

        public var viewCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.caption != nil {
                map["Caption"] = self.caption!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.columnCount != nil {
                map["ColumnCount"] = self.columnCount!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dataSize != nil {
                map["DataSize"] = self.dataSize!
            }
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.favoriteCount != nil {
                map["FavoriteCount"] = self.favoriteCount!
            }
            if self.isPartitionTable != nil {
                map["IsPartitionTable"] = self.isPartitionTable!
            }
            if self.isView != nil {
                map["IsView"] = self.isView!
            }
            if self.isVisible != nil {
                map["IsVisible"] = self.isVisible!
            }
            if self.lastAccessTime != nil {
                map["LastAccessTime"] = self.lastAccessTime!
            }
            if self.lastDdlTime != nil {
                map["LastDdlTime"] = self.lastDdlTime!
            }
            if self.lastModifyTime != nil {
                map["LastModifyTime"] = self.lastModifyTime!
            }
            if self.lifeCycle != nil {
                map["LifeCycle"] = self.lifeCycle!
            }
            if self.location != nil {
                map["Location"] = self.location!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.partitionKeys != nil {
                map["PartitionKeys"] = self.partitionKeys!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.readCount != nil {
                map["ReadCount"] = self.readCount!
            }
            if self.schema != nil {
                map["Schema"] = self.schema!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.viewCount != nil {
                map["ViewCount"] = self.viewCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Caption"] as? String {
                self.caption = value
            }
            if let value = dict["ClusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["ColumnCount"] as? Int32 {
                self.columnCount = value
            }
            if let value = dict["Comment"] as? String {
                self.comment = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["DataSize"] as? Int64 {
                self.dataSize = value
            }
            if let value = dict["DatabaseName"] as? String {
                self.databaseName = value
            }
            if let value = dict["EnvType"] as? Int32 {
                self.envType = value
            }
            if let value = dict["FavoriteCount"] as? Int64 {
                self.favoriteCount = value
            }
            if let value = dict["IsPartitionTable"] as? Bool {
                self.isPartitionTable = value
            }
            if let value = dict["IsView"] as? Bool {
                self.isView = value
            }
            if let value = dict["IsVisible"] as? Int32 {
                self.isVisible = value
            }
            if let value = dict["LastAccessTime"] as? Int64 {
                self.lastAccessTime = value
            }
            if let value = dict["LastDdlTime"] as? Int64 {
                self.lastDdlTime = value
            }
            if let value = dict["LastModifyTime"] as? Int64 {
                self.lastModifyTime = value
            }
            if let value = dict["LifeCycle"] as? Int32 {
                self.lifeCycle = value
            }
            if let value = dict["Location"] as? String {
                self.location = value
            }
            if let value = dict["OwnerId"] as? String {
                self.ownerId = value
            }
            if let value = dict["PartitionKeys"] as? String {
                self.partitionKeys = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["ProjectName"] as? String {
                self.projectName = value
            }
            if let value = dict["ReadCount"] as? Int64 {
                self.readCount = value
            }
            if let value = dict["Schema"] as? String {
                self.schema = value
            }
            if let value = dict["TableGuid"] as? String {
                self.tableGuid = value
            }
            if let value = dict["TableName"] as? String {
                self.tableName = value
            }
            if let value = dict["TenantId"] as? Int64 {
                self.tenantId = value
            }
            if let value = dict["ViewCount"] as? Int64 {
                self.viewCount = value
            }
        }
    }
    public var data: GetMetaTableBasicInfoResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetMetaTableBasicInfoResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMetaTableBasicInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableBasicInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaTableBasicInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaTableChangeLogRequest : Tea.TeaModel {
    public var changeType: String?

    public var endDate: String?

    public var objectType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startDate: String?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeType != nil {
            map["ChangeType"] = self.changeType!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeType"] as? String {
            self.changeType = value
        }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["ObjectType"] as? String {
            self.objectType = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
    }
}

public class GetMetaTableChangeLogResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataEntityList : Tea.TeaModel {
            public var changeContent: String?

            public var changeType: String?

            public var createTime: Int64?

            public var modifiedTime: Int64?

            public var objectType: String?

            public var operator_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.changeContent != nil {
                    map["ChangeContent"] = self.changeContent!
                }
                if self.changeType != nil {
                    map["ChangeType"] = self.changeType!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.objectType != nil {
                    map["ObjectType"] = self.objectType!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ChangeContent"] as? String {
                    self.changeContent = value
                }
                if let value = dict["ChangeType"] as? String {
                    self.changeType = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["ModifiedTime"] as? Int64 {
                    self.modifiedTime = value
                }
                if let value = dict["ObjectType"] as? String {
                    self.objectType = value
                }
                if let value = dict["Operator"] as? String {
                    self.operator_ = value
                }
            }
        }
        public var dataEntityList: [GetMetaTableChangeLogResponseBody.Data.DataEntityList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataEntityList != nil {
                var tmp : [Any] = []
                for k in self.dataEntityList! {
                    tmp.append(k.toMap())
                }
                map["DataEntityList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataEntityList"] as? [Any?] {
                var tmp : [GetMetaTableChangeLogResponseBody.Data.DataEntityList] = []
                for v in value {
                    if v != nil {
                        var model = GetMetaTableChangeLogResponseBody.Data.DataEntityList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataEntityList = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: GetMetaTableChangeLogResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetMetaTableChangeLogResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMetaTableChangeLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableChangeLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaTableChangeLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaTableColumnRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["DatabaseName"] as? String {
            self.databaseName = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class GetMetaTableColumnResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ColumnList : Tea.TeaModel {
            public var caption: String?

            public var columnGuid: String?

            public var columnName: String?

            public var columnType: String?

            public var comment: String?

            public var isForeignKey: Bool?

            public var isPartitionColumn: Bool?

            public var isPrimaryKey: Bool?

            public var position: Int32?

            public var relationCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.caption != nil {
                    map["Caption"] = self.caption!
                }
                if self.columnGuid != nil {
                    map["ColumnGuid"] = self.columnGuid!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.columnType != nil {
                    map["ColumnType"] = self.columnType!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.isForeignKey != nil {
                    map["IsForeignKey"] = self.isForeignKey!
                }
                if self.isPartitionColumn != nil {
                    map["IsPartitionColumn"] = self.isPartitionColumn!
                }
                if self.isPrimaryKey != nil {
                    map["IsPrimaryKey"] = self.isPrimaryKey!
                }
                if self.position != nil {
                    map["Position"] = self.position!
                }
                if self.relationCount != nil {
                    map["RelationCount"] = self.relationCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Caption"] as? String {
                    self.caption = value
                }
                if let value = dict["ColumnGuid"] as? String {
                    self.columnGuid = value
                }
                if let value = dict["ColumnName"] as? String {
                    self.columnName = value
                }
                if let value = dict["ColumnType"] as? String {
                    self.columnType = value
                }
                if let value = dict["Comment"] as? String {
                    self.comment = value
                }
                if let value = dict["IsForeignKey"] as? Bool {
                    self.isForeignKey = value
                }
                if let value = dict["IsPartitionColumn"] as? Bool {
                    self.isPartitionColumn = value
                }
                if let value = dict["IsPrimaryKey"] as? Bool {
                    self.isPrimaryKey = value
                }
                if let value = dict["Position"] as? Int32 {
                    self.position = value
                }
                if let value = dict["RelationCount"] as? Int64 {
                    self.relationCount = value
                }
            }
        }
        public var columnList: [GetMetaTableColumnResponseBody.Data.ColumnList]?

        public var pageNum: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columnList != nil {
                var tmp : [Any] = []
                for k in self.columnList! {
                    tmp.append(k.toMap())
                }
                map["ColumnList"] = tmp
            }
            if self.pageNum != nil {
                map["PageNum"] = self.pageNum!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ColumnList"] as? [Any?] {
                var tmp : [GetMetaTableColumnResponseBody.Data.ColumnList] = []
                for v in value {
                    if v != nil {
                        var model = GetMetaTableColumnResponseBody.Data.ColumnList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.columnList = tmp
            }
            if let value = dict["PageNum"] as? Int32 {
                self.pageNum = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: GetMetaTableColumnResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetMetaTableColumnResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMetaTableColumnResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableColumnResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaTableColumnResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaTableFullInfoRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["DatabaseName"] as? String {
            self.databaseName = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class GetMetaTableFullInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ColumnList : Tea.TeaModel {
            public var caption: String?

            public var columnGuid: String?

            public var columnName: String?

            public var columnType: String?

            public var comment: String?

            public var isForeignKey: Bool?

            public var isPartitionColumn: Bool?

            public var isPrimaryKey: Bool?

            public var position: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.caption != nil {
                    map["Caption"] = self.caption!
                }
                if self.columnGuid != nil {
                    map["ColumnGuid"] = self.columnGuid!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.columnType != nil {
                    map["ColumnType"] = self.columnType!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.isForeignKey != nil {
                    map["IsForeignKey"] = self.isForeignKey!
                }
                if self.isPartitionColumn != nil {
                    map["IsPartitionColumn"] = self.isPartitionColumn!
                }
                if self.isPrimaryKey != nil {
                    map["IsPrimaryKey"] = self.isPrimaryKey!
                }
                if self.position != nil {
                    map["Position"] = self.position!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Caption"] as? String {
                    self.caption = value
                }
                if let value = dict["ColumnGuid"] as? String {
                    self.columnGuid = value
                }
                if let value = dict["ColumnName"] as? String {
                    self.columnName = value
                }
                if let value = dict["ColumnType"] as? String {
                    self.columnType = value
                }
                if let value = dict["Comment"] as? String {
                    self.comment = value
                }
                if let value = dict["IsForeignKey"] as? Bool {
                    self.isForeignKey = value
                }
                if let value = dict["IsPartitionColumn"] as? Bool {
                    self.isPartitionColumn = value
                }
                if let value = dict["IsPrimaryKey"] as? Bool {
                    self.isPrimaryKey = value
                }
                if let value = dict["Position"] as? Int32 {
                    self.position = value
                }
            }
        }
        public var clusterId: String?

        public var columnList: [GetMetaTableFullInfoResponseBody.Data.ColumnList]?

        public var comment: String?

        public var createTime: Int64?

        public var dataSize: Int64?

        public var databaseName: String?

        public var envType: Int32?

        public var isVisible: Int32?

        public var lastAccessTime: Int64?

        public var lastDdlTime: Int64?

        public var lastModifyTime: Int64?

        public var lifeCycle: Int32?

        public var location: String?

        public var ownerId: String?

        public var partitionKeys: String?

        public var projectId: Int64?

        public var projectName: String?

        public var schema: String?

        public var tableGuid: String?

        public var tableName: String?

        public var tenantId: Int64?

        public var totalColumnCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.columnList != nil {
                var tmp : [Any] = []
                for k in self.columnList! {
                    tmp.append(k.toMap())
                }
                map["ColumnList"] = tmp
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dataSize != nil {
                map["DataSize"] = self.dataSize!
            }
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.isVisible != nil {
                map["IsVisible"] = self.isVisible!
            }
            if self.lastAccessTime != nil {
                map["LastAccessTime"] = self.lastAccessTime!
            }
            if self.lastDdlTime != nil {
                map["LastDdlTime"] = self.lastDdlTime!
            }
            if self.lastModifyTime != nil {
                map["LastModifyTime"] = self.lastModifyTime!
            }
            if self.lifeCycle != nil {
                map["LifeCycle"] = self.lifeCycle!
            }
            if self.location != nil {
                map["Location"] = self.location!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.partitionKeys != nil {
                map["PartitionKeys"] = self.partitionKeys!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.schema != nil {
                map["Schema"] = self.schema!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.totalColumnCount != nil {
                map["TotalColumnCount"] = self.totalColumnCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["ColumnList"] as? [Any?] {
                var tmp : [GetMetaTableFullInfoResponseBody.Data.ColumnList] = []
                for v in value {
                    if v != nil {
                        var model = GetMetaTableFullInfoResponseBody.Data.ColumnList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.columnList = tmp
            }
            if let value = dict["Comment"] as? String {
                self.comment = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["DataSize"] as? Int64 {
                self.dataSize = value
            }
            if let value = dict["DatabaseName"] as? String {
                self.databaseName = value
            }
            if let value = dict["EnvType"] as? Int32 {
                self.envType = value
            }
            if let value = dict["IsVisible"] as? Int32 {
                self.isVisible = value
            }
            if let value = dict["LastAccessTime"] as? Int64 {
                self.lastAccessTime = value
            }
            if let value = dict["LastDdlTime"] as? Int64 {
                self.lastDdlTime = value
            }
            if let value = dict["LastModifyTime"] as? Int64 {
                self.lastModifyTime = value
            }
            if let value = dict["LifeCycle"] as? Int32 {
                self.lifeCycle = value
            }
            if let value = dict["Location"] as? String {
                self.location = value
            }
            if let value = dict["OwnerId"] as? String {
                self.ownerId = value
            }
            if let value = dict["PartitionKeys"] as? String {
                self.partitionKeys = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["ProjectName"] as? String {
                self.projectName = value
            }
            if let value = dict["Schema"] as? String {
                self.schema = value
            }
            if let value = dict["TableGuid"] as? String {
                self.tableGuid = value
            }
            if let value = dict["TableName"] as? String {
                self.tableName = value
            }
            if let value = dict["TenantId"] as? Int64 {
                self.tenantId = value
            }
            if let value = dict["TotalColumnCount"] as? Int64 {
                self.totalColumnCount = value
            }
        }
    }
    public var data: GetMetaTableFullInfoResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetMetaTableFullInfoResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMetaTableFullInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableFullInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaTableFullInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaTableIntroWikiRequest : Tea.TeaModel {
    public var tableGuid: String?

    public var wikiVersion: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.wikiVersion != nil {
            map["WikiVersion"] = self.wikiVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
        if let value = dict["WikiVersion"] as? Int64 {
            self.wikiVersion = value
        }
    }
}

public class GetMetaTableIntroWikiResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var content: String?

        public var createTime: Int64?

        public var creator: String?

        public var creatorName: String?

        public var modifiedTime: Int64?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Content"] as? String {
                self.content = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Creator"] as? String {
                self.creator = value
            }
            if let value = dict["CreatorName"] as? String {
                self.creatorName = value
            }
            if let value = dict["ModifiedTime"] as? Int64 {
                self.modifiedTime = value
            }
            if let value = dict["Version"] as? Int64 {
                self.version = value
            }
        }
    }
    public var data: GetMetaTableIntroWikiResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetMetaTableIntroWikiResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMetaTableIntroWikiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableIntroWikiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaTableIntroWikiResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaTableLineageRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var direction: String?

    public var nextPrimaryKey: String?

    public var pageSize: Int32?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.nextPrimaryKey != nil {
            map["NextPrimaryKey"] = self.nextPrimaryKey!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["DatabaseName"] as? String {
            self.databaseName = value
        }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["NextPrimaryKey"] as? String {
            self.nextPrimaryKey = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class GetMetaTableLineageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataEntityList : Tea.TeaModel {
            public var createTimestamp: Int64?

            public var databaseName: String?

            public var tableGuid: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["DatabaseName"] as? String {
                    self.databaseName = value
                }
                if let value = dict["TableGuid"] as? String {
                    self.tableGuid = value
                }
                if let value = dict["TableName"] as? String {
                    self.tableName = value
                }
            }
        }
        public var dataEntityList: [GetMetaTableLineageResponseBody.Data.DataEntityList]?

        public var hasNext: Bool?

        public var nextPrimaryKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataEntityList != nil {
                var tmp : [Any] = []
                for k in self.dataEntityList! {
                    tmp.append(k.toMap())
                }
                map["DataEntityList"] = tmp
            }
            if self.hasNext != nil {
                map["HasNext"] = self.hasNext!
            }
            if self.nextPrimaryKey != nil {
                map["NextPrimaryKey"] = self.nextPrimaryKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataEntityList"] as? [Any?] {
                var tmp : [GetMetaTableLineageResponseBody.Data.DataEntityList] = []
                for v in value {
                    if v != nil {
                        var model = GetMetaTableLineageResponseBody.Data.DataEntityList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataEntityList = tmp
            }
            if let value = dict["HasNext"] as? Bool {
                self.hasNext = value
            }
            if let value = dict["NextPrimaryKey"] as? String {
                self.nextPrimaryKey = value
            }
        }
    }
    public var data: GetMetaTableLineageResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetMetaTableLineageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMetaTableLineageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableLineageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaTableLineageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaTableListByCategoryRequest : Tea.TeaModel {
    public var categoryId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CategoryId"] as? Int64 {
            self.categoryId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class GetMetaTableListByCategoryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var tableGuidList: [String]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.tableGuidList != nil {
                map["TableGuidList"] = self.tableGuidList!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TableGuidList"] as? [String] {
                self.tableGuidList = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: GetMetaTableListByCategoryResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetMetaTableListByCategoryResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMetaTableListByCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableListByCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaTableListByCategoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaTableOutputRequest : Tea.TeaModel {
    public var endDate: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startDate: String?

    public var tableGuid: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class GetMetaTableOutputResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataEntityList : Tea.TeaModel {
            public var endTime: String?

            public var projectId: Int64?

            public var startTime: String?

            public var tableGuid: String?

            public var taskId: String?

            public var taskInstanceId: Int64?

            public var waitTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskInstanceId != nil {
                    map["TaskInstanceId"] = self.taskInstanceId!
                }
                if self.waitTime != nil {
                    map["WaitTime"] = self.waitTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["TableGuid"] as? String {
                    self.tableGuid = value
                }
                if let value = dict["TaskId"] as? String {
                    self.taskId = value
                }
                if let value = dict["TaskInstanceId"] as? Int64 {
                    self.taskInstanceId = value
                }
                if let value = dict["WaitTime"] as? String {
                    self.waitTime = value
                }
            }
        }
        public var dataEntityList: [GetMetaTableOutputResponseBody.Data.DataEntityList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataEntityList != nil {
                var tmp : [Any] = []
                for k in self.dataEntityList! {
                    tmp.append(k.toMap())
                }
                map["DataEntityList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataEntityList"] as? [Any?] {
                var tmp : [GetMetaTableOutputResponseBody.Data.DataEntityList] = []
                for v in value {
                    if v != nil {
                        var model = GetMetaTableOutputResponseBody.Data.DataEntityList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataEntityList = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: GetMetaTableOutputResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetMetaTableOutputResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMetaTableOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaTableOutputResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaTablePartitionRequest : Tea.TeaModel {
    public class SortCriterion : Tea.TeaModel {
        public var order: String?

        public var sortField: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.order != nil {
                map["Order"] = self.order!
            }
            if self.sortField != nil {
                map["SortField"] = self.sortField!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Order"] as? String {
                self.order = value
            }
            if let value = dict["SortField"] as? String {
                self.sortField = value
            }
        }
    }
    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var sortCriterion: GetMetaTablePartitionRequest.SortCriterion?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sortCriterion?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortCriterion != nil {
            map["SortCriterion"] = self.sortCriterion?.toMap()
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["DatabaseName"] as? String {
            self.databaseName = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SortCriterion"] as? [String: Any?] {
            var model = GetMetaTablePartitionRequest.SortCriterion()
            model.fromMap(value)
            self.sortCriterion = model
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class GetMetaTablePartitionShrinkRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var databaseName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var sortCriterionShrink: String?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortCriterionShrink != nil {
            map["SortCriterion"] = self.sortCriterionShrink!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["DatabaseName"] as? String {
            self.databaseName = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SortCriterion"] as? String {
            self.sortCriterionShrink = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class GetMetaTablePartitionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataEntityList : Tea.TeaModel {
            public var comment: String?

            public var createTime: Int64?

            public var dataSize: Int64?

            public var modifiedTime: Int64?

            public var partitionGuid: String?

            public var partitionLocation: String?

            public var partitionName: String?

            public var partitionPath: String?

            public var partitionType: String?

            public var recordCount: Int64?

            public var tableGuid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dataSize != nil {
                    map["DataSize"] = self.dataSize!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.partitionGuid != nil {
                    map["PartitionGuid"] = self.partitionGuid!
                }
                if self.partitionLocation != nil {
                    map["PartitionLocation"] = self.partitionLocation!
                }
                if self.partitionName != nil {
                    map["PartitionName"] = self.partitionName!
                }
                if self.partitionPath != nil {
                    map["PartitionPath"] = self.partitionPath!
                }
                if self.partitionType != nil {
                    map["PartitionType"] = self.partitionType!
                }
                if self.recordCount != nil {
                    map["RecordCount"] = self.recordCount!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Comment"] as? String {
                    self.comment = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["DataSize"] as? Int64 {
                    self.dataSize = value
                }
                if let value = dict["ModifiedTime"] as? Int64 {
                    self.modifiedTime = value
                }
                if let value = dict["PartitionGuid"] as? String {
                    self.partitionGuid = value
                }
                if let value = dict["PartitionLocation"] as? String {
                    self.partitionLocation = value
                }
                if let value = dict["PartitionName"] as? String {
                    self.partitionName = value
                }
                if let value = dict["PartitionPath"] as? String {
                    self.partitionPath = value
                }
                if let value = dict["PartitionType"] as? String {
                    self.partitionType = value
                }
                if let value = dict["RecordCount"] as? Int64 {
                    self.recordCount = value
                }
                if let value = dict["TableGuid"] as? String {
                    self.tableGuid = value
                }
            }
        }
        public var dataEntityList: [GetMetaTablePartitionResponseBody.Data.DataEntityList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataEntityList != nil {
                var tmp : [Any] = []
                for k in self.dataEntityList! {
                    tmp.append(k.toMap())
                }
                map["DataEntityList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataEntityList"] as? [Any?] {
                var tmp : [GetMetaTablePartitionResponseBody.Data.DataEntityList] = []
                for v in value {
                    if v != nil {
                        var model = GetMetaTablePartitionResponseBody.Data.DataEntityList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataEntityList = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: GetMetaTablePartitionResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetMetaTablePartitionResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMetaTablePartitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTablePartitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaTablePartitionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaTableProducingTasksRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var dbName: String?

    public var schemaName: String?

    public var tableGuid: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["DbName"] as? String {
            self.dbName = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class GetMetaTableProducingTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var taskId: String?

        public var taskName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
            if let value = dict["TaskName"] as? String {
                self.taskName = value
            }
        }
    }
    public var data: [GetMetaTableProducingTasksResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [GetMetaTableProducingTasksResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = GetMetaTableProducingTasksResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMetaTableProducingTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableProducingTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaTableProducingTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaTableThemeLevelRequest : Tea.TeaModel {
    public var dataSourceType: String?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
    }
}

public class GetMetaTableThemeLevelResponseBody : Tea.TeaModel {
    public class Entity : Tea.TeaModel {
        public class Level : Tea.TeaModel {
            public var description_: String?

            public var levelId: Int64?

            public var name: String?

            public var type: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.levelId != nil {
                    map["LevelId"] = self.levelId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["LevelId"] as? Int64 {
                    self.levelId = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Type"] as? Int32 {
                    self.type = value
                }
            }
        }
        public class Theme : Tea.TeaModel {
            public var level: Int32?

            public var name: String?

            public var parentId: Int64?

            public var themeId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.themeId != nil {
                    map["ThemeId"] = self.themeId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Level"] as? Int32 {
                    self.level = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ParentId"] as? Int64 {
                    self.parentId = value
                }
                if let value = dict["ThemeId"] as? Int64 {
                    self.themeId = value
                }
            }
        }
        public var level: [GetMetaTableThemeLevelResponseBody.Entity.Level]?

        public var theme: [GetMetaTableThemeLevelResponseBody.Entity.Theme]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.level != nil {
                var tmp : [Any] = []
                for k in self.level! {
                    tmp.append(k.toMap())
                }
                map["Level"] = tmp
            }
            if self.theme != nil {
                var tmp : [Any] = []
                for k in self.theme! {
                    tmp.append(k.toMap())
                }
                map["Theme"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Level"] as? [Any?] {
                var tmp : [GetMetaTableThemeLevelResponseBody.Entity.Level] = []
                for v in value {
                    if v != nil {
                        var model = GetMetaTableThemeLevelResponseBody.Entity.Level()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.level = tmp
            }
            if let value = dict["Theme"] as? [Any?] {
                var tmp : [GetMetaTableThemeLevelResponseBody.Entity.Theme] = []
                for v in value {
                    if v != nil {
                        var model = GetMetaTableThemeLevelResponseBody.Entity.Theme()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.theme = tmp
            }
        }
    }
    public var entity: GetMetaTableThemeLevelResponseBody.Entity?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.entity?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entity != nil {
            map["Entity"] = self.entity?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Entity"] as? [String: Any?] {
            var model = GetMetaTableThemeLevelResponseBody.Entity()
            model.fromMap(value)
            self.entity = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMetaTableThemeLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableThemeLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaTableThemeLevelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMigrationProcessRequest : Tea.TeaModel {
    public var migrationId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationId != nil {
            map["MigrationId"] = self.migrationId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MigrationId"] as? Int64 {
            self.migrationId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetMigrationProcessResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var taskName: String?

        public var taskStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TaskName"] as? String {
                self.taskName = value
            }
            if let value = dict["TaskStatus"] as? String {
                self.taskStatus = value
            }
        }
    }
    public var data: [GetMigrationProcessResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [GetMigrationProcessResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = GetMigrationProcessResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMigrationProcessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMigrationProcessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMigrationProcessResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMigrationSummaryRequest : Tea.TeaModel {
    public var migrationId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationId != nil {
            map["MigrationId"] = self.migrationId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MigrationId"] as? Int64 {
            self.migrationId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetMigrationSummaryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createUser: String?

        public var downloadUrl: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var migrationId: Int64?

        public var name: String?

        public var opUser: String?

        public var projectId: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.downloadUrl != nil {
                map["DownloadUrl"] = self.downloadUrl!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.migrationId != nil {
                map["MigrationId"] = self.migrationId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.opUser != nil {
                map["OpUser"] = self.opUser!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateUser"] as? String {
                self.createUser = value
            }
            if let value = dict["DownloadUrl"] as? String {
                self.downloadUrl = value
            }
            if let value = dict["GmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["GmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["MigrationId"] as? Int64 {
                self.migrationId = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["OpUser"] as? String {
                self.opUser = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: GetMigrationSummaryResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetMigrationSummaryResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMigrationSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMigrationSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMigrationSummaryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetNodeRequest : Tea.TeaModel {
    public var nodeId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class GetNodeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var baselineId: Int64?

        public var businessId: Int64?

        public var connection: String?

        public var createTime: Int64?

        public var cronExpress: String?

        public var deployDate: Int64?

        public var description_: String?

        public var dqcDescription: String?

        public var dqcType: Int32?

        public var fileId: Int64?

        public var fileType: Int32?

        public var fileVersion: Int32?

        public var modifyTime: Int64?

        public var nodeId: Int64?

        public var nodeName: String?

        public var ownerId: String?

        public var paramValues: String?

        public var priority: Int32?

        public var programType: String?

        public var projectId: Int64?

        public var relatedFlowId: Int64?

        public var repeatInterval: Int64?

        public var repeatMode: Int32?

        public var repeatability: String?

        public var resGroupIdentifier: String?

        public var resGroupName: String?

        public var schedulerType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineId != nil {
                map["BaselineId"] = self.baselineId!
            }
            if self.businessId != nil {
                map["BusinessId"] = self.businessId!
            }
            if self.connection != nil {
                map["Connection"] = self.connection!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.cronExpress != nil {
                map["CronExpress"] = self.cronExpress!
            }
            if self.deployDate != nil {
                map["DeployDate"] = self.deployDate!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dqcDescription != nil {
                map["DqcDescription"] = self.dqcDescription!
            }
            if self.dqcType != nil {
                map["DqcType"] = self.dqcType!
            }
            if self.fileId != nil {
                map["FileId"] = self.fileId!
            }
            if self.fileType != nil {
                map["FileType"] = self.fileType!
            }
            if self.fileVersion != nil {
                map["FileVersion"] = self.fileVersion!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.paramValues != nil {
                map["ParamValues"] = self.paramValues!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.programType != nil {
                map["ProgramType"] = self.programType!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.relatedFlowId != nil {
                map["RelatedFlowId"] = self.relatedFlowId!
            }
            if self.repeatInterval != nil {
                map["RepeatInterval"] = self.repeatInterval!
            }
            if self.repeatMode != nil {
                map["RepeatMode"] = self.repeatMode!
            }
            if self.repeatability != nil {
                map["Repeatability"] = self.repeatability!
            }
            if self.resGroupIdentifier != nil {
                map["ResGroupIdentifier"] = self.resGroupIdentifier!
            }
            if self.resGroupName != nil {
                map["ResGroupName"] = self.resGroupName!
            }
            if self.schedulerType != nil {
                map["SchedulerType"] = self.schedulerType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BaselineId"] as? Int64 {
                self.baselineId = value
            }
            if let value = dict["BusinessId"] as? Int64 {
                self.businessId = value
            }
            if let value = dict["Connection"] as? String {
                self.connection = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CronExpress"] as? String {
                self.cronExpress = value
            }
            if let value = dict["DeployDate"] as? Int64 {
                self.deployDate = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DqcDescription"] as? String {
                self.dqcDescription = value
            }
            if let value = dict["DqcType"] as? Int32 {
                self.dqcType = value
            }
            if let value = dict["FileId"] as? Int64 {
                self.fileId = value
            }
            if let value = dict["FileType"] as? Int32 {
                self.fileType = value
            }
            if let value = dict["FileVersion"] as? Int32 {
                self.fileVersion = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["NodeId"] as? Int64 {
                self.nodeId = value
            }
            if let value = dict["NodeName"] as? String {
                self.nodeName = value
            }
            if let value = dict["OwnerId"] as? String {
                self.ownerId = value
            }
            if let value = dict["ParamValues"] as? String {
                self.paramValues = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["ProgramType"] as? String {
                self.programType = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["RelatedFlowId"] as? Int64 {
                self.relatedFlowId = value
            }
            if let value = dict["RepeatInterval"] as? Int64 {
                self.repeatInterval = value
            }
            if let value = dict["RepeatMode"] as? Int32 {
                self.repeatMode = value
            }
            if let value = dict["Repeatability"] as? String {
                self.repeatability = value
            }
            if let value = dict["ResGroupIdentifier"] as? String {
                self.resGroupIdentifier = value
            }
            if let value = dict["ResGroupName"] as? String {
                self.resGroupName = value
            }
            if let value = dict["SchedulerType"] as? String {
                self.schedulerType = value
            }
        }
    }
    public var data: GetNodeResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetNodeResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetNodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetNodeChildrenRequest : Tea.TeaModel {
    public var nodeId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class GetNodeChildrenResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Nodes : Tea.TeaModel {
            public var baselineId: Int64?

            public var cronExpress: String?

            public var nodeId: Int64?

            public var nodeName: String?

            public var ownerId: String?

            public var priority: Int32?

            public var programType: String?

            public var projectId: Int64?

            public var repeatability: Bool?

            public var schedulerType: String?

            public var stepType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.cronExpress != nil {
                    map["CronExpress"] = self.cronExpress!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.programType != nil {
                    map["ProgramType"] = self.programType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.repeatability != nil {
                    map["Repeatability"] = self.repeatability!
                }
                if self.schedulerType != nil {
                    map["SchedulerType"] = self.schedulerType!
                }
                if self.stepType != nil {
                    map["StepType"] = self.stepType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["CronExpress"] as? String {
                    self.cronExpress = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["OwnerId"] as? String {
                    self.ownerId = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["ProgramType"] as? String {
                    self.programType = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Repeatability"] as? Bool {
                    self.repeatability = value
                }
                if let value = dict["SchedulerType"] as? String {
                    self.schedulerType = value
                }
                if let value = dict["StepType"] as? String {
                    self.stepType = value
                }
            }
        }
        public var nodes: [GetNodeChildrenResponseBody.Data.Nodes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Nodes"] as? [Any?] {
                var tmp : [GetNodeChildrenResponseBody.Data.Nodes] = []
                for v in value {
                    if v != nil {
                        var model = GetNodeChildrenResponseBody.Data.Nodes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.nodes = tmp
            }
        }
    }
    public var data: GetNodeChildrenResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetNodeChildrenResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetNodeChildrenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeChildrenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetNodeChildrenResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetNodeCodeRequest : Tea.TeaModel {
    public var nodeId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class GetNodeCodeResponseBody : Tea.TeaModel {
    public var data: String?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetNodeCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetNodeCodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetNodeOnBaselineRequest : Tea.TeaModel {
    public var baselineId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BaselineId"] as? Int64 {
            self.baselineId = value
        }
    }
}

public class GetNodeOnBaselineResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var nodeId: Int64?

        public var nodeName: String?

        public var owner: String?

        public var projectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NodeId"] as? Int64 {
                self.nodeId = value
            }
            if let value = dict["NodeName"] as? String {
                self.nodeName = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
        }
    }
    public var data: [GetNodeOnBaselineResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [GetNodeOnBaselineResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = GetNodeOnBaselineResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class GetNodeOnBaselineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeOnBaselineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetNodeOnBaselineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetNodeParentsRequest : Tea.TeaModel {
    public var nodeId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class GetNodeParentsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Nodes : Tea.TeaModel {
            public var baselineId: Int64?

            public var cronExpress: String?

            public var nodeId: Int64?

            public var nodeName: String?

            public var ownerId: String?

            public var priority: Int32?

            public var programType: String?

            public var projectId: Int64?

            public var repeatability: Bool?

            public var schedulerType: String?

            public var stepType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.cronExpress != nil {
                    map["CronExpress"] = self.cronExpress!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.programType != nil {
                    map["ProgramType"] = self.programType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.repeatability != nil {
                    map["Repeatability"] = self.repeatability!
                }
                if self.schedulerType != nil {
                    map["SchedulerType"] = self.schedulerType!
                }
                if self.stepType != nil {
                    map["StepType"] = self.stepType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["CronExpress"] as? String {
                    self.cronExpress = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["OwnerId"] as? String {
                    self.ownerId = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["ProgramType"] as? String {
                    self.programType = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Repeatability"] as? Bool {
                    self.repeatability = value
                }
                if let value = dict["SchedulerType"] as? String {
                    self.schedulerType = value
                }
                if let value = dict["StepType"] as? String {
                    self.stepType = value
                }
            }
        }
        public var nodes: [GetNodeParentsResponseBody.Data.Nodes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Nodes"] as? [Any?] {
                var tmp : [GetNodeParentsResponseBody.Data.Nodes] = []
                for v in value {
                    if v != nil {
                        var model = GetNodeParentsResponseBody.Data.Nodes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.nodes = tmp
            }
        }
    }
    public var data: GetNodeParentsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetNodeParentsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetNodeParentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeParentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetNodeParentsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetNodeTypeListInfoRequest : Tea.TeaModel {
    public var keyword: String?

    public var locale: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.locale != nil {
            map["Locale"] = self.locale!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Locale"] as? String {
            self.locale = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class GetNodeTypeListInfoResponseBody : Tea.TeaModel {
    public class NodeTypeInfoList : Tea.TeaModel {
        public class NodeTypeInfo : Tea.TeaModel {
            public var nodeType: Int32?

            public var nodeTypeName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nodeType != nil {
                    map["NodeType"] = self.nodeType!
                }
                if self.nodeTypeName != nil {
                    map["NodeTypeName"] = self.nodeTypeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["NodeType"] as? Int32 {
                    self.nodeType = value
                }
                if let value = dict["NodeTypeName"] as? String {
                    self.nodeTypeName = value
                }
            }
        }
        public var nodeTypeInfo: [GetNodeTypeListInfoResponseBody.NodeTypeInfoList.NodeTypeInfo]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeTypeInfo != nil {
                var tmp : [Any] = []
                for k in self.nodeTypeInfo! {
                    tmp.append(k.toMap())
                }
                map["NodeTypeInfo"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NodeTypeInfo"] as? [Any?] {
                var tmp : [GetNodeTypeListInfoResponseBody.NodeTypeInfoList.NodeTypeInfo] = []
                for v in value {
                    if v != nil {
                        var model = GetNodeTypeListInfoResponseBody.NodeTypeInfoList.NodeTypeInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.nodeTypeInfo = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var nodeTypeInfoList: GetNodeTypeListInfoResponseBody.NodeTypeInfoList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeTypeInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeTypeInfoList != nil {
            map["NodeTypeInfoList"] = self.nodeTypeInfoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NodeTypeInfoList"] as? [String: Any?] {
            var model = GetNodeTypeListInfoResponseBody.NodeTypeInfoList()
            model.fromMap(value)
            self.nodeTypeInfoList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetNodeTypeListInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeTypeListInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetNodeTypeListInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetOpRiskDataRequest : Tea.TeaModel {
    public var date: String?

    public var name: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var riskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.date != nil {
            map["Date"] = self.date!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.riskType != nil {
            map["RiskType"] = self.riskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Date"] as? String {
            self.date = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RiskType"] as? String {
            self.riskType = value
        }
    }
}

public class GetOpRiskDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var riskData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.riskData != nil {
            map["RiskData"] = self.riskData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RiskData"] as? String {
            self.riskData = value
        }
    }
}

public class GetOpRiskDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpRiskDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetOpRiskDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetOpSensitiveDataRequest : Tea.TeaModel {
    public var date: String?

    public var name: String?

    public var opType: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.date != nil {
            map["Date"] = self.date!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.opType != nil {
            map["OpType"] = self.opType!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Date"] as? String {
            self.date = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OpType"] as? String {
            self.opType = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class GetOpSensitiveDataResponseBody : Tea.TeaModel {
    public var opSensitiveData: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.opSensitiveData != nil {
            map["OpSensitiveData"] = self.opSensitiveData!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OpSensitiveData"] as? String {
            self.opSensitiveData = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetOpSensitiveDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpSensitiveDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetOpSensitiveDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetOptionValueForProjectRequest : Tea.TeaModel {
    public var extensionCode: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extensionCode != nil {
            map["ExtensionCode"] = self.extensionCode!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ExtensionCode"] as? String {
            self.extensionCode = value
        }
        if let value = dict["ProjectId"] as? String {
            self.projectId = value
        }
    }
}

public class GetOptionValueForProjectResponseBody : Tea.TeaModel {
    public var optionValue: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.optionValue != nil {
            map["OptionValue"] = self.optionValue!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OptionValue"] as? String {
            self.optionValue = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetOptionValueForProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOptionValueForProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetOptionValueForProjectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPermissionApplyOrderDetailRequest : Tea.TeaModel {
    public var flowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FlowId"] as? String {
            self.flowId = value
        }
    }
}

public class GetPermissionApplyOrderDetailResponseBody : Tea.TeaModel {
    public class ApplyOrderDetail : Tea.TeaModel {
        public class ApproveAccountList : Tea.TeaModel {
            public var baseId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baseId != nil {
                    map["BaseId"] = self.baseId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaseId"] as? String {
                    self.baseId = value
                }
            }
        }
        public class ApproveContent : Tea.TeaModel {
            public class ProjectMeta : Tea.TeaModel {
                public class ObjectMetaList : Tea.TeaModel {
                    public class ColumnMetaList : Tea.TeaModel {
                        public var columnActions: [String]?

                        public var columnComment: String?

                        public var columnName: String?

                        public var securityLevel: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.columnActions != nil {
                                map["ColumnActions"] = self.columnActions!
                            }
                            if self.columnComment != nil {
                                map["ColumnComment"] = self.columnComment!
                            }
                            if self.columnName != nil {
                                map["ColumnName"] = self.columnName!
                            }
                            if self.securityLevel != nil {
                                map["SecurityLevel"] = self.securityLevel!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["ColumnActions"] as? [String] {
                                self.columnActions = value
                            }
                            if let value = dict["ColumnComment"] as? String {
                                self.columnComment = value
                            }
                            if let value = dict["ColumnName"] as? String {
                                self.columnName = value
                            }
                            if let value = dict["SecurityLevel"] as? String {
                                self.securityLevel = value
                            }
                        }
                    }
                    public var actions: [String]?

                    public var columnMetaList: [GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent.ProjectMeta.ObjectMetaList.ColumnMetaList]?

                    public var objectName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.actions != nil {
                            map["Actions"] = self.actions!
                        }
                        if self.columnMetaList != nil {
                            var tmp : [Any] = []
                            for k in self.columnMetaList! {
                                tmp.append(k.toMap())
                            }
                            map["ColumnMetaList"] = tmp
                        }
                        if self.objectName != nil {
                            map["ObjectName"] = self.objectName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Actions"] as? [String] {
                            self.actions = value
                        }
                        if let value = dict["ColumnMetaList"] as? [Any?] {
                            var tmp : [GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent.ProjectMeta.ObjectMetaList.ColumnMetaList] = []
                            for v in value {
                                if v != nil {
                                    var model = GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent.ProjectMeta.ObjectMetaList.ColumnMetaList()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.columnMetaList = tmp
                        }
                        if let value = dict["ObjectName"] as? String {
                            self.objectName = value
                        }
                    }
                }
                public var maxComputeProjectName: String?

                public var objectMetaList: [GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent.ProjectMeta.ObjectMetaList]?

                public var workspaceId: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxComputeProjectName != nil {
                        map["MaxComputeProjectName"] = self.maxComputeProjectName!
                    }
                    if self.objectMetaList != nil {
                        var tmp : [Any] = []
                        for k in self.objectMetaList! {
                            tmp.append(k.toMap())
                        }
                        map["ObjectMetaList"] = tmp
                    }
                    if self.workspaceId != nil {
                        map["WorkspaceId"] = self.workspaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MaxComputeProjectName"] as? String {
                        self.maxComputeProjectName = value
                    }
                    if let value = dict["ObjectMetaList"] as? [Any?] {
                        var tmp : [GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent.ProjectMeta.ObjectMetaList] = []
                        for v in value {
                            if v != nil {
                                var model = GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent.ProjectMeta.ObjectMetaList()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.objectMetaList = tmp
                    }
                    if let value = dict["WorkspaceId"] as? Int32 {
                        self.workspaceId = value
                    }
                }
            }
            public var applyReason: String?

            public var deadline: Int64?

            public var orderType: Int32?

            public var projectMeta: GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent.ProjectMeta?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.projectMeta?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applyReason != nil {
                    map["ApplyReason"] = self.applyReason!
                }
                if self.deadline != nil {
                    map["Deadline"] = self.deadline!
                }
                if self.orderType != nil {
                    map["OrderType"] = self.orderType!
                }
                if self.projectMeta != nil {
                    map["ProjectMeta"] = self.projectMeta?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ApplyReason"] as? String {
                    self.applyReason = value
                }
                if let value = dict["Deadline"] as? Int64 {
                    self.deadline = value
                }
                if let value = dict["OrderType"] as? Int32 {
                    self.orderType = value
                }
                if let value = dict["ProjectMeta"] as? [String: Any?] {
                    var model = GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent.ProjectMeta()
                    model.fromMap(value)
                    self.projectMeta = model
                }
            }
        }
        public class GranteeObjectList : Tea.TeaModel {
            public var granteeId: String?

            public var granteeName: String?

            public var granteeType: Int32?

            public var granteeTypeSub: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.granteeId != nil {
                    map["GranteeId"] = self.granteeId!
                }
                if self.granteeName != nil {
                    map["GranteeName"] = self.granteeName!
                }
                if self.granteeType != nil {
                    map["GranteeType"] = self.granteeType!
                }
                if self.granteeTypeSub != nil {
                    map["GranteeTypeSub"] = self.granteeTypeSub!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["GranteeId"] as? String {
                    self.granteeId = value
                }
                if let value = dict["GranteeName"] as? String {
                    self.granteeName = value
                }
                if let value = dict["GranteeType"] as? Int32 {
                    self.granteeType = value
                }
                if let value = dict["GranteeTypeSub"] as? Int32 {
                    self.granteeTypeSub = value
                }
            }
        }
        public var applyBaseId: String?

        public var applyTimestamp: Int64?

        public var approveAccountList: [GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveAccountList]?

        public var approveContent: GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent?

        public var flowId: String?

        public var flowStatus: Int32?

        public var granteeObjectList: [GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.GranteeObjectList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.approveContent?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applyBaseId != nil {
                map["ApplyBaseId"] = self.applyBaseId!
            }
            if self.applyTimestamp != nil {
                map["ApplyTimestamp"] = self.applyTimestamp!
            }
            if self.approveAccountList != nil {
                var tmp : [Any] = []
                for k in self.approveAccountList! {
                    tmp.append(k.toMap())
                }
                map["ApproveAccountList"] = tmp
            }
            if self.approveContent != nil {
                map["ApproveContent"] = self.approveContent?.toMap()
            }
            if self.flowId != nil {
                map["FlowId"] = self.flowId!
            }
            if self.flowStatus != nil {
                map["FlowStatus"] = self.flowStatus!
            }
            if self.granteeObjectList != nil {
                var tmp : [Any] = []
                for k in self.granteeObjectList! {
                    tmp.append(k.toMap())
                }
                map["GranteeObjectList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApplyBaseId"] as? String {
                self.applyBaseId = value
            }
            if let value = dict["ApplyTimestamp"] as? Int64 {
                self.applyTimestamp = value
            }
            if let value = dict["ApproveAccountList"] as? [Any?] {
                var tmp : [GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveAccountList] = []
                for v in value {
                    if v != nil {
                        var model = GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveAccountList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.approveAccountList = tmp
            }
            if let value = dict["ApproveContent"] as? [String: Any?] {
                var model = GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.ApproveContent()
                model.fromMap(value)
                self.approveContent = model
            }
            if let value = dict["FlowId"] as? String {
                self.flowId = value
            }
            if let value = dict["FlowStatus"] as? Int32 {
                self.flowStatus = value
            }
            if let value = dict["GranteeObjectList"] as? [Any?] {
                var tmp : [GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.GranteeObjectList] = []
                for v in value {
                    if v != nil {
                        var model = GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail.GranteeObjectList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.granteeObjectList = tmp
            }
        }
    }
    public var applyOrderDetail: GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applyOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applyOrderDetail != nil {
            map["ApplyOrderDetail"] = self.applyOrderDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplyOrderDetail"] as? [String: Any?] {
            var model = GetPermissionApplyOrderDetailResponseBody.ApplyOrderDetail()
            model.fromMap(value)
            self.applyOrderDetail = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetPermissionApplyOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPermissionApplyOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPermissionApplyOrderDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetProjectRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class GetProjectResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var appkey: String?

        public var baseProject: Bool?

        public var defaultDiResourceGroupIdentifier: String?

        public var destination: Int32?

        public var devStorageQuota: String?

        public var developmentType: Int32?

        public var disableDevelopment: Bool?

        public var envTypes: [String]?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var isAllowDownload: Int32?

        public var isDefault: Int32?

        public var maxFlowNode: Int32?

        public var prodStorageQuota: String?

        public var projectDescription: String?

        public var projectId: Int32?

        public var projectIdentifier: String?

        public var projectMode: Int32?

        public var projectName: String?

        public var projectOwnerBaseId: String?

        public var protectedMode: Int32?

        public var residentArea: String?

        public var resourceManagerResourceGroupId: String?

        public var schedulerMaxRetryTimes: Int32?

        public var schedulerRetryInterval: Int32?

        public var status: Int32?

        public var tablePrivacyMode: Int32?

        public var tags: [GetProjectResponseBody.Data.Tags]?

        public var tenantId: Int64?

        public var useProxyOdpsAccount: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appkey != nil {
                map["Appkey"] = self.appkey!
            }
            if self.baseProject != nil {
                map["BaseProject"] = self.baseProject!
            }
            if self.defaultDiResourceGroupIdentifier != nil {
                map["DefaultDiResourceGroupIdentifier"] = self.defaultDiResourceGroupIdentifier!
            }
            if self.destination != nil {
                map["Destination"] = self.destination!
            }
            if self.devStorageQuota != nil {
                map["DevStorageQuota"] = self.devStorageQuota!
            }
            if self.developmentType != nil {
                map["DevelopmentType"] = self.developmentType!
            }
            if self.disableDevelopment != nil {
                map["DisableDevelopment"] = self.disableDevelopment!
            }
            if self.envTypes != nil {
                map["EnvTypes"] = self.envTypes!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.isAllowDownload != nil {
                map["IsAllowDownload"] = self.isAllowDownload!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.maxFlowNode != nil {
                map["MaxFlowNode"] = self.maxFlowNode!
            }
            if self.prodStorageQuota != nil {
                map["ProdStorageQuota"] = self.prodStorageQuota!
            }
            if self.projectDescription != nil {
                map["ProjectDescription"] = self.projectDescription!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectIdentifier != nil {
                map["ProjectIdentifier"] = self.projectIdentifier!
            }
            if self.projectMode != nil {
                map["ProjectMode"] = self.projectMode!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.projectOwnerBaseId != nil {
                map["ProjectOwnerBaseId"] = self.projectOwnerBaseId!
            }
            if self.protectedMode != nil {
                map["ProtectedMode"] = self.protectedMode!
            }
            if self.residentArea != nil {
                map["ResidentArea"] = self.residentArea!
            }
            if self.resourceManagerResourceGroupId != nil {
                map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
            }
            if self.schedulerMaxRetryTimes != nil {
                map["SchedulerMaxRetryTimes"] = self.schedulerMaxRetryTimes!
            }
            if self.schedulerRetryInterval != nil {
                map["SchedulerRetryInterval"] = self.schedulerRetryInterval!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tablePrivacyMode != nil {
                map["TablePrivacyMode"] = self.tablePrivacyMode!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.useProxyOdpsAccount != nil {
                map["UseProxyOdpsAccount"] = self.useProxyOdpsAccount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Appkey"] as? String {
                self.appkey = value
            }
            if let value = dict["BaseProject"] as? Bool {
                self.baseProject = value
            }
            if let value = dict["DefaultDiResourceGroupIdentifier"] as? String {
                self.defaultDiResourceGroupIdentifier = value
            }
            if let value = dict["Destination"] as? Int32 {
                self.destination = value
            }
            if let value = dict["DevStorageQuota"] as? String {
                self.devStorageQuota = value
            }
            if let value = dict["DevelopmentType"] as? Int32 {
                self.developmentType = value
            }
            if let value = dict["DisableDevelopment"] as? Bool {
                self.disableDevelopment = value
            }
            if let value = dict["EnvTypes"] as? [String] {
                self.envTypes = value
            }
            if let value = dict["GmtCreate"] as? String {
                self.gmtCreate = value
            }
            if let value = dict["GmtModified"] as? String {
                self.gmtModified = value
            }
            if let value = dict["IsAllowDownload"] as? Int32 {
                self.isAllowDownload = value
            }
            if let value = dict["IsDefault"] as? Int32 {
                self.isDefault = value
            }
            if let value = dict["MaxFlowNode"] as? Int32 {
                self.maxFlowNode = value
            }
            if let value = dict["ProdStorageQuota"] as? String {
                self.prodStorageQuota = value
            }
            if let value = dict["ProjectDescription"] as? String {
                self.projectDescription = value
            }
            if let value = dict["ProjectId"] as? Int32 {
                self.projectId = value
            }
            if let value = dict["ProjectIdentifier"] as? String {
                self.projectIdentifier = value
            }
            if let value = dict["ProjectMode"] as? Int32 {
                self.projectMode = value
            }
            if let value = dict["ProjectName"] as? String {
                self.projectName = value
            }
            if let value = dict["ProjectOwnerBaseId"] as? String {
                self.projectOwnerBaseId = value
            }
            if let value = dict["ProtectedMode"] as? Int32 {
                self.protectedMode = value
            }
            if let value = dict["ResidentArea"] as? String {
                self.residentArea = value
            }
            if let value = dict["ResourceManagerResourceGroupId"] as? String {
                self.resourceManagerResourceGroupId = value
            }
            if let value = dict["SchedulerMaxRetryTimes"] as? Int32 {
                self.schedulerMaxRetryTimes = value
            }
            if let value = dict["SchedulerRetryInterval"] as? Int32 {
                self.schedulerRetryInterval = value
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
            if let value = dict["TablePrivacyMode"] as? Int32 {
                self.tablePrivacyMode = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [GetProjectResponseBody.Data.Tags] = []
                for v in value {
                    if v != nil {
                        var model = GetProjectResponseBody.Data.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TenantId"] as? Int64 {
                self.tenantId = value
            }
            if let value = dict["UseProxyOdpsAccount"] as? Bool {
                self.useProxyOdpsAccount = value
            }
        }
    }
    public var data: GetProjectResponseBody.Data?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetProjectResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetProjectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetProjectDetailRequest : Tea.TeaModel {
    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetProjectDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var defaultDiResourceGroupIdentifier: String?

        public var developmentType: Int32?

        public var disableDevelopment: Bool?

        public var envTypes: [String]?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var isAllowDownload: Int32?

        public var isDefault: Int32?

        public var projectDescription: String?

        public var projectId: Int32?

        public var projectIdentifier: String?

        public var projectMode: Int32?

        public var projectName: String?

        public var projectOwnerBaseId: String?

        public var protectedMode: Int32?

        public var residentArea: String?

        public var resourceManagerResourceGroupId: String?

        public var schedulerMaxRetryTimes: Int32?

        public var schedulerRetryInterval: Int32?

        public var status: Int32?

        public var tablePrivacyMode: Int32?

        public var tags: [GetProjectDetailResponseBody.Data.Tags]?

        public var tenantId: Int64?

        public var useProxyOdpsAccount: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultDiResourceGroupIdentifier != nil {
                map["DefaultDiResourceGroupIdentifier"] = self.defaultDiResourceGroupIdentifier!
            }
            if self.developmentType != nil {
                map["DevelopmentType"] = self.developmentType!
            }
            if self.disableDevelopment != nil {
                map["DisableDevelopment"] = self.disableDevelopment!
            }
            if self.envTypes != nil {
                map["EnvTypes"] = self.envTypes!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.isAllowDownload != nil {
                map["IsAllowDownload"] = self.isAllowDownload!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.projectDescription != nil {
                map["ProjectDescription"] = self.projectDescription!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectIdentifier != nil {
                map["ProjectIdentifier"] = self.projectIdentifier!
            }
            if self.projectMode != nil {
                map["ProjectMode"] = self.projectMode!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.projectOwnerBaseId != nil {
                map["ProjectOwnerBaseId"] = self.projectOwnerBaseId!
            }
            if self.protectedMode != nil {
                map["ProtectedMode"] = self.protectedMode!
            }
            if self.residentArea != nil {
                map["ResidentArea"] = self.residentArea!
            }
            if self.resourceManagerResourceGroupId != nil {
                map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
            }
            if self.schedulerMaxRetryTimes != nil {
                map["SchedulerMaxRetryTimes"] = self.schedulerMaxRetryTimes!
            }
            if self.schedulerRetryInterval != nil {
                map["SchedulerRetryInterval"] = self.schedulerRetryInterval!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tablePrivacyMode != nil {
                map["TablePrivacyMode"] = self.tablePrivacyMode!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.useProxyOdpsAccount != nil {
                map["UseProxyOdpsAccount"] = self.useProxyOdpsAccount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DefaultDiResourceGroupIdentifier"] as? String {
                self.defaultDiResourceGroupIdentifier = value
            }
            if let value = dict["DevelopmentType"] as? Int32 {
                self.developmentType = value
            }
            if let value = dict["DisableDevelopment"] as? Bool {
                self.disableDevelopment = value
            }
            if let value = dict["EnvTypes"] as? [String] {
                self.envTypes = value
            }
            if let value = dict["GmtCreate"] as? String {
                self.gmtCreate = value
            }
            if let value = dict["GmtModified"] as? String {
                self.gmtModified = value
            }
            if let value = dict["IsAllowDownload"] as? Int32 {
                self.isAllowDownload = value
            }
            if let value = dict["IsDefault"] as? Int32 {
                self.isDefault = value
            }
            if let value = dict["ProjectDescription"] as? String {
                self.projectDescription = value
            }
            if let value = dict["ProjectId"] as? Int32 {
                self.projectId = value
            }
            if let value = dict["ProjectIdentifier"] as? String {
                self.projectIdentifier = value
            }
            if let value = dict["ProjectMode"] as? Int32 {
                self.projectMode = value
            }
            if let value = dict["ProjectName"] as? String {
                self.projectName = value
            }
            if let value = dict["ProjectOwnerBaseId"] as? String {
                self.projectOwnerBaseId = value
            }
            if let value = dict["ProtectedMode"] as? Int32 {
                self.protectedMode = value
            }
            if let value = dict["ResidentArea"] as? String {
                self.residentArea = value
            }
            if let value = dict["ResourceManagerResourceGroupId"] as? String {
                self.resourceManagerResourceGroupId = value
            }
            if let value = dict["SchedulerMaxRetryTimes"] as? Int32 {
                self.schedulerMaxRetryTimes = value
            }
            if let value = dict["SchedulerRetryInterval"] as? Int32 {
                self.schedulerRetryInterval = value
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
            if let value = dict["TablePrivacyMode"] as? Int32 {
                self.tablePrivacyMode = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [GetProjectDetailResponseBody.Data.Tags] = []
                for v in value {
                    if v != nil {
                        var model = GetProjectDetailResponseBody.Data.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TenantId"] as? Int64 {
                self.tenantId = value
            }
            if let value = dict["UseProxyOdpsAccount"] as? Bool {
                self.useProxyOdpsAccount = value
            }
        }
    }
    public var data: GetProjectDetailResponseBody.Data?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetProjectDetailResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetProjectDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProjectDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetProjectDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetQualityEntityRequest : Tea.TeaModel {
    public var envType: String?

    public var matchExpression: String?

    public var projectId: Int64?

    public var projectName: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.matchExpression != nil {
            map["MatchExpression"] = self.matchExpression!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["MatchExpression"] as? String {
            self.matchExpression = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class GetQualityEntityResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createTime: Int64?

        public var entityLevel: Int32?

        public var envType: String?

        public var followers: String?

        public var hasRelativeNode: Bool?

        public var id: Int64?

        public var matchExpression: String?

        public var modifyTime: Int64?

        public var modifyUser: String?

        public var onDuty: String?

        public var onDutyAccountName: String?

        public var projectName: String?

        public var relativeNode: String?

        public var sql: Int32?

        public var tableName: String?

        public var task: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.entityLevel != nil {
                map["EntityLevel"] = self.entityLevel!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.followers != nil {
                map["Followers"] = self.followers!
            }
            if self.hasRelativeNode != nil {
                map["HasRelativeNode"] = self.hasRelativeNode!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchExpression != nil {
                map["MatchExpression"] = self.matchExpression!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser!
            }
            if self.onDuty != nil {
                map["OnDuty"] = self.onDuty!
            }
            if self.onDutyAccountName != nil {
                map["OnDutyAccountName"] = self.onDutyAccountName!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.relativeNode != nil {
                map["RelativeNode"] = self.relativeNode!
            }
            if self.sql != nil {
                map["Sql"] = self.sql!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.task != nil {
                map["Task"] = self.task!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["EntityLevel"] as? Int32 {
                self.entityLevel = value
            }
            if let value = dict["EnvType"] as? String {
                self.envType = value
            }
            if let value = dict["Followers"] as? String {
                self.followers = value
            }
            if let value = dict["HasRelativeNode"] as? Bool {
                self.hasRelativeNode = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["MatchExpression"] as? String {
                self.matchExpression = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["ModifyUser"] as? String {
                self.modifyUser = value
            }
            if let value = dict["OnDuty"] as? String {
                self.onDuty = value
            }
            if let value = dict["OnDutyAccountName"] as? String {
                self.onDutyAccountName = value
            }
            if let value = dict["ProjectName"] as? String {
                self.projectName = value
            }
            if let value = dict["RelativeNode"] as? String {
                self.relativeNode = value
            }
            if let value = dict["Sql"] as? Int32 {
                self.sql = value
            }
            if let value = dict["TableName"] as? String {
                self.tableName = value
            }
            if let value = dict["Task"] as? Int32 {
                self.task = value
            }
        }
    }
    public var data: [GetQualityEntityResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [GetQualityEntityResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = GetQualityEntityResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetQualityEntityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQualityEntityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetQualityEntityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetQualityFollowerRequest : Tea.TeaModel {
    public var entityId: Int64?

    public var projectId: Int64?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EntityId"] as? Int64 {
            self.entityId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
    }
}

public class GetQualityFollowerResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var alarmMode: Int32?

        public var createTime: Int64?

        public var entityId: String?

        public var follower: String?

        public var followerAccountName: String?

        public var id: Int64?

        public var modifyTime: Int64?

        public var projectName: String?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmMode != nil {
                map["AlarmMode"] = self.alarmMode!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.entityId != nil {
                map["EntityId"] = self.entityId!
            }
            if self.follower != nil {
                map["Follower"] = self.follower!
            }
            if self.followerAccountName != nil {
                map["FollowerAccountName"] = self.followerAccountName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlarmMode"] as? Int32 {
                self.alarmMode = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["EntityId"] as? String {
                self.entityId = value
            }
            if let value = dict["Follower"] as? String {
                self.follower = value
            }
            if let value = dict["FollowerAccountName"] as? String {
                self.followerAccountName = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["ProjectName"] as? String {
                self.projectName = value
            }
            if let value = dict["TableName"] as? String {
                self.tableName = value
            }
        }
    }
    public var data: [GetQualityFollowerResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [GetQualityFollowerResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = GetQualityFollowerResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetQualityFollowerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQualityFollowerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetQualityFollowerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetQualityRuleRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var projectName: String?

    public var ruleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
        if let value = dict["RuleId"] as? Int64 {
            self.ruleId = value
        }
    }
}

public class GetQualityRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var blockType: Int32?

        public var checker: Int32?

        public var checkerName: String?

        public var comment: String?

        public var criticalThreshold: String?

        public var entityId: Int64?

        public var expectValue: String?

        public var fixCheck: Bool?

        public var id: Int64?

        public var methodId: Int32?

        public var methodName: String?

        public var onDuty: String?

        public var onDutyAccountName: String?

        public var openSwitch: Bool?

        public var operator_: String?

        public var predictType: Int32?

        public var property: String?

        public var ruleName: String?

        public var ruleType: Int32?

        public var taskSetting: String?

        public var templateId: Int32?

        public var templateName: String?

        public var trend: String?

        public var warningThreshold: String?

        public var whereCondition: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.blockType != nil {
                map["BlockType"] = self.blockType!
            }
            if self.checker != nil {
                map["Checker"] = self.checker!
            }
            if self.checkerName != nil {
                map["CheckerName"] = self.checkerName!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.criticalThreshold != nil {
                map["CriticalThreshold"] = self.criticalThreshold!
            }
            if self.entityId != nil {
                map["EntityId"] = self.entityId!
            }
            if self.expectValue != nil {
                map["ExpectValue"] = self.expectValue!
            }
            if self.fixCheck != nil {
                map["FixCheck"] = self.fixCheck!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.methodId != nil {
                map["MethodId"] = self.methodId!
            }
            if self.methodName != nil {
                map["MethodName"] = self.methodName!
            }
            if self.onDuty != nil {
                map["OnDuty"] = self.onDuty!
            }
            if self.onDutyAccountName != nil {
                map["OnDutyAccountName"] = self.onDutyAccountName!
            }
            if self.openSwitch != nil {
                map["OpenSwitch"] = self.openSwitch!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.predictType != nil {
                map["PredictType"] = self.predictType!
            }
            if self.property != nil {
                map["Property"] = self.property!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.ruleType != nil {
                map["RuleType"] = self.ruleType!
            }
            if self.taskSetting != nil {
                map["TaskSetting"] = self.taskSetting!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.trend != nil {
                map["Trend"] = self.trend!
            }
            if self.warningThreshold != nil {
                map["WarningThreshold"] = self.warningThreshold!
            }
            if self.whereCondition != nil {
                map["WhereCondition"] = self.whereCondition!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BlockType"] as? Int32 {
                self.blockType = value
            }
            if let value = dict["Checker"] as? Int32 {
                self.checker = value
            }
            if let value = dict["CheckerName"] as? String {
                self.checkerName = value
            }
            if let value = dict["Comment"] as? String {
                self.comment = value
            }
            if let value = dict["CriticalThreshold"] as? String {
                self.criticalThreshold = value
            }
            if let value = dict["EntityId"] as? Int64 {
                self.entityId = value
            }
            if let value = dict["ExpectValue"] as? String {
                self.expectValue = value
            }
            if let value = dict["FixCheck"] as? Bool {
                self.fixCheck = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["MethodId"] as? Int32 {
                self.methodId = value
            }
            if let value = dict["MethodName"] as? String {
                self.methodName = value
            }
            if let value = dict["OnDuty"] as? String {
                self.onDuty = value
            }
            if let value = dict["OnDutyAccountName"] as? String {
                self.onDutyAccountName = value
            }
            if let value = dict["OpenSwitch"] as? Bool {
                self.openSwitch = value
            }
            if let value = dict["Operator"] as? String {
                self.operator_ = value
            }
            if let value = dict["PredictType"] as? Int32 {
                self.predictType = value
            }
            if let value = dict["Property"] as? String {
                self.property = value
            }
            if let value = dict["RuleName"] as? String {
                self.ruleName = value
            }
            if let value = dict["RuleType"] as? Int32 {
                self.ruleType = value
            }
            if let value = dict["TaskSetting"] as? String {
                self.taskSetting = value
            }
            if let value = dict["TemplateId"] as? Int32 {
                self.templateId = value
            }
            if let value = dict["TemplateName"] as? String {
                self.templateName = value
            }
            if let value = dict["Trend"] as? String {
                self.trend = value
            }
            if let value = dict["WarningThreshold"] as? String {
                self.warningThreshold = value
            }
            if let value = dict["WhereCondition"] as? String {
                self.whereCondition = value
            }
        }
    }
    public var data: GetQualityRuleResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetQualityRuleResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetQualityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQualityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetQualityRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetRemindRequest : Tea.TeaModel {
    public var remindId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remindId != nil {
            map["RemindId"] = self.remindId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RemindId"] as? Int64 {
            self.remindId = value
        }
    }
}

public class GetRemindResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Baselines : Tea.TeaModel {
            public var baselineId: Int64?

            public var baselineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.baselineName != nil {
                    map["BaselineName"] = self.baselineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["BaselineName"] as? String {
                    self.baselineName = value
                }
            }
        }
        public class BizProcesses : Tea.TeaModel {
            public var bizId: Int64?

            public var bizProcessName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.bizProcessName != nil {
                    map["BizProcessName"] = self.bizProcessName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BizId"] as? Int64 {
                    self.bizId = value
                }
                if let value = dict["BizProcessName"] as? String {
                    self.bizProcessName = value
                }
            }
        }
        public class Nodes : Tea.TeaModel {
            public var nodeId: Int64?

            public var nodeName: String?

            public var owner: String?

            public var projectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
            }
        }
        public class Projects : Tea.TeaModel {
            public var projectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
            }
        }
        public class Receivers : Tea.TeaModel {
            public var alertTargets: [String]?

            public var alertUnit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertTargets != nil {
                    map["AlertTargets"] = self.alertTargets!
                }
                if self.alertUnit != nil {
                    map["AlertUnit"] = self.alertUnit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AlertTargets"] as? [String] {
                    self.alertTargets = value
                }
                if let value = dict["AlertUnit"] as? String {
                    self.alertUnit = value
                }
            }
        }
        public class Robots : Tea.TeaModel {
            public var atAll: Bool?

            public var webUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.atAll != nil {
                    map["AtAll"] = self.atAll!
                }
                if self.webUrl != nil {
                    map["WebUrl"] = self.webUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AtAll"] as? Bool {
                    self.atAll = value
                }
                if let value = dict["WebUrl"] as? String {
                    self.webUrl = value
                }
            }
        }
        public var alertInterval: Int32?

        public var alertMethods: [String]?

        public var alertTargets: [String]?

        public var alertUnit: String?

        public var allowNodes: [Int64]?

        public var baselines: [GetRemindResponseBody.Data.Baselines]?

        public var bizProcesses: [GetRemindResponseBody.Data.BizProcesses]?

        public var detail: String?

        public var dndEnd: String?

        public var dndStart: String?

        public var founder: String?

        public var maxAlertTimes: Int32?

        public var nodes: [GetRemindResponseBody.Data.Nodes]?

        public var projects: [GetRemindResponseBody.Data.Projects]?

        public var receivers: [GetRemindResponseBody.Data.Receivers]?

        public var remindId: Int64?

        public var remindName: String?

        public var remindType: String?

        public var remindUnit: String?

        public var robots: [GetRemindResponseBody.Data.Robots]?

        public var useflag: Bool?

        public var webhooks: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertInterval != nil {
                map["AlertInterval"] = self.alertInterval!
            }
            if self.alertMethods != nil {
                map["AlertMethods"] = self.alertMethods!
            }
            if self.alertTargets != nil {
                map["AlertTargets"] = self.alertTargets!
            }
            if self.alertUnit != nil {
                map["AlertUnit"] = self.alertUnit!
            }
            if self.allowNodes != nil {
                map["AllowNodes"] = self.allowNodes!
            }
            if self.baselines != nil {
                var tmp : [Any] = []
                for k in self.baselines! {
                    tmp.append(k.toMap())
                }
                map["Baselines"] = tmp
            }
            if self.bizProcesses != nil {
                var tmp : [Any] = []
                for k in self.bizProcesses! {
                    tmp.append(k.toMap())
                }
                map["BizProcesses"] = tmp
            }
            if self.detail != nil {
                map["Detail"] = self.detail!
            }
            if self.dndEnd != nil {
                map["DndEnd"] = self.dndEnd!
            }
            if self.dndStart != nil {
                map["DndStart"] = self.dndStart!
            }
            if self.founder != nil {
                map["Founder"] = self.founder!
            }
            if self.maxAlertTimes != nil {
                map["MaxAlertTimes"] = self.maxAlertTimes!
            }
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            if self.projects != nil {
                var tmp : [Any] = []
                for k in self.projects! {
                    tmp.append(k.toMap())
                }
                map["Projects"] = tmp
            }
            if self.receivers != nil {
                var tmp : [Any] = []
                for k in self.receivers! {
                    tmp.append(k.toMap())
                }
                map["Receivers"] = tmp
            }
            if self.remindId != nil {
                map["RemindId"] = self.remindId!
            }
            if self.remindName != nil {
                map["RemindName"] = self.remindName!
            }
            if self.remindType != nil {
                map["RemindType"] = self.remindType!
            }
            if self.remindUnit != nil {
                map["RemindUnit"] = self.remindUnit!
            }
            if self.robots != nil {
                var tmp : [Any] = []
                for k in self.robots! {
                    tmp.append(k.toMap())
                }
                map["Robots"] = tmp
            }
            if self.useflag != nil {
                map["Useflag"] = self.useflag!
            }
            if self.webhooks != nil {
                map["Webhooks"] = self.webhooks!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlertInterval"] as? Int32 {
                self.alertInterval = value
            }
            if let value = dict["AlertMethods"] as? [String] {
                self.alertMethods = value
            }
            if let value = dict["AlertTargets"] as? [String] {
                self.alertTargets = value
            }
            if let value = dict["AlertUnit"] as? String {
                self.alertUnit = value
            }
            if let value = dict["AllowNodes"] as? [Int64] {
                self.allowNodes = value
            }
            if let value = dict["Baselines"] as? [Any?] {
                var tmp : [GetRemindResponseBody.Data.Baselines] = []
                for v in value {
                    if v != nil {
                        var model = GetRemindResponseBody.Data.Baselines()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.baselines = tmp
            }
            if let value = dict["BizProcesses"] as? [Any?] {
                var tmp : [GetRemindResponseBody.Data.BizProcesses] = []
                for v in value {
                    if v != nil {
                        var model = GetRemindResponseBody.Data.BizProcesses()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.bizProcesses = tmp
            }
            if let value = dict["Detail"] as? String {
                self.detail = value
            }
            if let value = dict["DndEnd"] as? String {
                self.dndEnd = value
            }
            if let value = dict["DndStart"] as? String {
                self.dndStart = value
            }
            if let value = dict["Founder"] as? String {
                self.founder = value
            }
            if let value = dict["MaxAlertTimes"] as? Int32 {
                self.maxAlertTimes = value
            }
            if let value = dict["Nodes"] as? [Any?] {
                var tmp : [GetRemindResponseBody.Data.Nodes] = []
                for v in value {
                    if v != nil {
                        var model = GetRemindResponseBody.Data.Nodes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.nodes = tmp
            }
            if let value = dict["Projects"] as? [Any?] {
                var tmp : [GetRemindResponseBody.Data.Projects] = []
                for v in value {
                    if v != nil {
                        var model = GetRemindResponseBody.Data.Projects()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.projects = tmp
            }
            if let value = dict["Receivers"] as? [Any?] {
                var tmp : [GetRemindResponseBody.Data.Receivers] = []
                for v in value {
                    if v != nil {
                        var model = GetRemindResponseBody.Data.Receivers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.receivers = tmp
            }
            if let value = dict["RemindId"] as? Int64 {
                self.remindId = value
            }
            if let value = dict["RemindName"] as? String {
                self.remindName = value
            }
            if let value = dict["RemindType"] as? String {
                self.remindType = value
            }
            if let value = dict["RemindUnit"] as? String {
                self.remindUnit = value
            }
            if let value = dict["Robots"] as? [Any?] {
                var tmp : [GetRemindResponseBody.Data.Robots] = []
                for v in value {
                    if v != nil {
                        var model = GetRemindResponseBody.Data.Robots()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.robots = tmp
            }
            if let value = dict["Useflag"] as? Bool {
                self.useflag = value
            }
            if let value = dict["Webhooks"] as? [String] {
                self.webhooks = value
            }
        }
    }
    public var data: GetRemindResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetRemindResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetRemindResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRemindResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetRemindResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSensitiveDataRequest : Tea.TeaModel {
    public var name: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class GetSensitiveDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var sensitiveData: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sensitiveData != nil {
            map["SensitiveData"] = self.sensitiveData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SensitiveData"] as? [String: Any] {
            self.sensitiveData = value
        }
    }
}

public class GetSensitiveDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSensitiveDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSensitiveDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSuccessInstanceTrendRequest : Tea.TeaModel {
    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetSuccessInstanceTrendResponseBody : Tea.TeaModel {
    public class InstanceStatusTrend : Tea.TeaModel {
        public class AvgTrend : Tea.TeaModel {
            public var count: Int32?

            public var timePoint: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timePoint != nil {
                    map["TimePoint"] = self.timePoint!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int32 {
                    self.count = value
                }
                if let value = dict["TimePoint"] as? String {
                    self.timePoint = value
                }
            }
        }
        public class TodayTrend : Tea.TeaModel {
            public var count: Int32?

            public var timePoint: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timePoint != nil {
                    map["TimePoint"] = self.timePoint!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int32 {
                    self.count = value
                }
                if let value = dict["TimePoint"] as? String {
                    self.timePoint = value
                }
            }
        }
        public class YesterdayTrend : Tea.TeaModel {
            public var count: Int32?

            public var timePoint: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timePoint != nil {
                    map["TimePoint"] = self.timePoint!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int32 {
                    self.count = value
                }
                if let value = dict["TimePoint"] as? String {
                    self.timePoint = value
                }
            }
        }
        public var avgTrend: [GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.AvgTrend]?

        public var todayTrend: [GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.TodayTrend]?

        public var yesterdayTrend: [GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.YesterdayTrend]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avgTrend != nil {
                var tmp : [Any] = []
                for k in self.avgTrend! {
                    tmp.append(k.toMap())
                }
                map["AvgTrend"] = tmp
            }
            if self.todayTrend != nil {
                var tmp : [Any] = []
                for k in self.todayTrend! {
                    tmp.append(k.toMap())
                }
                map["TodayTrend"] = tmp
            }
            if self.yesterdayTrend != nil {
                var tmp : [Any] = []
                for k in self.yesterdayTrend! {
                    tmp.append(k.toMap())
                }
                map["YesterdayTrend"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AvgTrend"] as? [Any?] {
                var tmp : [GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.AvgTrend] = []
                for v in value {
                    if v != nil {
                        var model = GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.AvgTrend()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.avgTrend = tmp
            }
            if let value = dict["TodayTrend"] as? [Any?] {
                var tmp : [GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.TodayTrend] = []
                for v in value {
                    if v != nil {
                        var model = GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.TodayTrend()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.todayTrend = tmp
            }
            if let value = dict["YesterdayTrend"] as? [Any?] {
                var tmp : [GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.YesterdayTrend] = []
                for v in value {
                    if v != nil {
                        var model = GetSuccessInstanceTrendResponseBody.InstanceStatusTrend.YesterdayTrend()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.yesterdayTrend = tmp
            }
        }
    }
    public var instanceStatusTrend: GetSuccessInstanceTrendResponseBody.InstanceStatusTrend?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceStatusTrend?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceStatusTrend != nil {
            map["InstanceStatusTrend"] = self.instanceStatusTrend?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceStatusTrend"] as? [String: Any?] {
            var model = GetSuccessInstanceTrendResponseBody.InstanceStatusTrend()
            model.fromMap(value)
            self.instanceStatusTrend = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetSuccessInstanceTrendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSuccessInstanceTrendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSuccessInstanceTrendResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetTopicRequest : Tea.TeaModel {
    public var topicId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.topicId != nil {
            map["TopicId"] = self.topicId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TopicId"] as? Int64 {
            self.topicId = value
        }
    }
}

public class GetTopicResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var addTime: Int64?

        public var alertTime: Int64?

        public var assigner: String?

        public var baselineBuffer: Int64?

        public var baselineId: Int64?

        public var baselineInGroupId: Int32?

        public var baselineName: String?

        public var baselineStatus: String?

        public var buffer: Int64?

        public var dealTime: Int64?

        public var dealUser: String?

        public var fixTime: Int64?

        public var happenTime: Int64?

        public var instanceId: Int64?

        public var nextAlertTime: Int64?

        public var nodeId: Int64?

        public var nodeName: String?

        public var owner: String?

        public var projectId: Int64?

        public var topicId: Int64?

        public var topicName: String?

        public var topicStatus: String?

        public var topicType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addTime != nil {
                map["AddTime"] = self.addTime!
            }
            if self.alertTime != nil {
                map["AlertTime"] = self.alertTime!
            }
            if self.assigner != nil {
                map["Assigner"] = self.assigner!
            }
            if self.baselineBuffer != nil {
                map["BaselineBuffer"] = self.baselineBuffer!
            }
            if self.baselineId != nil {
                map["BaselineId"] = self.baselineId!
            }
            if self.baselineInGroupId != nil {
                map["BaselineInGroupId"] = self.baselineInGroupId!
            }
            if self.baselineName != nil {
                map["BaselineName"] = self.baselineName!
            }
            if self.baselineStatus != nil {
                map["BaselineStatus"] = self.baselineStatus!
            }
            if self.buffer != nil {
                map["Buffer"] = self.buffer!
            }
            if self.dealTime != nil {
                map["DealTime"] = self.dealTime!
            }
            if self.dealUser != nil {
                map["DealUser"] = self.dealUser!
            }
            if self.fixTime != nil {
                map["FixTime"] = self.fixTime!
            }
            if self.happenTime != nil {
                map["HappenTime"] = self.happenTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.nextAlertTime != nil {
                map["NextAlertTime"] = self.nextAlertTime!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.topicId != nil {
                map["TopicId"] = self.topicId!
            }
            if self.topicName != nil {
                map["TopicName"] = self.topicName!
            }
            if self.topicStatus != nil {
                map["TopicStatus"] = self.topicStatus!
            }
            if self.topicType != nil {
                map["TopicType"] = self.topicType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AddTime"] as? Int64 {
                self.addTime = value
            }
            if let value = dict["AlertTime"] as? Int64 {
                self.alertTime = value
            }
            if let value = dict["Assigner"] as? String {
                self.assigner = value
            }
            if let value = dict["BaselineBuffer"] as? Int64 {
                self.baselineBuffer = value
            }
            if let value = dict["BaselineId"] as? Int64 {
                self.baselineId = value
            }
            if let value = dict["BaselineInGroupId"] as? Int32 {
                self.baselineInGroupId = value
            }
            if let value = dict["BaselineName"] as? String {
                self.baselineName = value
            }
            if let value = dict["BaselineStatus"] as? String {
                self.baselineStatus = value
            }
            if let value = dict["Buffer"] as? Int64 {
                self.buffer = value
            }
            if let value = dict["DealTime"] as? Int64 {
                self.dealTime = value
            }
            if let value = dict["DealUser"] as? String {
                self.dealUser = value
            }
            if let value = dict["FixTime"] as? Int64 {
                self.fixTime = value
            }
            if let value = dict["HappenTime"] as? Int64 {
                self.happenTime = value
            }
            if let value = dict["InstanceId"] as? Int64 {
                self.instanceId = value
            }
            if let value = dict["NextAlertTime"] as? Int64 {
                self.nextAlertTime = value
            }
            if let value = dict["NodeId"] as? Int64 {
                self.nodeId = value
            }
            if let value = dict["NodeName"] as? String {
                self.nodeName = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["TopicId"] as? Int64 {
                self.topicId = value
            }
            if let value = dict["TopicName"] as? String {
                self.topicName = value
            }
            if let value = dict["TopicStatus"] as? String {
                self.topicStatus = value
            }
            if let value = dict["TopicType"] as? String {
                self.topicType = value
            }
        }
    }
    public var data: GetTopicResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetTopicResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetTopicResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTopicResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetTopicResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetTopicInfluenceRequest : Tea.TeaModel {
    public var topicId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.topicId != nil {
            map["TopicId"] = self.topicId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TopicId"] as? Int64 {
            self.topicId = value
        }
    }
}

public class GetTopicInfluenceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Influences : Tea.TeaModel {
            public var baselineId: Int64?

            public var baselineName: String?

            public var bizdate: Int64?

            public var buffer: Int64?

            public var inGroupId: Int32?

            public var owner: String?

            public var priority: Int32?

            public var projectId: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.baselineName != nil {
                    map["BaselineName"] = self.baselineName!
                }
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.buffer != nil {
                    map["Buffer"] = self.buffer!
                }
                if self.inGroupId != nil {
                    map["InGroupId"] = self.inGroupId!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["BaselineName"] as? String {
                    self.baselineName = value
                }
                if let value = dict["Bizdate"] as? Int64 {
                    self.bizdate = value
                }
                if let value = dict["Buffer"] as? Int64 {
                    self.buffer = value
                }
                if let value = dict["InGroupId"] as? Int32 {
                    self.inGroupId = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var influences: [GetTopicInfluenceResponseBody.Data.Influences]?

        public var topicId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.influences != nil {
                var tmp : [Any] = []
                for k in self.influences! {
                    tmp.append(k.toMap())
                }
                map["Influences"] = tmp
            }
            if self.topicId != nil {
                map["TopicId"] = self.topicId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Influences"] as? [Any?] {
                var tmp : [GetTopicInfluenceResponseBody.Data.Influences] = []
                for v in value {
                    if v != nil {
                        var model = GetTopicInfluenceResponseBody.Data.Influences()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.influences = tmp
            }
            if let value = dict["TopicId"] as? Int64 {
                self.topicId = value
            }
        }
    }
    public var data: GetTopicInfluenceResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetTopicInfluenceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetTopicInfluenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTopicInfluenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetTopicInfluenceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ImportDataSourcesRequest : Tea.TeaModel {
    public var dataSources: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSources != nil {
            map["DataSources"] = self.dataSources!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataSources"] as? String {
            self.dataSources = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ImportDataSourcesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Status"] as? Bool {
                self.status = value
            }
        }
    }
    public var data: ImportDataSourcesResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ImportDataSourcesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ImportDataSourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportDataSourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ImportDataSourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAlertMessagesRequest : Tea.TeaModel {
    public var alertMethods: String?

    public var alertRuleTypes: String?

    public var alertUser: String?

    public var baselineId: Int64?

    public var beginTime: String?

    public var endTime: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remindId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertMethods != nil {
            map["AlertMethods"] = self.alertMethods!
        }
        if self.alertRuleTypes != nil {
            map["AlertRuleTypes"] = self.alertRuleTypes!
        }
        if self.alertUser != nil {
            map["AlertUser"] = self.alertUser!
        }
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remindId != nil {
            map["RemindId"] = self.remindId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlertMethods"] as? String {
            self.alertMethods = value
        }
        if let value = dict["AlertRuleTypes"] as? String {
            self.alertRuleTypes = value
        }
        if let value = dict["AlertUser"] as? String {
            self.alertUser = value
        }
        if let value = dict["BaselineId"] as? Int64 {
            self.baselineId = value
        }
        if let value = dict["BeginTime"] as? String {
            self.beginTime = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RemindId"] as? Int64 {
            self.remindId = value
        }
    }
}

public class ListAlertMessagesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AlertMessages : Tea.TeaModel {
            public class Instances : Tea.TeaModel {
                public var instanceId: Int64?

                public var nodeId: Int64?

                public var nodeName: String?

                public var projectId: Int64?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.nodeName != nil {
                        map["NodeName"] = self.nodeName!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["InstanceId"] as? Int64 {
                        self.instanceId = value
                    }
                    if let value = dict["NodeId"] as? Int64 {
                        self.nodeId = value
                    }
                    if let value = dict["NodeName"] as? String {
                        self.nodeName = value
                    }
                    if let value = dict["ProjectId"] as? Int64 {
                        self.projectId = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                }
            }
            public class Nodes : Tea.TeaModel {
                public var nodeId: Int64?

                public var nodeName: String?

                public var owner: String?

                public var projectId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.nodeName != nil {
                        map["NodeName"] = self.nodeName!
                    }
                    if self.owner != nil {
                        map["Owner"] = self.owner!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["NodeId"] as? Int64 {
                        self.nodeId = value
                    }
                    if let value = dict["NodeName"] as? String {
                        self.nodeName = value
                    }
                    if let value = dict["Owner"] as? String {
                        self.owner = value
                    }
                    if let value = dict["ProjectId"] as? Int64 {
                        self.projectId = value
                    }
                }
            }
            public class SlaAlert : Tea.TeaModel {
                public var baselineId: Int64?

                public var baselineName: String?

                public var baselineOwner: String?

                public var bizdate: Int64?

                public var inGroupId: Int32?

                public var projectId: Int64?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.baselineId != nil {
                        map["BaselineId"] = self.baselineId!
                    }
                    if self.baselineName != nil {
                        map["BaselineName"] = self.baselineName!
                    }
                    if self.baselineOwner != nil {
                        map["BaselineOwner"] = self.baselineOwner!
                    }
                    if self.bizdate != nil {
                        map["Bizdate"] = self.bizdate!
                    }
                    if self.inGroupId != nil {
                        map["InGroupId"] = self.inGroupId!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BaselineId"] as? Int64 {
                        self.baselineId = value
                    }
                    if let value = dict["BaselineName"] as? String {
                        self.baselineName = value
                    }
                    if let value = dict["BaselineOwner"] as? String {
                        self.baselineOwner = value
                    }
                    if let value = dict["Bizdate"] as? Int64 {
                        self.bizdate = value
                    }
                    if let value = dict["InGroupId"] as? Int32 {
                        self.inGroupId = value
                    }
                    if let value = dict["ProjectId"] as? Int64 {
                        self.projectId = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                }
            }
            public class Topics : Tea.TeaModel {
                public var instanceId: Int64?

                public var nodeId: Int64?

                public var topicId: Int64?

                public var topicName: String?

                public var topicOwner: String?

                public var topicStatus: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.topicId != nil {
                        map["TopicId"] = self.topicId!
                    }
                    if self.topicName != nil {
                        map["TopicName"] = self.topicName!
                    }
                    if self.topicOwner != nil {
                        map["TopicOwner"] = self.topicOwner!
                    }
                    if self.topicStatus != nil {
                        map["TopicStatus"] = self.topicStatus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["InstanceId"] as? Int64 {
                        self.instanceId = value
                    }
                    if let value = dict["NodeId"] as? Int64 {
                        self.nodeId = value
                    }
                    if let value = dict["TopicId"] as? Int64 {
                        self.topicId = value
                    }
                    if let value = dict["TopicName"] as? String {
                        self.topicName = value
                    }
                    if let value = dict["TopicOwner"] as? String {
                        self.topicOwner = value
                    }
                    if let value = dict["TopicStatus"] as? String {
                        self.topicStatus = value
                    }
                }
            }
            public var alertId: Int64?

            public var alertMessageStatus: String?

            public var alertMethod: String?

            public var alertTime: Int64?

            public var alertUser: String?

            public var content: String?

            public var instances: [ListAlertMessagesResponseBody.Data.AlertMessages.Instances]?

            public var nodes: [ListAlertMessagesResponseBody.Data.AlertMessages.Nodes]?

            public var remindId: Int64?

            public var remindName: String?

            public var slaAlert: ListAlertMessagesResponseBody.Data.AlertMessages.SlaAlert?

            public var source: String?

            public var topics: [ListAlertMessagesResponseBody.Data.AlertMessages.Topics]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.slaAlert?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertId != nil {
                    map["AlertId"] = self.alertId!
                }
                if self.alertMessageStatus != nil {
                    map["AlertMessageStatus"] = self.alertMessageStatus!
                }
                if self.alertMethod != nil {
                    map["AlertMethod"] = self.alertMethod!
                }
                if self.alertTime != nil {
                    map["AlertTime"] = self.alertTime!
                }
                if self.alertUser != nil {
                    map["AlertUser"] = self.alertUser!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.instances != nil {
                    var tmp : [Any] = []
                    for k in self.instances! {
                        tmp.append(k.toMap())
                    }
                    map["Instances"] = tmp
                }
                if self.nodes != nil {
                    var tmp : [Any] = []
                    for k in self.nodes! {
                        tmp.append(k.toMap())
                    }
                    map["Nodes"] = tmp
                }
                if self.remindId != nil {
                    map["RemindId"] = self.remindId!
                }
                if self.remindName != nil {
                    map["RemindName"] = self.remindName!
                }
                if self.slaAlert != nil {
                    map["SlaAlert"] = self.slaAlert?.toMap()
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.topics != nil {
                    var tmp : [Any] = []
                    for k in self.topics! {
                        tmp.append(k.toMap())
                    }
                    map["Topics"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AlertId"] as? Int64 {
                    self.alertId = value
                }
                if let value = dict["AlertMessageStatus"] as? String {
                    self.alertMessageStatus = value
                }
                if let value = dict["AlertMethod"] as? String {
                    self.alertMethod = value
                }
                if let value = dict["AlertTime"] as? Int64 {
                    self.alertTime = value
                }
                if let value = dict["AlertUser"] as? String {
                    self.alertUser = value
                }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["Instances"] as? [Any?] {
                    var tmp : [ListAlertMessagesResponseBody.Data.AlertMessages.Instances] = []
                    for v in value {
                        if v != nil {
                            var model = ListAlertMessagesResponseBody.Data.AlertMessages.Instances()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.instances = tmp
                }
                if let value = dict["Nodes"] as? [Any?] {
                    var tmp : [ListAlertMessagesResponseBody.Data.AlertMessages.Nodes] = []
                    for v in value {
                        if v != nil {
                            var model = ListAlertMessagesResponseBody.Data.AlertMessages.Nodes()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.nodes = tmp
                }
                if let value = dict["RemindId"] as? Int64 {
                    self.remindId = value
                }
                if let value = dict["RemindName"] as? String {
                    self.remindName = value
                }
                if let value = dict["SlaAlert"] as? [String: Any?] {
                    var model = ListAlertMessagesResponseBody.Data.AlertMessages.SlaAlert()
                    model.fromMap(value)
                    self.slaAlert = model
                }
                if let value = dict["Source"] as? String {
                    self.source = value
                }
                if let value = dict["Topics"] as? [Any?] {
                    var tmp : [ListAlertMessagesResponseBody.Data.AlertMessages.Topics] = []
                    for v in value {
                        if v != nil {
                            var model = ListAlertMessagesResponseBody.Data.AlertMessages.Topics()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.topics = tmp
                }
            }
        }
        public var alertMessages: [ListAlertMessagesResponseBody.Data.AlertMessages]?

        public var pageNumber: String?

        public var pageSize: String?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertMessages != nil {
                var tmp : [Any] = []
                for k in self.alertMessages! {
                    tmp.append(k.toMap())
                }
                map["AlertMessages"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlertMessages"] as? [Any?] {
                var tmp : [ListAlertMessagesResponseBody.Data.AlertMessages] = []
                for v in value {
                    if v != nil {
                        var model = ListAlertMessagesResponseBody.Data.AlertMessages()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.alertMessages = tmp
            }
            if let value = dict["PageNumber"] as? String {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? String {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? String {
                self.totalCount = value
            }
        }
    }
    public var data: ListAlertMessagesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListAlertMessagesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListAlertMessagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAlertMessagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAlertMessagesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListBaselineConfigsRequest : Tea.TeaModel {
    public var baselineTypes: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var priority: String?

    public var projectId: Int64?

    public var searchText: String?

    public var useflag: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineTypes != nil {
            map["BaselineTypes"] = self.baselineTypes!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.searchText != nil {
            map["SearchText"] = self.searchText!
        }
        if self.useflag != nil {
            map["Useflag"] = self.useflag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BaselineTypes"] as? String {
            self.baselineTypes = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Priority"] as? String {
            self.priority = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SearchText"] as? String {
            self.searchText = value
        }
        if let value = dict["Useflag"] as? Bool {
            self.useflag = value
        }
    }
}

public class ListBaselineConfigsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Baselines : Tea.TeaModel {
            public var baselineId: Int64?

            public var baselineName: String?

            public var baselineType: String?

            public var expHour: Int32?

            public var expMinu: Int32?

            public var hourExpDetail: String?

            public var hourSlaDetail: String?

            public var isDefault: Bool?

            public var owner: String?

            public var priority: Int32?

            public var projectId: Int64?

            public var slaHour: Int32?

            public var slaMinu: Int32?

            public var useFlag: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.baselineName != nil {
                    map["BaselineName"] = self.baselineName!
                }
                if self.baselineType != nil {
                    map["BaselineType"] = self.baselineType!
                }
                if self.expHour != nil {
                    map["ExpHour"] = self.expHour!
                }
                if self.expMinu != nil {
                    map["ExpMinu"] = self.expMinu!
                }
                if self.hourExpDetail != nil {
                    map["HourExpDetail"] = self.hourExpDetail!
                }
                if self.hourSlaDetail != nil {
                    map["HourSlaDetail"] = self.hourSlaDetail!
                }
                if self.isDefault != nil {
                    map["IsDefault"] = self.isDefault!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.slaHour != nil {
                    map["SlaHour"] = self.slaHour!
                }
                if self.slaMinu != nil {
                    map["SlaMinu"] = self.slaMinu!
                }
                if self.useFlag != nil {
                    map["UseFlag"] = self.useFlag!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["BaselineName"] as? String {
                    self.baselineName = value
                }
                if let value = dict["BaselineType"] as? String {
                    self.baselineType = value
                }
                if let value = dict["ExpHour"] as? Int32 {
                    self.expHour = value
                }
                if let value = dict["ExpMinu"] as? Int32 {
                    self.expMinu = value
                }
                if let value = dict["HourExpDetail"] as? String {
                    self.hourExpDetail = value
                }
                if let value = dict["HourSlaDetail"] as? String {
                    self.hourSlaDetail = value
                }
                if let value = dict["IsDefault"] as? Bool {
                    self.isDefault = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["SlaHour"] as? Int32 {
                    self.slaHour = value
                }
                if let value = dict["SlaMinu"] as? Int32 {
                    self.slaMinu = value
                }
                if let value = dict["UseFlag"] as? Bool {
                    self.useFlag = value
                }
            }
        }
        public var baselines: [ListBaselineConfigsResponseBody.Data.Baselines]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselines != nil {
                var tmp : [Any] = []
                for k in self.baselines! {
                    tmp.append(k.toMap())
                }
                map["Baselines"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Baselines"] as? [Any?] {
                var tmp : [ListBaselineConfigsResponseBody.Data.Baselines] = []
                for v in value {
                    if v != nil {
                        var model = ListBaselineConfigsResponseBody.Data.Baselines()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.baselines = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListBaselineConfigsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListBaselineConfigsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListBaselineConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBaselineConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListBaselineConfigsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListBaselineStatusesRequest : Tea.TeaModel {
    public var baselineTypes: String?

    public var bizdate: String?

    public var finishStatus: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var priority: String?

    public var searchText: String?

    public var status: String?

    public var topicId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineTypes != nil {
            map["BaselineTypes"] = self.baselineTypes!
        }
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.finishStatus != nil {
            map["FinishStatus"] = self.finishStatus!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.searchText != nil {
            map["SearchText"] = self.searchText!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.topicId != nil {
            map["TopicId"] = self.topicId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BaselineTypes"] as? String {
            self.baselineTypes = value
        }
        if let value = dict["Bizdate"] as? String {
            self.bizdate = value
        }
        if let value = dict["FinishStatus"] as? String {
            self.finishStatus = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Priority"] as? String {
            self.priority = value
        }
        if let value = dict["SearchText"] as? String {
            self.searchText = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["TopicId"] as? Int64 {
            self.topicId = value
        }
    }
}

public class ListBaselineStatusesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BaselineStatuses : Tea.TeaModel {
            public var baselineId: Int64?

            public var baselineName: String?

            public var baselineType: String?

            public var bizdate: Int64?

            public var buffer: Int64?

            public var endCast: Int64?

            public var expTime: Int64?

            public var finishStatus: String?

            public var finishTime: Int64?

            public var inGroupId: Int32?

            public var owner: String?

            public var priority: Int32?

            public var projectId: Int64?

            public var slaTime: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.baselineName != nil {
                    map["BaselineName"] = self.baselineName!
                }
                if self.baselineType != nil {
                    map["BaselineType"] = self.baselineType!
                }
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.buffer != nil {
                    map["Buffer"] = self.buffer!
                }
                if self.endCast != nil {
                    map["EndCast"] = self.endCast!
                }
                if self.expTime != nil {
                    map["ExpTime"] = self.expTime!
                }
                if self.finishStatus != nil {
                    map["FinishStatus"] = self.finishStatus!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.inGroupId != nil {
                    map["InGroupId"] = self.inGroupId!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.slaTime != nil {
                    map["SlaTime"] = self.slaTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["BaselineName"] as? String {
                    self.baselineName = value
                }
                if let value = dict["BaselineType"] as? String {
                    self.baselineType = value
                }
                if let value = dict["Bizdate"] as? Int64 {
                    self.bizdate = value
                }
                if let value = dict["Buffer"] as? Int64 {
                    self.buffer = value
                }
                if let value = dict["EndCast"] as? Int64 {
                    self.endCast = value
                }
                if let value = dict["ExpTime"] as? Int64 {
                    self.expTime = value
                }
                if let value = dict["FinishStatus"] as? String {
                    self.finishStatus = value
                }
                if let value = dict["FinishTime"] as? Int64 {
                    self.finishTime = value
                }
                if let value = dict["InGroupId"] as? Int32 {
                    self.inGroupId = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["SlaTime"] as? Int64 {
                    self.slaTime = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var baselineStatuses: [ListBaselineStatusesResponseBody.Data.BaselineStatuses]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineStatuses != nil {
                var tmp : [Any] = []
                for k in self.baselineStatuses! {
                    tmp.append(k.toMap())
                }
                map["BaselineStatuses"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BaselineStatuses"] as? [Any?] {
                var tmp : [ListBaselineStatusesResponseBody.Data.BaselineStatuses] = []
                for v in value {
                    if v != nil {
                        var model = ListBaselineStatusesResponseBody.Data.BaselineStatuses()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.baselineStatuses = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListBaselineStatusesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListBaselineStatusesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListBaselineStatusesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBaselineStatusesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListBaselineStatusesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListBaselinesRequest : Tea.TeaModel {
    public var baselineTypes: String?

    public var enable: Bool?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var priority: String?

    public var projectId: Int64?

    public var searchText: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineTypes != nil {
            map["BaselineTypes"] = self.baselineTypes!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.searchText != nil {
            map["SearchText"] = self.searchText!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BaselineTypes"] as? String {
            self.baselineTypes = value
        }
        if let value = dict["Enable"] as? Bool {
            self.enable = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Priority"] as? String {
            self.priority = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SearchText"] as? String {
            self.searchText = value
        }
    }
}

public class ListBaselinesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Baselines : Tea.TeaModel {
            public class OverTimeSettings : Tea.TeaModel {
                public var cycle: Int32?

                public var time: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cycle != nil {
                        map["Cycle"] = self.cycle!
                    }
                    if self.time != nil {
                        map["Time"] = self.time!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Cycle"] as? Int32 {
                        self.cycle = value
                    }
                    if let value = dict["Time"] as? String {
                        self.time = value
                    }
                }
            }
            public var alertEnabled: Bool?

            public var alertMarginThreshold: Int32?

            public var baselineId: Int64?

            public var baselineName: String?

            public var baselineType: String?

            public var enabled: Bool?

            public var overTimeSettings: [ListBaselinesResponseBody.Data.Baselines.OverTimeSettings]?

            public var owner: String?

            public var priority: Int32?

            public var projectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertEnabled != nil {
                    map["AlertEnabled"] = self.alertEnabled!
                }
                if self.alertMarginThreshold != nil {
                    map["AlertMarginThreshold"] = self.alertMarginThreshold!
                }
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.baselineName != nil {
                    map["BaselineName"] = self.baselineName!
                }
                if self.baselineType != nil {
                    map["BaselineType"] = self.baselineType!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.overTimeSettings != nil {
                    var tmp : [Any] = []
                    for k in self.overTimeSettings! {
                        tmp.append(k.toMap())
                    }
                    map["OverTimeSettings"] = tmp
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AlertEnabled"] as? Bool {
                    self.alertEnabled = value
                }
                if let value = dict["AlertMarginThreshold"] as? Int32 {
                    self.alertMarginThreshold = value
                }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["BaselineName"] as? String {
                    self.baselineName = value
                }
                if let value = dict["BaselineType"] as? String {
                    self.baselineType = value
                }
                if let value = dict["Enabled"] as? Bool {
                    self.enabled = value
                }
                if let value = dict["OverTimeSettings"] as? [Any?] {
                    var tmp : [ListBaselinesResponseBody.Data.Baselines.OverTimeSettings] = []
                    for v in value {
                        if v != nil {
                            var model = ListBaselinesResponseBody.Data.Baselines.OverTimeSettings()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.overTimeSettings = tmp
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
            }
        }
        public var baselines: [ListBaselinesResponseBody.Data.Baselines]?

        public var pageNumber: String?

        public var pageSize: String?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselines != nil {
                var tmp : [Any] = []
                for k in self.baselines! {
                    tmp.append(k.toMap())
                }
                map["Baselines"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Baselines"] as? [Any?] {
                var tmp : [ListBaselinesResponseBody.Data.Baselines] = []
                for v in value {
                    if v != nil {
                        var model = ListBaselinesResponseBody.Data.Baselines()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.baselines = tmp
            }
            if let value = dict["PageNumber"] as? String {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? String {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? String {
                self.totalCount = value
            }
        }
    }
    public var data: ListBaselinesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListBaselinesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListBaselinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBaselinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListBaselinesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListBusinessRequest : Tea.TeaModel {
    public var keyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class ListBusinessResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Business : Tea.TeaModel {
            public var businessId: Int64?

            public var businessName: String?

            public var description_: String?

            public var owner: String?

            public var projectId: Int64?

            public var useType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessId != nil {
                    map["BusinessId"] = self.businessId!
                }
                if self.businessName != nil {
                    map["BusinessName"] = self.businessName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.useType != nil {
                    map["UseType"] = self.useType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BusinessId"] as? Int64 {
                    self.businessId = value
                }
                if let value = dict["BusinessName"] as? String {
                    self.businessName = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["UseType"] as? String {
                    self.useType = value
                }
            }
        }
        public var business: [ListBusinessResponseBody.Data.Business]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.business != nil {
                var tmp : [Any] = []
                for k in self.business! {
                    tmp.append(k.toMap())
                }
                map["Business"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Business"] as? [Any?] {
                var tmp : [ListBusinessResponseBody.Data.Business] = []
                for v in value {
                    if v != nil {
                        var model = ListBusinessResponseBody.Data.Business()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.business = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListBusinessResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListBusinessResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListBusinessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBusinessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListBusinessResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCalcEnginesRequest : Tea.TeaModel {
    public var calcEngineType: String?

    public var envType: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calcEngineType != nil {
            map["CalcEngineType"] = self.calcEngineType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CalcEngineType"] as? String {
            self.calcEngineType = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ListCalcEnginesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CalcEngines : Tea.TeaModel {
            public var bindingProjectId: Int32?

            public var bindingProjectName: String?

            public var calcEngineType: String?

            public var dwRegion: String?

            public var engineId: Int32?

            public var engineInfo: [String: Any]?

            public var envType: String?

            public var gmtCreate: String?

            public var isDefault: Bool?

            public var name: String?

            public var region: String?

            public var taskAuthType: String?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindingProjectId != nil {
                    map["BindingProjectId"] = self.bindingProjectId!
                }
                if self.bindingProjectName != nil {
                    map["BindingProjectName"] = self.bindingProjectName!
                }
                if self.calcEngineType != nil {
                    map["CalcEngineType"] = self.calcEngineType!
                }
                if self.dwRegion != nil {
                    map["DwRegion"] = self.dwRegion!
                }
                if self.engineId != nil {
                    map["EngineId"] = self.engineId!
                }
                if self.engineInfo != nil {
                    map["EngineInfo"] = self.engineInfo!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.isDefault != nil {
                    map["IsDefault"] = self.isDefault!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.taskAuthType != nil {
                    map["TaskAuthType"] = self.taskAuthType!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BindingProjectId"] as? Int32 {
                    self.bindingProjectId = value
                }
                if let value = dict["BindingProjectName"] as? String {
                    self.bindingProjectName = value
                }
                if let value = dict["CalcEngineType"] as? String {
                    self.calcEngineType = value
                }
                if let value = dict["DwRegion"] as? String {
                    self.dwRegion = value
                }
                if let value = dict["EngineId"] as? Int32 {
                    self.engineId = value
                }
                if let value = dict["EngineInfo"] as? [String: Any] {
                    self.engineInfo = value
                }
                if let value = dict["EnvType"] as? String {
                    self.envType = value
                }
                if let value = dict["GmtCreate"] as? String {
                    self.gmtCreate = value
                }
                if let value = dict["IsDefault"] as? Bool {
                    self.isDefault = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["TaskAuthType"] as? String {
                    self.taskAuthType = value
                }
                if let value = dict["TenantId"] as? Int64 {
                    self.tenantId = value
                }
            }
        }
        public var calcEngines: [ListCalcEnginesResponseBody.Data.CalcEngines]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.calcEngines != nil {
                var tmp : [Any] = []
                for k in self.calcEngines! {
                    tmp.append(k.toMap())
                }
                map["CalcEngines"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CalcEngines"] as? [Any?] {
                var tmp : [ListCalcEnginesResponseBody.Data.CalcEngines] = []
                for v in value {
                    if v != nil {
                        var model = ListCalcEnginesResponseBody.Data.CalcEngines()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.calcEngines = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListCalcEnginesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListCalcEnginesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListCalcEnginesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCalcEnginesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCalcEnginesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCheckProcessesRequest : Tea.TeaModel {
    public var eventCode: String?

    public var messageId: String?

    public var operator_: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventCode != nil {
            map["EventCode"] = self.eventCode!
        }
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        if self.operator_ != nil {
            map["Operator"] = self.operator_!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EventCode"] as? String {
            self.eventCode = value
        }
        if let value = dict["MessageId"] as? String {
            self.messageId = value
        }
        if let value = dict["Operator"] as? String {
            self.operator_ = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class ListCheckProcessesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class CheckProcesses : Tea.TeaModel {
            public var eventCode: String?

            public var eventName: String?

            public var eventNameEn: String?

            public var messageId: String?

            public var operator_: String?

            public var processId: String?

            public var processName: String?

            public var projectId: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventCode != nil {
                    map["EventCode"] = self.eventCode!
                }
                if self.eventName != nil {
                    map["EventName"] = self.eventName!
                }
                if self.eventNameEn != nil {
                    map["EventNameEn"] = self.eventNameEn!
                }
                if self.messageId != nil {
                    map["MessageId"] = self.messageId!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.processId != nil {
                    map["ProcessId"] = self.processId!
                }
                if self.processName != nil {
                    map["ProcessName"] = self.processName!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EventCode"] as? String {
                    self.eventCode = value
                }
                if let value = dict["EventName"] as? String {
                    self.eventName = value
                }
                if let value = dict["EventNameEn"] as? String {
                    self.eventNameEn = value
                }
                if let value = dict["MessageId"] as? String {
                    self.messageId = value
                }
                if let value = dict["Operator"] as? String {
                    self.operator_ = value
                }
                if let value = dict["ProcessId"] as? String {
                    self.processId = value
                }
                if let value = dict["ProcessName"] as? String {
                    self.processName = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var checkProcesses: [ListCheckProcessesResponseBody.PagingInfo.CheckProcesses]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkProcesses != nil {
                var tmp : [Any] = []
                for k in self.checkProcesses! {
                    tmp.append(k.toMap())
                }
                map["CheckProcesses"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CheckProcesses"] as? [Any?] {
                var tmp : [ListCheckProcessesResponseBody.PagingInfo.CheckProcesses] = []
                for v in value {
                    if v != nil {
                        var model = ListCheckProcessesResponseBody.PagingInfo.CheckProcesses()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.checkProcesses = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListCheckProcessesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListCheckProcessesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListCheckProcessesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCheckProcessesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCheckProcessesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListClusterConfigsRequest : Tea.TeaModel {
    public var clusterId: Int64?

    public var configType: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configType != nil {
            map["ConfigType"] = self.configType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? Int64 {
            self.clusterId = value
        }
        if let value = dict["ConfigType"] as? String {
            self.configType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ListClusterConfigsResponseBody : Tea.TeaModel {
    public var clusterConfigs: [ClusterConfig]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterConfigs != nil {
            var tmp : [Any] = []
            for k in self.clusterConfigs! {
                tmp.append(k.toMap())
            }
            map["ClusterConfigs"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterConfigs"] as? [Any?] {
            var tmp : [ClusterConfig] = []
            for v in value {
                if v != nil {
                    var model = ClusterConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.clusterConfigs = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListClusterConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListClusterConfigsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListClustersRequest : Tea.TeaModel {
    public var clusterType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterType"] as? String {
            self.clusterType = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListClustersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusters: [Cluster]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusters != nil {
                var tmp : [Any] = []
                for k in self.clusters! {
                    tmp.append(k.toMap())
                }
                map["Clusters"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Clusters"] as? [Any?] {
                var tmp : [Cluster] = []
                for v in value {
                    if v != nil {
                        var model = Cluster()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.clusters = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListClustersResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListClustersResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListClustersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListConnectionsRequest : Tea.TeaModel {
    public var connectionType: String?

    public var envType: Int32?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var status: String?

    public var subType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionType != nil {
            map["ConnectionType"] = self.connectionType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.subType != nil {
            map["SubType"] = self.subType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionType"] as? String {
            self.connectionType = value
        }
        if let value = dict["EnvType"] as? Int32 {
            self.envType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["SubType"] as? String {
            self.subType = value
        }
    }
}

public class ListConnectionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Connections : Tea.TeaModel {
            public var bindingCalcEngineId: Int32?

            public var connectStatus: Int32?

            public var connectionType: String?

            public var content: String?

            public var defaultEngine: Bool?

            public var description_: String?

            public var envType: Int32?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int32?

            public var name: String?

            public var operator_: String?

            public var projectId: Int32?

            public var sequence: Int32?

            public var shared: Bool?

            public var status: Int32?

            public var subType: String?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindingCalcEngineId != nil {
                    map["BindingCalcEngineId"] = self.bindingCalcEngineId!
                }
                if self.connectStatus != nil {
                    map["ConnectStatus"] = self.connectStatus!
                }
                if self.connectionType != nil {
                    map["ConnectionType"] = self.connectionType!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.defaultEngine != nil {
                    map["DefaultEngine"] = self.defaultEngine!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.sequence != nil {
                    map["Sequence"] = self.sequence!
                }
                if self.shared != nil {
                    map["Shared"] = self.shared!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.subType != nil {
                    map["SubType"] = self.subType!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BindingCalcEngineId"] as? Int32 {
                    self.bindingCalcEngineId = value
                }
                if let value = dict["ConnectStatus"] as? Int32 {
                    self.connectStatus = value
                }
                if let value = dict["ConnectionType"] as? String {
                    self.connectionType = value
                }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["DefaultEngine"] as? Bool {
                    self.defaultEngine = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EnvType"] as? Int32 {
                    self.envType = value
                }
                if let value = dict["GmtCreate"] as? String {
                    self.gmtCreate = value
                }
                if let value = dict["GmtModified"] as? String {
                    self.gmtModified = value
                }
                if let value = dict["Id"] as? Int32 {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Operator"] as? String {
                    self.operator_ = value
                }
                if let value = dict["ProjectId"] as? Int32 {
                    self.projectId = value
                }
                if let value = dict["Sequence"] as? Int32 {
                    self.sequence = value
                }
                if let value = dict["Shared"] as? Bool {
                    self.shared = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
                if let value = dict["SubType"] as? String {
                    self.subType = value
                }
                if let value = dict["TenantId"] as? Int64 {
                    self.tenantId = value
                }
            }
        }
        public var connections: [ListConnectionsResponseBody.Data.Connections]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connections != nil {
                var tmp : [Any] = []
                for k in self.connections! {
                    tmp.append(k.toMap())
                }
                map["Connections"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Connections"] as? [Any?] {
                var tmp : [ListConnectionsResponseBody.Data.Connections] = []
                for v in value {
                    if v != nil {
                        var model = ListConnectionsResponseBody.Data.Connections()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.connections = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListConnectionsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListConnectionsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListConnectionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDIAlarmRulesRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class ListDIAlarmRulesResponseBody : Tea.TeaModel {
    public class DIAlarmRulePaging : Tea.TeaModel {
        public class DIJobAlarmRules : Tea.TeaModel {
            public class NotificationSettings : Tea.TeaModel {
                public class NotificationChannels : Tea.TeaModel {
                    public var channels: [String]?

                    public var severity: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.severity != nil {
                            map["Severity"] = self.severity!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Channels"] as? [String] {
                            self.channels = value
                        }
                        if let value = dict["Severity"] as? String {
                            self.severity = value
                        }
                    }
                }
                public class NotificationReceivers : Tea.TeaModel {
                    public var receiverType: String?

                    public var receiverValues: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.receiverType != nil {
                            map["ReceiverType"] = self.receiverType!
                        }
                        if self.receiverValues != nil {
                            map["ReceiverValues"] = self.receiverValues!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ReceiverType"] as? String {
                            self.receiverType = value
                        }
                        if let value = dict["ReceiverValues"] as? [String] {
                            self.receiverValues = value
                        }
                    }
                }
                public var inhibitionInterval: Int32?

                public var notificationChannels: [ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.NotificationSettings.NotificationChannels]?

                public var notificationReceivers: [ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.NotificationSettings.NotificationReceivers]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.inhibitionInterval != nil {
                        map["InhibitionInterval"] = self.inhibitionInterval!
                    }
                    if self.notificationChannels != nil {
                        var tmp : [Any] = []
                        for k in self.notificationChannels! {
                            tmp.append(k.toMap())
                        }
                        map["NotificationChannels"] = tmp
                    }
                    if self.notificationReceivers != nil {
                        var tmp : [Any] = []
                        for k in self.notificationReceivers! {
                            tmp.append(k.toMap())
                        }
                        map["NotificationReceivers"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["InhibitionInterval"] as? Int32 {
                        self.inhibitionInterval = value
                    }
                    if let value = dict["NotificationChannels"] as? [Any?] {
                        var tmp : [ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.NotificationSettings.NotificationChannels] = []
                        for v in value {
                            if v != nil {
                                var model = ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.NotificationSettings.NotificationChannels()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.notificationChannels = tmp
                    }
                    if let value = dict["NotificationReceivers"] as? [Any?] {
                        var tmp : [ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.NotificationSettings.NotificationReceivers] = []
                        for v in value {
                            if v != nil {
                                var model = ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.NotificationSettings.NotificationReceivers()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.notificationReceivers = tmp
                    }
                }
            }
            public class TriggerConditions : Tea.TeaModel {
                public var duration: Int64?

                public var severity: String?

                public var threshold: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.severity != nil {
                        map["Severity"] = self.severity!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Duration"] as? Int64 {
                        self.duration = value
                    }
                    if let value = dict["Severity"] as? String {
                        self.severity = value
                    }
                    if let value = dict["Threshold"] as? Int64 {
                        self.threshold = value
                    }
                }
            }
            public var DIAlarmRuleId: Int64?

            public var DIJobId: Int64?

            public var description_: String?

            public var enabled: Bool?

            public var metricType: String?

            public var notificationSettings: ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.NotificationSettings?

            public var triggerConditions: [ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.TriggerConditions]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.notificationSettings?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DIAlarmRuleId != nil {
                    map["DIAlarmRuleId"] = self.DIAlarmRuleId!
                }
                if self.DIJobId != nil {
                    map["DIJobId"] = self.DIJobId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.metricType != nil {
                    map["MetricType"] = self.metricType!
                }
                if self.notificationSettings != nil {
                    map["NotificationSettings"] = self.notificationSettings?.toMap()
                }
                if self.triggerConditions != nil {
                    var tmp : [Any] = []
                    for k in self.triggerConditions! {
                        tmp.append(k.toMap())
                    }
                    map["TriggerConditions"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DIAlarmRuleId"] as? Int64 {
                    self.DIAlarmRuleId = value
                }
                if let value = dict["DIJobId"] as? Int64 {
                    self.DIJobId = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Enabled"] as? Bool {
                    self.enabled = value
                }
                if let value = dict["MetricType"] as? String {
                    self.metricType = value
                }
                if let value = dict["NotificationSettings"] as? [String: Any?] {
                    var model = ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.NotificationSettings()
                    model.fromMap(value)
                    self.notificationSettings = model
                }
                if let value = dict["TriggerConditions"] as? [Any?] {
                    var tmp : [ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.TriggerConditions] = []
                    for v in value {
                        if v != nil {
                            var model = ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules.TriggerConditions()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.triggerConditions = tmp
                }
            }
        }
        public var DIJobAlarmRules: [ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DIJobAlarmRules != nil {
                var tmp : [Any] = []
                for k in self.DIJobAlarmRules! {
                    tmp.append(k.toMap())
                }
                map["DIJobAlarmRules"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DIJobAlarmRules"] as? [Any?] {
                var tmp : [ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules] = []
                for v in value {
                    if v != nil {
                        var model = ListDIAlarmRulesResponseBody.DIAlarmRulePaging.DIJobAlarmRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DIJobAlarmRules = tmp
            }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var DIAlarmRulePaging: ListDIAlarmRulesResponseBody.DIAlarmRulePaging?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DIAlarmRulePaging?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRulePaging != nil {
            map["DIAlarmRulePaging"] = self.DIAlarmRulePaging?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIAlarmRulePaging"] as? [String: Any?] {
            var model = ListDIAlarmRulesResponseBody.DIAlarmRulePaging()
            model.fromMap(value)
            self.DIAlarmRulePaging = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDIAlarmRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDIAlarmRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDIAlarmRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDIJobsRequest : Tea.TeaModel {
    public var destinationDataSourceType: String?

    public var jobName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var sourceDataSourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationDataSourceType != nil {
            map["DestinationDataSourceType"] = self.destinationDataSourceType!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sourceDataSourceType != nil {
            map["SourceDataSourceType"] = self.sourceDataSourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DestinationDataSourceType"] as? String {
            self.destinationDataSourceType = value
        }
        if let value = dict["JobName"] as? String {
            self.jobName = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SourceDataSourceType"] as? String {
            self.sourceDataSourceType = value
        }
    }
}

public class ListDIJobsResponseBody : Tea.TeaModel {
    public class DIJobPaging : Tea.TeaModel {
        public class DIJobs : Tea.TeaModel {
            public var DIJobId: Int64?

            public var destinationDataSourceType: String?

            public var jobName: String?

            public var jobStatus: String?

            public var migrationType: String?

            public var projectId: Int64?

            public var sourceDataSourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DIJobId != nil {
                    map["DIJobId"] = self.DIJobId!
                }
                if self.destinationDataSourceType != nil {
                    map["DestinationDataSourceType"] = self.destinationDataSourceType!
                }
                if self.jobName != nil {
                    map["JobName"] = self.jobName!
                }
                if self.jobStatus != nil {
                    map["JobStatus"] = self.jobStatus!
                }
                if self.migrationType != nil {
                    map["MigrationType"] = self.migrationType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.sourceDataSourceType != nil {
                    map["SourceDataSourceType"] = self.sourceDataSourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DIJobId"] as? Int64 {
                    self.DIJobId = value
                }
                if let value = dict["DestinationDataSourceType"] as? String {
                    self.destinationDataSourceType = value
                }
                if let value = dict["JobName"] as? String {
                    self.jobName = value
                }
                if let value = dict["JobStatus"] as? String {
                    self.jobStatus = value
                }
                if let value = dict["MigrationType"] as? String {
                    self.migrationType = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["SourceDataSourceType"] as? String {
                    self.sourceDataSourceType = value
                }
            }
        }
        public var DIJobs: [ListDIJobsResponseBody.DIJobPaging.DIJobs]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DIJobs != nil {
                var tmp : [Any] = []
                for k in self.DIJobs! {
                    tmp.append(k.toMap())
                }
                map["DIJobs"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DIJobs"] as? [Any?] {
                var tmp : [ListDIJobsResponseBody.DIJobPaging.DIJobs] = []
                for v in value {
                    if v != nil {
                        var model = ListDIJobsResponseBody.DIJobPaging.DIJobs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DIJobs = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var DIJobPaging: ListDIJobsResponseBody.DIJobPaging?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DIJobPaging?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobPaging != nil {
            map["DIJobPaging"] = self.DIJobPaging?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobPaging"] as? [String: Any?] {
            var model = ListDIJobsResponseBody.DIJobPaging()
            model.fromMap(value)
            self.DIJobPaging = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDIJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDIJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDIJobsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDIProjectConfigRequest : Tea.TeaModel {
    public var destinationType: String?

    public var projectId: Int64?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DestinationType"] as? String {
            self.destinationType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SourceType"] as? String {
            self.sourceType = value
        }
    }
}

public class ListDIProjectConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var config: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Config"] as? String {
                self.config = value
            }
        }
    }
    public var data: ListDIProjectConfigResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListDIProjectConfigResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListDIProjectConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDIProjectConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDIProjectConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDagsRequest : Tea.TeaModel {
    public var opSeq: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.opSeq != nil {
            map["OpSeq"] = self.opSeq!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OpSeq"] as? Int64 {
            self.opSeq = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class ListDagsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Dags : Tea.TeaModel {
            public var bizdate: Int64?

            public var createTime: Int64?

            public var createUser: String?

            public var dagId: Int64?

            public var finishTime: Int64?

            public var gmtdate: Int64?

            public var modifyTime: Int64?

            public var name: String?

            public var opSeq: Int64?

            public var projectId: Int64?

            public var startTime: Int64?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.dagId != nil {
                    map["DagId"] = self.dagId!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.gmtdate != nil {
                    map["Gmtdate"] = self.gmtdate!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.opSeq != nil {
                    map["OpSeq"] = self.opSeq!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Bizdate"] as? Int64 {
                    self.bizdate = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["DagId"] as? Int64 {
                    self.dagId = value
                }
                if let value = dict["FinishTime"] as? Int64 {
                    self.finishTime = value
                }
                if let value = dict["Gmtdate"] as? Int64 {
                    self.gmtdate = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["OpSeq"] as? Int64 {
                    self.opSeq = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["StartTime"] as? Int64 {
                    self.startTime = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var dags: [ListDagsResponseBody.Data.Dags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dags != nil {
                var tmp : [Any] = []
                for k in self.dags! {
                    tmp.append(k.toMap())
                }
                map["Dags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Dags"] as? [Any?] {
                var tmp : [ListDagsResponseBody.Data.Dags] = []
                for v in value {
                    if v != nil {
                        var model = ListDagsResponseBody.Data.Dags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dags = tmp
            }
        }
    }
    public var data: ListDagsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListDagsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListDagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataServiceApiAuthoritiesRequest : Tea.TeaModel {
    public var apiNameKeyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiNameKeyword != nil {
            map["ApiNameKeyword"] = self.apiNameKeyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiNameKeyword"] as? String {
            self.apiNameKeyword = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class ListDataServiceApiAuthoritiesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ApiAuthorizationList : Tea.TeaModel {
            public class AuthorizationRecords : Tea.TeaModel {
                public var createdTime: String?

                public var creatorId: String?

                public var endTime: String?

                public var projectId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.createdTime != nil {
                        map["CreatedTime"] = self.createdTime!
                    }
                    if self.creatorId != nil {
                        map["CreatorId"] = self.creatorId!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CreatedTime"] as? String {
                        self.createdTime = value
                    }
                    if let value = dict["CreatorId"] as? String {
                        self.creatorId = value
                    }
                    if let value = dict["EndTime"] as? String {
                        self.endTime = value
                    }
                    if let value = dict["ProjectId"] as? Int64 {
                        self.projectId = value
                    }
                }
            }
            public var apiId: Int64?

            public var apiName: String?

            public var apiPath: String?

            public var apiStatus: Int32?

            public var authorizationRecords: [ListDataServiceApiAuthoritiesResponseBody.Data.ApiAuthorizationList.AuthorizationRecords]?

            public var createdTime: String?

            public var creatorId: String?

            public var groupId: String?

            public var modifiedTime: String?

            public var projectId: Int64?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiPath != nil {
                    map["ApiPath"] = self.apiPath!
                }
                if self.apiStatus != nil {
                    map["ApiStatus"] = self.apiStatus!
                }
                if self.authorizationRecords != nil {
                    var tmp : [Any] = []
                    for k in self.authorizationRecords! {
                        tmp.append(k.toMap())
                    }
                    map["AuthorizationRecords"] = tmp
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ApiId"] as? Int64 {
                    self.apiId = value
                }
                if let value = dict["ApiName"] as? String {
                    self.apiName = value
                }
                if let value = dict["ApiPath"] as? String {
                    self.apiPath = value
                }
                if let value = dict["ApiStatus"] as? Int32 {
                    self.apiStatus = value
                }
                if let value = dict["AuthorizationRecords"] as? [Any?] {
                    var tmp : [ListDataServiceApiAuthoritiesResponseBody.Data.ApiAuthorizationList.AuthorizationRecords] = []
                    for v in value {
                        if v != nil {
                            var model = ListDataServiceApiAuthoritiesResponseBody.Data.ApiAuthorizationList.AuthorizationRecords()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.authorizationRecords = tmp
                }
                if let value = dict["CreatedTime"] as? String {
                    self.createdTime = value
                }
                if let value = dict["CreatorId"] as? String {
                    self.creatorId = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["ModifiedTime"] as? String {
                    self.modifiedTime = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["TenantId"] as? Int64 {
                    self.tenantId = value
                }
            }
        }
        public var apiAuthorizationList: [ListDataServiceApiAuthoritiesResponseBody.Data.ApiAuthorizationList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiAuthorizationList != nil {
                var tmp : [Any] = []
                for k in self.apiAuthorizationList! {
                    tmp.append(k.toMap())
                }
                map["ApiAuthorizationList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApiAuthorizationList"] as? [Any?] {
                var tmp : [ListDataServiceApiAuthoritiesResponseBody.Data.ApiAuthorizationList] = []
                for v in value {
                    if v != nil {
                        var model = ListDataServiceApiAuthoritiesResponseBody.Data.ApiAuthorizationList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.apiAuthorizationList = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListDataServiceApiAuthoritiesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListDataServiceApiAuthoritiesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListDataServiceApiAuthoritiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataServiceApiAuthoritiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataServiceApiAuthoritiesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataServiceApiTestRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiId"] as? Int64 {
            self.apiId = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListDataServiceApiTestResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var apiId: Int64?

        public var costTime: Int32?

        public var createTime: Int64?

        public var paramMap: String?

        public var retCode: Int64?

        public var retResult: String?

        public var status: String?

        public var testId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiId != nil {
                map["ApiId"] = self.apiId!
            }
            if self.costTime != nil {
                map["CostTime"] = self.costTime!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.paramMap != nil {
                map["ParamMap"] = self.paramMap!
            }
            if self.retCode != nil {
                map["RetCode"] = self.retCode!
            }
            if self.retResult != nil {
                map["RetResult"] = self.retResult!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.testId != nil {
                map["TestId"] = self.testId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApiId"] as? Int64 {
                self.apiId = value
            }
            if let value = dict["CostTime"] as? Int32 {
                self.costTime = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["ParamMap"] as? String {
                self.paramMap = value
            }
            if let value = dict["RetCode"] as? Int64 {
                self.retCode = value
            }
            if let value = dict["RetResult"] as? String {
                self.retResult = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TestId"] as? Int64 {
                self.testId = value
            }
        }
    }
    public var data: [ListDataServiceApiTestResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListDataServiceApiTestResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListDataServiceApiTestResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDataServiceApiTestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataServiceApiTestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataServiceApiTestResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataServiceApisRequest : Tea.TeaModel {
    public var apiNameKeyword: String?

    public var apiPathKeyword: String?

    public var creatorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiNameKeyword != nil {
            map["ApiNameKeyword"] = self.apiNameKeyword!
        }
        if self.apiPathKeyword != nil {
            map["ApiPathKeyword"] = self.apiPathKeyword!
        }
        if self.creatorId != nil {
            map["CreatorId"] = self.creatorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiNameKeyword"] as? String {
            self.apiNameKeyword = value
        }
        if let value = dict["ApiPathKeyword"] as? String {
            self.apiPathKeyword = value
        }
        if let value = dict["CreatorId"] as? String {
            self.creatorId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class ListDataServiceApisResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Apis : Tea.TeaModel {
            public class RegistrationDetails : Tea.TeaModel {
                public class RegistrationErrorCodes : Tea.TeaModel {
                    public var errorCode: String?

                    public var errorMessage: String?

                    public var errorSolution: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorMessage != nil {
                            map["ErrorMessage"] = self.errorMessage!
                        }
                        if self.errorSolution != nil {
                            map["ErrorSolution"] = self.errorSolution!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ErrorCode"] as? String {
                            self.errorCode = value
                        }
                        if let value = dict["ErrorMessage"] as? String {
                            self.errorMessage = value
                        }
                        if let value = dict["ErrorSolution"] as? String {
                            self.errorSolution = value
                        }
                    }
                }
                public class RegistrationRequestParameters : Tea.TeaModel {
                    public var columnName: String?

                    public var defaultValue: String?

                    public var exampleValue: String?

                    public var isRequiredParameter: Bool?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public var parameterOperator: Int32?

                    public var parameterPosition: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.columnName != nil {
                            map["ColumnName"] = self.columnName!
                        }
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.isRequiredParameter != nil {
                            map["IsRequiredParameter"] = self.isRequiredParameter!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        if self.parameterOperator != nil {
                            map["ParameterOperator"] = self.parameterOperator!
                        }
                        if self.parameterPosition != nil {
                            map["ParameterPosition"] = self.parameterPosition!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ColumnName"] as? String {
                            self.columnName = value
                        }
                        if let value = dict["DefaultValue"] as? String {
                            self.defaultValue = value
                        }
                        if let value = dict["ExampleValue"] as? String {
                            self.exampleValue = value
                        }
                        if let value = dict["IsRequiredParameter"] as? Bool {
                            self.isRequiredParameter = value
                        }
                        if let value = dict["ParameterDataType"] as? Int32 {
                            self.parameterDataType = value
                        }
                        if let value = dict["ParameterDescription"] as? String {
                            self.parameterDescription = value
                        }
                        if let value = dict["ParameterName"] as? String {
                            self.parameterName = value
                        }
                        if let value = dict["ParameterOperator"] as? Int32 {
                            self.parameterOperator = value
                        }
                        if let value = dict["ParameterPosition"] as? Int32 {
                            self.parameterPosition = value
                        }
                    }
                }
                public var failedResultSample: String?

                public var registrationErrorCodes: [ListDataServiceApisResponseBody.Data.Apis.RegistrationDetails.RegistrationErrorCodes]?

                public var registrationRequestParameters: [ListDataServiceApisResponseBody.Data.Apis.RegistrationDetails.RegistrationRequestParameters]?

                public var serviceContentType: Int32?

                public var serviceHost: String?

                public var servicePath: String?

                public var serviceRequestBodyDescription: String?

                public var successfulResultSample: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.failedResultSample != nil {
                        map["FailedResultSample"] = self.failedResultSample!
                    }
                    if self.registrationErrorCodes != nil {
                        var tmp : [Any] = []
                        for k in self.registrationErrorCodes! {
                            tmp.append(k.toMap())
                        }
                        map["RegistrationErrorCodes"] = tmp
                    }
                    if self.registrationRequestParameters != nil {
                        var tmp : [Any] = []
                        for k in self.registrationRequestParameters! {
                            tmp.append(k.toMap())
                        }
                        map["RegistrationRequestParameters"] = tmp
                    }
                    if self.serviceContentType != nil {
                        map["ServiceContentType"] = self.serviceContentType!
                    }
                    if self.serviceHost != nil {
                        map["ServiceHost"] = self.serviceHost!
                    }
                    if self.servicePath != nil {
                        map["ServicePath"] = self.servicePath!
                    }
                    if self.serviceRequestBodyDescription != nil {
                        map["ServiceRequestBodyDescription"] = self.serviceRequestBodyDescription!
                    }
                    if self.successfulResultSample != nil {
                        map["SuccessfulResultSample"] = self.successfulResultSample!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["FailedResultSample"] as? String {
                        self.failedResultSample = value
                    }
                    if let value = dict["RegistrationErrorCodes"] as? [Any?] {
                        var tmp : [ListDataServiceApisResponseBody.Data.Apis.RegistrationDetails.RegistrationErrorCodes] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataServiceApisResponseBody.Data.Apis.RegistrationDetails.RegistrationErrorCodes()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.registrationErrorCodes = tmp
                    }
                    if let value = dict["RegistrationRequestParameters"] as? [Any?] {
                        var tmp : [ListDataServiceApisResponseBody.Data.Apis.RegistrationDetails.RegistrationRequestParameters] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataServiceApisResponseBody.Data.Apis.RegistrationDetails.RegistrationRequestParameters()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.registrationRequestParameters = tmp
                    }
                    if let value = dict["ServiceContentType"] as? Int32 {
                        self.serviceContentType = value
                    }
                    if let value = dict["ServiceHost"] as? String {
                        self.serviceHost = value
                    }
                    if let value = dict["ServicePath"] as? String {
                        self.servicePath = value
                    }
                    if let value = dict["ServiceRequestBodyDescription"] as? String {
                        self.serviceRequestBodyDescription = value
                    }
                    if let value = dict["SuccessfulResultSample"] as? String {
                        self.successfulResultSample = value
                    }
                }
            }
            public class ScriptDetails : Tea.TeaModel {
                public class ScriptConnection : Tea.TeaModel {
                    public var connectionId: Int64?

                    public var tableName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.connectionId != nil {
                            map["ConnectionId"] = self.connectionId!
                        }
                        if self.tableName != nil {
                            map["TableName"] = self.tableName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ConnectionId"] as? Int64 {
                            self.connectionId = value
                        }
                        if let value = dict["TableName"] as? String {
                            self.tableName = value
                        }
                    }
                }
                public class ScriptRequestParameters : Tea.TeaModel {
                    public var columnName: String?

                    public var defaultValue: String?

                    public var exampleValue: String?

                    public var isRequiredParameter: Bool?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public var parameterOperator: Int32?

                    public var parameterPosition: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.columnName != nil {
                            map["ColumnName"] = self.columnName!
                        }
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.isRequiredParameter != nil {
                            map["IsRequiredParameter"] = self.isRequiredParameter!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        if self.parameterOperator != nil {
                            map["ParameterOperator"] = self.parameterOperator!
                        }
                        if self.parameterPosition != nil {
                            map["ParameterPosition"] = self.parameterPosition!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ColumnName"] as? String {
                            self.columnName = value
                        }
                        if let value = dict["DefaultValue"] as? String {
                            self.defaultValue = value
                        }
                        if let value = dict["ExampleValue"] as? String {
                            self.exampleValue = value
                        }
                        if let value = dict["IsRequiredParameter"] as? Bool {
                            self.isRequiredParameter = value
                        }
                        if let value = dict["ParameterDataType"] as? Int32 {
                            self.parameterDataType = value
                        }
                        if let value = dict["ParameterDescription"] as? String {
                            self.parameterDescription = value
                        }
                        if let value = dict["ParameterName"] as? String {
                            self.parameterName = value
                        }
                        if let value = dict["ParameterOperator"] as? Int32 {
                            self.parameterOperator = value
                        }
                        if let value = dict["ParameterPosition"] as? Int32 {
                            self.parameterPosition = value
                        }
                    }
                }
                public class ScriptResponseParameters : Tea.TeaModel {
                    public var columnName: String?

                    public var exampleValue: String?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.columnName != nil {
                            map["ColumnName"] = self.columnName!
                        }
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ColumnName"] as? String {
                            self.columnName = value
                        }
                        if let value = dict["ExampleValue"] as? String {
                            self.exampleValue = value
                        }
                        if let value = dict["ParameterDataType"] as? Int32 {
                            self.parameterDataType = value
                        }
                        if let value = dict["ParameterDescription"] as? String {
                            self.parameterDescription = value
                        }
                        if let value = dict["ParameterName"] as? String {
                            self.parameterName = value
                        }
                    }
                }
                public var isPagedResponse: Bool?

                public var script: String?

                public var scriptConnection: ListDataServiceApisResponseBody.Data.Apis.ScriptDetails.ScriptConnection?

                public var scriptRequestParameters: [ListDataServiceApisResponseBody.Data.Apis.ScriptDetails.ScriptRequestParameters]?

                public var scriptResponseParameters: [ListDataServiceApisResponseBody.Data.Apis.ScriptDetails.ScriptResponseParameters]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.scriptConnection?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.isPagedResponse != nil {
                        map["IsPagedResponse"] = self.isPagedResponse!
                    }
                    if self.script != nil {
                        map["Script"] = self.script!
                    }
                    if self.scriptConnection != nil {
                        map["ScriptConnection"] = self.scriptConnection?.toMap()
                    }
                    if self.scriptRequestParameters != nil {
                        var tmp : [Any] = []
                        for k in self.scriptRequestParameters! {
                            tmp.append(k.toMap())
                        }
                        map["ScriptRequestParameters"] = tmp
                    }
                    if self.scriptResponseParameters != nil {
                        var tmp : [Any] = []
                        for k in self.scriptResponseParameters! {
                            tmp.append(k.toMap())
                        }
                        map["ScriptResponseParameters"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IsPagedResponse"] as? Bool {
                        self.isPagedResponse = value
                    }
                    if let value = dict["Script"] as? String {
                        self.script = value
                    }
                    if let value = dict["ScriptConnection"] as? [String: Any?] {
                        var model = ListDataServiceApisResponseBody.Data.Apis.ScriptDetails.ScriptConnection()
                        model.fromMap(value)
                        self.scriptConnection = model
                    }
                    if let value = dict["ScriptRequestParameters"] as? [Any?] {
                        var tmp : [ListDataServiceApisResponseBody.Data.Apis.ScriptDetails.ScriptRequestParameters] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataServiceApisResponseBody.Data.Apis.ScriptDetails.ScriptRequestParameters()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.scriptRequestParameters = tmp
                    }
                    if let value = dict["ScriptResponseParameters"] as? [Any?] {
                        var tmp : [ListDataServiceApisResponseBody.Data.Apis.ScriptDetails.ScriptResponseParameters] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataServiceApisResponseBody.Data.Apis.ScriptDetails.ScriptResponseParameters()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.scriptResponseParameters = tmp
                    }
                }
            }
            public class WizardDetails : Tea.TeaModel {
                public class WizardConnection : Tea.TeaModel {
                    public var connectionId: Int64?

                    public var tableName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.connectionId != nil {
                            map["ConnectionId"] = self.connectionId!
                        }
                        if self.tableName != nil {
                            map["TableName"] = self.tableName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ConnectionId"] as? Int64 {
                            self.connectionId = value
                        }
                        if let value = dict["TableName"] as? String {
                            self.tableName = value
                        }
                    }
                }
                public class WizardRequestParameters : Tea.TeaModel {
                    public var columnName: String?

                    public var defaultValue: String?

                    public var exampleValue: String?

                    public var isRequiredParameter: Bool?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public var parameterOperator: Int32?

                    public var parameterPosition: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.columnName != nil {
                            map["ColumnName"] = self.columnName!
                        }
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.isRequiredParameter != nil {
                            map["IsRequiredParameter"] = self.isRequiredParameter!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        if self.parameterOperator != nil {
                            map["ParameterOperator"] = self.parameterOperator!
                        }
                        if self.parameterPosition != nil {
                            map["ParameterPosition"] = self.parameterPosition!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ColumnName"] as? String {
                            self.columnName = value
                        }
                        if let value = dict["DefaultValue"] as? String {
                            self.defaultValue = value
                        }
                        if let value = dict["ExampleValue"] as? String {
                            self.exampleValue = value
                        }
                        if let value = dict["IsRequiredParameter"] as? Bool {
                            self.isRequiredParameter = value
                        }
                        if let value = dict["ParameterDataType"] as? Int32 {
                            self.parameterDataType = value
                        }
                        if let value = dict["ParameterDescription"] as? String {
                            self.parameterDescription = value
                        }
                        if let value = dict["ParameterName"] as? String {
                            self.parameterName = value
                        }
                        if let value = dict["ParameterOperator"] as? Int32 {
                            self.parameterOperator = value
                        }
                        if let value = dict["ParameterPosition"] as? Int32 {
                            self.parameterPosition = value
                        }
                    }
                }
                public class WizardResponseParameters : Tea.TeaModel {
                    public var columnName: String?

                    public var exampleValue: String?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.columnName != nil {
                            map["ColumnName"] = self.columnName!
                        }
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ColumnName"] as? String {
                            self.columnName = value
                        }
                        if let value = dict["ExampleValue"] as? String {
                            self.exampleValue = value
                        }
                        if let value = dict["ParameterDataType"] as? Int32 {
                            self.parameterDataType = value
                        }
                        if let value = dict["ParameterDescription"] as? String {
                            self.parameterDescription = value
                        }
                        if let value = dict["ParameterName"] as? String {
                            self.parameterName = value
                        }
                    }
                }
                public var isPagedResponse: Bool?

                public var wizardConnection: ListDataServiceApisResponseBody.Data.Apis.WizardDetails.WizardConnection?

                public var wizardRequestParameters: [ListDataServiceApisResponseBody.Data.Apis.WizardDetails.WizardRequestParameters]?

                public var wizardResponseParameters: [ListDataServiceApisResponseBody.Data.Apis.WizardDetails.WizardResponseParameters]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.wizardConnection?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.isPagedResponse != nil {
                        map["IsPagedResponse"] = self.isPagedResponse!
                    }
                    if self.wizardConnection != nil {
                        map["WizardConnection"] = self.wizardConnection?.toMap()
                    }
                    if self.wizardRequestParameters != nil {
                        var tmp : [Any] = []
                        for k in self.wizardRequestParameters! {
                            tmp.append(k.toMap())
                        }
                        map["WizardRequestParameters"] = tmp
                    }
                    if self.wizardResponseParameters != nil {
                        var tmp : [Any] = []
                        for k in self.wizardResponseParameters! {
                            tmp.append(k.toMap())
                        }
                        map["WizardResponseParameters"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IsPagedResponse"] as? Bool {
                        self.isPagedResponse = value
                    }
                    if let value = dict["WizardConnection"] as? [String: Any?] {
                        var model = ListDataServiceApisResponseBody.Data.Apis.WizardDetails.WizardConnection()
                        model.fromMap(value)
                        self.wizardConnection = model
                    }
                    if let value = dict["WizardRequestParameters"] as? [Any?] {
                        var tmp : [ListDataServiceApisResponseBody.Data.Apis.WizardDetails.WizardRequestParameters] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataServiceApisResponseBody.Data.Apis.WizardDetails.WizardRequestParameters()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.wizardRequestParameters = tmp
                    }
                    if let value = dict["WizardResponseParameters"] as? [Any?] {
                        var tmp : [ListDataServiceApisResponseBody.Data.Apis.WizardDetails.WizardResponseParameters] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataServiceApisResponseBody.Data.Apis.WizardDetails.WizardResponseParameters()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.wizardResponseParameters = tmp
                    }
                }
            }
            public var apiId: Int64?

            public var apiMode: Int32?

            public var apiName: String?

            public var apiPath: String?

            public var createdTime: String?

            public var creatorId: String?

            public var description_: String?

            public var folderId: Int64?

            public var groupId: String?

            public var modifiedTime: String?

            public var operatorId: String?

            public var projectId: Int64?

            public var protocols: [Int32]?

            public var registrationDetails: ListDataServiceApisResponseBody.Data.Apis.RegistrationDetails?

            public var requestMethod: Int32?

            public var responseContentType: Int32?

            public var scriptDetails: ListDataServiceApisResponseBody.Data.Apis.ScriptDetails?

            public var status: Int32?

            public var tenantId: Int64?

            public var timeout: Int32?

            public var visibleRange: Int32?

            public var wizardDetails: ListDataServiceApisResponseBody.Data.Apis.WizardDetails?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.registrationDetails?.validate()
                try self.scriptDetails?.validate()
                try self.wizardDetails?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiMode != nil {
                    map["ApiMode"] = self.apiMode!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiPath != nil {
                    map["ApiPath"] = self.apiPath!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.folderId != nil {
                    map["FolderId"] = self.folderId!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.operatorId != nil {
                    map["OperatorId"] = self.operatorId!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.protocols != nil {
                    map["Protocols"] = self.protocols!
                }
                if self.registrationDetails != nil {
                    map["RegistrationDetails"] = self.registrationDetails?.toMap()
                }
                if self.requestMethod != nil {
                    map["RequestMethod"] = self.requestMethod!
                }
                if self.responseContentType != nil {
                    map["ResponseContentType"] = self.responseContentType!
                }
                if self.scriptDetails != nil {
                    map["ScriptDetails"] = self.scriptDetails?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.visibleRange != nil {
                    map["VisibleRange"] = self.visibleRange!
                }
                if self.wizardDetails != nil {
                    map["WizardDetails"] = self.wizardDetails?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ApiId"] as? Int64 {
                    self.apiId = value
                }
                if let value = dict["ApiMode"] as? Int32 {
                    self.apiMode = value
                }
                if let value = dict["ApiName"] as? String {
                    self.apiName = value
                }
                if let value = dict["ApiPath"] as? String {
                    self.apiPath = value
                }
                if let value = dict["CreatedTime"] as? String {
                    self.createdTime = value
                }
                if let value = dict["CreatorId"] as? String {
                    self.creatorId = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["FolderId"] as? Int64 {
                    self.folderId = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["ModifiedTime"] as? String {
                    self.modifiedTime = value
                }
                if let value = dict["OperatorId"] as? String {
                    self.operatorId = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Protocols"] as? [Int32] {
                    self.protocols = value
                }
                if let value = dict["RegistrationDetails"] as? [String: Any?] {
                    var model = ListDataServiceApisResponseBody.Data.Apis.RegistrationDetails()
                    model.fromMap(value)
                    self.registrationDetails = model
                }
                if let value = dict["RequestMethod"] as? Int32 {
                    self.requestMethod = value
                }
                if let value = dict["ResponseContentType"] as? Int32 {
                    self.responseContentType = value
                }
                if let value = dict["ScriptDetails"] as? [String: Any?] {
                    var model = ListDataServiceApisResponseBody.Data.Apis.ScriptDetails()
                    model.fromMap(value)
                    self.scriptDetails = model
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
                if let value = dict["TenantId"] as? Int64 {
                    self.tenantId = value
                }
                if let value = dict["Timeout"] as? Int32 {
                    self.timeout = value
                }
                if let value = dict["VisibleRange"] as? Int32 {
                    self.visibleRange = value
                }
                if let value = dict["WizardDetails"] as? [String: Any?] {
                    var model = ListDataServiceApisResponseBody.Data.Apis.WizardDetails()
                    model.fromMap(value)
                    self.wizardDetails = model
                }
            }
        }
        public var apis: [ListDataServiceApisResponseBody.Data.Apis]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apis != nil {
                var tmp : [Any] = []
                for k in self.apis! {
                    tmp.append(k.toMap())
                }
                map["Apis"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Apis"] as? [Any?] {
                var tmp : [ListDataServiceApisResponseBody.Data.Apis] = []
                for v in value {
                    if v != nil {
                        var model = ListDataServiceApisResponseBody.Data.Apis()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.apis = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListDataServiceApisResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListDataServiceApisResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListDataServiceApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataServiceApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataServiceApisResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataServiceApplicationsRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectIdList: String?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectIdList != nil {
            map["ProjectIdList"] = self.projectIdList!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectIdList"] as? String {
            self.projectIdList = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class ListDataServiceApplicationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Applications : Tea.TeaModel {
            public var applicationId: Int64?

            public var applicationName: String?

            public var projectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applicationId != nil {
                    map["ApplicationId"] = self.applicationId!
                }
                if self.applicationName != nil {
                    map["ApplicationName"] = self.applicationName!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ApplicationId"] as? Int64 {
                    self.applicationId = value
                }
                if let value = dict["ApplicationName"] as? String {
                    self.applicationName = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
            }
        }
        public var applications: [ListDataServiceApplicationsResponseBody.Data.Applications]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applications != nil {
                var tmp : [Any] = []
                for k in self.applications! {
                    tmp.append(k.toMap())
                }
                map["Applications"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Applications"] as? [Any?] {
                var tmp : [ListDataServiceApplicationsResponseBody.Data.Applications] = []
                for v in value {
                    if v != nil {
                        var model = ListDataServiceApplicationsResponseBody.Data.Applications()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.applications = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListDataServiceApplicationsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListDataServiceApplicationsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListDataServiceApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataServiceApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataServiceApplicationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataServiceAuthorizedApisRequest : Tea.TeaModel {
    public var apiNameKeyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiNameKeyword != nil {
            map["ApiNameKeyword"] = self.apiNameKeyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiNameKeyword"] as? String {
            self.apiNameKeyword = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class ListDataServiceAuthorizedApisResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ApiAuthorizedList : Tea.TeaModel {
            public var apiId: Int64?

            public var apiName: String?

            public var apiPath: String?

            public var apiStatus: Int32?

            public var createdTime: String?

            public var creatorId: String?

            public var grantCreatedTime: String?

            public var grantEndTime: String?

            public var grantOperatorId: String?

            public var groupId: String?

            public var modifiedTime: String?

            public var projectId: Int64?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiPath != nil {
                    map["ApiPath"] = self.apiPath!
                }
                if self.apiStatus != nil {
                    map["ApiStatus"] = self.apiStatus!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.grantCreatedTime != nil {
                    map["GrantCreatedTime"] = self.grantCreatedTime!
                }
                if self.grantEndTime != nil {
                    map["GrantEndTime"] = self.grantEndTime!
                }
                if self.grantOperatorId != nil {
                    map["GrantOperatorId"] = self.grantOperatorId!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ApiId"] as? Int64 {
                    self.apiId = value
                }
                if let value = dict["ApiName"] as? String {
                    self.apiName = value
                }
                if let value = dict["ApiPath"] as? String {
                    self.apiPath = value
                }
                if let value = dict["ApiStatus"] as? Int32 {
                    self.apiStatus = value
                }
                if let value = dict["CreatedTime"] as? String {
                    self.createdTime = value
                }
                if let value = dict["CreatorId"] as? String {
                    self.creatorId = value
                }
                if let value = dict["GrantCreatedTime"] as? String {
                    self.grantCreatedTime = value
                }
                if let value = dict["GrantEndTime"] as? String {
                    self.grantEndTime = value
                }
                if let value = dict["GrantOperatorId"] as? String {
                    self.grantOperatorId = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["ModifiedTime"] as? String {
                    self.modifiedTime = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["TenantId"] as? Int64 {
                    self.tenantId = value
                }
            }
        }
        public var apiAuthorizedList: [ListDataServiceAuthorizedApisResponseBody.Data.ApiAuthorizedList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiAuthorizedList != nil {
                var tmp : [Any] = []
                for k in self.apiAuthorizedList! {
                    tmp.append(k.toMap())
                }
                map["ApiAuthorizedList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApiAuthorizedList"] as? [Any?] {
                var tmp : [ListDataServiceAuthorizedApisResponseBody.Data.ApiAuthorizedList] = []
                for v in value {
                    if v != nil {
                        var model = ListDataServiceAuthorizedApisResponseBody.Data.ApiAuthorizedList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.apiAuthorizedList = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListDataServiceAuthorizedApisResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListDataServiceAuthorizedApisResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListDataServiceAuthorizedApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataServiceAuthorizedApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataServiceAuthorizedApisResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataServiceFoldersRequest : Tea.TeaModel {
    public var folderNameKeyword: String?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderNameKeyword != nil {
            map["FolderNameKeyword"] = self.folderNameKeyword!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FolderNameKeyword"] as? String {
            self.folderNameKeyword = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class ListDataServiceFoldersResponseBody : Tea.TeaModel {
    public class FolderPagingResult : Tea.TeaModel {
        public class Folders : Tea.TeaModel {
            public var createdTime: String?

            public var folderId: Int64?

            public var folderName: String?

            public var groupId: String?

            public var modifiedTime: String?

            public var parentId: Int64?

            public var projectId: Int64?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.folderId != nil {
                    map["FolderId"] = self.folderId!
                }
                if self.folderName != nil {
                    map["FolderName"] = self.folderName!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreatedTime"] as? String {
                    self.createdTime = value
                }
                if let value = dict["FolderId"] as? Int64 {
                    self.folderId = value
                }
                if let value = dict["FolderName"] as? String {
                    self.folderName = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["ModifiedTime"] as? String {
                    self.modifiedTime = value
                }
                if let value = dict["ParentId"] as? Int64 {
                    self.parentId = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["TenantId"] as? Int64 {
                    self.tenantId = value
                }
            }
        }
        public var folders: [ListDataServiceFoldersResponseBody.FolderPagingResult.Folders]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.folders != nil {
                var tmp : [Any] = []
                for k in self.folders! {
                    tmp.append(k.toMap())
                }
                map["Folders"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Folders"] as? [Any?] {
                var tmp : [ListDataServiceFoldersResponseBody.FolderPagingResult.Folders] = []
                for v in value {
                    if v != nil {
                        var model = ListDataServiceFoldersResponseBody.FolderPagingResult.Folders()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.folders = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var folderPagingResult: ListDataServiceFoldersResponseBody.FolderPagingResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.folderPagingResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderPagingResult != nil {
            map["FolderPagingResult"] = self.folderPagingResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FolderPagingResult"] as? [String: Any?] {
            var model = ListDataServiceFoldersResponseBody.FolderPagingResult()
            model.fromMap(value)
            self.folderPagingResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDataServiceFoldersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataServiceFoldersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataServiceFoldersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataServiceGroupsRequest : Tea.TeaModel {
    public var groupNameKeyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupNameKeyword != nil {
            map["GroupNameKeyword"] = self.groupNameKeyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupNameKeyword"] as? String {
            self.groupNameKeyword = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class ListDataServiceGroupsResponseBody : Tea.TeaModel {
    public class GroupPagingResult : Tea.TeaModel {
        public class Groups : Tea.TeaModel {
            public var apiGatewayGroupId: String?

            public var createdTime: String?

            public var creatorId: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var modifiedTime: String?

            public var projectId: Int64?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiGatewayGroupId != nil {
                    map["ApiGatewayGroupId"] = self.apiGatewayGroupId!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ApiGatewayGroupId"] as? String {
                    self.apiGatewayGroupId = value
                }
                if let value = dict["CreatedTime"] as? String {
                    self.createdTime = value
                }
                if let value = dict["CreatorId"] as? String {
                    self.creatorId = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["ModifiedTime"] as? String {
                    self.modifiedTime = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["TenantId"] as? Int64 {
                    self.tenantId = value
                }
            }
        }
        public var groups: [ListDataServiceGroupsResponseBody.GroupPagingResult.Groups]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groups != nil {
                var tmp : [Any] = []
                for k in self.groups! {
                    tmp.append(k.toMap())
                }
                map["Groups"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Groups"] as? [Any?] {
                var tmp : [ListDataServiceGroupsResponseBody.GroupPagingResult.Groups] = []
                for v in value {
                    if v != nil {
                        var model = ListDataServiceGroupsResponseBody.GroupPagingResult.Groups()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.groups = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var groupPagingResult: ListDataServiceGroupsResponseBody.GroupPagingResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.groupPagingResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupPagingResult != nil {
            map["GroupPagingResult"] = self.groupPagingResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupPagingResult"] as? [String: Any?] {
            var model = ListDataServiceGroupsResponseBody.GroupPagingResult()
            model.fromMap(value)
            self.groupPagingResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDataServiceGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataServiceGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataServiceGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataServicePublishedApisRequest : Tea.TeaModel {
    public var apiNameKeyword: String?

    public var apiPathKeyword: String?

    public var creatorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiNameKeyword != nil {
            map["ApiNameKeyword"] = self.apiNameKeyword!
        }
        if self.apiPathKeyword != nil {
            map["ApiPathKeyword"] = self.apiPathKeyword!
        }
        if self.creatorId != nil {
            map["CreatorId"] = self.creatorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiNameKeyword"] as? String {
            self.apiNameKeyword = value
        }
        if let value = dict["ApiPathKeyword"] as? String {
            self.apiPathKeyword = value
        }
        if let value = dict["CreatorId"] as? String {
            self.creatorId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class ListDataServicePublishedApisResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Apis : Tea.TeaModel {
            public class RegistrationDetails : Tea.TeaModel {
                public class RegistrationErrorCodes : Tea.TeaModel {
                    public var errorCode: String?

                    public var errorMessage: String?

                    public var errorSolution: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorMessage != nil {
                            map["ErrorMessage"] = self.errorMessage!
                        }
                        if self.errorSolution != nil {
                            map["ErrorSolution"] = self.errorSolution!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ErrorCode"] as? String {
                            self.errorCode = value
                        }
                        if let value = dict["ErrorMessage"] as? String {
                            self.errorMessage = value
                        }
                        if let value = dict["ErrorSolution"] as? String {
                            self.errorSolution = value
                        }
                    }
                }
                public class RegistrationRequestParameters : Tea.TeaModel {
                    public var defaultValue: String?

                    public var exampleValue: String?

                    public var isRequiredParameter: Bool?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public var parameterOperator: Int32?

                    public var parameterPosition: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.isRequiredParameter != nil {
                            map["IsRequiredParameter"] = self.isRequiredParameter!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        if self.parameterOperator != nil {
                            map["ParameterOperator"] = self.parameterOperator!
                        }
                        if self.parameterPosition != nil {
                            map["ParameterPosition"] = self.parameterPosition!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DefaultValue"] as? String {
                            self.defaultValue = value
                        }
                        if let value = dict["ExampleValue"] as? String {
                            self.exampleValue = value
                        }
                        if let value = dict["IsRequiredParameter"] as? Bool {
                            self.isRequiredParameter = value
                        }
                        if let value = dict["ParameterDataType"] as? Int32 {
                            self.parameterDataType = value
                        }
                        if let value = dict["ParameterDescription"] as? String {
                            self.parameterDescription = value
                        }
                        if let value = dict["ParameterName"] as? String {
                            self.parameterName = value
                        }
                        if let value = dict["ParameterOperator"] as? Int32 {
                            self.parameterOperator = value
                        }
                        if let value = dict["ParameterPosition"] as? Int32 {
                            self.parameterPosition = value
                        }
                    }
                }
                public var failedResultSample: String?

                public var registrationErrorCodes: [ListDataServicePublishedApisResponseBody.Data.Apis.RegistrationDetails.RegistrationErrorCodes]?

                public var registrationRequestParameters: [ListDataServicePublishedApisResponseBody.Data.Apis.RegistrationDetails.RegistrationRequestParameters]?

                public var serviceContentType: Int32?

                public var serviceHost: String?

                public var servicePath: String?

                public var serviceRequestBodyDescription: String?

                public var successfulResultSample: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.failedResultSample != nil {
                        map["FailedResultSample"] = self.failedResultSample!
                    }
                    if self.registrationErrorCodes != nil {
                        var tmp : [Any] = []
                        for k in self.registrationErrorCodes! {
                            tmp.append(k.toMap())
                        }
                        map["RegistrationErrorCodes"] = tmp
                    }
                    if self.registrationRequestParameters != nil {
                        var tmp : [Any] = []
                        for k in self.registrationRequestParameters! {
                            tmp.append(k.toMap())
                        }
                        map["RegistrationRequestParameters"] = tmp
                    }
                    if self.serviceContentType != nil {
                        map["ServiceContentType"] = self.serviceContentType!
                    }
                    if self.serviceHost != nil {
                        map["ServiceHost"] = self.serviceHost!
                    }
                    if self.servicePath != nil {
                        map["ServicePath"] = self.servicePath!
                    }
                    if self.serviceRequestBodyDescription != nil {
                        map["ServiceRequestBodyDescription"] = self.serviceRequestBodyDescription!
                    }
                    if self.successfulResultSample != nil {
                        map["SuccessfulResultSample"] = self.successfulResultSample!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["FailedResultSample"] as? String {
                        self.failedResultSample = value
                    }
                    if let value = dict["RegistrationErrorCodes"] as? [Any?] {
                        var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis.RegistrationDetails.RegistrationErrorCodes] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataServicePublishedApisResponseBody.Data.Apis.RegistrationDetails.RegistrationErrorCodes()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.registrationErrorCodes = tmp
                    }
                    if let value = dict["RegistrationRequestParameters"] as? [Any?] {
                        var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis.RegistrationDetails.RegistrationRequestParameters] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataServicePublishedApisResponseBody.Data.Apis.RegistrationDetails.RegistrationRequestParameters()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.registrationRequestParameters = tmp
                    }
                    if let value = dict["ServiceContentType"] as? Int32 {
                        self.serviceContentType = value
                    }
                    if let value = dict["ServiceHost"] as? String {
                        self.serviceHost = value
                    }
                    if let value = dict["ServicePath"] as? String {
                        self.servicePath = value
                    }
                    if let value = dict["ServiceRequestBodyDescription"] as? String {
                        self.serviceRequestBodyDescription = value
                    }
                    if let value = dict["SuccessfulResultSample"] as? String {
                        self.successfulResultSample = value
                    }
                }
            }
            public class ScriptDetails : Tea.TeaModel {
                public class ScriptConnection : Tea.TeaModel {
                    public var connectionId: Int64?

                    public var tableName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.connectionId != nil {
                            map["ConnectionId"] = self.connectionId!
                        }
                        if self.tableName != nil {
                            map["TableName"] = self.tableName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ConnectionId"] as? Int64 {
                            self.connectionId = value
                        }
                        if let value = dict["TableName"] as? String {
                            self.tableName = value
                        }
                    }
                }
                public class ScriptErrorCodes : Tea.TeaModel {
                    public var errorCode: String?

                    public var errorMessage: String?

                    public var errorSolution: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorMessage != nil {
                            map["ErrorMessage"] = self.errorMessage!
                        }
                        if self.errorSolution != nil {
                            map["ErrorSolution"] = self.errorSolution!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ErrorCode"] as? String {
                            self.errorCode = value
                        }
                        if let value = dict["ErrorMessage"] as? String {
                            self.errorMessage = value
                        }
                        if let value = dict["ErrorSolution"] as? String {
                            self.errorSolution = value
                        }
                    }
                }
                public class ScriptRequestParameters : Tea.TeaModel {
                    public var defaultValue: String?

                    public var exampleValue: String?

                    public var isRequiredParameter: Bool?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public var parameterOperator: Int32?

                    public var parameterPosition: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.isRequiredParameter != nil {
                            map["IsRequiredParameter"] = self.isRequiredParameter!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        if self.parameterOperator != nil {
                            map["ParameterOperator"] = self.parameterOperator!
                        }
                        if self.parameterPosition != nil {
                            map["ParameterPosition"] = self.parameterPosition!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DefaultValue"] as? String {
                            self.defaultValue = value
                        }
                        if let value = dict["ExampleValue"] as? String {
                            self.exampleValue = value
                        }
                        if let value = dict["IsRequiredParameter"] as? Bool {
                            self.isRequiredParameter = value
                        }
                        if let value = dict["ParameterDataType"] as? Int32 {
                            self.parameterDataType = value
                        }
                        if let value = dict["ParameterDescription"] as? String {
                            self.parameterDescription = value
                        }
                        if let value = dict["ParameterName"] as? String {
                            self.parameterName = value
                        }
                        if let value = dict["ParameterOperator"] as? Int32 {
                            self.parameterOperator = value
                        }
                        if let value = dict["ParameterPosition"] as? Int32 {
                            self.parameterPosition = value
                        }
                    }
                }
                public class ScriptResponseParameters : Tea.TeaModel {
                    public var exampleValue: String?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ExampleValue"] as? String {
                            self.exampleValue = value
                        }
                        if let value = dict["ParameterDataType"] as? Int32 {
                            self.parameterDataType = value
                        }
                        if let value = dict["ParameterDescription"] as? String {
                            self.parameterDescription = value
                        }
                        if let value = dict["ParameterName"] as? String {
                            self.parameterName = value
                        }
                    }
                }
                public var failedResultSample: String?

                public var isPagedResponse: Bool?

                public var script: String?

                public var scriptConnection: ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptConnection?

                public var scriptErrorCodes: [ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptErrorCodes]?

                public var scriptRequestParameters: [ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptRequestParameters]?

                public var scriptResponseParameters: [ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptResponseParameters]?

                public var successfulResultSample: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.scriptConnection?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.failedResultSample != nil {
                        map["FailedResultSample"] = self.failedResultSample!
                    }
                    if self.isPagedResponse != nil {
                        map["IsPagedResponse"] = self.isPagedResponse!
                    }
                    if self.script != nil {
                        map["Script"] = self.script!
                    }
                    if self.scriptConnection != nil {
                        map["ScriptConnection"] = self.scriptConnection?.toMap()
                    }
                    if self.scriptErrorCodes != nil {
                        var tmp : [Any] = []
                        for k in self.scriptErrorCodes! {
                            tmp.append(k.toMap())
                        }
                        map["ScriptErrorCodes"] = tmp
                    }
                    if self.scriptRequestParameters != nil {
                        var tmp : [Any] = []
                        for k in self.scriptRequestParameters! {
                            tmp.append(k.toMap())
                        }
                        map["ScriptRequestParameters"] = tmp
                    }
                    if self.scriptResponseParameters != nil {
                        var tmp : [Any] = []
                        for k in self.scriptResponseParameters! {
                            tmp.append(k.toMap())
                        }
                        map["ScriptResponseParameters"] = tmp
                    }
                    if self.successfulResultSample != nil {
                        map["SuccessfulResultSample"] = self.successfulResultSample!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["FailedResultSample"] as? String {
                        self.failedResultSample = value
                    }
                    if let value = dict["IsPagedResponse"] as? Bool {
                        self.isPagedResponse = value
                    }
                    if let value = dict["Script"] as? String {
                        self.script = value
                    }
                    if let value = dict["ScriptConnection"] as? [String: Any?] {
                        var model = ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptConnection()
                        model.fromMap(value)
                        self.scriptConnection = model
                    }
                    if let value = dict["ScriptErrorCodes"] as? [Any?] {
                        var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptErrorCodes] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptErrorCodes()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.scriptErrorCodes = tmp
                    }
                    if let value = dict["ScriptRequestParameters"] as? [Any?] {
                        var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptRequestParameters] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptRequestParameters()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.scriptRequestParameters = tmp
                    }
                    if let value = dict["ScriptResponseParameters"] as? [Any?] {
                        var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptResponseParameters] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails.ScriptResponseParameters()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.scriptResponseParameters = tmp
                    }
                    if let value = dict["SuccessfulResultSample"] as? String {
                        self.successfulResultSample = value
                    }
                }
            }
            public class WizardDetails : Tea.TeaModel {
                public class WizardConnection : Tea.TeaModel {
                    public var connectionId: Int64?

                    public var tableName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.connectionId != nil {
                            map["ConnectionId"] = self.connectionId!
                        }
                        if self.tableName != nil {
                            map["TableName"] = self.tableName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ConnectionId"] as? Int64 {
                            self.connectionId = value
                        }
                        if let value = dict["TableName"] as? String {
                            self.tableName = value
                        }
                    }
                }
                public class WizardErrorCodes : Tea.TeaModel {
                    public var errorCode: String?

                    public var errorMessage: String?

                    public var errorSolution: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorMessage != nil {
                            map["ErrorMessage"] = self.errorMessage!
                        }
                        if self.errorSolution != nil {
                            map["ErrorSolution"] = self.errorSolution!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ErrorCode"] as? String {
                            self.errorCode = value
                        }
                        if let value = dict["ErrorMessage"] as? String {
                            self.errorMessage = value
                        }
                        if let value = dict["ErrorSolution"] as? String {
                            self.errorSolution = value
                        }
                    }
                }
                public class WizardRequestParameters : Tea.TeaModel {
                    public var defaultValue: String?

                    public var exampleValue: String?

                    public var isRequiredParameter: Bool?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public var parameterOperator: Int32?

                    public var parameterPosition: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.isRequiredParameter != nil {
                            map["IsRequiredParameter"] = self.isRequiredParameter!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        if self.parameterOperator != nil {
                            map["ParameterOperator"] = self.parameterOperator!
                        }
                        if self.parameterPosition != nil {
                            map["ParameterPosition"] = self.parameterPosition!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DefaultValue"] as? String {
                            self.defaultValue = value
                        }
                        if let value = dict["ExampleValue"] as? String {
                            self.exampleValue = value
                        }
                        if let value = dict["IsRequiredParameter"] as? Bool {
                            self.isRequiredParameter = value
                        }
                        if let value = dict["ParameterDataType"] as? Int32 {
                            self.parameterDataType = value
                        }
                        if let value = dict["ParameterDescription"] as? String {
                            self.parameterDescription = value
                        }
                        if let value = dict["ParameterName"] as? String {
                            self.parameterName = value
                        }
                        if let value = dict["ParameterOperator"] as? Int32 {
                            self.parameterOperator = value
                        }
                        if let value = dict["ParameterPosition"] as? Int32 {
                            self.parameterPosition = value
                        }
                    }
                }
                public class WizardResponseParameters : Tea.TeaModel {
                    public var exampleValue: String?

                    public var parameterDataType: Int32?

                    public var parameterDescription: String?

                    public var parameterName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.exampleValue != nil {
                            map["ExampleValue"] = self.exampleValue!
                        }
                        if self.parameterDataType != nil {
                            map["ParameterDataType"] = self.parameterDataType!
                        }
                        if self.parameterDescription != nil {
                            map["ParameterDescription"] = self.parameterDescription!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ExampleValue"] as? String {
                            self.exampleValue = value
                        }
                        if let value = dict["ParameterDataType"] as? Int32 {
                            self.parameterDataType = value
                        }
                        if let value = dict["ParameterDescription"] as? String {
                            self.parameterDescription = value
                        }
                        if let value = dict["ParameterName"] as? String {
                            self.parameterName = value
                        }
                    }
                }
                public var failedResultSample: String?

                public var isPagedResponse: Bool?

                public var successfulResultSample: String?

                public var wizardConnection: ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardConnection?

                public var wizardErrorCodes: [ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardErrorCodes]?

                public var wizardRequestParameters: [ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardRequestParameters]?

                public var wizardResponseParameters: [ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardResponseParameters]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.wizardConnection?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.failedResultSample != nil {
                        map["FailedResultSample"] = self.failedResultSample!
                    }
                    if self.isPagedResponse != nil {
                        map["IsPagedResponse"] = self.isPagedResponse!
                    }
                    if self.successfulResultSample != nil {
                        map["SuccessfulResultSample"] = self.successfulResultSample!
                    }
                    if self.wizardConnection != nil {
                        map["WizardConnection"] = self.wizardConnection?.toMap()
                    }
                    if self.wizardErrorCodes != nil {
                        var tmp : [Any] = []
                        for k in self.wizardErrorCodes! {
                            tmp.append(k.toMap())
                        }
                        map["WizardErrorCodes"] = tmp
                    }
                    if self.wizardRequestParameters != nil {
                        var tmp : [Any] = []
                        for k in self.wizardRequestParameters! {
                            tmp.append(k.toMap())
                        }
                        map["WizardRequestParameters"] = tmp
                    }
                    if self.wizardResponseParameters != nil {
                        var tmp : [Any] = []
                        for k in self.wizardResponseParameters! {
                            tmp.append(k.toMap())
                        }
                        map["WizardResponseParameters"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["FailedResultSample"] as? String {
                        self.failedResultSample = value
                    }
                    if let value = dict["IsPagedResponse"] as? Bool {
                        self.isPagedResponse = value
                    }
                    if let value = dict["SuccessfulResultSample"] as? String {
                        self.successfulResultSample = value
                    }
                    if let value = dict["WizardConnection"] as? [String: Any?] {
                        var model = ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardConnection()
                        model.fromMap(value)
                        self.wizardConnection = model
                    }
                    if let value = dict["WizardErrorCodes"] as? [Any?] {
                        var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardErrorCodes] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardErrorCodes()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.wizardErrorCodes = tmp
                    }
                    if let value = dict["WizardRequestParameters"] as? [Any?] {
                        var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardRequestParameters] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardRequestParameters()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.wizardRequestParameters = tmp
                    }
                    if let value = dict["WizardResponseParameters"] as? [Any?] {
                        var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardResponseParameters] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails.WizardResponseParameters()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.wizardResponseParameters = tmp
                    }
                }
            }
            public var apiId: Int64?

            public var apiMode: Int32?

            public var apiName: String?

            public var apiPath: String?

            public var createdTime: String?

            public var creatorId: String?

            public var description_: String?

            public var groupId: String?

            public var modifiedTime: String?

            public var operatorId: String?

            public var projectId: Int64?

            public var protocols: [Int32]?

            public var registrationDetails: ListDataServicePublishedApisResponseBody.Data.Apis.RegistrationDetails?

            public var requestMethod: Int32?

            public var responseContentType: Int32?

            public var scriptDetails: ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails?

            public var sqlMode: Int32?

            public var status: Int32?

            public var tenantId: Int64?

            public var timeout: Int32?

            public var visibleRange: Int32?

            public var wizardDetails: ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.registrationDetails?.validate()
                try self.scriptDetails?.validate()
                try self.wizardDetails?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiMode != nil {
                    map["ApiMode"] = self.apiMode!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiPath != nil {
                    map["ApiPath"] = self.apiPath!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.operatorId != nil {
                    map["OperatorId"] = self.operatorId!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.protocols != nil {
                    map["Protocols"] = self.protocols!
                }
                if self.registrationDetails != nil {
                    map["RegistrationDetails"] = self.registrationDetails?.toMap()
                }
                if self.requestMethod != nil {
                    map["RequestMethod"] = self.requestMethod!
                }
                if self.responseContentType != nil {
                    map["ResponseContentType"] = self.responseContentType!
                }
                if self.scriptDetails != nil {
                    map["ScriptDetails"] = self.scriptDetails?.toMap()
                }
                if self.sqlMode != nil {
                    map["SqlMode"] = self.sqlMode!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.visibleRange != nil {
                    map["VisibleRange"] = self.visibleRange!
                }
                if self.wizardDetails != nil {
                    map["WizardDetails"] = self.wizardDetails?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ApiId"] as? Int64 {
                    self.apiId = value
                }
                if let value = dict["ApiMode"] as? Int32 {
                    self.apiMode = value
                }
                if let value = dict["ApiName"] as? String {
                    self.apiName = value
                }
                if let value = dict["ApiPath"] as? String {
                    self.apiPath = value
                }
                if let value = dict["CreatedTime"] as? String {
                    self.createdTime = value
                }
                if let value = dict["CreatorId"] as? String {
                    self.creatorId = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["ModifiedTime"] as? String {
                    self.modifiedTime = value
                }
                if let value = dict["OperatorId"] as? String {
                    self.operatorId = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Protocols"] as? [Int32] {
                    self.protocols = value
                }
                if let value = dict["RegistrationDetails"] as? [String: Any?] {
                    var model = ListDataServicePublishedApisResponseBody.Data.Apis.RegistrationDetails()
                    model.fromMap(value)
                    self.registrationDetails = model
                }
                if let value = dict["RequestMethod"] as? Int32 {
                    self.requestMethod = value
                }
                if let value = dict["ResponseContentType"] as? Int32 {
                    self.responseContentType = value
                }
                if let value = dict["ScriptDetails"] as? [String: Any?] {
                    var model = ListDataServicePublishedApisResponseBody.Data.Apis.ScriptDetails()
                    model.fromMap(value)
                    self.scriptDetails = model
                }
                if let value = dict["SqlMode"] as? Int32 {
                    self.sqlMode = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
                if let value = dict["TenantId"] as? Int64 {
                    self.tenantId = value
                }
                if let value = dict["Timeout"] as? Int32 {
                    self.timeout = value
                }
                if let value = dict["VisibleRange"] as? Int32 {
                    self.visibleRange = value
                }
                if let value = dict["WizardDetails"] as? [String: Any?] {
                    var model = ListDataServicePublishedApisResponseBody.Data.Apis.WizardDetails()
                    model.fromMap(value)
                    self.wizardDetails = model
                }
            }
        }
        public var apis: [ListDataServicePublishedApisResponseBody.Data.Apis]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apis != nil {
                var tmp : [Any] = []
                for k in self.apis! {
                    tmp.append(k.toMap())
                }
                map["Apis"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Apis"] as? [Any?] {
                var tmp : [ListDataServicePublishedApisResponseBody.Data.Apis] = []
                for v in value {
                    if v != nil {
                        var model = ListDataServicePublishedApisResponseBody.Data.Apis()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.apis = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListDataServicePublishedApisResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListDataServicePublishedApisResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListDataServicePublishedApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataServicePublishedApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataServicePublishedApisResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataSourcesRequest : Tea.TeaModel {
    public var dataSourceType: String?

    public var envType: Int32?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var status: String?

    public var subType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.subType != nil {
            map["SubType"] = self.subType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["EnvType"] as? Int32 {
            self.envType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["SubType"] as? String {
            self.subType = value
        }
    }
}

public class ListDataSourcesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataSources : Tea.TeaModel {
            public var bindingCalcEngineId: Int64?

            public var connectStatus: Int32?

            public var content: String?

            public var dataSourceType: String?

            public var defaultEngine: Bool?

            public var description_: String?

            public var envType: Int32?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var name: String?

            public var operator_: String?

            public var projectId: Int32?

            public var sequence: Int32?

            public var shared: Bool?

            public var status: Int32?

            public var subType: String?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindingCalcEngineId != nil {
                    map["BindingCalcEngineId"] = self.bindingCalcEngineId!
                }
                if self.connectStatus != nil {
                    map["ConnectStatus"] = self.connectStatus!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.dataSourceType != nil {
                    map["DataSourceType"] = self.dataSourceType!
                }
                if self.defaultEngine != nil {
                    map["DefaultEngine"] = self.defaultEngine!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.sequence != nil {
                    map["Sequence"] = self.sequence!
                }
                if self.shared != nil {
                    map["Shared"] = self.shared!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.subType != nil {
                    map["SubType"] = self.subType!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BindingCalcEngineId"] as? Int64 {
                    self.bindingCalcEngineId = value
                }
                if let value = dict["ConnectStatus"] as? Int32 {
                    self.connectStatus = value
                }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["DataSourceType"] as? String {
                    self.dataSourceType = value
                }
                if let value = dict["DefaultEngine"] as? Bool {
                    self.defaultEngine = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EnvType"] as? Int32 {
                    self.envType = value
                }
                if let value = dict["GmtCreate"] as? String {
                    self.gmtCreate = value
                }
                if let value = dict["GmtModified"] as? String {
                    self.gmtModified = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Operator"] as? String {
                    self.operator_ = value
                }
                if let value = dict["ProjectId"] as? Int32 {
                    self.projectId = value
                }
                if let value = dict["Sequence"] as? Int32 {
                    self.sequence = value
                }
                if let value = dict["Shared"] as? Bool {
                    self.shared = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
                if let value = dict["SubType"] as? String {
                    self.subType = value
                }
                if let value = dict["TenantId"] as? Int64 {
                    self.tenantId = value
                }
            }
        }
        public var dataSources: [ListDataSourcesResponseBody.Data.DataSources]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSources != nil {
                var tmp : [Any] = []
                for k in self.dataSources! {
                    tmp.append(k.toMap())
                }
                map["DataSources"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataSources"] as? [Any?] {
                var tmp : [ListDataSourcesResponseBody.Data.DataSources] = []
                for v in value {
                    if v != nil {
                        var model = ListDataSourcesResponseBody.Data.DataSources()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataSources = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListDataSourcesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListDataSourcesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListDataSourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataSourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataSourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDeploymentsRequest : Tea.TeaModel {
    public var creator: String?

    public var endCreateTime: Int64?

    public var endExecuteTime: Int64?

    public var executor: String?

    public var keyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        if self.endCreateTime != nil {
            map["EndCreateTime"] = self.endCreateTime!
        }
        if self.endExecuteTime != nil {
            map["EndExecuteTime"] = self.endExecuteTime!
        }
        if self.executor != nil {
            map["Executor"] = self.executor!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Creator"] as? String {
            self.creator = value
        }
        if let value = dict["EndCreateTime"] as? Int64 {
            self.endCreateTime = value
        }
        if let value = dict["EndExecuteTime"] as? Int64 {
            self.endExecuteTime = value
        }
        if let value = dict["Executor"] as? String {
            self.executor = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
        if let value = dict["Status"] as? Int32 {
            self.status = value
        }
    }
}

public class ListDeploymentsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Deployments : Tea.TeaModel {
            public var createTime: Int64?

            public var creator: String?

            public var errorMessage: String?

            public var executeTime: Int64?

            public var executor: String?

            public var id: Int64?

            public var name: String?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.executeTime != nil {
                    map["ExecuteTime"] = self.executeTime!
                }
                if self.executor != nil {
                    map["Executor"] = self.executor!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["Creator"] as? String {
                    self.creator = value
                }
                if let value = dict["ErrorMessage"] as? String {
                    self.errorMessage = value
                }
                if let value = dict["ExecuteTime"] as? Int64 {
                    self.executeTime = value
                }
                if let value = dict["Executor"] as? String {
                    self.executor = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
            }
        }
        public var deployments: [ListDeploymentsResponseBody.Data.Deployments]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deployments != nil {
                var tmp : [Any] = []
                for k in self.deployments! {
                    tmp.append(k.toMap())
                }
                map["Deployments"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Deployments"] as? [Any?] {
                var tmp : [ListDeploymentsResponseBody.Data.Deployments] = []
                for v in value {
                    if v != nil {
                        var model = ListDeploymentsResponseBody.Data.Deployments()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.deployments = tmp
            }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: ListDeploymentsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListDeploymentsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDeploymentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDeploymentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDeploymentsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListEnabledExtensionsForProjectRequest : Tea.TeaModel {
    public var eventCode: String?

    public var fileType: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventCode != nil {
            map["EventCode"] = self.eventCode!
        }
        if self.fileType != nil {
            map["FileType"] = self.fileType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EventCode"] as? String {
            self.eventCode = value
        }
        if let value = dict["FileType"] as? String {
            self.fileType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ListEnabledExtensionsForProjectResponseBody : Tea.TeaModel {
    public class Extensions : Tea.TeaModel {
        public var createUser: String?

        public var extensionCode: String?

        public var extensionDesc: String?

        public var extensionName: String?

        public var modifyUser: String?

        public var owner: String?

        public var parameterSetting: String?

        public var tenantId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.extensionCode != nil {
                map["ExtensionCode"] = self.extensionCode!
            }
            if self.extensionDesc != nil {
                map["ExtensionDesc"] = self.extensionDesc!
            }
            if self.extensionName != nil {
                map["ExtensionName"] = self.extensionName!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.parameterSetting != nil {
                map["ParameterSetting"] = self.parameterSetting!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateUser"] as? String {
                self.createUser = value
            }
            if let value = dict["ExtensionCode"] as? String {
                self.extensionCode = value
            }
            if let value = dict["ExtensionDesc"] as? String {
                self.extensionDesc = value
            }
            if let value = dict["ExtensionName"] as? String {
                self.extensionName = value
            }
            if let value = dict["ModifyUser"] as? String {
                self.modifyUser = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["ParameterSetting"] as? String {
                self.parameterSetting = value
            }
            if let value = dict["TenantId"] as? Int64 {
                self.tenantId = value
            }
        }
    }
    public var extensions: [ListEnabledExtensionsForProjectResponseBody.Extensions]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extensions != nil {
            var tmp : [Any] = []
            for k in self.extensions! {
                tmp.append(k.toMap())
            }
            map["Extensions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Extensions"] as? [Any?] {
            var tmp : [ListEnabledExtensionsForProjectResponseBody.Extensions] = []
            for v in value {
                if v != nil {
                    var model = ListEnabledExtensionsForProjectResponseBody.Extensions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.extensions = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListEnabledExtensionsForProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEnabledExtensionsForProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListEnabledExtensionsForProjectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListEntitiesByTagsRequest : Tea.TeaModel {
    public var entityType: String?

    public var nextToken: String?

    public var pageSize: Int32?

    public var tags: [UserEntityTag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityType != nil {
            map["EntityType"] = self.entityType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EntityType"] as? String {
            self.entityType = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [UserEntityTag] = []
            for v in value {
                if v != nil {
                    var model = UserEntityTag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class ListEntitiesByTagsShrinkRequest : Tea.TeaModel {
    public var entityType: String?

    public var nextToken: String?

    public var pageSize: Int32?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityType != nil {
            map["EntityType"] = self.entityType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EntityType"] as? String {
            self.entityType = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Tags"] as? String {
            self.tagsShrink = value
        }
    }
}

public class ListEntitiesByTagsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var entityList: [Entity]?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.entityList != nil {
                var tmp : [Any] = []
                for k in self.entityList! {
                    tmp.append(k.toMap())
                }
                map["EntityList"] = tmp
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EntityList"] as? [Any?] {
                var tmp : [Entity] = []
                for v in value {
                    if v != nil {
                        var model = Entity()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.entityList = tmp
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
        }
    }
    public var data: ListEntitiesByTagsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListEntitiesByTagsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListEntitiesByTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEntitiesByTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListEntitiesByTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListEntityTagsRequest : Tea.TeaModel {
    public var qualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["QualifiedName"] as? String {
            self.qualifiedName = value
        }
    }
}

public class ListEntityTagsResponseBody : Tea.TeaModel {
    public var data: [UserEntityTag]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [UserEntityTag] = []
            for v in value {
                if v != nil {
                    var model = UserEntityTag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListEntityTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEntityTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListEntityTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListExtensionsRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListExtensionsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Extensions : Tea.TeaModel {
            public class BindEventList : Tea.TeaModel {
                public var eventCode: String?

                public var eventName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.eventCode != nil {
                        map["EventCode"] = self.eventCode!
                    }
                    if self.eventName != nil {
                        map["EventName"] = self.eventName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EventCode"] as? String {
                        self.eventCode = value
                    }
                    if let value = dict["EventName"] as? String {
                        self.eventName = value
                    }
                }
            }
            public var bindEventList: [ListExtensionsResponseBody.PagingInfo.Extensions.BindEventList]?

            public var extensionCode: String?

            public var extensionDesc: String?

            public var extensionName: String?

            public var owner: String?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindEventList != nil {
                    var tmp : [Any] = []
                    for k in self.bindEventList! {
                        tmp.append(k.toMap())
                    }
                    map["BindEventList"] = tmp
                }
                if self.extensionCode != nil {
                    map["ExtensionCode"] = self.extensionCode!
                }
                if self.extensionDesc != nil {
                    map["ExtensionDesc"] = self.extensionDesc!
                }
                if self.extensionName != nil {
                    map["ExtensionName"] = self.extensionName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BindEventList"] as? [Any?] {
                    var tmp : [ListExtensionsResponseBody.PagingInfo.Extensions.BindEventList] = []
                    for v in value {
                        if v != nil {
                            var model = ListExtensionsResponseBody.PagingInfo.Extensions.BindEventList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.bindEventList = tmp
                }
                if let value = dict["ExtensionCode"] as? String {
                    self.extensionCode = value
                }
                if let value = dict["ExtensionDesc"] as? String {
                    self.extensionDesc = value
                }
                if let value = dict["ExtensionName"] as? String {
                    self.extensionName = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
            }
        }
        public var extensions: [ListExtensionsResponseBody.PagingInfo.Extensions]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extensions != nil {
                var tmp : [Any] = []
                for k in self.extensions! {
                    tmp.append(k.toMap())
                }
                map["Extensions"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Extensions"] as? [Any?] {
                var tmp : [ListExtensionsResponseBody.PagingInfo.Extensions] = []
                for v in value {
                    if v != nil {
                        var model = ListExtensionsResponseBody.PagingInfo.Extensions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.extensions = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListExtensionsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListExtensionsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListExtensionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListExtensionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListExtensionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListFileTypeRequest : Tea.TeaModel {
    public var keyword: String?

    public var locale: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.locale != nil {
            map["Locale"] = self.locale!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Locale"] as? String {
            self.locale = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class ListFileTypeResponseBody : Tea.TeaModel {
    public class NodeTypeInfoList : Tea.TeaModel {
        public class NodeTypeInfo : Tea.TeaModel {
            public var nodeType: Int32?

            public var nodeTypeName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nodeType != nil {
                    map["NodeType"] = self.nodeType!
                }
                if self.nodeTypeName != nil {
                    map["NodeTypeName"] = self.nodeTypeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["NodeType"] as? Int32 {
                    self.nodeType = value
                }
                if let value = dict["NodeTypeName"] as? String {
                    self.nodeTypeName = value
                }
            }
        }
        public var nodeTypeInfo: [ListFileTypeResponseBody.NodeTypeInfoList.NodeTypeInfo]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeTypeInfo != nil {
                var tmp : [Any] = []
                for k in self.nodeTypeInfo! {
                    tmp.append(k.toMap())
                }
                map["NodeTypeInfo"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NodeTypeInfo"] as? [Any?] {
                var tmp : [ListFileTypeResponseBody.NodeTypeInfoList.NodeTypeInfo] = []
                for v in value {
                    if v != nil {
                        var model = ListFileTypeResponseBody.NodeTypeInfoList.NodeTypeInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.nodeTypeInfo = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var nodeTypeInfoList: ListFileTypeResponseBody.NodeTypeInfoList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeTypeInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeTypeInfoList != nil {
            map["NodeTypeInfoList"] = self.nodeTypeInfoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NodeTypeInfoList"] as? [String: Any?] {
            var model = ListFileTypeResponseBody.NodeTypeInfoList()
            model.fromMap(value)
            self.nodeTypeInfoList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListFileTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFileTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListFileTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListFileVersionsRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FileId"] as? Int64 {
            self.fileId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class ListFileVersionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class FileVersions : Tea.TeaModel {
            public var changeType: String?

            public var comment: String?

            public var commitTime: Int64?

            public var commitUser: String?

            public var fileContent: String?

            public var fileName: String?

            public var filePropertyContent: String?

            public var fileVersion: Int32?

            public var isCurrentProd: Bool?

            public var nodeContent: String?

            public var nodeId: Int64?

            public var status: String?

            public var useType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.changeType != nil {
                    map["ChangeType"] = self.changeType!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.commitTime != nil {
                    map["CommitTime"] = self.commitTime!
                }
                if self.commitUser != nil {
                    map["CommitUser"] = self.commitUser!
                }
                if self.fileContent != nil {
                    map["FileContent"] = self.fileContent!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.filePropertyContent != nil {
                    map["FilePropertyContent"] = self.filePropertyContent!
                }
                if self.fileVersion != nil {
                    map["FileVersion"] = self.fileVersion!
                }
                if self.isCurrentProd != nil {
                    map["IsCurrentProd"] = self.isCurrentProd!
                }
                if self.nodeContent != nil {
                    map["NodeContent"] = self.nodeContent!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.useType != nil {
                    map["UseType"] = self.useType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ChangeType"] as? String {
                    self.changeType = value
                }
                if let value = dict["Comment"] as? String {
                    self.comment = value
                }
                if let value = dict["CommitTime"] as? Int64 {
                    self.commitTime = value
                }
                if let value = dict["CommitUser"] as? String {
                    self.commitUser = value
                }
                if let value = dict["FileContent"] as? String {
                    self.fileContent = value
                }
                if let value = dict["FileName"] as? String {
                    self.fileName = value
                }
                if let value = dict["FilePropertyContent"] as? String {
                    self.filePropertyContent = value
                }
                if let value = dict["FileVersion"] as? Int32 {
                    self.fileVersion = value
                }
                if let value = dict["IsCurrentProd"] as? Bool {
                    self.isCurrentProd = value
                }
                if let value = dict["NodeContent"] as? String {
                    self.nodeContent = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["UseType"] as? String {
                    self.useType = value
                }
            }
        }
        public var fileVersions: [ListFileVersionsResponseBody.Data.FileVersions]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileVersions != nil {
                var tmp : [Any] = []
                for k in self.fileVersions! {
                    tmp.append(k.toMap())
                }
                map["FileVersions"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FileVersions"] as? [Any?] {
                var tmp : [ListFileVersionsResponseBody.Data.FileVersions] = []
                for v in value {
                    if v != nil {
                        var model = ListFileVersionsResponseBody.Data.FileVersions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.fileVersions = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListFileVersionsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListFileVersionsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListFileVersionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFileVersionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListFileVersionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListFilesRequest : Tea.TeaModel {
    public var exactFileName: String?

    public var fileFolderPath: String?

    public var fileIdIn: String?

    public var fileTypes: String?

    public var keyword: String?

    public var lastEditUser: String?

    public var needAbsoluteFolderPath: Bool?

    public var needContent: Bool?

    public var nodeId: Int64?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var useType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exactFileName != nil {
            map["ExactFileName"] = self.exactFileName!
        }
        if self.fileFolderPath != nil {
            map["FileFolderPath"] = self.fileFolderPath!
        }
        if self.fileIdIn != nil {
            map["FileIdIn"] = self.fileIdIn!
        }
        if self.fileTypes != nil {
            map["FileTypes"] = self.fileTypes!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lastEditUser != nil {
            map["LastEditUser"] = self.lastEditUser!
        }
        if self.needAbsoluteFolderPath != nil {
            map["NeedAbsoluteFolderPath"] = self.needAbsoluteFolderPath!
        }
        if self.needContent != nil {
            map["NeedContent"] = self.needContent!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.useType != nil {
            map["UseType"] = self.useType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ExactFileName"] as? String {
            self.exactFileName = value
        }
        if let value = dict["FileFolderPath"] as? String {
            self.fileFolderPath = value
        }
        if let value = dict["FileIdIn"] as? String {
            self.fileIdIn = value
        }
        if let value = dict["FileTypes"] as? String {
            self.fileTypes = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["LastEditUser"] as? String {
            self.lastEditUser = value
        }
        if let value = dict["NeedAbsoluteFolderPath"] as? Bool {
            self.needAbsoluteFolderPath = value
        }
        if let value = dict["NeedContent"] as? Bool {
            self.needContent = value
        }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
        if let value = dict["UseType"] as? String {
            self.useType = value
        }
    }
}

public class ListFilesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Files : Tea.TeaModel {
            public var absoluteFolderPath: String?

            public var autoParsing: Bool?

            public var bizId: Int64?

            public var businessId: Int64?

            public var commitStatus: Int32?

            public var connectionName: String?

            public var content: String?

            public var createTime: Int64?

            public var createUser: String?

            public var currentVersion: Int32?

            public var fileDescription: String?

            public var fileFolderId: String?

            public var fileId: Int64?

            public var fileName: String?

            public var fileType: Int32?

            public var isMaxCompute: Bool?

            public var lastEditTime: Int64?

            public var lastEditUser: String?

            public var nodeId: Int64?

            public var owner: String?

            public var parentId: Int64?

            public var useType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.absoluteFolderPath != nil {
                    map["AbsoluteFolderPath"] = self.absoluteFolderPath!
                }
                if self.autoParsing != nil {
                    map["AutoParsing"] = self.autoParsing!
                }
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.businessId != nil {
                    map["BusinessId"] = self.businessId!
                }
                if self.commitStatus != nil {
                    map["CommitStatus"] = self.commitStatus!
                }
                if self.connectionName != nil {
                    map["ConnectionName"] = self.connectionName!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.currentVersion != nil {
                    map["CurrentVersion"] = self.currentVersion!
                }
                if self.fileDescription != nil {
                    map["FileDescription"] = self.fileDescription!
                }
                if self.fileFolderId != nil {
                    map["FileFolderId"] = self.fileFolderId!
                }
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.fileType != nil {
                    map["FileType"] = self.fileType!
                }
                if self.isMaxCompute != nil {
                    map["IsMaxCompute"] = self.isMaxCompute!
                }
                if self.lastEditTime != nil {
                    map["LastEditTime"] = self.lastEditTime!
                }
                if self.lastEditUser != nil {
                    map["LastEditUser"] = self.lastEditUser!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.useType != nil {
                    map["UseType"] = self.useType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AbsoluteFolderPath"] as? String {
                    self.absoluteFolderPath = value
                }
                if let value = dict["AutoParsing"] as? Bool {
                    self.autoParsing = value
                }
                if let value = dict["BizId"] as? Int64 {
                    self.bizId = value
                }
                if let value = dict["BusinessId"] as? Int64 {
                    self.businessId = value
                }
                if let value = dict["CommitStatus"] as? Int32 {
                    self.commitStatus = value
                }
                if let value = dict["ConnectionName"] as? String {
                    self.connectionName = value
                }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["CurrentVersion"] as? Int32 {
                    self.currentVersion = value
                }
                if let value = dict["FileDescription"] as? String {
                    self.fileDescription = value
                }
                if let value = dict["FileFolderId"] as? String {
                    self.fileFolderId = value
                }
                if let value = dict["FileId"] as? Int64 {
                    self.fileId = value
                }
                if let value = dict["FileName"] as? String {
                    self.fileName = value
                }
                if let value = dict["FileType"] as? Int32 {
                    self.fileType = value
                }
                if let value = dict["IsMaxCompute"] as? Bool {
                    self.isMaxCompute = value
                }
                if let value = dict["LastEditTime"] as? Int64 {
                    self.lastEditTime = value
                }
                if let value = dict["LastEditUser"] as? String {
                    self.lastEditUser = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["ParentId"] as? Int64 {
                    self.parentId = value
                }
                if let value = dict["UseType"] as? String {
                    self.useType = value
                }
            }
        }
        public var files: [ListFilesResponseBody.Data.Files]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.files != nil {
                var tmp : [Any] = []
                for k in self.files! {
                    tmp.append(k.toMap())
                }
                map["Files"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Files"] as? [Any?] {
                var tmp : [ListFilesResponseBody.Data.Files] = []
                for v in value {
                    if v != nil {
                        var model = ListFilesResponseBody.Data.Files()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.files = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListFilesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListFilesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListFilesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListFoldersRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var parentFolderPath: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentFolderPath != nil {
            map["ParentFolderPath"] = self.parentFolderPath!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ParentFolderPath"] as? String {
            self.parentFolderPath = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class ListFoldersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Folders : Tea.TeaModel {
            public var folderId: String?

            public var folderPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.folderId != nil {
                    map["FolderId"] = self.folderId!
                }
                if self.folderPath != nil {
                    map["FolderPath"] = self.folderPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FolderId"] as? String {
                    self.folderId = value
                }
                if let value = dict["FolderPath"] as? String {
                    self.folderPath = value
                }
            }
        }
        public var folders: [ListFoldersResponseBody.Data.Folders]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.folders != nil {
                var tmp : [Any] = []
                for k in self.folders! {
                    tmp.append(k.toMap())
                }
                map["Folders"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Folders"] as? [Any?] {
                var tmp : [ListFoldersResponseBody.Data.Folders] = []
                for v in value {
                    if v != nil {
                        var model = ListFoldersResponseBody.Data.Folders()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.folders = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListFoldersResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListFoldersResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListFoldersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFoldersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListFoldersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListInnerNodesRequest : Tea.TeaModel {
    public var nodeName: String?

    public var outerNodeId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var programType: String?

    public var projectEnv: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.outerNodeId != nil {
            map["OuterNodeId"] = self.outerNodeId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.programType != nil {
            map["ProgramType"] = self.programType!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NodeName"] as? String {
            self.nodeName = value
        }
        if let value = dict["OuterNodeId"] as? Int64 {
            self.outerNodeId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProgramType"] as? String {
            self.programType = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ListInnerNodesResponseBody : Tea.TeaModel {
    public class Paging : Tea.TeaModel {
        public class Nodes : Tea.TeaModel {
            public var baselineId: Int64?

            public var businessId: Int64?

            public var connection: String?

            public var cronExpress: String?

            public var description_: String?

            public var dqcDescription: String?

            public var dqcType: String?

            public var nodeId: Int64?

            public var nodeName: String?

            public var ownerId: String?

            public var paramValues: String?

            public var priority: Int32?

            public var programType: String?

            public var projectId: Int64?

            public var repeatInterval: Int64?

            public var repeatability: Bool?

            public var resGroupName: String?

            public var schedulerType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.businessId != nil {
                    map["BusinessId"] = self.businessId!
                }
                if self.connection != nil {
                    map["Connection"] = self.connection!
                }
                if self.cronExpress != nil {
                    map["CronExpress"] = self.cronExpress!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.dqcDescription != nil {
                    map["DqcDescription"] = self.dqcDescription!
                }
                if self.dqcType != nil {
                    map["DqcType"] = self.dqcType!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.paramValues != nil {
                    map["ParamValues"] = self.paramValues!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.programType != nil {
                    map["ProgramType"] = self.programType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.repeatInterval != nil {
                    map["RepeatInterval"] = self.repeatInterval!
                }
                if self.repeatability != nil {
                    map["Repeatability"] = self.repeatability!
                }
                if self.resGroupName != nil {
                    map["ResGroupName"] = self.resGroupName!
                }
                if self.schedulerType != nil {
                    map["SchedulerType"] = self.schedulerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["BusinessId"] as? Int64 {
                    self.businessId = value
                }
                if let value = dict["Connection"] as? String {
                    self.connection = value
                }
                if let value = dict["CronExpress"] as? String {
                    self.cronExpress = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DqcDescription"] as? String {
                    self.dqcDescription = value
                }
                if let value = dict["DqcType"] as? String {
                    self.dqcType = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["OwnerId"] as? String {
                    self.ownerId = value
                }
                if let value = dict["ParamValues"] as? String {
                    self.paramValues = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["ProgramType"] as? String {
                    self.programType = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["RepeatInterval"] as? Int64 {
                    self.repeatInterval = value
                }
                if let value = dict["Repeatability"] as? Bool {
                    self.repeatability = value
                }
                if let value = dict["ResGroupName"] as? String {
                    self.resGroupName = value
                }
                if let value = dict["SchedulerType"] as? String {
                    self.schedulerType = value
                }
            }
        }
        public var nodes: [ListInnerNodesResponseBody.Paging.Nodes]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Nodes"] as? [Any?] {
                var tmp : [ListInnerNodesResponseBody.Paging.Nodes] = []
                for v in value {
                    if v != nil {
                        var model = ListInnerNodesResponseBody.Paging.Nodes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.nodes = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var paging: ListInnerNodesResponseBody.Paging?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.paging?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.paging != nil {
            map["Paging"] = self.paging?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Paging"] as? [String: Any?] {
            var model = ListInnerNodesResponseBody.Paging()
            model.fromMap(value)
            self.paging = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListInnerNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInnerNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListInnerNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListInstanceAmountRequest : Tea.TeaModel {
    public var beginDate: String?

    public var endDate: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginDate != nil {
            map["BeginDate"] = self.beginDate!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BeginDate"] as? String {
            self.beginDate = value
        }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ListInstanceAmountResponseBody : Tea.TeaModel {
    public class InstanceCounts : Tea.TeaModel {
        public var count: Int32?

        public var date: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.date != nil {
                map["Date"] = self.date!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Count"] as? Int32 {
                self.count = value
            }
            if let value = dict["Date"] as? Int64 {
                self.date = value
            }
        }
    }
    public var instanceCounts: [ListInstanceAmountResponseBody.InstanceCounts]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceCounts != nil {
            var tmp : [Any] = []
            for k in self.instanceCounts! {
                tmp.append(k.toMap())
            }
            map["InstanceCounts"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceCounts"] as? [Any?] {
            var tmp : [ListInstanceAmountResponseBody.InstanceCounts] = []
            for v in value {
                if v != nil {
                    var model = ListInstanceAmountResponseBody.InstanceCounts()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instanceCounts = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListInstanceAmountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceAmountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListInstanceAmountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListInstanceHistoryRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? Int64 {
            self.instanceId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class ListInstanceHistoryResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public var beginRunningTime: Int64?

        public var beginWaitResTime: Int64?

        public var beginWaitTimeTime: Int64?

        public var bizdate: Int64?

        public var createTime: Int64?

        public var cycTime: Int64?

        public var dagId: Int64?

        public var dagType: String?

        public var errorMessage: String?

        public var finishTime: Int64?

        public var instanceHistoryId: Int64?

        public var instanceId: Int64?

        public var modifyTime: Int64?

        public var nodeId: Int64?

        public var nodeName: String?

        public var status: String?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.beginRunningTime != nil {
                map["BeginRunningTime"] = self.beginRunningTime!
            }
            if self.beginWaitResTime != nil {
                map["BeginWaitResTime"] = self.beginWaitResTime!
            }
            if self.beginWaitTimeTime != nil {
                map["BeginWaitTimeTime"] = self.beginWaitTimeTime!
            }
            if self.bizdate != nil {
                map["Bizdate"] = self.bizdate!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.cycTime != nil {
                map["CycTime"] = self.cycTime!
            }
            if self.dagId != nil {
                map["DagId"] = self.dagId!
            }
            if self.dagType != nil {
                map["DagType"] = self.dagType!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.instanceHistoryId != nil {
                map["InstanceHistoryId"] = self.instanceHistoryId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BeginRunningTime"] as? Int64 {
                self.beginRunningTime = value
            }
            if let value = dict["BeginWaitResTime"] as? Int64 {
                self.beginWaitResTime = value
            }
            if let value = dict["BeginWaitTimeTime"] as? Int64 {
                self.beginWaitTimeTime = value
            }
            if let value = dict["Bizdate"] as? Int64 {
                self.bizdate = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CycTime"] as? Int64 {
                self.cycTime = value
            }
            if let value = dict["DagId"] as? Int64 {
                self.dagId = value
            }
            if let value = dict["DagType"] as? String {
                self.dagType = value
            }
            if let value = dict["ErrorMessage"] as? String {
                self.errorMessage = value
            }
            if let value = dict["FinishTime"] as? Int64 {
                self.finishTime = value
            }
            if let value = dict["InstanceHistoryId"] as? Int64 {
                self.instanceHistoryId = value
            }
            if let value = dict["InstanceId"] as? Int64 {
                self.instanceId = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["NodeId"] as? Int64 {
                self.nodeId = value
            }
            if let value = dict["NodeName"] as? String {
                self.nodeName = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TaskType"] as? String {
                self.taskType = value
            }
        }
    }
    public var instances: [ListInstanceHistoryResponseBody.Instances]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Instances"] as? [Any?] {
            var tmp : [ListInstanceHistoryResponseBody.Instances] = []
            for v in value {
                if v != nil {
                    var model = ListInstanceHistoryResponseBody.Instances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instances = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListInstanceHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListInstanceHistoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListInstancesRequest : Tea.TeaModel {
    public var beginBizdate: String?

    public var bizName: String?

    public var bizdate: String?

    public var dagId: Int64?

    public var endBizdate: String?

    public var nodeId: Int64?

    public var nodeName: String?

    public var orderBy: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var programType: String?

    public var projectEnv: String?

    public var projectId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginBizdate != nil {
            map["BeginBizdate"] = self.beginBizdate!
        }
        if self.bizName != nil {
            map["BizName"] = self.bizName!
        }
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.endBizdate != nil {
            map["EndBizdate"] = self.endBizdate!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.programType != nil {
            map["ProgramType"] = self.programType!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BeginBizdate"] as? String {
            self.beginBizdate = value
        }
        if let value = dict["BizName"] as? String {
            self.bizName = value
        }
        if let value = dict["Bizdate"] as? String {
            self.bizdate = value
        }
        if let value = dict["DagId"] as? Int64 {
            self.dagId = value
        }
        if let value = dict["EndBizdate"] as? String {
            self.endBizdate = value
        }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["NodeName"] as? String {
            self.nodeName = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProgramType"] as? String {
            self.programType = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class ListInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Instances : Tea.TeaModel {
            public var baselineId: Int64?

            public var beginRunningTime: Int64?

            public var beginWaitResTime: Int64?

            public var beginWaitTimeTime: Int64?

            public var bizdate: Int64?

            public var businessId: Int64?

            public var connection: String?

            public var createTime: Int64?

            public var createUser: String?

            public var cycTime: Int64?

            public var dagId: Int64?

            public var dagType: String?

            public var dqcDescription: String?

            public var dqcType: Int32?

            public var errorMessage: String?

            public var finishTime: Int64?

            public var instanceId: Int64?

            public var modifyTime: Int64?

            public var nodeId: Int64?

            public var nodeName: String?

            public var paramValues: String?

            public var priority: Int32?

            public var relatedFlowId: Int64?

            public var repeatInterval: Int64?

            public var repeatability: Bool?

            public var status: String?

            public var taskRerunTime: Int32?

            public var taskType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.beginRunningTime != nil {
                    map["BeginRunningTime"] = self.beginRunningTime!
                }
                if self.beginWaitResTime != nil {
                    map["BeginWaitResTime"] = self.beginWaitResTime!
                }
                if self.beginWaitTimeTime != nil {
                    map["BeginWaitTimeTime"] = self.beginWaitTimeTime!
                }
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.businessId != nil {
                    map["BusinessId"] = self.businessId!
                }
                if self.connection != nil {
                    map["Connection"] = self.connection!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.cycTime != nil {
                    map["CycTime"] = self.cycTime!
                }
                if self.dagId != nil {
                    map["DagId"] = self.dagId!
                }
                if self.dagType != nil {
                    map["DagType"] = self.dagType!
                }
                if self.dqcDescription != nil {
                    map["DqcDescription"] = self.dqcDescription!
                }
                if self.dqcType != nil {
                    map["DqcType"] = self.dqcType!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.paramValues != nil {
                    map["ParamValues"] = self.paramValues!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.relatedFlowId != nil {
                    map["RelatedFlowId"] = self.relatedFlowId!
                }
                if self.repeatInterval != nil {
                    map["RepeatInterval"] = self.repeatInterval!
                }
                if self.repeatability != nil {
                    map["Repeatability"] = self.repeatability!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskRerunTime != nil {
                    map["TaskRerunTime"] = self.taskRerunTime!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["BeginRunningTime"] as? Int64 {
                    self.beginRunningTime = value
                }
                if let value = dict["BeginWaitResTime"] as? Int64 {
                    self.beginWaitResTime = value
                }
                if let value = dict["BeginWaitTimeTime"] as? Int64 {
                    self.beginWaitTimeTime = value
                }
                if let value = dict["Bizdate"] as? Int64 {
                    self.bizdate = value
                }
                if let value = dict["BusinessId"] as? Int64 {
                    self.businessId = value
                }
                if let value = dict["Connection"] as? String {
                    self.connection = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["CycTime"] as? Int64 {
                    self.cycTime = value
                }
                if let value = dict["DagId"] as? Int64 {
                    self.dagId = value
                }
                if let value = dict["DagType"] as? String {
                    self.dagType = value
                }
                if let value = dict["DqcDescription"] as? String {
                    self.dqcDescription = value
                }
                if let value = dict["DqcType"] as? Int32 {
                    self.dqcType = value
                }
                if let value = dict["ErrorMessage"] as? String {
                    self.errorMessage = value
                }
                if let value = dict["FinishTime"] as? Int64 {
                    self.finishTime = value
                }
                if let value = dict["InstanceId"] as? Int64 {
                    self.instanceId = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["ParamValues"] as? String {
                    self.paramValues = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["RelatedFlowId"] as? Int64 {
                    self.relatedFlowId = value
                }
                if let value = dict["RepeatInterval"] as? Int64 {
                    self.repeatInterval = value
                }
                if let value = dict["Repeatability"] as? Bool {
                    self.repeatability = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["TaskRerunTime"] as? Int32 {
                    self.taskRerunTime = value
                }
                if let value = dict["TaskType"] as? String {
                    self.taskType = value
                }
            }
        }
        public var instances: [ListInstancesResponseBody.Data.Instances]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instances != nil {
                var tmp : [Any] = []
                for k in self.instances! {
                    tmp.append(k.toMap())
                }
                map["Instances"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Instances"] as? [Any?] {
                var tmp : [ListInstancesResponseBody.Data.Instances] = []
                for v in value {
                    if v != nil {
                        var model = ListInstancesResponseBody.Data.Instances()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instances = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListInstancesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListInstancesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLineageRequest : Tea.TeaModel {
    public var direction: String?

    public var entityQualifiedName: String?

    public var keyword: String?

    public var nextToken: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.entityQualifiedName != nil {
            map["EntityQualifiedName"] = self.entityQualifiedName!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["EntityQualifiedName"] as? String {
            self.entityQualifiedName = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListLineageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataEntityList : Tea.TeaModel {
            public class RelationList : Tea.TeaModel {
                public var channel: String?

                public var datasource: String?

                public var guid: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.channel != nil {
                        map["Channel"] = self.channel!
                    }
                    if self.datasource != nil {
                        map["Datasource"] = self.datasource!
                    }
                    if self.guid != nil {
                        map["Guid"] = self.guid!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Channel"] as? String {
                        self.channel = value
                    }
                    if let value = dict["Datasource"] as? String {
                        self.datasource = value
                    }
                    if let value = dict["Guid"] as? String {
                        self.guid = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var createTimestamp: Int64?

            public var entity: Entity?

            public var relationList: [ListLineageResponseBody.Data.DataEntityList.RelationList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.entity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.entity != nil {
                    map["Entity"] = self.entity?.toMap()
                }
                if self.relationList != nil {
                    var tmp : [Any] = []
                    for k in self.relationList! {
                        tmp.append(k.toMap())
                    }
                    map["RelationList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["Entity"] as? [String: Any?] {
                    var model = Entity()
                    model.fromMap(value)
                    self.entity = model
                }
                if let value = dict["RelationList"] as? [Any?] {
                    var tmp : [ListLineageResponseBody.Data.DataEntityList.RelationList] = []
                    for v in value {
                        if v != nil {
                            var model = ListLineageResponseBody.Data.DataEntityList.RelationList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.relationList = tmp
                }
            }
        }
        public var dataEntityList: [ListLineageResponseBody.Data.DataEntityList]?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataEntityList != nil {
                var tmp : [Any] = []
                for k in self.dataEntityList! {
                    tmp.append(k.toMap())
                }
                map["DataEntityList"] = tmp
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataEntityList"] as? [Any?] {
                var tmp : [ListLineageResponseBody.Data.DataEntityList] = []
                for v in value {
                    if v != nil {
                        var model = ListLineageResponseBody.Data.DataEntityList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataEntityList = tmp
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
        }
    }
    public var data: ListLineageResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListLineageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListLineageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLineageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLineageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListManualDagInstancesRequest : Tea.TeaModel {
    public var dagId: String?

    public var projectEnv: String?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DagId"] as? String {
            self.dagId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
    }
}

public class ListManualDagInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public var beginRunningTime: Int64?

        public var beginWaitResTime: Int64?

        public var beginWaitTimeTime: Int64?

        public var bizDate: Int64?

        public var createTime: Int64?

        public var createUser: String?

        public var cycTime: Int64?

        public var dagId: Int64?

        public var dagType: String?

        public var finishTime: Int64?

        public var instanceId: Int64?

        public var modifyTime: Int64?

        public var nodeId: Int64?

        public var nodeName: String?

        public var paramValues: String?

        public var status: String?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.beginRunningTime != nil {
                map["BeginRunningTime"] = self.beginRunningTime!
            }
            if self.beginWaitResTime != nil {
                map["BeginWaitResTime"] = self.beginWaitResTime!
            }
            if self.beginWaitTimeTime != nil {
                map["BeginWaitTimeTime"] = self.beginWaitTimeTime!
            }
            if self.bizDate != nil {
                map["BizDate"] = self.bizDate!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.cycTime != nil {
                map["CycTime"] = self.cycTime!
            }
            if self.dagId != nil {
                map["DagId"] = self.dagId!
            }
            if self.dagType != nil {
                map["DagType"] = self.dagType!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.paramValues != nil {
                map["ParamValues"] = self.paramValues!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BeginRunningTime"] as? Int64 {
                self.beginRunningTime = value
            }
            if let value = dict["BeginWaitResTime"] as? Int64 {
                self.beginWaitResTime = value
            }
            if let value = dict["BeginWaitTimeTime"] as? Int64 {
                self.beginWaitTimeTime = value
            }
            if let value = dict["BizDate"] as? Int64 {
                self.bizDate = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CreateUser"] as? String {
                self.createUser = value
            }
            if let value = dict["CycTime"] as? Int64 {
                self.cycTime = value
            }
            if let value = dict["DagId"] as? Int64 {
                self.dagId = value
            }
            if let value = dict["DagType"] as? String {
                self.dagType = value
            }
            if let value = dict["FinishTime"] as? Int64 {
                self.finishTime = value
            }
            if let value = dict["InstanceId"] as? Int64 {
                self.instanceId = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["NodeId"] as? Int64 {
                self.nodeId = value
            }
            if let value = dict["NodeName"] as? String {
                self.nodeName = value
            }
            if let value = dict["ParamValues"] as? String {
                self.paramValues = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TaskType"] as? String {
                self.taskType = value
            }
        }
    }
    public var instances: [ListManualDagInstancesResponseBody.Instances]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Instances"] as? [Any?] {
            var tmp : [ListManualDagInstancesResponseBody.Instances] = []
            for v in value {
                if v != nil {
                    var model = ListManualDagInstancesResponseBody.Instances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instances = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListManualDagInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListManualDagInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListManualDagInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMeasureDataRequest : Tea.TeaModel {
    public var componentCode: String?

    public var domainCode: String?

    public var endTime: Int64?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.componentCode != nil {
            map["ComponentCode"] = self.componentCode!
        }
        if self.domainCode != nil {
            map["DomainCode"] = self.domainCode!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ComponentCode"] as? String {
            self.componentCode = value
        }
        if let value = dict["DomainCode"] as? String {
            self.domainCode = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class ListMeasureDataResponseBody : Tea.TeaModel {
    public class MeasureDatas : Tea.TeaModel {
        public var componentCode: String?

        public var domainCode: String?

        public var endTime: Int64?

        public var startTime: Int64?

        public var usage: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.componentCode != nil {
                map["ComponentCode"] = self.componentCode!
            }
            if self.domainCode != nil {
                map["DomainCode"] = self.domainCode!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.usage != nil {
                map["Usage"] = self.usage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComponentCode"] as? String {
                self.componentCode = value
            }
            if let value = dict["DomainCode"] as? String {
                self.domainCode = value
            }
            if let value = dict["EndTime"] as? Int64 {
                self.endTime = value
            }
            if let value = dict["StartTime"] as? Int64 {
                self.startTime = value
            }
            if let value = dict["Usage"] as? Int64 {
                self.usage = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var measureDatas: [ListMeasureDataResponseBody.MeasureDatas]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.measureDatas != nil {
            var tmp : [Any] = []
            for k in self.measureDatas! {
                tmp.append(k.toMap())
            }
            map["MeasureDatas"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["MeasureDatas"] as? [Any?] {
            var tmp : [ListMeasureDataResponseBody.MeasureDatas] = []
            for v in value {
                if v != nil {
                    var model = ListMeasureDataResponseBody.MeasureDatas()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.measureDatas = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListMeasureDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMeasureDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMeasureDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMetaCollectionEntitiesRequest : Tea.TeaModel {
    public var collectionQualifiedName: String?

    public var entityType: String?

    public var keyword: String?

    public var nextToken: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectionQualifiedName != nil {
            map["CollectionQualifiedName"] = self.collectionQualifiedName!
        }
        if self.entityType != nil {
            map["EntityType"] = self.entityType!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CollectionQualifiedName"] as? String {
            self.collectionQualifiedName = value
        }
        if let value = dict["EntityType"] as? String {
            self.entityType = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListMetaCollectionEntitiesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var entityList: [Entity]?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.entityList != nil {
                var tmp : [Any] = []
                for k in self.entityList! {
                    tmp.append(k.toMap())
                }
                map["EntityList"] = tmp
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EntityList"] as? [Any?] {
                var tmp : [Entity] = []
                for v in value {
                    if v != nil {
                        var model = Entity()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.entityList = tmp
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
        }
    }
    public var data: ListMetaCollectionEntitiesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListMetaCollectionEntitiesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListMetaCollectionEntitiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMetaCollectionEntitiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMetaCollectionEntitiesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMetaCollectionsRequest : Tea.TeaModel {
    public var administrator: String?

    public var collectionType: String?

    public var creator: String?

    public var follower: String?

    public var keyword: String?

    public var nextToken: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var parentQualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.administrator != nil {
            map["Administrator"] = self.administrator!
        }
        if self.collectionType != nil {
            map["CollectionType"] = self.collectionType!
        }
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        if self.follower != nil {
            map["Follower"] = self.follower!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentQualifiedName != nil {
            map["ParentQualifiedName"] = self.parentQualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Administrator"] as? String {
            self.administrator = value
        }
        if let value = dict["CollectionType"] as? String {
            self.collectionType = value
        }
        if let value = dict["Creator"] as? String {
            self.creator = value
        }
        if let value = dict["Follower"] as? String {
            self.follower = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ParentQualifiedName"] as? String {
            self.parentQualifiedName = value
        }
    }
}

public class ListMetaCollectionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var collectionList: [Collection]?

        public var nextToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.collectionList != nil {
                var tmp : [Any] = []
                for k in self.collectionList! {
                    tmp.append(k.toMap())
                }
                map["CollectionList"] = tmp
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CollectionList"] as? [Any?] {
                var tmp : [Collection] = []
                for v in value {
                    if v != nil {
                        var model = Collection()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.collectionList = tmp
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
        }
    }
    public var data: ListMetaCollectionsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListMetaCollectionsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListMetaCollectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMetaCollectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMetaCollectionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMetaDBRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dataSourceType: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ListMetaDBResponseBody : Tea.TeaModel {
    public class DatabaseInfo : Tea.TeaModel {
        public class DbList : Tea.TeaModel {
            public var createTimeStamp: Int64?

            public var location: String?

            public var modifiedTimeStamp: Int64?

            public var name: String?

            public var ownerId: String?

            public var type: String?

            public var UUID: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTimeStamp != nil {
                    map["CreateTimeStamp"] = self.createTimeStamp!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.modifiedTimeStamp != nil {
                    map["ModifiedTimeStamp"] = self.modifiedTimeStamp!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.UUID != nil {
                    map["UUID"] = self.UUID!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTimeStamp"] as? Int64 {
                    self.createTimeStamp = value
                }
                if let value = dict["Location"] as? String {
                    self.location = value
                }
                if let value = dict["ModifiedTimeStamp"] as? Int64 {
                    self.modifiedTimeStamp = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["OwnerId"] as? String {
                    self.ownerId = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["UUID"] as? String {
                    self.UUID = value
                }
            }
        }
        public var dbList: [ListMetaDBResponseBody.DatabaseInfo.DbList]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbList != nil {
                var tmp : [Any] = []
                for k in self.dbList! {
                    tmp.append(k.toMap())
                }
                map["DbList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DbList"] as? [Any?] {
                var tmp : [ListMetaDBResponseBody.DatabaseInfo.DbList] = []
                for v in value {
                    if v != nil {
                        var model = ListMetaDBResponseBody.DatabaseInfo.DbList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dbList = tmp
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var databaseInfo: ListMetaDBResponseBody.DatabaseInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.databaseInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseInfo != nil {
            map["DatabaseInfo"] = self.databaseInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DatabaseInfo"] as? [String: Any?] {
            var model = ListMetaDBResponseBody.DatabaseInfo()
            model.fromMap(value)
            self.databaseInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListMetaDBResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMetaDBResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMetaDBResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMigrationsRequest : Tea.TeaModel {
    public var migrationType: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationType != nil {
            map["MigrationType"] = self.migrationType!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MigrationType"] as? String {
            self.migrationType = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ListMigrationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Migrations : Tea.TeaModel {
            public var createTime: Int64?

            public var createUser: String?

            public var createUserName: String?

            public var description_: String?

            public var downloadUrl: String?

            public var id: Int64?

            public var message: String?

            public var migrationType: String?

            public var name: String?

            public var packageType: String?

            public var projectId: Int64?

            public var status: String?

            public var tenantId: Int64?

            public var updateTime: Int64?

            public var updateUser: String?

            public var updateUserName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.createUserName != nil {
                    map["CreateUserName"] = self.createUserName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.downloadUrl != nil {
                    map["DownloadUrl"] = self.downloadUrl!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.migrationType != nil {
                    map["MigrationType"] = self.migrationType!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.packageType != nil {
                    map["PackageType"] = self.packageType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateUser != nil {
                    map["UpdateUser"] = self.updateUser!
                }
                if self.updateUserName != nil {
                    map["UpdateUserName"] = self.updateUserName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["CreateUserName"] as? String {
                    self.createUserName = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DownloadUrl"] as? String {
                    self.downloadUrl = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["MigrationType"] as? String {
                    self.migrationType = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["PackageType"] as? String {
                    self.packageType = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["TenantId"] as? Int64 {
                    self.tenantId = value
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
                if let value = dict["UpdateUser"] as? String {
                    self.updateUser = value
                }
                if let value = dict["UpdateUserName"] as? String {
                    self.updateUserName = value
                }
            }
        }
        public var migrations: [ListMigrationsResponseBody.Data.Migrations]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.migrations != nil {
                var tmp : [Any] = []
                for k in self.migrations! {
                    tmp.append(k.toMap())
                }
                map["Migrations"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Migrations"] as? [Any?] {
                var tmp : [ListMigrationsResponseBody.Data.Migrations] = []
                for v in value {
                    if v != nil {
                        var model = ListMigrationsResponseBody.Data.Migrations()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.migrations = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListMigrationsResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListMigrationsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListMigrationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMigrationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMigrationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNodeIORequest : Tea.TeaModel {
    public var ioType: String?

    public var nodeId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ioType != nil {
            map["IoType"] = self.ioType!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IoType"] as? String {
            self.ioType = value
        }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class ListNodeIOResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var data: String?

        public var nodeId: Int64?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Data"] as? String {
                self.data = value
            }
            if let value = dict["NodeId"] as? Int64 {
                self.nodeId = value
            }
            if let value = dict["TableName"] as? String {
                self.tableName = value
            }
        }
    }
    public var data: [ListNodeIOResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListNodeIOResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListNodeIOResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListNodeIOResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodeIOResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNodeIOResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNodeInputOrOutputRequest : Tea.TeaModel {
    public var ioType: String?

    public var nodeId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ioType != nil {
            map["IoType"] = self.ioType!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IoType"] as? String {
            self.ioType = value
        }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class ListNodeInputOrOutputResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var data: String?

        public var nodeId: Int64?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Data"] as? String {
                self.data = value
            }
            if let value = dict["NodeId"] as? Int64 {
                self.nodeId = value
            }
            if let value = dict["TableName"] as? String {
                self.tableName = value
            }
        }
    }
    public var data: [ListNodeInputOrOutputResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListNodeInputOrOutputResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListNodeInputOrOutputResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListNodeInputOrOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodeInputOrOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNodeInputOrOutputResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNodesRequest : Tea.TeaModel {
    public var bizName: String?

    public var nodeName: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var programType: String?

    public var projectEnv: String?

    public var projectId: Int64?

    public var schedulerType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizName != nil {
            map["BizName"] = self.bizName!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.programType != nil {
            map["ProgramType"] = self.programType!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.schedulerType != nil {
            map["SchedulerType"] = self.schedulerType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BizName"] as? String {
            self.bizName = value
        }
        if let value = dict["NodeName"] as? String {
            self.nodeName = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProgramType"] as? String {
            self.programType = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SchedulerType"] as? String {
            self.schedulerType = value
        }
    }
}

public class ListNodesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Nodes : Tea.TeaModel {
            public var baselineId: Int64?

            public var businessId: Int64?

            public var connection: String?

            public var createTime: Int64?

            public var cronExpress: String?

            public var deployDate: Int64?

            public var description_: String?

            public var dqcDescription: String?

            public var dqcType: Int32?

            public var fileId: Int64?

            public var fileType: Int32?

            public var fileVersion: Int32?

            public var modifyTime: Int64?

            public var nodeId: Int64?

            public var nodeName: String?

            public var ownerId: String?

            public var paramValues: String?

            public var priority: Int32?

            public var programType: String?

            public var projectId: Int64?

            public var relatedFlowId: Int64?

            public var repeatInterval: Int64?

            public var repeatMode: Int32?

            public var repeatability: Bool?

            public var resGroupIdentifier: String?

            public var resGroupName: String?

            public var schedulerType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.businessId != nil {
                    map["BusinessId"] = self.businessId!
                }
                if self.connection != nil {
                    map["Connection"] = self.connection!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.cronExpress != nil {
                    map["CronExpress"] = self.cronExpress!
                }
                if self.deployDate != nil {
                    map["DeployDate"] = self.deployDate!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.dqcDescription != nil {
                    map["DqcDescription"] = self.dqcDescription!
                }
                if self.dqcType != nil {
                    map["DqcType"] = self.dqcType!
                }
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.fileType != nil {
                    map["FileType"] = self.fileType!
                }
                if self.fileVersion != nil {
                    map["FileVersion"] = self.fileVersion!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.paramValues != nil {
                    map["ParamValues"] = self.paramValues!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.programType != nil {
                    map["ProgramType"] = self.programType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.relatedFlowId != nil {
                    map["RelatedFlowId"] = self.relatedFlowId!
                }
                if self.repeatInterval != nil {
                    map["RepeatInterval"] = self.repeatInterval!
                }
                if self.repeatMode != nil {
                    map["RepeatMode"] = self.repeatMode!
                }
                if self.repeatability != nil {
                    map["Repeatability"] = self.repeatability!
                }
                if self.resGroupIdentifier != nil {
                    map["ResGroupIdentifier"] = self.resGroupIdentifier!
                }
                if self.resGroupName != nil {
                    map["ResGroupName"] = self.resGroupName!
                }
                if self.schedulerType != nil {
                    map["SchedulerType"] = self.schedulerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["BusinessId"] as? Int64 {
                    self.businessId = value
                }
                if let value = dict["Connection"] as? String {
                    self.connection = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CronExpress"] as? String {
                    self.cronExpress = value
                }
                if let value = dict["DeployDate"] as? Int64 {
                    self.deployDate = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DqcDescription"] as? String {
                    self.dqcDescription = value
                }
                if let value = dict["DqcType"] as? Int32 {
                    self.dqcType = value
                }
                if let value = dict["FileId"] as? Int64 {
                    self.fileId = value
                }
                if let value = dict["FileType"] as? Int32 {
                    self.fileType = value
                }
                if let value = dict["FileVersion"] as? Int32 {
                    self.fileVersion = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["OwnerId"] as? String {
                    self.ownerId = value
                }
                if let value = dict["ParamValues"] as? String {
                    self.paramValues = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["ProgramType"] as? String {
                    self.programType = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["RelatedFlowId"] as? Int64 {
                    self.relatedFlowId = value
                }
                if let value = dict["RepeatInterval"] as? Int64 {
                    self.repeatInterval = value
                }
                if let value = dict["RepeatMode"] as? Int32 {
                    self.repeatMode = value
                }
                if let value = dict["Repeatability"] as? Bool {
                    self.repeatability = value
                }
                if let value = dict["ResGroupIdentifier"] as? String {
                    self.resGroupIdentifier = value
                }
                if let value = dict["ResGroupName"] as? String {
                    self.resGroupName = value
                }
                if let value = dict["SchedulerType"] as? String {
                    self.schedulerType = value
                }
            }
        }
        public var nodes: [ListNodesResponseBody.Data.Nodes]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Nodes"] as? [Any?] {
                var tmp : [ListNodesResponseBody.Data.Nodes] = []
                for v in value {
                    if v != nil {
                        var model = ListNodesResponseBody.Data.Nodes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.nodes = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListNodesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListNodesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNodesByBaselineRequest : Tea.TeaModel {
    public var baselineId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BaselineId"] as? Int64 {
            self.baselineId = value
        }
    }
}

public class ListNodesByBaselineResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var nodeId: Int64?

        public var nodeName: String?

        public var owner: String?

        public var projectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NodeId"] as? Int64 {
                self.nodeId = value
            }
            if let value = dict["NodeName"] as? String {
                self.nodeName = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
        }
    }
    public var data: [ListNodesByBaselineResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListNodesByBaselineResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListNodesByBaselineResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class ListNodesByBaselineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodesByBaselineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNodesByBaselineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNodesByOutputRequest : Tea.TeaModel {
    public var outputs: String?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.outputs != nil {
            map["Outputs"] = self.outputs!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Outputs"] as? String {
            self.outputs = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class ListNodesByOutputResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class NodeList : Tea.TeaModel {
            public var baselineId: Int64?

            public var connection: String?

            public var cronExpress: String?

            public var description_: String?

            public var dqcDescription: String?

            public var dqcType: Int32?

            public var fileType: String?

            public var nodeId: Int64?

            public var nodeName: String?

            public var ownerId: String?

            public var paramValues: String?

            public var priority: Int32?

            public var programType: String?

            public var projectId: Int64?

            public var relatedFlowId: Int64?

            public var repeatInterval: Int32?

            public var repeatability: Bool?

            public var resGroupName: String?

            public var schedulerType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.connection != nil {
                    map["Connection"] = self.connection!
                }
                if self.cronExpress != nil {
                    map["CronExpress"] = self.cronExpress!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.dqcDescription != nil {
                    map["DqcDescription"] = self.dqcDescription!
                }
                if self.dqcType != nil {
                    map["DqcType"] = self.dqcType!
                }
                if self.fileType != nil {
                    map["FileType"] = self.fileType!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.paramValues != nil {
                    map["ParamValues"] = self.paramValues!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.programType != nil {
                    map["ProgramType"] = self.programType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.relatedFlowId != nil {
                    map["RelatedFlowId"] = self.relatedFlowId!
                }
                if self.repeatInterval != nil {
                    map["RepeatInterval"] = self.repeatInterval!
                }
                if self.repeatability != nil {
                    map["Repeatability"] = self.repeatability!
                }
                if self.resGroupName != nil {
                    map["ResGroupName"] = self.resGroupName!
                }
                if self.schedulerType != nil {
                    map["SchedulerType"] = self.schedulerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["Connection"] as? String {
                    self.connection = value
                }
                if let value = dict["CronExpress"] as? String {
                    self.cronExpress = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DqcDescription"] as? String {
                    self.dqcDescription = value
                }
                if let value = dict["DqcType"] as? Int32 {
                    self.dqcType = value
                }
                if let value = dict["FileType"] as? String {
                    self.fileType = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["OwnerId"] as? String {
                    self.ownerId = value
                }
                if let value = dict["ParamValues"] as? String {
                    self.paramValues = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["ProgramType"] as? String {
                    self.programType = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["RelatedFlowId"] as? Int64 {
                    self.relatedFlowId = value
                }
                if let value = dict["RepeatInterval"] as? Int32 {
                    self.repeatInterval = value
                }
                if let value = dict["Repeatability"] as? Bool {
                    self.repeatability = value
                }
                if let value = dict["ResGroupName"] as? String {
                    self.resGroupName = value
                }
                if let value = dict["SchedulerType"] as? String {
                    self.schedulerType = value
                }
            }
        }
        public var nodeList: [ListNodesByOutputResponseBody.Data.NodeList]?

        public var output: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeList != nil {
                var tmp : [Any] = []
                for k in self.nodeList! {
                    tmp.append(k.toMap())
                }
                map["NodeList"] = tmp
            }
            if self.output != nil {
                map["Output"] = self.output!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NodeList"] as? [Any?] {
                var tmp : [ListNodesByOutputResponseBody.Data.NodeList] = []
                for v in value {
                    if v != nil {
                        var model = ListNodesByOutputResponseBody.Data.NodeList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.nodeList = tmp
            }
            if let value = dict["Output"] as? String {
                self.output = value
            }
        }
    }
    public var data: [ListNodesByOutputResponseBody.Data]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListNodesByOutputResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListNodesByOutputResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListNodesByOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodesByOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNodesByOutputResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPermissionApplyOrdersRequest : Tea.TeaModel {
    public var applyType: String?

    public var catalogName: String?

    public var endTime: Int64?

    public var engineType: String?

    public var flowStatus: Int32?

    public var maxComputeProjectName: String?

    public var orderType: Int32?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var queryType: Int32?

    public var startTime: Int64?

    public var tableName: String?

    public var workspaceId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applyType != nil {
            map["ApplyType"] = self.applyType!
        }
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.engineType != nil {
            map["EngineType"] = self.engineType!
        }
        if self.flowStatus != nil {
            map["FlowStatus"] = self.flowStatus!
        }
        if self.maxComputeProjectName != nil {
            map["MaxComputeProjectName"] = self.maxComputeProjectName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queryType != nil {
            map["QueryType"] = self.queryType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplyType"] as? String {
            self.applyType = value
        }
        if let value = dict["CatalogName"] as? String {
            self.catalogName = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["EngineType"] as? String {
            self.engineType = value
        }
        if let value = dict["FlowStatus"] as? Int32 {
            self.flowStatus = value
        }
        if let value = dict["MaxComputeProjectName"] as? String {
            self.maxComputeProjectName = value
        }
        if let value = dict["OrderType"] as? Int32 {
            self.orderType = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["QueryType"] as? Int32 {
            self.queryType = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["WorkspaceId"] as? Int32 {
            self.workspaceId = value
        }
    }
}

public class ListPermissionApplyOrdersResponseBody : Tea.TeaModel {
    public class ApplyOrders : Tea.TeaModel {
        public class ApplyOrder : Tea.TeaModel {
            public class ApproveContent : Tea.TeaModel {
                public class ProjectMeta : Tea.TeaModel {
                    public class ObjectMetaList : Tea.TeaModel {
                        public var actions: [String]?

                        public var objectName: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.actions != nil {
                                map["Actions"] = self.actions!
                            }
                            if self.objectName != nil {
                                map["ObjectName"] = self.objectName!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Actions"] as? [String] {
                                self.actions = value
                            }
                            if let value = dict["ObjectName"] as? String {
                                self.objectName = value
                            }
                        }
                    }
                    public var objectMetaList: [ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder.ApproveContent.ProjectMeta.ObjectMetaList]?

                    public var workspaceName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.objectMetaList != nil {
                            var tmp : [Any] = []
                            for k in self.objectMetaList! {
                                tmp.append(k.toMap())
                            }
                            map["ObjectMetaList"] = tmp
                        }
                        if self.workspaceName != nil {
                            map["WorkspaceName"] = self.workspaceName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ObjectMetaList"] as? [Any?] {
                            var tmp : [ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder.ApproveContent.ProjectMeta.ObjectMetaList] = []
                            for v in value {
                                if v != nil {
                                    var model = ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder.ApproveContent.ProjectMeta.ObjectMetaList()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.objectMetaList = tmp
                        }
                        if let value = dict["WorkspaceName"] as? String {
                            self.workspaceName = value
                        }
                    }
                }
                public var applyReason: String?

                public var orderType: Int32?

                public var projectMeta: ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder.ApproveContent.ProjectMeta?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.projectMeta?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.applyReason != nil {
                        map["ApplyReason"] = self.applyReason!
                    }
                    if self.orderType != nil {
                        map["OrderType"] = self.orderType!
                    }
                    if self.projectMeta != nil {
                        map["ProjectMeta"] = self.projectMeta?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ApplyReason"] as? String {
                        self.applyReason = value
                    }
                    if let value = dict["OrderType"] as? Int32 {
                        self.orderType = value
                    }
                    if let value = dict["ProjectMeta"] as? [String: Any?] {
                        var model = ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder.ApproveContent.ProjectMeta()
                        model.fromMap(value)
                        self.projectMeta = model
                    }
                }
            }
            public var applyBaseId: String?

            public var applyTimestamp: Int64?

            public var approveContent: ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder.ApproveContent?

            public var flowId: String?

            public var flowStatus: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.approveContent?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applyBaseId != nil {
                    map["ApplyBaseId"] = self.applyBaseId!
                }
                if self.applyTimestamp != nil {
                    map["ApplyTimestamp"] = self.applyTimestamp!
                }
                if self.approveContent != nil {
                    map["ApproveContent"] = self.approveContent?.toMap()
                }
                if self.flowId != nil {
                    map["FlowId"] = self.flowId!
                }
                if self.flowStatus != nil {
                    map["FlowStatus"] = self.flowStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ApplyBaseId"] as? String {
                    self.applyBaseId = value
                }
                if let value = dict["ApplyTimestamp"] as? Int64 {
                    self.applyTimestamp = value
                }
                if let value = dict["ApproveContent"] as? [String: Any?] {
                    var model = ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder.ApproveContent()
                    model.fromMap(value)
                    self.approveContent = model
                }
                if let value = dict["FlowId"] as? String {
                    self.flowId = value
                }
                if let value = dict["FlowStatus"] as? Int32 {
                    self.flowStatus = value
                }
            }
        }
        public var applyOrder: [ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applyOrder != nil {
                var tmp : [Any] = []
                for k in self.applyOrder! {
                    tmp.append(k.toMap())
                }
                map["ApplyOrder"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApplyOrder"] as? [Any?] {
                var tmp : [ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder] = []
                for v in value {
                    if v != nil {
                        var model = ListPermissionApplyOrdersResponseBody.ApplyOrders.ApplyOrder()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.applyOrder = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var applyOrders: ListPermissionApplyOrdersResponseBody.ApplyOrders?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applyOrders?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applyOrders != nil {
            map["ApplyOrders"] = self.applyOrders?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplyOrders"] as? [String: Any?] {
            var model = ListPermissionApplyOrdersResponseBody.ApplyOrders()
            model.fromMap(value)
            self.applyOrders = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListPermissionApplyOrdersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPermissionApplyOrdersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPermissionApplyOrdersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListProgramTypeCountRequest : Tea.TeaModel {
    public var projectEnv: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ListProgramTypeCountResponseBody : Tea.TeaModel {
    public class ProgramTypeAndCounts : Tea.TeaModel {
        public var count: Int32?

        public var programType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.programType != nil {
                map["ProgramType"] = self.programType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Count"] as? Int32 {
                self.count = value
            }
            if let value = dict["ProgramType"] as? String {
                self.programType = value
            }
        }
    }
    public var programTypeAndCounts: [ListProgramTypeCountResponseBody.ProgramTypeAndCounts]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.programTypeAndCounts != nil {
            var tmp : [Any] = []
            for k in self.programTypeAndCounts! {
                tmp.append(k.toMap())
            }
            map["ProgramTypeAndCounts"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProgramTypeAndCounts"] as? [Any?] {
            var tmp : [ListProgramTypeCountResponseBody.ProgramTypeAndCounts] = []
            for v in value {
                if v != nil {
                    var model = ListProgramTypeCountResponseBody.ProgramTypeAndCounts()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.programTypeAndCounts = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListProgramTypeCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProgramTypeCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListProgramTypeCountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListProjectIdsRequest : Tea.TeaModel {
    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class ListProjectIdsResponseBody : Tea.TeaModel {
    public var projectIds: [Int64]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectIds != nil {
            map["ProjectIds"] = self.projectIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectIds"] as? [Int64] {
            self.projectIds = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListProjectIdsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectIdsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListProjectIdsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListProjectMembersRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ListProjectMembersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ProjectMemberList : Tea.TeaModel {
            public class ProjectRoleList : Tea.TeaModel {
                public var projectRoleCode: String?

                public var projectRoleId: Int32?

                public var projectRoleName: String?

                public var projectRoleType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.projectRoleCode != nil {
                        map["ProjectRoleCode"] = self.projectRoleCode!
                    }
                    if self.projectRoleId != nil {
                        map["ProjectRoleId"] = self.projectRoleId!
                    }
                    if self.projectRoleName != nil {
                        map["ProjectRoleName"] = self.projectRoleName!
                    }
                    if self.projectRoleType != nil {
                        map["ProjectRoleType"] = self.projectRoleType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ProjectRoleCode"] as? String {
                        self.projectRoleCode = value
                    }
                    if let value = dict["ProjectRoleId"] as? Int32 {
                        self.projectRoleId = value
                    }
                    if let value = dict["ProjectRoleName"] as? String {
                        self.projectRoleName = value
                    }
                    if let value = dict["ProjectRoleType"] as? String {
                        self.projectRoleType = value
                    }
                }
            }
            public var nick: String?

            public var projectMemberId: String?

            public var projectMemberName: String?

            public var projectMemberType: String?

            public var projectRoleList: [ListProjectMembersResponseBody.Data.ProjectMemberList.ProjectRoleList]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nick != nil {
                    map["Nick"] = self.nick!
                }
                if self.projectMemberId != nil {
                    map["ProjectMemberId"] = self.projectMemberId!
                }
                if self.projectMemberName != nil {
                    map["ProjectMemberName"] = self.projectMemberName!
                }
                if self.projectMemberType != nil {
                    map["ProjectMemberType"] = self.projectMemberType!
                }
                if self.projectRoleList != nil {
                    var tmp : [Any] = []
                    for k in self.projectRoleList! {
                        tmp.append(k.toMap())
                    }
                    map["ProjectRoleList"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Nick"] as? String {
                    self.nick = value
                }
                if let value = dict["ProjectMemberId"] as? String {
                    self.projectMemberId = value
                }
                if let value = dict["ProjectMemberName"] as? String {
                    self.projectMemberName = value
                }
                if let value = dict["ProjectMemberType"] as? String {
                    self.projectMemberType = value
                }
                if let value = dict["ProjectRoleList"] as? [Any?] {
                    var tmp : [ListProjectMembersResponseBody.Data.ProjectMemberList.ProjectRoleList] = []
                    for v in value {
                        if v != nil {
                            var model = ListProjectMembersResponseBody.Data.ProjectMemberList.ProjectRoleList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.projectRoleList = tmp
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var projectMemberList: [ListProjectMembersResponseBody.Data.ProjectMemberList]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.projectMemberList != nil {
                var tmp : [Any] = []
                for k in self.projectMemberList! {
                    tmp.append(k.toMap())
                }
                map["ProjectMemberList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["ProjectMemberList"] as? [Any?] {
                var tmp : [ListProjectMembersResponseBody.Data.ProjectMemberList] = []
                for v in value {
                    if v != nil {
                        var model = ListProjectMembersResponseBody.Data.ProjectMemberList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.projectMemberList = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListProjectMembersResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListProjectMembersResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListProjectMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListProjectMembersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListProjectRolesRequest : Tea.TeaModel {
    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ListProjectRolesResponseBody : Tea.TeaModel {
    public class ProjectRoleList : Tea.TeaModel {
        public var projectRoleCode: String?

        public var projectRoleId: Int32?

        public var projectRoleName: String?

        public var projectRoleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.projectRoleCode != nil {
                map["ProjectRoleCode"] = self.projectRoleCode!
            }
            if self.projectRoleId != nil {
                map["ProjectRoleId"] = self.projectRoleId!
            }
            if self.projectRoleName != nil {
                map["ProjectRoleName"] = self.projectRoleName!
            }
            if self.projectRoleType != nil {
                map["ProjectRoleType"] = self.projectRoleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ProjectRoleCode"] as? String {
                self.projectRoleCode = value
            }
            if let value = dict["ProjectRoleId"] as? Int32 {
                self.projectRoleId = value
            }
            if let value = dict["ProjectRoleName"] as? String {
                self.projectRoleName = value
            }
            if let value = dict["ProjectRoleType"] as? String {
                self.projectRoleType = value
            }
        }
    }
    public var projectRoleList: [ListProjectRolesResponseBody.ProjectRoleList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectRoleList != nil {
            var tmp : [Any] = []
            for k in self.projectRoleList! {
                tmp.append(k.toMap())
            }
            map["ProjectRoleList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectRoleList"] as? [Any?] {
            var tmp : [ListProjectRolesResponseBody.ProjectRoleList] = []
            for v in value {
                if v != nil {
                    var model = ListProjectRolesResponseBody.ProjectRoleList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.projectRoleList = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListProjectRolesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectRolesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListProjectRolesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListProjectsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceManagerResourceGroupId: String?

    public var tags: [ListProjectsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceManagerResourceGroupId != nil {
            map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceManagerResourceGroupId"] as? String {
            self.resourceManagerResourceGroupId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [ListProjectsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = ListProjectsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class ListProjectsShrinkRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceManagerResourceGroupId: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceManagerResourceGroupId != nil {
            map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceManagerResourceGroupId"] as? String {
            self.resourceManagerResourceGroupId = value
        }
        if let value = dict["Tags"] as? String {
            self.tagsShrink = value
        }
    }
}

public class ListProjectsResponseBody : Tea.TeaModel {
    public class PageResult : Tea.TeaModel {
        public class ProjectList : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var disableDevelopment: Bool?

            public var isDefault: Int32?

            public var projectDescription: String?

            public var projectId: Int64?

            public var projectIdentifier: String?

            public var projectName: String?

            public var projectOwnerBaseId: String?

            public var projectStatus: Int32?

            public var projectStatusCode: String?

            public var resourceManagerResourceGroupId: String?

            public var tablePrivacyMode: Int32?

            public var tags: [ListProjectsResponseBody.PageResult.ProjectList.Tags]?

            public var useProxyOdpsAccount: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disableDevelopment != nil {
                    map["DisableDevelopment"] = self.disableDevelopment!
                }
                if self.isDefault != nil {
                    map["IsDefault"] = self.isDefault!
                }
                if self.projectDescription != nil {
                    map["ProjectDescription"] = self.projectDescription!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.projectIdentifier != nil {
                    map["ProjectIdentifier"] = self.projectIdentifier!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                if self.projectOwnerBaseId != nil {
                    map["ProjectOwnerBaseId"] = self.projectOwnerBaseId!
                }
                if self.projectStatus != nil {
                    map["ProjectStatus"] = self.projectStatus!
                }
                if self.projectStatusCode != nil {
                    map["ProjectStatusCode"] = self.projectStatusCode!
                }
                if self.resourceManagerResourceGroupId != nil {
                    map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
                }
                if self.tablePrivacyMode != nil {
                    map["TablePrivacyMode"] = self.tablePrivacyMode!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.useProxyOdpsAccount != nil {
                    map["UseProxyOdpsAccount"] = self.useProxyOdpsAccount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DisableDevelopment"] as? Bool {
                    self.disableDevelopment = value
                }
                if let value = dict["IsDefault"] as? Int32 {
                    self.isDefault = value
                }
                if let value = dict["ProjectDescription"] as? String {
                    self.projectDescription = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["ProjectIdentifier"] as? String {
                    self.projectIdentifier = value
                }
                if let value = dict["ProjectName"] as? String {
                    self.projectName = value
                }
                if let value = dict["ProjectOwnerBaseId"] as? String {
                    self.projectOwnerBaseId = value
                }
                if let value = dict["ProjectStatus"] as? Int32 {
                    self.projectStatus = value
                }
                if let value = dict["ProjectStatusCode"] as? String {
                    self.projectStatusCode = value
                }
                if let value = dict["ResourceManagerResourceGroupId"] as? String {
                    self.resourceManagerResourceGroupId = value
                }
                if let value = dict["TablePrivacyMode"] as? Int32 {
                    self.tablePrivacyMode = value
                }
                if let value = dict["Tags"] as? [Any?] {
                    var tmp : [ListProjectsResponseBody.PageResult.ProjectList.Tags] = []
                    for v in value {
                        if v != nil {
                            var model = ListProjectsResponseBody.PageResult.ProjectList.Tags()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.tags = tmp
                }
                if let value = dict["UseProxyOdpsAccount"] as? Bool {
                    self.useProxyOdpsAccount = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var projectList: [ListProjectsResponseBody.PageResult.ProjectList]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.projectList != nil {
                var tmp : [Any] = []
                for k in self.projectList! {
                    tmp.append(k.toMap())
                }
                map["ProjectList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["ProjectList"] as? [Any?] {
                var tmp : [ListProjectsResponseBody.PageResult.ProjectList] = []
                for v in value {
                    if v != nil {
                        var model = ListProjectsResponseBody.PageResult.ProjectList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.projectList = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pageResult: ListProjectsResponseBody.PageResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageResult != nil {
            map["PageResult"] = self.pageResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageResult"] as? [String: Any?] {
            var model = ListProjectsResponseBody.PageResult()
            model.fromMap(value)
            self.pageResult = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListProjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListProjectsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListQualityResultsByEntityRequest : Tea.TeaModel {
    public var endDate: String?

    public var entityId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectName: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["EntityId"] as? Int64 {
            self.entityId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
    }
}

public class ListQualityResultsByEntityResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RuleChecks : Tea.TeaModel {
            public class ReferenceValue : Tea.TeaModel {
                public var bizDate: String?

                public var discreteProperty: String?

                public var singleCheckResult: Int32?

                public var threshold: Double?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizDate != nil {
                        map["BizDate"] = self.bizDate!
                    }
                    if self.discreteProperty != nil {
                        map["DiscreteProperty"] = self.discreteProperty!
                    }
                    if self.singleCheckResult != nil {
                        map["SingleCheckResult"] = self.singleCheckResult!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BizDate"] as? String {
                        self.bizDate = value
                    }
                    if let value = dict["DiscreteProperty"] as? String {
                        self.discreteProperty = value
                    }
                    if let value = dict["SingleCheckResult"] as? Int32 {
                        self.singleCheckResult = value
                    }
                    if let value = dict["Threshold"] as? Double {
                        self.threshold = value
                    }
                    if let value = dict["Value"] as? Double {
                        self.value = value
                    }
                }
            }
            public class SampleValue : Tea.TeaModel {
                public var bizDate: String?

                public var discreteProperty: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizDate != nil {
                        map["BizDate"] = self.bizDate!
                    }
                    if self.discreteProperty != nil {
                        map["DiscreteProperty"] = self.discreteProperty!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BizDate"] as? String {
                        self.bizDate = value
                    }
                    if let value = dict["DiscreteProperty"] as? String {
                        self.discreteProperty = value
                    }
                    if let value = dict["Value"] as? Double {
                        self.value = value
                    }
                }
            }
            public var actualExpression: String?

            public var beginTime: Int64?

            public var bizDate: Int64?

            public var blockType: Int32?

            public var checkResult: Int32?

            public var checkResultStatus: Int32?

            public var checkerId: Int32?

            public var checkerName: String?

            public var checkerType: Int32?

            public var comment: String?

            public var criticalThreshold: Double?

            public var dateType: String?

            public var discreteCheck: Bool?

            public var endTime: Int64?

            public var entityId: Int64?

            public var expectValue: Double?

            public var externalId: String?

            public var externalType: String?

            public var fixedCheck: Bool?

            public var id: Int64?

            public var isPrediction: Bool?

            public var lowerValue: Double?

            public var matchExpression: String?

            public var methodName: String?

            public var op: String?

            public var projectName: String?

            public var property: String?

            public var referenceValue: [ListQualityResultsByEntityResponseBody.Data.RuleChecks.ReferenceValue]?

            public var resultString: String?

            public var ruleId: Int64?

            public var ruleName: String?

            public var sampleValue: [ListQualityResultsByEntityResponseBody.Data.RuleChecks.SampleValue]?

            public var tableName: String?

            public var taskId: String?

            public var templateId: Int32?

            public var templateName: String?

            public var timeCost: String?

            public var trend: String?

            public var upperValue: Double?

            public var warningThreshold: Double?

            public var whereCondition: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actualExpression != nil {
                    map["ActualExpression"] = self.actualExpression!
                }
                if self.beginTime != nil {
                    map["BeginTime"] = self.beginTime!
                }
                if self.bizDate != nil {
                    map["BizDate"] = self.bizDate!
                }
                if self.blockType != nil {
                    map["BlockType"] = self.blockType!
                }
                if self.checkResult != nil {
                    map["CheckResult"] = self.checkResult!
                }
                if self.checkResultStatus != nil {
                    map["CheckResultStatus"] = self.checkResultStatus!
                }
                if self.checkerId != nil {
                    map["CheckerId"] = self.checkerId!
                }
                if self.checkerName != nil {
                    map["CheckerName"] = self.checkerName!
                }
                if self.checkerType != nil {
                    map["CheckerType"] = self.checkerType!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.criticalThreshold != nil {
                    map["CriticalThreshold"] = self.criticalThreshold!
                }
                if self.dateType != nil {
                    map["DateType"] = self.dateType!
                }
                if self.discreteCheck != nil {
                    map["DiscreteCheck"] = self.discreteCheck!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.entityId != nil {
                    map["EntityId"] = self.entityId!
                }
                if self.expectValue != nil {
                    map["ExpectValue"] = self.expectValue!
                }
                if self.externalId != nil {
                    map["ExternalId"] = self.externalId!
                }
                if self.externalType != nil {
                    map["ExternalType"] = self.externalType!
                }
                if self.fixedCheck != nil {
                    map["FixedCheck"] = self.fixedCheck!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isPrediction != nil {
                    map["IsPrediction"] = self.isPrediction!
                }
                if self.lowerValue != nil {
                    map["LowerValue"] = self.lowerValue!
                }
                if self.matchExpression != nil {
                    map["MatchExpression"] = self.matchExpression!
                }
                if self.methodName != nil {
                    map["MethodName"] = self.methodName!
                }
                if self.op != nil {
                    map["Op"] = self.op!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                if self.property != nil {
                    map["Property"] = self.property!
                }
                if self.referenceValue != nil {
                    var tmp : [Any] = []
                    for k in self.referenceValue! {
                        tmp.append(k.toMap())
                    }
                    map["ReferenceValue"] = tmp
                }
                if self.resultString != nil {
                    map["ResultString"] = self.resultString!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.sampleValue != nil {
                    var tmp : [Any] = []
                    for k in self.sampleValue! {
                        tmp.append(k.toMap())
                    }
                    map["SampleValue"] = tmp
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.timeCost != nil {
                    map["TimeCost"] = self.timeCost!
                }
                if self.trend != nil {
                    map["Trend"] = self.trend!
                }
                if self.upperValue != nil {
                    map["UpperValue"] = self.upperValue!
                }
                if self.warningThreshold != nil {
                    map["WarningThreshold"] = self.warningThreshold!
                }
                if self.whereCondition != nil {
                    map["WhereCondition"] = self.whereCondition!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ActualExpression"] as? String {
                    self.actualExpression = value
                }
                if let value = dict["BeginTime"] as? Int64 {
                    self.beginTime = value
                }
                if let value = dict["BizDate"] as? Int64 {
                    self.bizDate = value
                }
                if let value = dict["BlockType"] as? Int32 {
                    self.blockType = value
                }
                if let value = dict["CheckResult"] as? Int32 {
                    self.checkResult = value
                }
                if let value = dict["CheckResultStatus"] as? Int32 {
                    self.checkResultStatus = value
                }
                if let value = dict["CheckerId"] as? Int32 {
                    self.checkerId = value
                }
                if let value = dict["CheckerName"] as? String {
                    self.checkerName = value
                }
                if let value = dict["CheckerType"] as? Int32 {
                    self.checkerType = value
                }
                if let value = dict["Comment"] as? String {
                    self.comment = value
                }
                if let value = dict["CriticalThreshold"] as? Double {
                    self.criticalThreshold = value
                }
                if let value = dict["DateType"] as? String {
                    self.dateType = value
                }
                if let value = dict["DiscreteCheck"] as? Bool {
                    self.discreteCheck = value
                }
                if let value = dict["EndTime"] as? Int64 {
                    self.endTime = value
                }
                if let value = dict["EntityId"] as? Int64 {
                    self.entityId = value
                }
                if let value = dict["ExpectValue"] as? Double {
                    self.expectValue = value
                }
                if let value = dict["ExternalId"] as? String {
                    self.externalId = value
                }
                if let value = dict["ExternalType"] as? String {
                    self.externalType = value
                }
                if let value = dict["FixedCheck"] as? Bool {
                    self.fixedCheck = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["IsPrediction"] as? Bool {
                    self.isPrediction = value
                }
                if let value = dict["LowerValue"] as? Double {
                    self.lowerValue = value
                }
                if let value = dict["MatchExpression"] as? String {
                    self.matchExpression = value
                }
                if let value = dict["MethodName"] as? String {
                    self.methodName = value
                }
                if let value = dict["Op"] as? String {
                    self.op = value
                }
                if let value = dict["ProjectName"] as? String {
                    self.projectName = value
                }
                if let value = dict["Property"] as? String {
                    self.property = value
                }
                if let value = dict["ReferenceValue"] as? [Any?] {
                    var tmp : [ListQualityResultsByEntityResponseBody.Data.RuleChecks.ReferenceValue] = []
                    for v in value {
                        if v != nil {
                            var model = ListQualityResultsByEntityResponseBody.Data.RuleChecks.ReferenceValue()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.referenceValue = tmp
                }
                if let value = dict["ResultString"] as? String {
                    self.resultString = value
                }
                if let value = dict["RuleId"] as? Int64 {
                    self.ruleId = value
                }
                if let value = dict["RuleName"] as? String {
                    self.ruleName = value
                }
                if let value = dict["SampleValue"] as? [Any?] {
                    var tmp : [ListQualityResultsByEntityResponseBody.Data.RuleChecks.SampleValue] = []
                    for v in value {
                        if v != nil {
                            var model = ListQualityResultsByEntityResponseBody.Data.RuleChecks.SampleValue()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.sampleValue = tmp
                }
                if let value = dict["TableName"] as? String {
                    self.tableName = value
                }
                if let value = dict["TaskId"] as? String {
                    self.taskId = value
                }
                if let value = dict["TemplateId"] as? Int32 {
                    self.templateId = value
                }
                if let value = dict["TemplateName"] as? String {
                    self.templateName = value
                }
                if let value = dict["TimeCost"] as? String {
                    self.timeCost = value
                }
                if let value = dict["Trend"] as? String {
                    self.trend = value
                }
                if let value = dict["UpperValue"] as? Double {
                    self.upperValue = value
                }
                if let value = dict["WarningThreshold"] as? Double {
                    self.warningThreshold = value
                }
                if let value = dict["WhereCondition"] as? String {
                    self.whereCondition = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var ruleChecks: [ListQualityResultsByEntityResponseBody.Data.RuleChecks]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.ruleChecks != nil {
                var tmp : [Any] = []
                for k in self.ruleChecks! {
                    tmp.append(k.toMap())
                }
                map["RuleChecks"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["RuleChecks"] as? [Any?] {
                var tmp : [ListQualityResultsByEntityResponseBody.Data.RuleChecks] = []
                for v in value {
                    if v != nil {
                        var model = ListQualityResultsByEntityResponseBody.Data.RuleChecks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ruleChecks = tmp
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: ListQualityResultsByEntityResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListQualityResultsByEntityResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListQualityResultsByEntityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListQualityResultsByEntityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListQualityResultsByEntityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListQualityResultsByRuleRequest : Tea.TeaModel {
    public var endDate: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectName: String?

    public var ruleId: Int64?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
        if let value = dict["RuleId"] as? Int64 {
            self.ruleId = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
    }
}

public class ListQualityResultsByRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RuleChecks : Tea.TeaModel {
            public class ReferenceValue : Tea.TeaModel {
                public var bizDate: String?

                public var discreteProperty: String?

                public var singleCheckResult: Int32?

                public var threshold: Double?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizDate != nil {
                        map["BizDate"] = self.bizDate!
                    }
                    if self.discreteProperty != nil {
                        map["DiscreteProperty"] = self.discreteProperty!
                    }
                    if self.singleCheckResult != nil {
                        map["SingleCheckResult"] = self.singleCheckResult!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BizDate"] as? String {
                        self.bizDate = value
                    }
                    if let value = dict["DiscreteProperty"] as? String {
                        self.discreteProperty = value
                    }
                    if let value = dict["SingleCheckResult"] as? Int32 {
                        self.singleCheckResult = value
                    }
                    if let value = dict["Threshold"] as? Double {
                        self.threshold = value
                    }
                    if let value = dict["Value"] as? Double {
                        self.value = value
                    }
                }
            }
            public class SampleValue : Tea.TeaModel {
                public var bizDate: String?

                public var discreteProperty: String?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizDate != nil {
                        map["BizDate"] = self.bizDate!
                    }
                    if self.discreteProperty != nil {
                        map["DiscreteProperty"] = self.discreteProperty!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BizDate"] as? String {
                        self.bizDate = value
                    }
                    if let value = dict["DiscreteProperty"] as? String {
                        self.discreteProperty = value
                    }
                    if let value = dict["Value"] as? Double {
                        self.value = value
                    }
                }
            }
            public var actualExpression: String?

            public var beginTime: Int64?

            public var bizDate: Int64?

            public var blockType: Int32?

            public var checkResult: Int32?

            public var checkResultStatus: Int32?

            public var checkerId: Int32?

            public var checkerName: String?

            public var checkerType: Int32?

            public var comment: String?

            public var criticalThreshold: Double?

            public var dateType: String?

            public var discreteCheck: Bool?

            public var endTime: Int64?

            public var entityId: Int64?

            public var expectValue: Double?

            public var externalId: String?

            public var externalType: String?

            public var fixedCheck: Bool?

            public var id: Int64?

            public var isPrediction: Bool?

            public var lowerValue: Double?

            public var matchExpression: String?

            public var methodName: String?

            public var op: String?

            public var open_: Bool?

            public var projectName: String?

            public var property: String?

            public var referenceValue: [ListQualityResultsByRuleResponseBody.Data.RuleChecks.ReferenceValue]?

            public var resultString: String?

            public var ruleId: Int64?

            public var ruleName: String?

            public var sampleValue: [ListQualityResultsByRuleResponseBody.Data.RuleChecks.SampleValue]?

            public var tableName: String?

            public var taskId: String?

            public var templateId: Int32?

            public var templateName: String?

            public var timeCost: String?

            public var trend: String?

            public var upperValue: Double?

            public var warningThreshold: Double?

            public var whereCondition: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actualExpression != nil {
                    map["ActualExpression"] = self.actualExpression!
                }
                if self.beginTime != nil {
                    map["BeginTime"] = self.beginTime!
                }
                if self.bizDate != nil {
                    map["BizDate"] = self.bizDate!
                }
                if self.blockType != nil {
                    map["BlockType"] = self.blockType!
                }
                if self.checkResult != nil {
                    map["CheckResult"] = self.checkResult!
                }
                if self.checkResultStatus != nil {
                    map["CheckResultStatus"] = self.checkResultStatus!
                }
                if self.checkerId != nil {
                    map["CheckerId"] = self.checkerId!
                }
                if self.checkerName != nil {
                    map["CheckerName"] = self.checkerName!
                }
                if self.checkerType != nil {
                    map["CheckerType"] = self.checkerType!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.criticalThreshold != nil {
                    map["CriticalThreshold"] = self.criticalThreshold!
                }
                if self.dateType != nil {
                    map["DateType"] = self.dateType!
                }
                if self.discreteCheck != nil {
                    map["DiscreteCheck"] = self.discreteCheck!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.entityId != nil {
                    map["EntityId"] = self.entityId!
                }
                if self.expectValue != nil {
                    map["ExpectValue"] = self.expectValue!
                }
                if self.externalId != nil {
                    map["ExternalId"] = self.externalId!
                }
                if self.externalType != nil {
                    map["ExternalType"] = self.externalType!
                }
                if self.fixedCheck != nil {
                    map["FixedCheck"] = self.fixedCheck!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isPrediction != nil {
                    map["IsPrediction"] = self.isPrediction!
                }
                if self.lowerValue != nil {
                    map["LowerValue"] = self.lowerValue!
                }
                if self.matchExpression != nil {
                    map["MatchExpression"] = self.matchExpression!
                }
                if self.methodName != nil {
                    map["MethodName"] = self.methodName!
                }
                if self.op != nil {
                    map["Op"] = self.op!
                }
                if self.open_ != nil {
                    map["Open"] = self.open_!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                if self.property != nil {
                    map["Property"] = self.property!
                }
                if self.referenceValue != nil {
                    var tmp : [Any] = []
                    for k in self.referenceValue! {
                        tmp.append(k.toMap())
                    }
                    map["ReferenceValue"] = tmp
                }
                if self.resultString != nil {
                    map["ResultString"] = self.resultString!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.sampleValue != nil {
                    var tmp : [Any] = []
                    for k in self.sampleValue! {
                        tmp.append(k.toMap())
                    }
                    map["SampleValue"] = tmp
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.timeCost != nil {
                    map["TimeCost"] = self.timeCost!
                }
                if self.trend != nil {
                    map["Trend"] = self.trend!
                }
                if self.upperValue != nil {
                    map["UpperValue"] = self.upperValue!
                }
                if self.warningThreshold != nil {
                    map["WarningThreshold"] = self.warningThreshold!
                }
                if self.whereCondition != nil {
                    map["WhereCondition"] = self.whereCondition!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ActualExpression"] as? String {
                    self.actualExpression = value
                }
                if let value = dict["BeginTime"] as? Int64 {
                    self.beginTime = value
                }
                if let value = dict["BizDate"] as? Int64 {
                    self.bizDate = value
                }
                if let value = dict["BlockType"] as? Int32 {
                    self.blockType = value
                }
                if let value = dict["CheckResult"] as? Int32 {
                    self.checkResult = value
                }
                if let value = dict["CheckResultStatus"] as? Int32 {
                    self.checkResultStatus = value
                }
                if let value = dict["CheckerId"] as? Int32 {
                    self.checkerId = value
                }
                if let value = dict["CheckerName"] as? String {
                    self.checkerName = value
                }
                if let value = dict["CheckerType"] as? Int32 {
                    self.checkerType = value
                }
                if let value = dict["Comment"] as? String {
                    self.comment = value
                }
                if let value = dict["CriticalThreshold"] as? Double {
                    self.criticalThreshold = value
                }
                if let value = dict["DateType"] as? String {
                    self.dateType = value
                }
                if let value = dict["DiscreteCheck"] as? Bool {
                    self.discreteCheck = value
                }
                if let value = dict["EndTime"] as? Int64 {
                    self.endTime = value
                }
                if let value = dict["EntityId"] as? Int64 {
                    self.entityId = value
                }
                if let value = dict["ExpectValue"] as? Double {
                    self.expectValue = value
                }
                if let value = dict["ExternalId"] as? String {
                    self.externalId = value
                }
                if let value = dict["ExternalType"] as? String {
                    self.externalType = value
                }
                if let value = dict["FixedCheck"] as? Bool {
                    self.fixedCheck = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["IsPrediction"] as? Bool {
                    self.isPrediction = value
                }
                if let value = dict["LowerValue"] as? Double {
                    self.lowerValue = value
                }
                if let value = dict["MatchExpression"] as? String {
                    self.matchExpression = value
                }
                if let value = dict["MethodName"] as? String {
                    self.methodName = value
                }
                if let value = dict["Op"] as? String {
                    self.op = value
                }
                if let value = dict["Open"] as? Bool {
                    self.open_ = value
                }
                if let value = dict["ProjectName"] as? String {
                    self.projectName = value
                }
                if let value = dict["Property"] as? String {
                    self.property = value
                }
                if let value = dict["ReferenceValue"] as? [Any?] {
                    var tmp : [ListQualityResultsByRuleResponseBody.Data.RuleChecks.ReferenceValue] = []
                    for v in value {
                        if v != nil {
                            var model = ListQualityResultsByRuleResponseBody.Data.RuleChecks.ReferenceValue()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.referenceValue = tmp
                }
                if let value = dict["ResultString"] as? String {
                    self.resultString = value
                }
                if let value = dict["RuleId"] as? Int64 {
                    self.ruleId = value
                }
                if let value = dict["RuleName"] as? String {
                    self.ruleName = value
                }
                if let value = dict["SampleValue"] as? [Any?] {
                    var tmp : [ListQualityResultsByRuleResponseBody.Data.RuleChecks.SampleValue] = []
                    for v in value {
                        if v != nil {
                            var model = ListQualityResultsByRuleResponseBody.Data.RuleChecks.SampleValue()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.sampleValue = tmp
                }
                if let value = dict["TableName"] as? String {
                    self.tableName = value
                }
                if let value = dict["TaskId"] as? String {
                    self.taskId = value
                }
                if let value = dict["TemplateId"] as? Int32 {
                    self.templateId = value
                }
                if let value = dict["TemplateName"] as? String {
                    self.templateName = value
                }
                if let value = dict["TimeCost"] as? String {
                    self.timeCost = value
                }
                if let value = dict["Trend"] as? String {
                    self.trend = value
                }
                if let value = dict["UpperValue"] as? Double {
                    self.upperValue = value
                }
                if let value = dict["WarningThreshold"] as? Double {
                    self.warningThreshold = value
                }
                if let value = dict["WhereCondition"] as? String {
                    self.whereCondition = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var ruleChecks: [ListQualityResultsByRuleResponseBody.Data.RuleChecks]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.ruleChecks != nil {
                var tmp : [Any] = []
                for k in self.ruleChecks! {
                    tmp.append(k.toMap())
                }
                map["RuleChecks"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["RuleChecks"] as? [Any?] {
                var tmp : [ListQualityResultsByRuleResponseBody.Data.RuleChecks] = []
                for v in value {
                    if v != nil {
                        var model = ListQualityResultsByRuleResponseBody.Data.RuleChecks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ruleChecks = tmp
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: ListQualityResultsByRuleResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListQualityResultsByRuleResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListQualityResultsByRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListQualityResultsByRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListQualityResultsByRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListQualityRulesRequest : Tea.TeaModel {
    public var entityId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EntityId"] as? Int64 {
            self.entityId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
    }
}

public class ListQualityRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Rules : Tea.TeaModel {
            public var blockType: Int32?

            public var checkerId: Int32?

            public var comment: String?

            public var criticalThreshold: String?

            public var entityId: Int64?

            public var expectValue: String?

            public var fixCheck: Bool?

            public var historyCriticalThreshold: String?

            public var historyWarningThreshold: String?

            public var id: Int64?

            public var matchExpression: String?

            public var methodId: Int32?

            public var methodName: String?

            public var onDuty: String?

            public var onDutyAccountName: String?

            public var projectName: String?

            public var property: String?

            public var propertyKey: String?

            public var ruleCheckerRelationId: Int64?

            public var ruleName: String?

            public var ruleType: Int32?

            public var tableName: String?

            public var templateId: Int32?

            public var templateName: String?

            public var trend: String?

            public var warningThreshold: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blockType != nil {
                    map["BlockType"] = self.blockType!
                }
                if self.checkerId != nil {
                    map["CheckerId"] = self.checkerId!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.criticalThreshold != nil {
                    map["CriticalThreshold"] = self.criticalThreshold!
                }
                if self.entityId != nil {
                    map["EntityId"] = self.entityId!
                }
                if self.expectValue != nil {
                    map["ExpectValue"] = self.expectValue!
                }
                if self.fixCheck != nil {
                    map["FixCheck"] = self.fixCheck!
                }
                if self.historyCriticalThreshold != nil {
                    map["HistoryCriticalThreshold"] = self.historyCriticalThreshold!
                }
                if self.historyWarningThreshold != nil {
                    map["HistoryWarningThreshold"] = self.historyWarningThreshold!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.matchExpression != nil {
                    map["MatchExpression"] = self.matchExpression!
                }
                if self.methodId != nil {
                    map["MethodId"] = self.methodId!
                }
                if self.methodName != nil {
                    map["MethodName"] = self.methodName!
                }
                if self.onDuty != nil {
                    map["OnDuty"] = self.onDuty!
                }
                if self.onDutyAccountName != nil {
                    map["OnDutyAccountName"] = self.onDutyAccountName!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                if self.property != nil {
                    map["Property"] = self.property!
                }
                if self.propertyKey != nil {
                    map["PropertyKey"] = self.propertyKey!
                }
                if self.ruleCheckerRelationId != nil {
                    map["RuleCheckerRelationId"] = self.ruleCheckerRelationId!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.ruleType != nil {
                    map["RuleType"] = self.ruleType!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.trend != nil {
                    map["Trend"] = self.trend!
                }
                if self.warningThreshold != nil {
                    map["WarningThreshold"] = self.warningThreshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BlockType"] as? Int32 {
                    self.blockType = value
                }
                if let value = dict["CheckerId"] as? Int32 {
                    self.checkerId = value
                }
                if let value = dict["Comment"] as? String {
                    self.comment = value
                }
                if let value = dict["CriticalThreshold"] as? String {
                    self.criticalThreshold = value
                }
                if let value = dict["EntityId"] as? Int64 {
                    self.entityId = value
                }
                if let value = dict["ExpectValue"] as? String {
                    self.expectValue = value
                }
                if let value = dict["FixCheck"] as? Bool {
                    self.fixCheck = value
                }
                if let value = dict["HistoryCriticalThreshold"] as? String {
                    self.historyCriticalThreshold = value
                }
                if let value = dict["HistoryWarningThreshold"] as? String {
                    self.historyWarningThreshold = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["MatchExpression"] as? String {
                    self.matchExpression = value
                }
                if let value = dict["MethodId"] as? Int32 {
                    self.methodId = value
                }
                if let value = dict["MethodName"] as? String {
                    self.methodName = value
                }
                if let value = dict["OnDuty"] as? String {
                    self.onDuty = value
                }
                if let value = dict["OnDutyAccountName"] as? String {
                    self.onDutyAccountName = value
                }
                if let value = dict["ProjectName"] as? String {
                    self.projectName = value
                }
                if let value = dict["Property"] as? String {
                    self.property = value
                }
                if let value = dict["PropertyKey"] as? String {
                    self.propertyKey = value
                }
                if let value = dict["RuleCheckerRelationId"] as? Int64 {
                    self.ruleCheckerRelationId = value
                }
                if let value = dict["RuleName"] as? String {
                    self.ruleName = value
                }
                if let value = dict["RuleType"] as? Int32 {
                    self.ruleType = value
                }
                if let value = dict["TableName"] as? String {
                    self.tableName = value
                }
                if let value = dict["TemplateId"] as? Int32 {
                    self.templateId = value
                }
                if let value = dict["TemplateName"] as? String {
                    self.templateName = value
                }
                if let value = dict["Trend"] as? String {
                    self.trend = value
                }
                if let value = dict["WarningThreshold"] as? String {
                    self.warningThreshold = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var rules: [ListQualityRulesResponseBody.Data.Rules]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Rules"] as? [Any?] {
                var tmp : [ListQualityRulesResponseBody.Data.Rules] = []
                for v in value {
                    if v != nil {
                        var model = ListQualityRulesResponseBody.Data.Rules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.rules = tmp
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: ListQualityRulesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListQualityRulesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListQualityRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListQualityRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListQualityRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRefDISyncTasksRequest : Tea.TeaModel {
    public var datasourceName: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var projectId: Int64?

    public var refType: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasourceName != nil {
            map["DatasourceName"] = self.datasourceName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.refType != nil {
            map["RefType"] = self.refType!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DatasourceName"] as? String {
            self.datasourceName = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RefType"] as? String {
            self.refType = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
    }
}

public class ListRefDISyncTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DISyncTasks : Tea.TeaModel {
            public var diDestinationDatasource: String?

            public var diSourceDatasource: String?

            public var nodeId: Int64?

            public var nodeName: String?

            public var taskType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diDestinationDatasource != nil {
                    map["DiDestinationDatasource"] = self.diDestinationDatasource!
                }
                if self.diSourceDatasource != nil {
                    map["DiSourceDatasource"] = self.diSourceDatasource!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DiDestinationDatasource"] as? String {
                    self.diDestinationDatasource = value
                }
                if let value = dict["DiSourceDatasource"] as? String {
                    self.diSourceDatasource = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["TaskType"] as? String {
                    self.taskType = value
                }
            }
        }
        public var DISyncTasks: [ListRefDISyncTasksResponseBody.Data.DISyncTasks]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DISyncTasks != nil {
                var tmp : [Any] = []
                for k in self.DISyncTasks! {
                    tmp.append(k.toMap())
                }
                map["DISyncTasks"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DISyncTasks"] as? [Any?] {
                var tmp : [ListRefDISyncTasksResponseBody.Data.DISyncTasks] = []
                for v in value {
                    if v != nil {
                        var model = ListRefDISyncTasksResponseBody.Data.DISyncTasks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DISyncTasks = tmp
            }
        }
    }
    public var data: ListRefDISyncTasksResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListRefDISyncTasksResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListRefDISyncTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRefDISyncTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRefDISyncTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRemindsRequest : Tea.TeaModel {
    public var alertTarget: String?

    public var founder: String?

    public var nodeId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remindTypes: String?

    public var searchText: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertTarget != nil {
            map["AlertTarget"] = self.alertTarget!
        }
        if self.founder != nil {
            map["Founder"] = self.founder!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remindTypes != nil {
            map["RemindTypes"] = self.remindTypes!
        }
        if self.searchText != nil {
            map["SearchText"] = self.searchText!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlertTarget"] as? String {
            self.alertTarget = value
        }
        if let value = dict["Founder"] as? String {
            self.founder = value
        }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RemindTypes"] as? String {
            self.remindTypes = value
        }
        if let value = dict["SearchText"] as? String {
            self.searchText = value
        }
    }
}

public class ListRemindsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Reminds : Tea.TeaModel {
            public var alertMethods: [String]?

            public var alertTargets: [String]?

            public var alertUnit: String?

            public var baselineIds: [Int64]?

            public var bizProcessIds: [Int64]?

            public var dndEnd: String?

            public var dndStart: String?

            public var founder: String?

            public var nodeIds: [Int64]?

            public var projectIds: [Int64]?

            public var remindId: Int64?

            public var remindName: String?

            public var remindType: String?

            public var remindUnit: String?

            public var useflag: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertMethods != nil {
                    map["AlertMethods"] = self.alertMethods!
                }
                if self.alertTargets != nil {
                    map["AlertTargets"] = self.alertTargets!
                }
                if self.alertUnit != nil {
                    map["AlertUnit"] = self.alertUnit!
                }
                if self.baselineIds != nil {
                    map["BaselineIds"] = self.baselineIds!
                }
                if self.bizProcessIds != nil {
                    map["BizProcessIds"] = self.bizProcessIds!
                }
                if self.dndEnd != nil {
                    map["DndEnd"] = self.dndEnd!
                }
                if self.dndStart != nil {
                    map["DndStart"] = self.dndStart!
                }
                if self.founder != nil {
                    map["Founder"] = self.founder!
                }
                if self.nodeIds != nil {
                    map["NodeIds"] = self.nodeIds!
                }
                if self.projectIds != nil {
                    map["ProjectIds"] = self.projectIds!
                }
                if self.remindId != nil {
                    map["RemindId"] = self.remindId!
                }
                if self.remindName != nil {
                    map["RemindName"] = self.remindName!
                }
                if self.remindType != nil {
                    map["RemindType"] = self.remindType!
                }
                if self.remindUnit != nil {
                    map["RemindUnit"] = self.remindUnit!
                }
                if self.useflag != nil {
                    map["Useflag"] = self.useflag!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AlertMethods"] as? [String] {
                    self.alertMethods = value
                }
                if let value = dict["AlertTargets"] as? [String] {
                    self.alertTargets = value
                }
                if let value = dict["AlertUnit"] as? String {
                    self.alertUnit = value
                }
                if let value = dict["BaselineIds"] as? [Int64] {
                    self.baselineIds = value
                }
                if let value = dict["BizProcessIds"] as? [Int64] {
                    self.bizProcessIds = value
                }
                if let value = dict["DndEnd"] as? String {
                    self.dndEnd = value
                }
                if let value = dict["DndStart"] as? String {
                    self.dndStart = value
                }
                if let value = dict["Founder"] as? String {
                    self.founder = value
                }
                if let value = dict["NodeIds"] as? [Int64] {
                    self.nodeIds = value
                }
                if let value = dict["ProjectIds"] as? [Int64] {
                    self.projectIds = value
                }
                if let value = dict["RemindId"] as? Int64 {
                    self.remindId = value
                }
                if let value = dict["RemindName"] as? String {
                    self.remindName = value
                }
                if let value = dict["RemindType"] as? String {
                    self.remindType = value
                }
                if let value = dict["RemindUnit"] as? String {
                    self.remindUnit = value
                }
                if let value = dict["Useflag"] as? Bool {
                    self.useflag = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var reminds: [ListRemindsResponseBody.Data.Reminds]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.reminds != nil {
                var tmp : [Any] = []
                for k in self.reminds! {
                    tmp.append(k.toMap())
                }
                map["Reminds"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Reminds"] as? [Any?] {
                var tmp : [ListRemindsResponseBody.Data.Reminds] = []
                for v in value {
                    if v != nil {
                        var model = ListRemindsResponseBody.Data.Reminds()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.reminds = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListRemindsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListRemindsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListRemindsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRemindsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRemindsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListResourceGroupsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var bizExtKey: String?

    public var keyword: String?

    public var resourceGroupType: Int32?

    public var resourceManagerResourceGroupId: String?

    public var tags: [ListResourceGroupsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizExtKey != nil {
            map["BizExtKey"] = self.bizExtKey!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.resourceGroupType != nil {
            map["ResourceGroupType"] = self.resourceGroupType!
        }
        if self.resourceManagerResourceGroupId != nil {
            map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BizExtKey"] as? String {
            self.bizExtKey = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["ResourceGroupType"] as? Int32 {
            self.resourceGroupType = value
        }
        if let value = dict["ResourceManagerResourceGroupId"] as? String {
            self.resourceManagerResourceGroupId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [ListResourceGroupsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = ListResourceGroupsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class ListResourceGroupsShrinkRequest : Tea.TeaModel {
    public var bizExtKey: String?

    public var keyword: String?

    public var resourceGroupType: Int32?

    public var resourceManagerResourceGroupId: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizExtKey != nil {
            map["BizExtKey"] = self.bizExtKey!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.resourceGroupType != nil {
            map["ResourceGroupType"] = self.resourceGroupType!
        }
        if self.resourceManagerResourceGroupId != nil {
            map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BizExtKey"] as? String {
            self.bizExtKey = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["ResourceGroupType"] as? Int32 {
            self.resourceGroupType = value
        }
        if let value = dict["ResourceManagerResourceGroupId"] as? String {
            self.resourceManagerResourceGroupId = value
        }
        if let value = dict["Tags"] as? String {
            self.tagsShrink = value
        }
    }
}

public class ListResourceGroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var bizExtKey: String?

        public var cluster: String?

        public var createTime: String?

        public var enableKp: Bool?

        public var id: Int64?

        public var identifier: String?

        public var isDefault: Bool?

        public var mode: String?

        public var name: String?

        public var resourceGroupType: String?

        public var resourceManagerResourceGroupId: String?

        public var sequence: Int32?

        public var specs: [String: Any]?

        public var status: Int32?

        public var tags: [ListResourceGroupsResponseBody.Data.Tags]?

        public var tenantId: Int64?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizExtKey != nil {
                map["BizExtKey"] = self.bizExtKey!
            }
            if self.cluster != nil {
                map["Cluster"] = self.cluster!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.enableKp != nil {
                map["EnableKp"] = self.enableKp!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.identifier != nil {
                map["Identifier"] = self.identifier!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.resourceGroupType != nil {
                map["ResourceGroupType"] = self.resourceGroupType!
            }
            if self.resourceManagerResourceGroupId != nil {
                map["ResourceManagerResourceGroupId"] = self.resourceManagerResourceGroupId!
            }
            if self.sequence != nil {
                map["Sequence"] = self.sequence!
            }
            if self.specs != nil {
                map["Specs"] = self.specs!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BizExtKey"] as? String {
                self.bizExtKey = value
            }
            if let value = dict["Cluster"] as? String {
                self.cluster = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["EnableKp"] as? Bool {
                self.enableKp = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["IsDefault"] as? Bool {
                self.isDefault = value
            }
            if let value = dict["Mode"] as? String {
                self.mode = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["ResourceGroupType"] as? String {
                self.resourceGroupType = value
            }
            if let value = dict["ResourceManagerResourceGroupId"] as? String {
                self.resourceManagerResourceGroupId = value
            }
            if let value = dict["Sequence"] as? Int32 {
                self.sequence = value
            }
            if let value = dict["Specs"] as? [String: Any] {
                self.specs = value
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [ListResourceGroupsResponseBody.Data.Tags] = []
                for v in value {
                    if v != nil {
                        var model = ListResourceGroupsResponseBody.Data.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TenantId"] as? Int64 {
                self.tenantId = value
            }
            if let value = dict["UpdateTime"] as? String {
                self.updateTime = value
            }
        }
    }
    public var data: [ListResourceGroupsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListResourceGroupsResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListResourceGroupsResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListResourceGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResourceGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListResourceGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListShiftPersonnelsRequest : Tea.TeaModel {
    public var beginTime: Int64?

    public var endTime: Int64?

    public var shiftPersonUID: String?

    public var shiftScheduleIdentifier: String?

    public var userType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.shiftPersonUID != nil {
            map["ShiftPersonUID"] = self.shiftPersonUID!
        }
        if self.shiftScheduleIdentifier != nil {
            map["ShiftScheduleIdentifier"] = self.shiftScheduleIdentifier!
        }
        if self.userType != nil {
            map["UserType"] = self.userType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BeginTime"] as? Int64 {
            self.beginTime = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["ShiftPersonUID"] as? String {
            self.shiftPersonUID = value
        }
        if let value = dict["ShiftScheduleIdentifier"] as? String {
            self.shiftScheduleIdentifier = value
        }
        if let value = dict["UserType"] as? String {
            self.userType = value
        }
    }
}

public class ListShiftPersonnelsResponseBody : Tea.TeaModel {
    public class Paging : Tea.TeaModel {
        public class ShiftPersons : Tea.TeaModel {
            public var beginTime: Int64?

            public var endTime: Int64?

            public var shiftPersonName: String?

            public var shiftPersonUID: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beginTime != nil {
                    map["BeginTime"] = self.beginTime!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.shiftPersonName != nil {
                    map["ShiftPersonName"] = self.shiftPersonName!
                }
                if self.shiftPersonUID != nil {
                    map["ShiftPersonUID"] = self.shiftPersonUID!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BeginTime"] as? Int64 {
                    self.beginTime = value
                }
                if let value = dict["EndTime"] as? Int64 {
                    self.endTime = value
                }
                if let value = dict["ShiftPersonName"] as? String {
                    self.shiftPersonName = value
                }
                if let value = dict["ShiftPersonUID"] as? String {
                    self.shiftPersonUID = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var shiftPersons: [ListShiftPersonnelsResponseBody.Paging.ShiftPersons]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.shiftPersons != nil {
                var tmp : [Any] = []
                for k in self.shiftPersons! {
                    tmp.append(k.toMap())
                }
                map["ShiftPersons"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["ShiftPersons"] as? [Any?] {
                var tmp : [ListShiftPersonnelsResponseBody.Paging.ShiftPersons] = []
                for v in value {
                    if v != nil {
                        var model = ListShiftPersonnelsResponseBody.Paging.ShiftPersons()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.shiftPersons = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var paging: ListShiftPersonnelsResponseBody.Paging?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.paging?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.paging != nil {
            map["Paging"] = self.paging?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Paging"] as? [String: Any?] {
            var model = ListShiftPersonnelsResponseBody.Paging()
            model.fromMap(value)
            self.paging = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListShiftPersonnelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListShiftPersonnelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListShiftPersonnelsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListShiftSchedulesRequest : Tea.TeaModel {
    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var shiftScheduleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.shiftScheduleName != nil {
            map["ShiftScheduleName"] = self.shiftScheduleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ShiftScheduleName"] as? String {
            self.shiftScheduleName = value
        }
    }
}

public class ListShiftSchedulesResponseBody : Tea.TeaModel {
    public class Paging : Tea.TeaModel {
        public class ShiftSchedules : Tea.TeaModel {
            public var shiftScheduleIdentifier: String?

            public var shiftScheduleName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.shiftScheduleIdentifier != nil {
                    map["ShiftScheduleIdentifier"] = self.shiftScheduleIdentifier!
                }
                if self.shiftScheduleName != nil {
                    map["ShiftScheduleName"] = self.shiftScheduleName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ShiftScheduleIdentifier"] as? String {
                    self.shiftScheduleIdentifier = value
                }
                if let value = dict["ShiftScheduleName"] as? String {
                    self.shiftScheduleName = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var shiftSchedules: [ListShiftSchedulesResponseBody.Paging.ShiftSchedules]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.shiftSchedules != nil {
                var tmp : [Any] = []
                for k in self.shiftSchedules! {
                    tmp.append(k.toMap())
                }
                map["ShiftSchedules"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["ShiftSchedules"] as? [Any?] {
                var tmp : [ListShiftSchedulesResponseBody.Paging.ShiftSchedules] = []
                for v in value {
                    if v != nil {
                        var model = ListShiftSchedulesResponseBody.Paging.ShiftSchedules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.shiftSchedules = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var paging: ListShiftSchedulesResponseBody.Paging?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.paging?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.paging != nil {
            map["Paging"] = self.paging?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Paging"] as? [String: Any?] {
            var model = ListShiftSchedulesResponseBody.Paging()
            model.fromMap(value)
            self.paging = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListShiftSchedulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListShiftSchedulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListShiftSchedulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSuccessInstanceAmountRequest : Tea.TeaModel {
    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ListSuccessInstanceAmountResponseBody : Tea.TeaModel {
    public class InstanceStatusTrend : Tea.TeaModel {
        public class AvgTrend : Tea.TeaModel {
            public var count: Int32?

            public var timePoint: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timePoint != nil {
                    map["TimePoint"] = self.timePoint!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int32 {
                    self.count = value
                }
                if let value = dict["TimePoint"] as? String {
                    self.timePoint = value
                }
            }
        }
        public class TodayTrend : Tea.TeaModel {
            public var count: Int32?

            public var timePoint: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timePoint != nil {
                    map["TimePoint"] = self.timePoint!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int32 {
                    self.count = value
                }
                if let value = dict["TimePoint"] as? String {
                    self.timePoint = value
                }
            }
        }
        public class YesterdayTrend : Tea.TeaModel {
            public var count: Int32?

            public var timePoint: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timePoint != nil {
                    map["TimePoint"] = self.timePoint!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int32 {
                    self.count = value
                }
                if let value = dict["TimePoint"] as? String {
                    self.timePoint = value
                }
            }
        }
        public var avgTrend: [ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.AvgTrend]?

        public var todayTrend: [ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.TodayTrend]?

        public var yesterdayTrend: [ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.YesterdayTrend]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avgTrend != nil {
                var tmp : [Any] = []
                for k in self.avgTrend! {
                    tmp.append(k.toMap())
                }
                map["AvgTrend"] = tmp
            }
            if self.todayTrend != nil {
                var tmp : [Any] = []
                for k in self.todayTrend! {
                    tmp.append(k.toMap())
                }
                map["TodayTrend"] = tmp
            }
            if self.yesterdayTrend != nil {
                var tmp : [Any] = []
                for k in self.yesterdayTrend! {
                    tmp.append(k.toMap())
                }
                map["YesterdayTrend"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AvgTrend"] as? [Any?] {
                var tmp : [ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.AvgTrend] = []
                for v in value {
                    if v != nil {
                        var model = ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.AvgTrend()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.avgTrend = tmp
            }
            if let value = dict["TodayTrend"] as? [Any?] {
                var tmp : [ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.TodayTrend] = []
                for v in value {
                    if v != nil {
                        var model = ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.TodayTrend()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.todayTrend = tmp
            }
            if let value = dict["YesterdayTrend"] as? [Any?] {
                var tmp : [ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.YesterdayTrend] = []
                for v in value {
                    if v != nil {
                        var model = ListSuccessInstanceAmountResponseBody.InstanceStatusTrend.YesterdayTrend()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.yesterdayTrend = tmp
            }
        }
    }
    public var instanceStatusTrend: ListSuccessInstanceAmountResponseBody.InstanceStatusTrend?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceStatusTrend?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceStatusTrend != nil {
            map["InstanceStatusTrend"] = self.instanceStatusTrend?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceStatusTrend"] as? [String: Any?] {
            var model = ListSuccessInstanceAmountResponseBody.InstanceStatusTrend()
            model.fromMap(value)
            self.instanceStatusTrend = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListSuccessInstanceAmountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSuccessInstanceAmountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSuccessInstanceAmountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTableLevelRequest : Tea.TeaModel {
    public var levelType: Int32?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.levelType != nil {
            map["LevelType"] = self.levelType!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LevelType"] as? Int32 {
            self.levelType = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ListTableLevelResponseBody : Tea.TeaModel {
    public class TableLevelInfo : Tea.TeaModel {
        public class LevelList : Tea.TeaModel {
            public var description_: String?

            public var levelId: Int64?

            public var levelType: Int32?

            public var name: String?

            public var projectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.levelId != nil {
                    map["LevelId"] = self.levelId!
                }
                if self.levelType != nil {
                    map["LevelType"] = self.levelType!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["LevelId"] as? Int64 {
                    self.levelId = value
                }
                if let value = dict["LevelType"] as? Int32 {
                    self.levelType = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
            }
        }
        public var levelList: [ListTableLevelResponseBody.TableLevelInfo.LevelList]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.levelList != nil {
                var tmp : [Any] = []
                for k in self.levelList! {
                    tmp.append(k.toMap())
                }
                map["LevelList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LevelList"] as? [Any?] {
                var tmp : [ListTableLevelResponseBody.TableLevelInfo.LevelList] = []
                for v in value {
                    if v != nil {
                        var model = ListTableLevelResponseBody.TableLevelInfo.LevelList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.levelList = tmp
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public var tableLevelInfo: ListTableLevelResponseBody.TableLevelInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tableLevelInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tableLevelInfo != nil {
            map["TableLevelInfo"] = self.tableLevelInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TableLevelInfo"] as? [String: Any?] {
            var model = ListTableLevelResponseBody.TableLevelInfo()
            model.fromMap(value)
            self.tableLevelInfo = model
        }
    }
}

public class ListTableLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTableLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTableLevelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTableThemeRequest : Tea.TeaModel {
    public var pageNum: Int32?

    public var pageSize: Int32?

    public var parentId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ParentId"] as? Int64 {
            self.parentId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ListTableThemeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ThemeList : Tea.TeaModel {
            public var createTimeStamp: Int64?

            public var creator: String?

            public var level: Int32?

            public var name: String?

            public var parentId: Int64?

            public var projectId: Int64?

            public var themeId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTimeStamp != nil {
                    map["CreateTimeStamp"] = self.createTimeStamp!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.themeId != nil {
                    map["ThemeId"] = self.themeId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTimeStamp"] as? Int64 {
                    self.createTimeStamp = value
                }
                if let value = dict["Creator"] as? String {
                    self.creator = value
                }
                if let value = dict["Level"] as? Int32 {
                    self.level = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ParentId"] as? Int64 {
                    self.parentId = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["ThemeId"] as? Int64 {
                    self.themeId = value
                }
            }
        }
        public var themeList: [ListTableThemeResponseBody.Data.ThemeList]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.themeList != nil {
                var tmp : [Any] = []
                for k in self.themeList! {
                    tmp.append(k.toMap())
                }
                map["ThemeList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ThemeList"] as? [Any?] {
                var tmp : [ListTableThemeResponseBody.Data.ThemeList] = []
                for v in value {
                    if v != nil {
                        var model = ListTableThemeResponseBody.Data.ThemeList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.themeList = tmp
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: ListTableThemeResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListTableThemeResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListTableThemeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTableThemeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTableThemeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTablesRequest : Tea.TeaModel {
    public var dataSourceType: String?

    public var nextToken: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListTablesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TableEntityList : Tea.TeaModel {
            public class EntityContent : Tea.TeaModel {
                public var dataSourceQualifiedName: String?

                public var dataSourceUniqueId: String?

                public var databaseName: String?

                public var instanceId: String?

                public var projectName: String?

                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataSourceQualifiedName != nil {
                        map["DataSourceQualifiedName"] = self.dataSourceQualifiedName!
                    }
                    if self.dataSourceUniqueId != nil {
                        map["DataSourceUniqueId"] = self.dataSourceUniqueId!
                    }
                    if self.databaseName != nil {
                        map["DatabaseName"] = self.databaseName!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.projectName != nil {
                        map["ProjectName"] = self.projectName!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DataSourceQualifiedName"] as? String {
                        self.dataSourceQualifiedName = value
                    }
                    if let value = dict["DataSourceUniqueId"] as? String {
                        self.dataSourceUniqueId = value
                    }
                    if let value = dict["DatabaseName"] as? String {
                        self.databaseName = value
                    }
                    if let value = dict["InstanceId"] as? String {
                        self.instanceId = value
                    }
                    if let value = dict["ProjectName"] as? String {
                        self.projectName = value
                    }
                    if let value = dict["TableName"] as? String {
                        self.tableName = value
                    }
                }
            }
            public var entityContent: ListTablesResponseBody.Data.TableEntityList.EntityContent?

            public var entityQualifiedName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.entityContent?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.entityContent != nil {
                    map["EntityContent"] = self.entityContent?.toMap()
                }
                if self.entityQualifiedName != nil {
                    map["EntityQualifiedName"] = self.entityQualifiedName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EntityContent"] as? [String: Any?] {
                    var model = ListTablesResponseBody.Data.TableEntityList.EntityContent()
                    model.fromMap(value)
                    self.entityContent = model
                }
                if let value = dict["EntityQualifiedName"] as? String {
                    self.entityQualifiedName = value
                }
            }
        }
        public var nextToken: String?

        public var tableEntityList: [ListTablesResponseBody.Data.TableEntityList]?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.tableEntityList != nil {
                var tmp : [Any] = []
                for k in self.tableEntityList! {
                    tmp.append(k.toMap())
                }
                map["TableEntityList"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
            if let value = dict["TableEntityList"] as? [Any?] {
                var tmp : [ListTablesResponseBody.Data.TableEntityList] = []
                for v in value {
                    if v != nil {
                        var model = ListTablesResponseBody.Data.TableEntityList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tableEntityList = tmp
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var data: ListTablesResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListTablesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTablesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTopicsRequest : Tea.TeaModel {
    public var beginTime: String?

    public var endTime: String?

    public var instanceId: Int64?

    public var nodeId: Int64?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var topicStatuses: String?

    public var topicTypes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.topicStatuses != nil {
            map["TopicStatuses"] = self.topicStatuses!
        }
        if self.topicTypes != nil {
            map["TopicTypes"] = self.topicTypes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BeginTime"] as? String {
            self.beginTime = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? Int64 {
            self.instanceId = value
        }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["TopicStatuses"] as? String {
            self.topicStatuses = value
        }
        if let value = dict["TopicTypes"] as? String {
            self.topicTypes = value
        }
    }
}

public class ListTopicsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Topics : Tea.TeaModel {
            public var addTime: Int64?

            public var fixTime: Int64?

            public var happenTime: Int64?

            public var instanceId: Int64?

            public var nodeId: Int64?

            public var nodeName: String?

            public var nodeOwner: String?

            public var projectId: Int64?

            public var topicId: Int64?

            public var topicName: String?

            public var topicStatus: String?

            public var topicType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addTime != nil {
                    map["AddTime"] = self.addTime!
                }
                if self.fixTime != nil {
                    map["FixTime"] = self.fixTime!
                }
                if self.happenTime != nil {
                    map["HappenTime"] = self.happenTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.nodeOwner != nil {
                    map["NodeOwner"] = self.nodeOwner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.topicId != nil {
                    map["TopicId"] = self.topicId!
                }
                if self.topicName != nil {
                    map["TopicName"] = self.topicName!
                }
                if self.topicStatus != nil {
                    map["TopicStatus"] = self.topicStatus!
                }
                if self.topicType != nil {
                    map["TopicType"] = self.topicType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddTime"] as? Int64 {
                    self.addTime = value
                }
                if let value = dict["FixTime"] as? Int64 {
                    self.fixTime = value
                }
                if let value = dict["HappenTime"] as? Int64 {
                    self.happenTime = value
                }
                if let value = dict["InstanceId"] as? Int64 {
                    self.instanceId = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["NodeOwner"] as? String {
                    self.nodeOwner = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["TopicId"] as? Int64 {
                    self.topicId = value
                }
                if let value = dict["TopicName"] as? String {
                    self.topicName = value
                }
                if let value = dict["TopicStatus"] as? String {
                    self.topicStatus = value
                }
                if let value = dict["TopicType"] as? String {
                    self.topicType = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var topics: [ListTopicsResponseBody.Data.Topics]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.topics != nil {
                var tmp : [Any] = []
                for k in self.topics! {
                    tmp.append(k.toMap())
                }
                map["Topics"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Topics"] as? [Any?] {
                var tmp : [ListTopicsResponseBody.Data.Topics] = []
                for v in value {
                    if v != nil {
                        var model = ListTopicsResponseBody.Data.Topics()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.topics = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListTopicsResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListTopicsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListTopicsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTopicsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTopicsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class OfflineNodeRequest : Tea.TeaModel {
    public var nodeId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class OfflineNodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class OfflineNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OfflineNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = OfflineNodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PublishDataServiceApiRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiId"] as? Int64 {
            self.apiId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class PublishDataServiceApiResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class PublishDataServiceApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublishDataServiceApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PublishDataServiceApiResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryDISyncTaskConfigProcessResultRequest : Tea.TeaModel {
    public var asyncProcessId: Int64?

    public var projectId: Int64?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asyncProcessId != nil {
            map["AsyncProcessId"] = self.asyncProcessId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AsyncProcessId"] as? Int64 {
            self.asyncProcessId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
    }
}

public class QueryDISyncTaskConfigProcessResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public var taskContent: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskContent != nil {
                map["TaskContent"] = self.taskContent!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TaskContent"] as? String {
                self.taskContent = value
            }
        }
    }
    public var data: QueryDISyncTaskConfigProcessResultResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = QueryDISyncTaskConfigProcessResultResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class QueryDISyncTaskConfigProcessResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryDISyncTaskConfigProcessResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryDISyncTaskConfigProcessResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryDefaultTemplateRequest : Tea.TeaModel {
    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TenantId"] as? String {
            self.tenantId = value
        }
    }
}

public class QueryDefaultTemplateResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Any {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class QueryDefaultTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryDefaultTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryDefaultTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryPublicModelEngineRequest : Tea.TeaModel {
    public var projectId: String?

    public var text: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.text != nil {
            map["Text"] = self.text!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? String {
            self.projectId = value
        }
        if let value = dict["Text"] as? String {
            self.text = value
        }
    }
}

public class QueryPublicModelEngineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var returnValue: [[String: Any]]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.returnValue != nil {
            map["ReturnValue"] = self.returnValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ReturnValue"] as? [[String: Any]] {
            self.returnValue = value
        }
    }
}

public class QueryPublicModelEngineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryPublicModelEngineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryPublicModelEngineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryRecognizeDataByRuleTypeRequest : Tea.TeaModel {
    public var recognizeRulesType: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recognizeRulesType != nil {
            map["RecognizeRulesType"] = self.recognizeRulesType!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RecognizeRulesType"] as? String {
            self.recognizeRulesType = value
        }
        if let value = dict["TenantId"] as? String {
            self.tenantId = value
        }
    }
}

public class QueryRecognizeDataByRuleTypeResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Any {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class QueryRecognizeDataByRuleTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryRecognizeDataByRuleTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryRecognizeDataByRuleTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryRecognizeRuleDetailRequest : Tea.TeaModel {
    public var sensitiveName: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sensitiveName != nil {
            map["SensitiveName"] = self.sensitiveName!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["SensitiveName"] as? String {
            self.sensitiveName = value
        }
        if let value = dict["TenantId"] as? String {
            self.tenantId = value
        }
    }
}

public class QueryRecognizeRuleDetailResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Any {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class QueryRecognizeRuleDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryRecognizeRuleDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryRecognizeRuleDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryRecognizeRulesTypeResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Any {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class QueryRecognizeRulesTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryRecognizeRulesTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryRecognizeRulesTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QuerySensClassificationRequest : Tea.TeaModel {
    public var templateId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
        if let value = dict["TenantId"] as? String {
            self.tenantId = value
        }
    }
}

public class QuerySensClassificationResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Any {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class QuerySensClassificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySensClassificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QuerySensClassificationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QuerySensLevelRequest : Tea.TeaModel {
    public var templateId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantId != nil {
            map["tenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
        if let value = dict["tenantId"] as? String {
            self.tenantId = value
        }
    }
}

public class QuerySensLevelResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Any {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class QuerySensLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySensLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QuerySensLevelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QuerySensNodeInfoRequest : Tea.TeaModel {
    public var nodeId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sensitiveName: String?

    public var templateId: String?

    public var tenantId: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sensitiveName != nil {
            map["SensitiveName"] = self.sensitiveName!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SensitiveName"] as? String {
            self.sensitiveName = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
        if let value = dict["TenantId"] as? String {
            self.tenantId = value
        }
        if let value = dict["status"] as? Int32 {
            self.status = value
        }
    }
}

public class QuerySensNodeInfoResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Any {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class QuerySensNodeInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySensNodeInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QuerySensNodeInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RegisterLineageRelationRequest : Tea.TeaModel {
    public var lineageRelationRegisterVO: LineageRelationRegisterVO?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lineageRelationRegisterVO?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lineageRelationRegisterVO != nil {
            map["LineageRelationRegisterVO"] = self.lineageRelationRegisterVO?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LineageRelationRegisterVO"] as? [String: Any?] {
            var model = LineageRelationRegisterVO()
            model.fromMap(value)
            self.lineageRelationRegisterVO = model
        }
    }
}

public class RegisterLineageRelationShrinkRequest : Tea.TeaModel {
    public var lineageRelationRegisterVOShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lineageRelationRegisterVOShrink != nil {
            map["LineageRelationRegisterVO"] = self.lineageRelationRegisterVOShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LineageRelationRegisterVO"] as? String {
            self.lineageRelationRegisterVOShrink = value
        }
    }
}

public class RegisterLineageRelationResponseBody : Tea.TeaModel {
    public class LineageRelation : Tea.TeaModel {
        public var destEntityQualifiedName: String?

        public var relationshipGuid: String?

        public var srcEntityQualifiedName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.destEntityQualifiedName != nil {
                map["DestEntityQualifiedName"] = self.destEntityQualifiedName!
            }
            if self.relationshipGuid != nil {
                map["RelationshipGuid"] = self.relationshipGuid!
            }
            if self.srcEntityQualifiedName != nil {
                map["SrcEntityQualifiedName"] = self.srcEntityQualifiedName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DestEntityQualifiedName"] as? String {
                self.destEntityQualifiedName = value
            }
            if let value = dict["RelationshipGuid"] as? String {
                self.relationshipGuid = value
            }
            if let value = dict["SrcEntityQualifiedName"] as? String {
                self.srcEntityQualifiedName = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var lineageRelation: RegisterLineageRelationResponseBody.LineageRelation?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lineageRelation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.lineageRelation != nil {
            map["LineageRelation"] = self.lineageRelation?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["LineageRelation"] as? [String: Any?] {
            var model = RegisterLineageRelationResponseBody.LineageRelation()
            model.fromMap(value)
            self.lineageRelation = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class RegisterLineageRelationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterLineageRelationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RegisterLineageRelationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveEntityTagsRequest : Tea.TeaModel {
    public var qualifiedName: String?

    public var tagKeys: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["QualifiedName"] as? String {
            self.qualifiedName = value
        }
        if let value = dict["TagKeys"] as? [String] {
            self.tagKeys = value
        }
    }
}

public class RemoveEntityTagsShrinkRequest : Tea.TeaModel {
    public var qualifiedName: String?

    public var tagKeysShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        if self.tagKeysShrink != nil {
            map["TagKeys"] = self.tagKeysShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["QualifiedName"] as? String {
            self.qualifiedName = value
        }
        if let value = dict["TagKeys"] as? String {
            self.tagKeysShrink = value
        }
    }
}

public class RemoveEntityTagsResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class RemoveEntityTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveEntityTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveEntityTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveProjectMemberFromRoleRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var roleCode: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCode != nil {
            map["RoleCode"] = self.roleCode!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RoleCode"] as? String {
            self.roleCode = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class RemoveProjectMemberFromRoleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RemoveProjectMemberFromRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveProjectMemberFromRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveProjectMemberFromRoleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RestartInstanceRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? Int64 {
            self.instanceId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class RestartInstanceResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class RestartInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RestartInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResumeInstanceRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? Int64 {
            self.instanceId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class ResumeInstanceResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ResumeInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResumeInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RevokeTablePermissionRequest : Tea.TeaModel {
    public var actions: String?

    public var maxComputeProjectName: String?

    public var revokeUserId: String?

    public var revokeUserName: String?

    public var tableName: String?

    public var workspaceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actions != nil {
            map["Actions"] = self.actions!
        }
        if self.maxComputeProjectName != nil {
            map["MaxComputeProjectName"] = self.maxComputeProjectName!
        }
        if self.revokeUserId != nil {
            map["RevokeUserId"] = self.revokeUserId!
        }
        if self.revokeUserName != nil {
            map["RevokeUserName"] = self.revokeUserName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Actions"] as? String {
            self.actions = value
        }
        if let value = dict["MaxComputeProjectName"] as? String {
            self.maxComputeProjectName = value
        }
        if let value = dict["RevokeUserId"] as? String {
            self.revokeUserId = value
        }
        if let value = dict["RevokeUserName"] as? String {
            self.revokeUserName = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["WorkspaceId"] as? Int64 {
            self.workspaceId = value
        }
    }
}

public class RevokeTablePermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var revokeSuccess: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.revokeSuccess != nil {
            map["RevokeSuccess"] = self.revokeSuccess!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RevokeSuccess"] as? Bool {
            self.revokeSuccess = value
        }
    }
}

public class RevokeTablePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeTablePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RevokeTablePermissionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RunCycleDagNodesRequest : Tea.TeaModel {
    public var alertNoticeType: String?

    public var alertType: String?

    public var bizBeginTime: String?

    public var bizEndTime: String?

    public var concurrentRuns: Int32?

    public var endBizDate: String?

    public var excludeNodeIds: String?

    public var includeNodeIds: String?

    public var name: String?

    public var nodeParams: String?

    public var parallelism: Bool?

    public var projectEnv: String?

    public var rootNodeId: Int64?

    public var startBizDate: String?

    public var startFutureInstanceImmediately: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertNoticeType != nil {
            map["AlertNoticeType"] = self.alertNoticeType!
        }
        if self.alertType != nil {
            map["AlertType"] = self.alertType!
        }
        if self.bizBeginTime != nil {
            map["BizBeginTime"] = self.bizBeginTime!
        }
        if self.bizEndTime != nil {
            map["BizEndTime"] = self.bizEndTime!
        }
        if self.concurrentRuns != nil {
            map["ConcurrentRuns"] = self.concurrentRuns!
        }
        if self.endBizDate != nil {
            map["EndBizDate"] = self.endBizDate!
        }
        if self.excludeNodeIds != nil {
            map["ExcludeNodeIds"] = self.excludeNodeIds!
        }
        if self.includeNodeIds != nil {
            map["IncludeNodeIds"] = self.includeNodeIds!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nodeParams != nil {
            map["NodeParams"] = self.nodeParams!
        }
        if self.parallelism != nil {
            map["Parallelism"] = self.parallelism!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.rootNodeId != nil {
            map["RootNodeId"] = self.rootNodeId!
        }
        if self.startBizDate != nil {
            map["StartBizDate"] = self.startBizDate!
        }
        if self.startFutureInstanceImmediately != nil {
            map["StartFutureInstanceImmediately"] = self.startFutureInstanceImmediately!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlertNoticeType"] as? String {
            self.alertNoticeType = value
        }
        if let value = dict["AlertType"] as? String {
            self.alertType = value
        }
        if let value = dict["BizBeginTime"] as? String {
            self.bizBeginTime = value
        }
        if let value = dict["BizEndTime"] as? String {
            self.bizEndTime = value
        }
        if let value = dict["ConcurrentRuns"] as? Int32 {
            self.concurrentRuns = value
        }
        if let value = dict["EndBizDate"] as? String {
            self.endBizDate = value
        }
        if let value = dict["ExcludeNodeIds"] as? String {
            self.excludeNodeIds = value
        }
        if let value = dict["IncludeNodeIds"] as? String {
            self.includeNodeIds = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NodeParams"] as? String {
            self.nodeParams = value
        }
        if let value = dict["Parallelism"] as? Bool {
            self.parallelism = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["RootNodeId"] as? Int64 {
            self.rootNodeId = value
        }
        if let value = dict["StartBizDate"] as? String {
            self.startBizDate = value
        }
        if let value = dict["StartFutureInstanceImmediately"] as? Bool {
            self.startFutureInstanceImmediately = value
        }
    }
}

public class RunCycleDagNodesResponseBody : Tea.TeaModel {
    public var data: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Int64] {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class RunCycleDagNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunCycleDagNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RunCycleDagNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RunManualDagNodesRequest : Tea.TeaModel {
    public var bizDate: String?

    public var dagParameters: String?

    public var endBizDate: String?

    public var excludeNodeIds: String?

    public var flowName: String?

    public var includeNodeIds: String?

    public var nodeParameters: String?

    public var projectEnv: String?

    public var projectId: Int64?

    public var projectName: String?

    public var startBizDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizDate != nil {
            map["BizDate"] = self.bizDate!
        }
        if self.dagParameters != nil {
            map["DagParameters"] = self.dagParameters!
        }
        if self.endBizDate != nil {
            map["EndBizDate"] = self.endBizDate!
        }
        if self.excludeNodeIds != nil {
            map["ExcludeNodeIds"] = self.excludeNodeIds!
        }
        if self.flowName != nil {
            map["FlowName"] = self.flowName!
        }
        if self.includeNodeIds != nil {
            map["IncludeNodeIds"] = self.includeNodeIds!
        }
        if self.nodeParameters != nil {
            map["NodeParameters"] = self.nodeParameters!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.startBizDate != nil {
            map["StartBizDate"] = self.startBizDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BizDate"] as? String {
            self.bizDate = value
        }
        if let value = dict["DagParameters"] as? String {
            self.dagParameters = value
        }
        if let value = dict["EndBizDate"] as? String {
            self.endBizDate = value
        }
        if let value = dict["ExcludeNodeIds"] as? String {
            self.excludeNodeIds = value
        }
        if let value = dict["FlowName"] as? String {
            self.flowName = value
        }
        if let value = dict["IncludeNodeIds"] as? String {
            self.includeNodeIds = value
        }
        if let value = dict["NodeParameters"] as? String {
            self.nodeParameters = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
        if let value = dict["StartBizDate"] as? String {
            self.startBizDate = value
        }
    }
}

public class RunManualDagNodesResponseBody : Tea.TeaModel {
    public var dagId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DagId"] as? Int64 {
            self.dagId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RunManualDagNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunManualDagNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RunManualDagNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RunSmokeTestRequest : Tea.TeaModel {
    public var bizdate: String?

    public var name: String?

    public var nodeId: Int64?

    public var nodeParams: String?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeParams != nil {
            map["NodeParams"] = self.nodeParams!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bizdate"] as? String {
            self.bizdate = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["NodeParams"] as? String {
            self.nodeParams = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class RunSmokeTestResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int64 {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class RunSmokeTestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunSmokeTestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RunSmokeTestResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RunTriggerNodeRequest : Tea.TeaModel {
    public var appId: Int64?

    public var bizDate: Int64?

    public var cycleTime: Int64?

    public var nodeId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.bizDate != nil {
            map["BizDate"] = self.bizDate!
        }
        if self.cycleTime != nil {
            map["CycleTime"] = self.cycleTime!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? Int64 {
            self.appId = value
        }
        if let value = dict["BizDate"] as? Int64 {
            self.bizDate = value
        }
        if let value = dict["CycleTime"] as? Int64 {
            self.cycleTime = value
        }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
    }
}

public class RunTriggerNodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class RunTriggerNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunTriggerNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RunTriggerNodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SaveDataServiceApiTestResultRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var autoGenerate: Bool?

    public var failResultSample: String?

    public var projectId: Int64?

    public var resultSample: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.autoGenerate != nil {
            map["AutoGenerate"] = self.autoGenerate!
        }
        if self.failResultSample != nil {
            map["FailResultSample"] = self.failResultSample!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resultSample != nil {
            map["ResultSample"] = self.resultSample!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiId"] as? Int64 {
            self.apiId = value
        }
        if let value = dict["AutoGenerate"] as? Bool {
            self.autoGenerate = value
        }
        if let value = dict["FailResultSample"] as? String {
            self.failResultSample = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResultSample"] as? String {
            self.resultSample = value
        }
    }
}

public class SaveDataServiceApiTestResultResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class SaveDataServiceApiTestResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveDataServiceApiTestResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SaveDataServiceApiTestResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ScanSensitiveDataRequest : Tea.TeaModel {
    public var data: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? String {
            self.data = value
        }
    }
}

public class ScanSensitiveDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var sensitives: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sensitives != nil {
            map["Sensitives"] = self.sensitives!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Sensitives"] as? [String: Any] {
            self.sensitives = value
        }
    }
}

public class ScanSensitiveDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ScanSensitiveDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ScanSensitiveDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SearchMetaTablesRequest : Tea.TeaModel {
    public var appGuid: String?

    public var clusterId: String?

    public var dataSourceType: String?

    public var entityType: Int32?

    public var keyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var schema: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGuid != nil {
            map["AppGuid"] = self.appGuid!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.entityType != nil {
            map["EntityType"] = self.entityType!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppGuid"] as? String {
            self.appGuid = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["DataSourceType"] as? String {
            self.dataSourceType = value
        }
        if let value = dict["EntityType"] as? Int32 {
            self.entityType = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Schema"] as? String {
            self.schema = value
        }
    }
}

public class SearchMetaTablesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataEntityList : Tea.TeaModel {
            public var clusterId: String?

            public var databaseName: String?

            public var entityType: Int32?

            public var envType: Int32?

            public var ownerId: String?

            public var projectId: Int64?

            public var projectName: String?

            public var schema: String?

            public var tableGuid: String?

            public var tableName: String?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.entityType != nil {
                    map["EntityType"] = self.entityType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                if self.schema != nil {
                    map["Schema"] = self.schema!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ClusterId"] as? String {
                    self.clusterId = value
                }
                if let value = dict["DatabaseName"] as? String {
                    self.databaseName = value
                }
                if let value = dict["EntityType"] as? Int32 {
                    self.entityType = value
                }
                if let value = dict["EnvType"] as? Int32 {
                    self.envType = value
                }
                if let value = dict["OwnerId"] as? String {
                    self.ownerId = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["ProjectName"] as? String {
                    self.projectName = value
                }
                if let value = dict["Schema"] as? String {
                    self.schema = value
                }
                if let value = dict["TableGuid"] as? String {
                    self.tableGuid = value
                }
                if let value = dict["TableName"] as? String {
                    self.tableName = value
                }
                if let value = dict["TenantId"] as? Int64 {
                    self.tenantId = value
                }
            }
        }
        public var dataEntityList: [SearchMetaTablesResponseBody.Data.DataEntityList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataEntityList != nil {
                var tmp : [Any] = []
                for k in self.dataEntityList! {
                    tmp.append(k.toMap())
                }
                map["DataEntityList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataEntityList"] as? [Any?] {
                var tmp : [SearchMetaTablesResponseBody.Data.DataEntityList] = []
                for v in value {
                    if v != nil {
                        var model = SearchMetaTablesResponseBody.Data.DataEntityList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataEntityList = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: SearchMetaTablesResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = SearchMetaTablesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class SearchMetaTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMetaTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SearchMetaTablesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SearchNodesByOutputRequest : Tea.TeaModel {
    public var outputs: String?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.outputs != nil {
            map["Outputs"] = self.outputs!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Outputs"] as? String {
            self.outputs = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class SearchNodesByOutputResponseBody : Tea.TeaModel {
    public var data: [String: Any]?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any] {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class SearchNodesByOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchNodesByOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SearchNodesByOutputResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetDataSourceShareRequest : Tea.TeaModel {
    public var datasourceName: String?

    public var envType: String?

    public var projectId: Int64?

    public var projectPermissions: String?

    public var userPermissions: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasourceName != nil {
            map["DatasourceName"] = self.datasourceName!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectPermissions != nil {
            map["ProjectPermissions"] = self.projectPermissions!
        }
        if self.userPermissions != nil {
            map["UserPermissions"] = self.userPermissions!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DatasourceName"] as? String {
            self.datasourceName = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectPermissions"] as? String {
            self.projectPermissions = value
        }
        if let value = dict["UserPermissions"] as? String {
            self.userPermissions = value
        }
    }
}

public class SetDataSourceShareResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: SetDataSourceShareResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = SetDataSourceShareResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class SetDataSourceShareResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDataSourceShareResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetDataSourceShareResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetEntityTagsRequest : Tea.TeaModel {
    public var qualifiedName: String?

    public var tags: [UserEntityTag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["QualifiedName"] as? String {
            self.qualifiedName = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [UserEntityTag] = []
            for v in value {
                if v != nil {
                    var model = UserEntityTag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class SetEntityTagsShrinkRequest : Tea.TeaModel {
    public var qualifiedName: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["QualifiedName"] as? String {
            self.qualifiedName = value
        }
        if let value = dict["Tags"] as? String {
            self.tagsShrink = value
        }
    }
}

public class SetEntityTagsResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class SetEntityTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetEntityTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetEntityTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetSuccessInstanceRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? Int64 {
            self.instanceId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class SetSuccessInstanceResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class SetSuccessInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetSuccessInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetSuccessInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartDIJobRequest : Tea.TeaModel {
    public class RealtimeStartSettings : Tea.TeaModel {
        public class FailoverSettings : Tea.TeaModel {
            public var interval: Int64?

            public var upperLimit: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.upperLimit != nil {
                    map["UpperLimit"] = self.upperLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Interval"] as? Int64 {
                    self.interval = value
                }
                if let value = dict["UpperLimit"] as? Int64 {
                    self.upperLimit = value
                }
            }
        }
        public var failoverSettings: StartDIJobRequest.RealtimeStartSettings.FailoverSettings?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.failoverSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failoverSettings != nil {
                map["FailoverSettings"] = self.failoverSettings?.toMap()
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FailoverSettings"] as? [String: Any?] {
                var model = StartDIJobRequest.RealtimeStartSettings.FailoverSettings()
                model.fromMap(value)
                self.failoverSettings = model
            }
            if let value = dict["StartTime"] as? Int64 {
                self.startTime = value
            }
        }
    }
    public var DIJobId: Int64?

    public var forceToRerun: Bool?

    public var realtimeStartSettings: StartDIJobRequest.RealtimeStartSettings?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.realtimeStartSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.forceToRerun != nil {
            map["ForceToRerun"] = self.forceToRerun!
        }
        if self.realtimeStartSettings != nil {
            map["RealtimeStartSettings"] = self.realtimeStartSettings?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["ForceToRerun"] as? Bool {
            self.forceToRerun = value
        }
        if let value = dict["RealtimeStartSettings"] as? [String: Any?] {
            var model = StartDIJobRequest.RealtimeStartSettings()
            model.fromMap(value)
            self.realtimeStartSettings = model
        }
    }
}

public class StartDIJobShrinkRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var forceToRerun: Bool?

    public var realtimeStartSettingsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.forceToRerun != nil {
            map["ForceToRerun"] = self.forceToRerun!
        }
        if self.realtimeStartSettingsShrink != nil {
            map["RealtimeStartSettings"] = self.realtimeStartSettingsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["ForceToRerun"] as? Bool {
            self.forceToRerun = value
        }
        if let value = dict["RealtimeStartSettings"] as? String {
            self.realtimeStartSettingsShrink = value
        }
    }
}

public class StartDIJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartDIJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartDISyncInstanceRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var startParam: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.startParam != nil {
            map["StartParam"] = self.startParam!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FileId"] as? Int64 {
            self.fileId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["StartParam"] as? String {
            self.startParam = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
    }
}

public class StartDISyncInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: StartDISyncInstanceResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = StartDISyncInstanceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class StartDISyncInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartDISyncInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartDISyncInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartMigrationRequest : Tea.TeaModel {
    public var migrationId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationId != nil {
            map["MigrationId"] = self.migrationId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MigrationId"] as? Int64 {
            self.migrationId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class StartMigrationResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class StartMigrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartMigrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartMigrationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopDIJobRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
    }
}

public class StopDIJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopDIJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopDISyncInstanceRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FileId"] as? Int64 {
            self.fileId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
    }
}

public class StopDISyncInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: StopDISyncInstanceResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = StopDISyncInstanceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class StopDISyncInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopDISyncInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopDISyncInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopInstanceRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? Int64 {
            self.instanceId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class StopInstanceResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class StopInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SubmitDataServiceApiRequest : Tea.TeaModel {
    public var apiId: Int64?

    public var projectId: Int64?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiId"] as? Int64 {
            self.apiId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class SubmitDataServiceApiResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class SubmitDataServiceApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDataServiceApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SubmitDataServiceApiResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SubmitFileRequest : Tea.TeaModel {
    public var comment: String?

    public var fileId: Int64?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var skipAllDeployFileExtensions: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.skipAllDeployFileExtensions != nil {
            map["SkipAllDeployFileExtensions"] = self.skipAllDeployFileExtensions!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["FileId"] as? Int64 {
            self.fileId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
        if let value = dict["SkipAllDeployFileExtensions"] as? Bool {
            self.skipAllDeployFileExtensions = value
        }
    }
}

public class SubmitFileResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Int64 {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class SubmitFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SubmitFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SuspendInstanceRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? Int64 {
            self.instanceId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class SuspendInstanceResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class SuspendInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SuspendInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TerminateDISyncInstanceRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FileId"] as? Int64 {
            self.fileId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
    }
}

public class TerminateDISyncInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: TerminateDISyncInstanceResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = TerminateDISyncInstanceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class TerminateDISyncInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TerminateDISyncInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TerminateDISyncInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TestDataServiceApiRequest : Tea.TeaModel {
    public class BodyParams : Tea.TeaModel {
        public var paramKey: String?

        public var paramValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.paramKey != nil {
                map["ParamKey"] = self.paramKey!
            }
            if self.paramValue != nil {
                map["ParamValue"] = self.paramValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ParamKey"] as? String {
                self.paramKey = value
            }
            if let value = dict["ParamValue"] as? String {
                self.paramValue = value
            }
        }
    }
    public class HeadParams : Tea.TeaModel {
        public var paramKey: String?

        public var paramValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.paramKey != nil {
                map["ParamKey"] = self.paramKey!
            }
            if self.paramValue != nil {
                map["ParamValue"] = self.paramValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ParamKey"] as? String {
                self.paramKey = value
            }
            if let value = dict["ParamValue"] as? String {
                self.paramValue = value
            }
        }
    }
    public class PathParams : Tea.TeaModel {
        public var paramKey: String?

        public var paramValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.paramKey != nil {
                map["ParamKey"] = self.paramKey!
            }
            if self.paramValue != nil {
                map["ParamValue"] = self.paramValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ParamKey"] as? String {
                self.paramKey = value
            }
            if let value = dict["ParamValue"] as? String {
                self.paramValue = value
            }
        }
    }
    public class QueryParam : Tea.TeaModel {
        public var paramKey: String?

        public var paramValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.paramKey != nil {
                map["ParamKey"] = self.paramKey!
            }
            if self.paramValue != nil {
                map["ParamValue"] = self.paramValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ParamKey"] as? String {
                self.paramKey = value
            }
            if let value = dict["ParamValue"] as? String {
                self.paramValue = value
            }
        }
    }
    public var apiId: Int64?

    public var bodyContent: String?

    public var bodyParams: [TestDataServiceApiRequest.BodyParams]?

    public var headParams: [TestDataServiceApiRequest.HeadParams]?

    public var pathParams: [TestDataServiceApiRequest.PathParams]?

    public var queryParam: [TestDataServiceApiRequest.QueryParam]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.bodyContent != nil {
            map["BodyContent"] = self.bodyContent!
        }
        if self.bodyParams != nil {
            var tmp : [Any] = []
            for k in self.bodyParams! {
                tmp.append(k.toMap())
            }
            map["BodyParams"] = tmp
        }
        if self.headParams != nil {
            var tmp : [Any] = []
            for k in self.headParams! {
                tmp.append(k.toMap())
            }
            map["HeadParams"] = tmp
        }
        if self.pathParams != nil {
            var tmp : [Any] = []
            for k in self.pathParams! {
                tmp.append(k.toMap())
            }
            map["PathParams"] = tmp
        }
        if self.queryParam != nil {
            var tmp : [Any] = []
            for k in self.queryParam! {
                tmp.append(k.toMap())
            }
            map["QueryParam"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiId"] as? Int64 {
            self.apiId = value
        }
        if let value = dict["BodyContent"] as? String {
            self.bodyContent = value
        }
        if let value = dict["BodyParams"] as? [Any?] {
            var tmp : [TestDataServiceApiRequest.BodyParams] = []
            for v in value {
                if v != nil {
                    var model = TestDataServiceApiRequest.BodyParams()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.bodyParams = tmp
        }
        if let value = dict["HeadParams"] as? [Any?] {
            var tmp : [TestDataServiceApiRequest.HeadParams] = []
            for v in value {
                if v != nil {
                    var model = TestDataServiceApiRequest.HeadParams()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.headParams = tmp
        }
        if let value = dict["PathParams"] as? [Any?] {
            var tmp : [TestDataServiceApiRequest.PathParams] = []
            for v in value {
                if v != nil {
                    var model = TestDataServiceApiRequest.PathParams()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.pathParams = tmp
        }
        if let value = dict["QueryParam"] as? [Any?] {
            var tmp : [TestDataServiceApiRequest.QueryParam] = []
            for v in value {
                if v != nil {
                    var model = TestDataServiceApiRequest.QueryParam()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.queryParam = tmp
        }
    }
}

public class TestDataServiceApiResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var testId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.testId != nil {
                map["TestId"] = self.testId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TestId"] as? String {
                self.testId = value
            }
        }
    }
    public var data: TestDataServiceApiResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = TestDataServiceApiResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TestDataServiceApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TestDataServiceApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TestDataServiceApiResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TestNetworkConnectionRequest : Tea.TeaModel {
    public var datasourceName: String?

    public var envType: String?

    public var projectId: Int64?

    public var resourceGroup: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasourceName != nil {
            map["DatasourceName"] = self.datasourceName!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceGroup != nil {
            map["ResourceGroup"] = self.resourceGroup!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DatasourceName"] as? String {
            self.datasourceName = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceGroup"] as? String {
            self.resourceGroup = value
        }
    }
}

public class TestNetworkConnectionResponseBody : Tea.TeaModel {
    public class TaskList : Tea.TeaModel {
        public var connectMessage: String?

        public var connectStatus: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectMessage != nil {
                map["ConnectMessage"] = self.connectMessage!
            }
            if self.connectStatus != nil {
                map["ConnectStatus"] = self.connectStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConnectMessage"] as? String {
                self.connectMessage = value
            }
            if let value = dict["ConnectStatus"] as? Bool {
                self.connectStatus = value
            }
        }
    }
    public var requestId: String?

    public var success: Bool?

    public var taskList: TestNetworkConnectionResponseBody.TaskList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskList != nil {
            map["TaskList"] = self.taskList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TaskList"] as? [String: Any?] {
            var model = TestNetworkConnectionResponseBody.TaskList()
            model.fromMap(value)
            self.taskList = model
        }
    }
}

public class TestNetworkConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TestNetworkConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TestNetworkConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TopTenElapsedTimeInstanceRequest : Tea.TeaModel {
    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class TopTenElapsedTimeInstanceResponseBody : Tea.TeaModel {
    public class InstanceConsumeTimeRank : Tea.TeaModel {
        public class ConsumeTimeRank : Tea.TeaModel {
            public var businessDate: Int64?

            public var consumed: Int64?

            public var instanceId: Int64?

            public var nodeId: Int64?

            public var nodeName: String?

            public var owner: String?

            public var programType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessDate != nil {
                    map["BusinessDate"] = self.businessDate!
                }
                if self.consumed != nil {
                    map["Consumed"] = self.consumed!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.programType != nil {
                    map["ProgramType"] = self.programType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BusinessDate"] as? Int64 {
                    self.businessDate = value
                }
                if let value = dict["Consumed"] as? Int64 {
                    self.consumed = value
                }
                if let value = dict["InstanceId"] as? Int64 {
                    self.instanceId = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["ProgramType"] as? Int32 {
                    self.programType = value
                }
            }
        }
        public var consumeTimeRank: [TopTenElapsedTimeInstanceResponseBody.InstanceConsumeTimeRank.ConsumeTimeRank]?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consumeTimeRank != nil {
                var tmp : [Any] = []
                for k in self.consumeTimeRank! {
                    tmp.append(k.toMap())
                }
                map["ConsumeTimeRank"] = tmp
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConsumeTimeRank"] as? [Any?] {
                var tmp : [TopTenElapsedTimeInstanceResponseBody.InstanceConsumeTimeRank.ConsumeTimeRank] = []
                for v in value {
                    if v != nil {
                        var model = TopTenElapsedTimeInstanceResponseBody.InstanceConsumeTimeRank.ConsumeTimeRank()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.consumeTimeRank = tmp
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var instanceConsumeTimeRank: TopTenElapsedTimeInstanceResponseBody.InstanceConsumeTimeRank?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceConsumeTimeRank?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceConsumeTimeRank != nil {
            map["InstanceConsumeTimeRank"] = self.instanceConsumeTimeRank?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceConsumeTimeRank"] as? [String: Any?] {
            var model = TopTenElapsedTimeInstanceResponseBody.InstanceConsumeTimeRank()
            model.fromMap(value)
            self.instanceConsumeTimeRank = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TopTenElapsedTimeInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TopTenElapsedTimeInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TopTenElapsedTimeInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TopTenErrorTimesInstanceRequest : Tea.TeaModel {
    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class TopTenErrorTimesInstanceResponseBody : Tea.TeaModel {
    public class InstanceErrorRank : Tea.TeaModel {
        public class ErrorRank : Tea.TeaModel {
            public var count: Int32?

            public var nodeId: Int64?

            public var nodeName: String?

            public var owner: String?

            public var programType: Int32?

            public var projectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.programType != nil {
                    map["ProgramType"] = self.programType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int32 {
                    self.count = value
                }
                if let value = dict["NodeId"] as? Int64 {
                    self.nodeId = value
                }
                if let value = dict["NodeName"] as? String {
                    self.nodeName = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["ProgramType"] as? Int32 {
                    self.programType = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
            }
        }
        public var errorRank: [TopTenErrorTimesInstanceResponseBody.InstanceErrorRank.ErrorRank]?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorRank != nil {
                var tmp : [Any] = []
                for k in self.errorRank! {
                    tmp.append(k.toMap())
                }
                map["ErrorRank"] = tmp
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ErrorRank"] as? [Any?] {
                var tmp : [TopTenErrorTimesInstanceResponseBody.InstanceErrorRank.ErrorRank] = []
                for v in value {
                    if v != nil {
                        var model = TopTenErrorTimesInstanceResponseBody.InstanceErrorRank.ErrorRank()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.errorRank = tmp
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var instanceErrorRank: TopTenErrorTimesInstanceResponseBody.InstanceErrorRank?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceErrorRank?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceErrorRank != nil {
            map["InstanceErrorRank"] = self.instanceErrorRank?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceErrorRank"] as? [String: Any?] {
            var model = TopTenErrorTimesInstanceResponseBody.InstanceErrorRank()
            model.fromMap(value)
            self.instanceErrorRank = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TopTenErrorTimesInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TopTenErrorTimesInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TopTenErrorTimesInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateBaselineRequest : Tea.TeaModel {
    public class AlertSettings : Tea.TeaModel {
        public class DingRobots : Tea.TeaModel {
            public var atAll: Bool?

            public var webUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.atAll != nil {
                    map["AtAll"] = self.atAll!
                }
                if self.webUrl != nil {
                    map["WebUrl"] = self.webUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AtAll"] as? Bool {
                    self.atAll = value
                }
                if let value = dict["WebUrl"] as? String {
                    self.webUrl = value
                }
            }
        }
        public var alertInterval: Int32?

        public var alertMaximum: Int32?

        public var alertMethods: [String]?

        public var alertRecipient: String?

        public var alertRecipientType: String?

        public var alertType: String?

        public var baselineAlertEnabled: Bool?

        public var dingRobots: [UpdateBaselineRequest.AlertSettings.DingRobots]?

        public var silenceEndTime: String?

        public var silenceStartTime: String?

        public var topicTypes: [String]?

        public var webhooks: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertInterval != nil {
                map["AlertInterval"] = self.alertInterval!
            }
            if self.alertMaximum != nil {
                map["AlertMaximum"] = self.alertMaximum!
            }
            if self.alertMethods != nil {
                map["AlertMethods"] = self.alertMethods!
            }
            if self.alertRecipient != nil {
                map["AlertRecipient"] = self.alertRecipient!
            }
            if self.alertRecipientType != nil {
                map["AlertRecipientType"] = self.alertRecipientType!
            }
            if self.alertType != nil {
                map["AlertType"] = self.alertType!
            }
            if self.baselineAlertEnabled != nil {
                map["BaselineAlertEnabled"] = self.baselineAlertEnabled!
            }
            if self.dingRobots != nil {
                var tmp : [Any] = []
                for k in self.dingRobots! {
                    tmp.append(k.toMap())
                }
                map["DingRobots"] = tmp
            }
            if self.silenceEndTime != nil {
                map["SilenceEndTime"] = self.silenceEndTime!
            }
            if self.silenceStartTime != nil {
                map["SilenceStartTime"] = self.silenceStartTime!
            }
            if self.topicTypes != nil {
                map["TopicTypes"] = self.topicTypes!
            }
            if self.webhooks != nil {
                map["Webhooks"] = self.webhooks!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlertInterval"] as? Int32 {
                self.alertInterval = value
            }
            if let value = dict["AlertMaximum"] as? Int32 {
                self.alertMaximum = value
            }
            if let value = dict["AlertMethods"] as? [String] {
                self.alertMethods = value
            }
            if let value = dict["AlertRecipient"] as? String {
                self.alertRecipient = value
            }
            if let value = dict["AlertRecipientType"] as? String {
                self.alertRecipientType = value
            }
            if let value = dict["AlertType"] as? String {
                self.alertType = value
            }
            if let value = dict["BaselineAlertEnabled"] as? Bool {
                self.baselineAlertEnabled = value
            }
            if let value = dict["DingRobots"] as? [Any?] {
                var tmp : [UpdateBaselineRequest.AlertSettings.DingRobots] = []
                for v in value {
                    if v != nil {
                        var model = UpdateBaselineRequest.AlertSettings.DingRobots()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dingRobots = tmp
            }
            if let value = dict["SilenceEndTime"] as? String {
                self.silenceEndTime = value
            }
            if let value = dict["SilenceStartTime"] as? String {
                self.silenceStartTime = value
            }
            if let value = dict["TopicTypes"] as? [String] {
                self.topicTypes = value
            }
            if let value = dict["Webhooks"] as? [String] {
                self.webhooks = value
            }
        }
    }
    public class OvertimeSettings : Tea.TeaModel {
        public var cycle: Int32?

        public var time: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycle != nil {
                map["Cycle"] = self.cycle!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cycle"] as? Int32 {
                self.cycle = value
            }
            if let value = dict["Time"] as? String {
                self.time = value
            }
        }
    }
    public var alertEnabled: Bool?

    public var alertMarginThreshold: Int32?

    public var alertSettings: [UpdateBaselineRequest.AlertSettings]?

    public var baselineId: Int64?

    public var baselineName: String?

    public var baselineType: String?

    public var enabled: Bool?

    public var nodeIds: String?

    public var overtimeSettings: [UpdateBaselineRequest.OvertimeSettings]?

    public var owner: String?

    public var priority: Int32?

    public var projectId: Int64?

    public var removeNodeIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertEnabled != nil {
            map["AlertEnabled"] = self.alertEnabled!
        }
        if self.alertMarginThreshold != nil {
            map["AlertMarginThreshold"] = self.alertMarginThreshold!
        }
        if self.alertSettings != nil {
            var tmp : [Any] = []
            for k in self.alertSettings! {
                tmp.append(k.toMap())
            }
            map["AlertSettings"] = tmp
        }
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        if self.baselineName != nil {
            map["BaselineName"] = self.baselineName!
        }
        if self.baselineType != nil {
            map["BaselineType"] = self.baselineType!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.overtimeSettings != nil {
            var tmp : [Any] = []
            for k in self.overtimeSettings! {
                tmp.append(k.toMap())
            }
            map["OvertimeSettings"] = tmp
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.removeNodeIds != nil {
            map["RemoveNodeIds"] = self.removeNodeIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlertEnabled"] as? Bool {
            self.alertEnabled = value
        }
        if let value = dict["AlertMarginThreshold"] as? Int32 {
            self.alertMarginThreshold = value
        }
        if let value = dict["AlertSettings"] as? [Any?] {
            var tmp : [UpdateBaselineRequest.AlertSettings] = []
            for v in value {
                if v != nil {
                    var model = UpdateBaselineRequest.AlertSettings()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.alertSettings = tmp
        }
        if let value = dict["BaselineId"] as? Int64 {
            self.baselineId = value
        }
        if let value = dict["BaselineName"] as? String {
            self.baselineName = value
        }
        if let value = dict["BaselineType"] as? String {
            self.baselineType = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["NodeIds"] as? String {
            self.nodeIds = value
        }
        if let value = dict["OvertimeSettings"] as? [Any?] {
            var tmp : [UpdateBaselineRequest.OvertimeSettings] = []
            for v in value {
                if v != nil {
                    var model = UpdateBaselineRequest.OvertimeSettings()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.overtimeSettings = tmp
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RemoveNodeIds"] as? String {
            self.removeNodeIds = value
        }
    }
}

public class UpdateBaselineShrinkRequest : Tea.TeaModel {
    public var alertEnabled: Bool?

    public var alertMarginThreshold: Int32?

    public var alertSettingsShrink: String?

    public var baselineId: Int64?

    public var baselineName: String?

    public var baselineType: String?

    public var enabled: Bool?

    public var nodeIds: String?

    public var overtimeSettingsShrink: String?

    public var owner: String?

    public var priority: Int32?

    public var projectId: Int64?

    public var removeNodeIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertEnabled != nil {
            map["AlertEnabled"] = self.alertEnabled!
        }
        if self.alertMarginThreshold != nil {
            map["AlertMarginThreshold"] = self.alertMarginThreshold!
        }
        if self.alertSettingsShrink != nil {
            map["AlertSettings"] = self.alertSettingsShrink!
        }
        if self.baselineId != nil {
            map["BaselineId"] = self.baselineId!
        }
        if self.baselineName != nil {
            map["BaselineName"] = self.baselineName!
        }
        if self.baselineType != nil {
            map["BaselineType"] = self.baselineType!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.overtimeSettingsShrink != nil {
            map["OvertimeSettings"] = self.overtimeSettingsShrink!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.removeNodeIds != nil {
            map["RemoveNodeIds"] = self.removeNodeIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlertEnabled"] as? Bool {
            self.alertEnabled = value
        }
        if let value = dict["AlertMarginThreshold"] as? Int32 {
            self.alertMarginThreshold = value
        }
        if let value = dict["AlertSettings"] as? String {
            self.alertSettingsShrink = value
        }
        if let value = dict["BaselineId"] as? Int64 {
            self.baselineId = value
        }
        if let value = dict["BaselineName"] as? String {
            self.baselineName = value
        }
        if let value = dict["BaselineType"] as? String {
            self.baselineType = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["NodeIds"] as? String {
            self.nodeIds = value
        }
        if let value = dict["OvertimeSettings"] as? String {
            self.overtimeSettingsShrink = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RemoveNodeIds"] as? String {
            self.removeNodeIds = value
        }
    }
}

public class UpdateBaselineResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateBaselineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateBaselineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateBaselineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateBusinessRequest : Tea.TeaModel {
    public var businessId: Int64?

    public var businessName: String?

    public var description_: String?

    public var owner: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessId != nil {
            map["BusinessId"] = self.businessId!
        }
        if self.businessName != nil {
            map["BusinessName"] = self.businessName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BusinessId"] as? Int64 {
            self.businessId = value
        }
        if let value = dict["BusinessName"] as? String {
            self.businessName = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class UpdateBusinessResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateBusinessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateBusinessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateBusinessResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateClusterConfigsRequest : Tea.TeaModel {
    public var clusterId: Int64?

    public var configType: String?

    public var configValues: [ClusterConfig]?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configType != nil {
            map["ConfigType"] = self.configType!
        }
        if self.configValues != nil {
            var tmp : [Any] = []
            for k in self.configValues! {
                tmp.append(k.toMap())
            }
            map["ConfigValues"] = tmp
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? Int64 {
            self.clusterId = value
        }
        if let value = dict["ConfigType"] as? String {
            self.configType = value
        }
        if let value = dict["ConfigValues"] as? [Any?] {
            var tmp : [ClusterConfig] = []
            for v in value {
                if v != nil {
                    var model = ClusterConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.configValues = tmp
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class UpdateClusterConfigsShrinkRequest : Tea.TeaModel {
    public var clusterId: Int64?

    public var configType: String?

    public var configValuesShrink: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configType != nil {
            map["ConfigType"] = self.configType!
        }
        if self.configValuesShrink != nil {
            map["ConfigValues"] = self.configValuesShrink!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? Int64 {
            self.clusterId = value
        }
        if let value = dict["ConfigType"] as? String {
            self.configType = value
        }
        if let value = dict["ConfigValues"] as? String {
            self.configValuesShrink = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class UpdateClusterConfigsResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateClusterConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateClusterConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateClusterConfigsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateConnectionRequest : Tea.TeaModel {
    public var connectionId: Int64?

    public var content: String?

    public var description_: String?

    public var envType: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionId != nil {
            map["ConnectionId"] = self.connectionId!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionId"] as? Int64 {
            self.connectionId = value
        }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnvType"] as? Int32 {
            self.envType = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class UpdateConnectionResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? String {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDIAlarmRuleRequest : Tea.TeaModel {
    public class NotificationSettings : Tea.TeaModel {
        public class NotificationChannels : Tea.TeaModel {
            public var channels: [String]?

            public var severity: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Channels"] as? [String] {
                    self.channels = value
                }
                if let value = dict["Severity"] as? String {
                    self.severity = value
                }
            }
        }
        public class NotificationReceivers : Tea.TeaModel {
            public var receiverType: String?

            public var receiverValues: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.receiverType != nil {
                    map["ReceiverType"] = self.receiverType!
                }
                if self.receiverValues != nil {
                    map["ReceiverValues"] = self.receiverValues!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ReceiverType"] as? String {
                    self.receiverType = value
                }
                if let value = dict["ReceiverValues"] as? [String] {
                    self.receiverValues = value
                }
            }
        }
        public var inhibitionInterval: Int32?

        public var notificationChannels: [UpdateDIAlarmRuleRequest.NotificationSettings.NotificationChannels]?

        public var notificationReceivers: [UpdateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inhibitionInterval != nil {
                map["InhibitionInterval"] = self.inhibitionInterval!
            }
            if self.notificationChannels != nil {
                var tmp : [Any] = []
                for k in self.notificationChannels! {
                    tmp.append(k.toMap())
                }
                map["NotificationChannels"] = tmp
            }
            if self.notificationReceivers != nil {
                var tmp : [Any] = []
                for k in self.notificationReceivers! {
                    tmp.append(k.toMap())
                }
                map["NotificationReceivers"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InhibitionInterval"] as? Int32 {
                self.inhibitionInterval = value
            }
            if let value = dict["NotificationChannels"] as? [Any?] {
                var tmp : [UpdateDIAlarmRuleRequest.NotificationSettings.NotificationChannels] = []
                for v in value {
                    if v != nil {
                        var model = UpdateDIAlarmRuleRequest.NotificationSettings.NotificationChannels()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.notificationChannels = tmp
            }
            if let value = dict["NotificationReceivers"] as? [Any?] {
                var tmp : [UpdateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers] = []
                for v in value {
                    if v != nil {
                        var model = UpdateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.notificationReceivers = tmp
            }
        }
    }
    public class TriggerConditions : Tea.TeaModel {
        public var duration: Int64?

        public var severity: String?

        public var threshold: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Duration"] as? Int64 {
                self.duration = value
            }
            if let value = dict["Severity"] as? String {
                self.severity = value
            }
            if let value = dict["Threshold"] as? Int64 {
                self.threshold = value
            }
        }
    }
    public var DIAlarmRuleId: Int64?

    public var description_: String?

    public var enabled: Bool?

    public var metricType: String?

    public var notificationSettings: UpdateDIAlarmRuleRequest.NotificationSettings?

    public var triggerConditions: [UpdateDIAlarmRuleRequest.TriggerConditions]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notificationSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.notificationSettings != nil {
            map["NotificationSettings"] = self.notificationSettings?.toMap()
        }
        if self.triggerConditions != nil {
            var tmp : [Any] = []
            for k in self.triggerConditions! {
                tmp.append(k.toMap())
            }
            map["TriggerConditions"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIAlarmRuleId"] as? Int64 {
            self.DIAlarmRuleId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["MetricType"] as? String {
            self.metricType = value
        }
        if let value = dict["NotificationSettings"] as? [String: Any?] {
            var model = UpdateDIAlarmRuleRequest.NotificationSettings()
            model.fromMap(value)
            self.notificationSettings = model
        }
        if let value = dict["TriggerConditions"] as? [Any?] {
            var tmp : [UpdateDIAlarmRuleRequest.TriggerConditions] = []
            for v in value {
                if v != nil {
                    var model = UpdateDIAlarmRuleRequest.TriggerConditions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.triggerConditions = tmp
        }
    }
}

public class UpdateDIAlarmRuleShrinkRequest : Tea.TeaModel {
    public var DIAlarmRuleId: Int64?

    public var description_: String?

    public var enabled: Bool?

    public var metricType: String?

    public var notificationSettingsShrink: String?

    public var triggerConditionsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.notificationSettingsShrink != nil {
            map["NotificationSettings"] = self.notificationSettingsShrink!
        }
        if self.triggerConditionsShrink != nil {
            map["TriggerConditions"] = self.triggerConditionsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIAlarmRuleId"] as? Int64 {
            self.DIAlarmRuleId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["MetricType"] as? String {
            self.metricType = value
        }
        if let value = dict["NotificationSettings"] as? String {
            self.notificationSettingsShrink = value
        }
        if let value = dict["TriggerConditions"] as? String {
            self.triggerConditionsShrink = value
        }
    }
}

public class UpdateDIAlarmRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateDIAlarmRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDIAlarmRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDIAlarmRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDIJobRequest : Tea.TeaModel {
    public class JobSettings : Tea.TeaModel {
        public class ColumnDataTypeSettings : Tea.TeaModel {
            public var destinationDataType: String?

            public var sourceDataType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.destinationDataType != nil {
                    map["DestinationDataType"] = self.destinationDataType!
                }
                if self.sourceDataType != nil {
                    map["SourceDataType"] = self.sourceDataType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DestinationDataType"] as? String {
                    self.destinationDataType = value
                }
                if let value = dict["SourceDataType"] as? String {
                    self.sourceDataType = value
                }
            }
        }
        public class CycleScheduleSettings : Tea.TeaModel {
            public var scheduleParameters: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.scheduleParameters != nil {
                    map["ScheduleParameters"] = self.scheduleParameters!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ScheduleParameters"] as? String {
                    self.scheduleParameters = value
                }
            }
        }
        public class DdlHandlingSettings : Tea.TeaModel {
            public var action: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Action"] as? String {
                    self.action = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class RuntimeSettings : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var channelSettings: String?

        public var columnDataTypeSettings: [UpdateDIJobRequest.JobSettings.ColumnDataTypeSettings]?

        public var cycleScheduleSettings: UpdateDIJobRequest.JobSettings.CycleScheduleSettings?

        public var ddlHandlingSettings: [UpdateDIJobRequest.JobSettings.DdlHandlingSettings]?

        public var runtimeSettings: [UpdateDIJobRequest.JobSettings.RuntimeSettings]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cycleScheduleSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelSettings != nil {
                map["ChannelSettings"] = self.channelSettings!
            }
            if self.columnDataTypeSettings != nil {
                var tmp : [Any] = []
                for k in self.columnDataTypeSettings! {
                    tmp.append(k.toMap())
                }
                map["ColumnDataTypeSettings"] = tmp
            }
            if self.cycleScheduleSettings != nil {
                map["CycleScheduleSettings"] = self.cycleScheduleSettings?.toMap()
            }
            if self.ddlHandlingSettings != nil {
                var tmp : [Any] = []
                for k in self.ddlHandlingSettings! {
                    tmp.append(k.toMap())
                }
                map["DdlHandlingSettings"] = tmp
            }
            if self.runtimeSettings != nil {
                var tmp : [Any] = []
                for k in self.runtimeSettings! {
                    tmp.append(k.toMap())
                }
                map["RuntimeSettings"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChannelSettings"] as? String {
                self.channelSettings = value
            }
            if let value = dict["ColumnDataTypeSettings"] as? [Any?] {
                var tmp : [UpdateDIJobRequest.JobSettings.ColumnDataTypeSettings] = []
                for v in value {
                    if v != nil {
                        var model = UpdateDIJobRequest.JobSettings.ColumnDataTypeSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.columnDataTypeSettings = tmp
            }
            if let value = dict["CycleScheduleSettings"] as? [String: Any?] {
                var model = UpdateDIJobRequest.JobSettings.CycleScheduleSettings()
                model.fromMap(value)
                self.cycleScheduleSettings = model
            }
            if let value = dict["DdlHandlingSettings"] as? [Any?] {
                var tmp : [UpdateDIJobRequest.JobSettings.DdlHandlingSettings] = []
                for v in value {
                    if v != nil {
                        var model = UpdateDIJobRequest.JobSettings.DdlHandlingSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ddlHandlingSettings = tmp
            }
            if let value = dict["RuntimeSettings"] as? [Any?] {
                var tmp : [UpdateDIJobRequest.JobSettings.RuntimeSettings] = []
                for v in value {
                    if v != nil {
                        var model = UpdateDIJobRequest.JobSettings.RuntimeSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.runtimeSettings = tmp
            }
        }
    }
    public class ResourceSettings : Tea.TeaModel {
        public class OfflineResourceSettings : Tea.TeaModel {
            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceGroupIdentifier"] as? String {
                    self.resourceGroupIdentifier = value
                }
            }
        }
        public class RealtimeResourceSettings : Tea.TeaModel {
            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceGroupIdentifier"] as? String {
                    self.resourceGroupIdentifier = value
                }
            }
        }
        public var offlineResourceSettings: UpdateDIJobRequest.ResourceSettings.OfflineResourceSettings?

        public var realtimeResourceSettings: UpdateDIJobRequest.ResourceSettings.RealtimeResourceSettings?

        public var requestedCu: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.offlineResourceSettings?.validate()
            try self.realtimeResourceSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.offlineResourceSettings != nil {
                map["OfflineResourceSettings"] = self.offlineResourceSettings?.toMap()
            }
            if self.realtimeResourceSettings != nil {
                map["RealtimeResourceSettings"] = self.realtimeResourceSettings?.toMap()
            }
            if self.requestedCu != nil {
                map["RequestedCu"] = self.requestedCu!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OfflineResourceSettings"] as? [String: Any?] {
                var model = UpdateDIJobRequest.ResourceSettings.OfflineResourceSettings()
                model.fromMap(value)
                self.offlineResourceSettings = model
            }
            if let value = dict["RealtimeResourceSettings"] as? [String: Any?] {
                var model = UpdateDIJobRequest.ResourceSettings.RealtimeResourceSettings()
                model.fromMap(value)
                self.realtimeResourceSettings = model
            }
            if let value = dict["RequestedCu"] as? Double {
                self.requestedCu = value
            }
        }
    }
    public class TableMappings : Tea.TeaModel {
        public class SourceObjectSelectionRules : Tea.TeaModel {
            public var expression: String?

            public var objectType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.objectType != nil {
                    map["ObjectType"] = self.objectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Expression"] as? String {
                    self.expression = value
                }
                if let value = dict["ObjectType"] as? String {
                    self.objectType = value
                }
            }
        }
        public class TransformationRules : Tea.TeaModel {
            public var ruleActionType: String?

            public var ruleName: String?

            public var ruleTargetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ruleActionType != nil {
                    map["RuleActionType"] = self.ruleActionType!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.ruleTargetType != nil {
                    map["RuleTargetType"] = self.ruleTargetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RuleActionType"] as? String {
                    self.ruleActionType = value
                }
                if let value = dict["RuleName"] as? String {
                    self.ruleName = value
                }
                if let value = dict["RuleTargetType"] as? String {
                    self.ruleTargetType = value
                }
            }
        }
        public var sourceObjectSelectionRules: [UpdateDIJobRequest.TableMappings.SourceObjectSelectionRules]?

        public var transformationRules: [UpdateDIJobRequest.TableMappings.TransformationRules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sourceObjectSelectionRules != nil {
                var tmp : [Any] = []
                for k in self.sourceObjectSelectionRules! {
                    tmp.append(k.toMap())
                }
                map["SourceObjectSelectionRules"] = tmp
            }
            if self.transformationRules != nil {
                var tmp : [Any] = []
                for k in self.transformationRules! {
                    tmp.append(k.toMap())
                }
                map["TransformationRules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SourceObjectSelectionRules"] as? [Any?] {
                var tmp : [UpdateDIJobRequest.TableMappings.SourceObjectSelectionRules] = []
                for v in value {
                    if v != nil {
                        var model = UpdateDIJobRequest.TableMappings.SourceObjectSelectionRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sourceObjectSelectionRules = tmp
            }
            if let value = dict["TransformationRules"] as? [Any?] {
                var tmp : [UpdateDIJobRequest.TableMappings.TransformationRules] = []
                for v in value {
                    if v != nil {
                        var model = UpdateDIJobRequest.TableMappings.TransformationRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.transformationRules = tmp
            }
        }
    }
    public class TransformationRules : Tea.TeaModel {
        public var ruleActionType: String?

        public var ruleExpression: String?

        public var ruleName: String?

        public var ruleTargetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleActionType != nil {
                map["RuleActionType"] = self.ruleActionType!
            }
            if self.ruleExpression != nil {
                map["RuleExpression"] = self.ruleExpression!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.ruleTargetType != nil {
                map["RuleTargetType"] = self.ruleTargetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RuleActionType"] as? String {
                self.ruleActionType = value
            }
            if let value = dict["RuleExpression"] as? String {
                self.ruleExpression = value
            }
            if let value = dict["RuleName"] as? String {
                self.ruleName = value
            }
            if let value = dict["RuleTargetType"] as? String {
                self.ruleTargetType = value
            }
        }
    }
    public var DIJobId: Int64?

    public var description_: String?

    public var jobSettings: UpdateDIJobRequest.JobSettings?

    public var resourceSettings: UpdateDIJobRequest.ResourceSettings?

    public var tableMappings: [UpdateDIJobRequest.TableMappings]?

    public var transformationRules: [UpdateDIJobRequest.TransformationRules]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobSettings?.validate()
        try self.resourceSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.jobSettings != nil {
            map["JobSettings"] = self.jobSettings?.toMap()
        }
        if self.resourceSettings != nil {
            map["ResourceSettings"] = self.resourceSettings?.toMap()
        }
        if self.tableMappings != nil {
            var tmp : [Any] = []
            for k in self.tableMappings! {
                tmp.append(k.toMap())
            }
            map["TableMappings"] = tmp
        }
        if self.transformationRules != nil {
            var tmp : [Any] = []
            for k in self.transformationRules! {
                tmp.append(k.toMap())
            }
            map["TransformationRules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["JobSettings"] as? [String: Any?] {
            var model = UpdateDIJobRequest.JobSettings()
            model.fromMap(value)
            self.jobSettings = model
        }
        if let value = dict["ResourceSettings"] as? [String: Any?] {
            var model = UpdateDIJobRequest.ResourceSettings()
            model.fromMap(value)
            self.resourceSettings = model
        }
        if let value = dict["TableMappings"] as? [Any?] {
            var tmp : [UpdateDIJobRequest.TableMappings] = []
            for v in value {
                if v != nil {
                    var model = UpdateDIJobRequest.TableMappings()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tableMappings = tmp
        }
        if let value = dict["TransformationRules"] as? [Any?] {
            var tmp : [UpdateDIJobRequest.TransformationRules] = []
            for v in value {
                if v != nil {
                    var model = UpdateDIJobRequest.TransformationRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.transformationRules = tmp
        }
    }
}

public class UpdateDIJobShrinkRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var description_: String?

    public var jobSettingsShrink: String?

    public var resourceSettingsShrink: String?

    public var tableMappingsShrink: String?

    public var transformationRulesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.jobSettingsShrink != nil {
            map["JobSettings"] = self.jobSettingsShrink!
        }
        if self.resourceSettingsShrink != nil {
            map["ResourceSettings"] = self.resourceSettingsShrink!
        }
        if self.tableMappingsShrink != nil {
            map["TableMappings"] = self.tableMappingsShrink!
        }
        if self.transformationRulesShrink != nil {
            map["TransformationRules"] = self.transformationRulesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["JobSettings"] as? String {
            self.jobSettingsShrink = value
        }
        if let value = dict["ResourceSettings"] as? String {
            self.resourceSettingsShrink = value
        }
        if let value = dict["TableMappings"] as? String {
            self.tableMappingsShrink = value
        }
        if let value = dict["TransformationRules"] as? String {
            self.transformationRulesShrink = value
        }
    }
}

public class UpdateDIJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDIJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDIProjectConfigRequest : Tea.TeaModel {
    public var destinationType: String?

    public var projectConfig: String?

    public var projectId: Int64?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.projectConfig != nil {
            map["ProjectConfig"] = self.projectConfig!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DestinationType"] as? String {
            self.destinationType = value
        }
        if let value = dict["ProjectConfig"] as? String {
            self.projectConfig = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SourceType"] as? String {
            self.sourceType = value
        }
    }
}

public class UpdateDIProjectConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: UpdateDIProjectConfigResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateDIProjectConfigResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateDIProjectConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDIProjectConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDIProjectConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDISyncTaskRequest : Tea.TeaModel {
    public var fileId: Int64?

    public var projectId: Int64?

    public var taskContent: String?

    public var taskParam: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskContent != nil {
            map["TaskContent"] = self.taskContent!
        }
        if self.taskParam != nil {
            map["TaskParam"] = self.taskParam!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FileId"] as? Int64 {
            self.fileId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TaskContent"] as? String {
            self.taskContent = value
        }
        if let value = dict["TaskParam"] as? String {
            self.taskParam = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
    }
}

public class UpdateDISyncTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var data: UpdateDISyncTaskResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateDISyncTaskResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateDISyncTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDISyncTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDISyncTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDataServiceApiRequest : Tea.TeaModel {
    public var apiDescription: String?

    public var apiId: Int64?

    public var apiPath: String?

    public var projectId: Int64?

    public var protocols: String?

    public var registrationDetails: String?

    public var requestMethod: Int32?

    public var resourceGroupId: Int64?

    public var responseContentType: Int32?

    public var scriptDetails: String?

    public var tenantId: Int64?

    public var timeout: Int32?

    public var visibleRange: Int32?

    public var wizardDetails: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiDescription != nil {
            map["ApiDescription"] = self.apiDescription!
        }
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiPath != nil {
            map["ApiPath"] = self.apiPath!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.protocols != nil {
            map["Protocols"] = self.protocols!
        }
        if self.registrationDetails != nil {
            map["RegistrationDetails"] = self.registrationDetails!
        }
        if self.requestMethod != nil {
            map["RequestMethod"] = self.requestMethod!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.responseContentType != nil {
            map["ResponseContentType"] = self.responseContentType!
        }
        if self.scriptDetails != nil {
            map["ScriptDetails"] = self.scriptDetails!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.visibleRange != nil {
            map["VisibleRange"] = self.visibleRange!
        }
        if self.wizardDetails != nil {
            map["WizardDetails"] = self.wizardDetails!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApiDescription"] as? String {
            self.apiDescription = value
        }
        if let value = dict["ApiId"] as? Int64 {
            self.apiId = value
        }
        if let value = dict["ApiPath"] as? String {
            self.apiPath = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Protocols"] as? String {
            self.protocols = value
        }
        if let value = dict["RegistrationDetails"] as? String {
            self.registrationDetails = value
        }
        if let value = dict["RequestMethod"] as? Int32 {
            self.requestMethod = value
        }
        if let value = dict["ResourceGroupId"] as? Int64 {
            self.resourceGroupId = value
        }
        if let value = dict["ResponseContentType"] as? Int32 {
            self.responseContentType = value
        }
        if let value = dict["ScriptDetails"] as? String {
            self.scriptDetails = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
        if let value = dict["VisibleRange"] as? Int32 {
            self.visibleRange = value
        }
        if let value = dict["WizardDetails"] as? String {
            self.wizardDetails = value
        }
    }
}

public class UpdateDataServiceApiResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateDataServiceApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataServiceApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDataServiceApiResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDataSourceRequest : Tea.TeaModel {
    public var content: String?

    public var dataSourceId: Int64?

    public var description_: String?

    public var envType: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["DataSourceId"] as? Int64 {
            self.dataSourceId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnvType"] as? Int32 {
            self.envType = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class UpdateDataSourceResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? String {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDataSourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateFileRequest : Tea.TeaModel {
    public var advancedSettings: String?

    public var applyScheduleImmediately: Bool?

    public var autoParsing: Bool?

    public var autoRerunIntervalMillis: Int32?

    public var autoRerunTimes: Int32?

    public var connectionName: String?

    public var content: String?

    public var cronExpress: String?

    public var cycleType: String?

    public var dependentNodeIdList: String?

    public var dependentType: String?

    public var endEffectDate: Int64?

    public var fileDescription: String?

    public var fileFolderPath: String?

    public var fileId: Int64?

    public var fileName: String?

    public var ignoreParentSkipRunningProperty: Bool?

    public var imageId: String?

    public var inputList: String?

    public var inputParameters: String?

    public var outputList: String?

    public var outputParameters: String?

    public var owner: String?

    public var paraValue: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var rerunMode: String?

    public var resourceGroupIdentifier: String?

    public var schedulerType: String?

    public var startEffectDate: Int64?

    public var startImmediately: Bool?

    public var stop: Bool?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advancedSettings != nil {
            map["AdvancedSettings"] = self.advancedSettings!
        }
        if self.applyScheduleImmediately != nil {
            map["ApplyScheduleImmediately"] = self.applyScheduleImmediately!
        }
        if self.autoParsing != nil {
            map["AutoParsing"] = self.autoParsing!
        }
        if self.autoRerunIntervalMillis != nil {
            map["AutoRerunIntervalMillis"] = self.autoRerunIntervalMillis!
        }
        if self.autoRerunTimes != nil {
            map["AutoRerunTimes"] = self.autoRerunTimes!
        }
        if self.connectionName != nil {
            map["ConnectionName"] = self.connectionName!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.cronExpress != nil {
            map["CronExpress"] = self.cronExpress!
        }
        if self.cycleType != nil {
            map["CycleType"] = self.cycleType!
        }
        if self.dependentNodeIdList != nil {
            map["DependentNodeIdList"] = self.dependentNodeIdList!
        }
        if self.dependentType != nil {
            map["DependentType"] = self.dependentType!
        }
        if self.endEffectDate != nil {
            map["EndEffectDate"] = self.endEffectDate!
        }
        if self.fileDescription != nil {
            map["FileDescription"] = self.fileDescription!
        }
        if self.fileFolderPath != nil {
            map["FileFolderPath"] = self.fileFolderPath!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.ignoreParentSkipRunningProperty != nil {
            map["IgnoreParentSkipRunningProperty"] = self.ignoreParentSkipRunningProperty!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.inputList != nil {
            map["InputList"] = self.inputList!
        }
        if self.inputParameters != nil {
            map["InputParameters"] = self.inputParameters!
        }
        if self.outputList != nil {
            map["OutputList"] = self.outputList!
        }
        if self.outputParameters != nil {
            map["OutputParameters"] = self.outputParameters!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.paraValue != nil {
            map["ParaValue"] = self.paraValue!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.rerunMode != nil {
            map["RerunMode"] = self.rerunMode!
        }
        if self.resourceGroupIdentifier != nil {
            map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
        }
        if self.schedulerType != nil {
            map["SchedulerType"] = self.schedulerType!
        }
        if self.startEffectDate != nil {
            map["StartEffectDate"] = self.startEffectDate!
        }
        if self.startImmediately != nil {
            map["StartImmediately"] = self.startImmediately!
        }
        if self.stop != nil {
            map["Stop"] = self.stop!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AdvancedSettings"] as? String {
            self.advancedSettings = value
        }
        if let value = dict["ApplyScheduleImmediately"] as? Bool {
            self.applyScheduleImmediately = value
        }
        if let value = dict["AutoParsing"] as? Bool {
            self.autoParsing = value
        }
        if let value = dict["AutoRerunIntervalMillis"] as? Int32 {
            self.autoRerunIntervalMillis = value
        }
        if let value = dict["AutoRerunTimes"] as? Int32 {
            self.autoRerunTimes = value
        }
        if let value = dict["ConnectionName"] as? String {
            self.connectionName = value
        }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["CronExpress"] as? String {
            self.cronExpress = value
        }
        if let value = dict["CycleType"] as? String {
            self.cycleType = value
        }
        if let value = dict["DependentNodeIdList"] as? String {
            self.dependentNodeIdList = value
        }
        if let value = dict["DependentType"] as? String {
            self.dependentType = value
        }
        if let value = dict["EndEffectDate"] as? Int64 {
            self.endEffectDate = value
        }
        if let value = dict["FileDescription"] as? String {
            self.fileDescription = value
        }
        if let value = dict["FileFolderPath"] as? String {
            self.fileFolderPath = value
        }
        if let value = dict["FileId"] as? Int64 {
            self.fileId = value
        }
        if let value = dict["FileName"] as? String {
            self.fileName = value
        }
        if let value = dict["IgnoreParentSkipRunningProperty"] as? Bool {
            self.ignoreParentSkipRunningProperty = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["InputList"] as? String {
            self.inputList = value
        }
        if let value = dict["InputParameters"] as? String {
            self.inputParameters = value
        }
        if let value = dict["OutputList"] as? String {
            self.outputList = value
        }
        if let value = dict["OutputParameters"] as? String {
            self.outputParameters = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["ParaValue"] as? String {
            self.paraValue = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
        if let value = dict["RerunMode"] as? String {
            self.rerunMode = value
        }
        if let value = dict["ResourceGroupIdentifier"] as? String {
            self.resourceGroupIdentifier = value
        }
        if let value = dict["SchedulerType"] as? String {
            self.schedulerType = value
        }
        if let value = dict["StartEffectDate"] as? Int64 {
            self.startEffectDate = value
        }
        if let value = dict["StartImmediately"] as? Bool {
            self.startImmediately = value
        }
        if let value = dict["Stop"] as? Bool {
            self.stop = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
    }
}

public class UpdateFileResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateFolderRequest : Tea.TeaModel {
    public var folderId: String?

    public var folderName: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.folderId != nil {
            map["FolderId"] = self.folderId!
        }
        if self.folderName != nil {
            map["FolderName"] = self.folderName!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FolderId"] as? String {
            self.folderId = value
        }
        if let value = dict["FolderName"] as? String {
            self.folderName = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
    }
}

public class UpdateFolderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateFolderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFolderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateFolderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateIDEEventResultRequest : Tea.TeaModel {
    public var checkResult: String?

    public var checkResultTip: String?

    public var extensionCode: String?

    public var messageId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkResult != nil {
            map["CheckResult"] = self.checkResult!
        }
        if self.checkResultTip != nil {
            map["CheckResultTip"] = self.checkResultTip!
        }
        if self.extensionCode != nil {
            map["ExtensionCode"] = self.extensionCode!
        }
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CheckResult"] as? String {
            self.checkResult = value
        }
        if let value = dict["CheckResultTip"] as? String {
            self.checkResultTip = value
        }
        if let value = dict["ExtensionCode"] as? String {
            self.extensionCode = value
        }
        if let value = dict["MessageId"] as? String {
            self.messageId = value
        }
    }
}

public class UpdateIDEEventResultResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateIDEEventResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIDEEventResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateIDEEventResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateMetaCategoryRequest : Tea.TeaModel {
    public var categoryId: Int64?

    public var comment: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CategoryId"] as? Int64 {
            self.categoryId = value
        }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class UpdateMetaCategoryResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateMetaCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMetaCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateMetaCategoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateMetaCollectionRequest : Tea.TeaModel {
    public var comment: String?

    public var name: String?

    public var qualifiedName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["QualifiedName"] as? String {
            self.qualifiedName = value
        }
    }
}

public class UpdateMetaCollectionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var status: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? Bool {
            self.status = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateMetaCollectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMetaCollectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateMetaCollectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateMetaTableRequest : Tea.TeaModel {
    public var addedLabels: String?

    public var caption: String?

    public var categoryId: Int64?

    public var envType: Int32?

    public var newOwnerId: String?

    public var projectId: Int64?

    public var removedLabels: String?

    public var schema: String?

    public var tableGuid: String?

    public var tableName: String?

    public var visibility: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addedLabels != nil {
            map["AddedLabels"] = self.addedLabels!
        }
        if self.caption != nil {
            map["Caption"] = self.caption!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.newOwnerId != nil {
            map["NewOwnerId"] = self.newOwnerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.removedLabels != nil {
            map["RemovedLabels"] = self.removedLabels!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddedLabels"] as? String {
            self.addedLabels = value
        }
        if let value = dict["Caption"] as? String {
            self.caption = value
        }
        if let value = dict["CategoryId"] as? Int64 {
            self.categoryId = value
        }
        if let value = dict["EnvType"] as? Int32 {
            self.envType = value
        }
        if let value = dict["NewOwnerId"] as? String {
            self.newOwnerId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RemovedLabels"] as? String {
            self.removedLabels = value
        }
        if let value = dict["Schema"] as? String {
            self.schema = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["Visibility"] as? Int32 {
            self.visibility = value
        }
    }
}

public class UpdateMetaTableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var updateResult: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.updateResult != nil {
            map["UpdateResult"] = self.updateResult!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UpdateResult"] as? Bool {
            self.updateResult = value
        }
    }
}

public class UpdateMetaTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMetaTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateMetaTableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateMetaTableIntroWikiRequest : Tea.TeaModel {
    public var content: String?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
    }
}

public class UpdateMetaTableIntroWikiResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var updateResult: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.updateResult != nil {
            map["UpdateResult"] = self.updateResult!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UpdateResult"] as? Bool {
            self.updateResult = value
        }
    }
}

public class UpdateMetaTableIntroWikiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMetaTableIntroWikiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateMetaTableIntroWikiResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateNodeOwnerRequest : Tea.TeaModel {
    public var nodeId: Int64?

    public var projectEnv: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class UpdateNodeOwnerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateNodeOwnerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNodeOwnerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateNodeOwnerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateNodeRunModeRequest : Tea.TeaModel {
    public var nodeId: Int64?

    public var projectEnv: String?

    public var schedulerType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.schedulerType != nil {
            map["SchedulerType"] = self.schedulerType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NodeId"] as? Int64 {
            self.nodeId = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["SchedulerType"] as? Int32 {
            self.schedulerType = value
        }
    }
}

public class UpdateNodeRunModeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateNodeRunModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNodeRunModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateNodeRunModeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateQualityFollowerRequest : Tea.TeaModel {
    public var alarmMode: Int32?

    public var follower: String?

    public var followerId: Int64?

    public var projectId: Int64?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmMode != nil {
            map["AlarmMode"] = self.alarmMode!
        }
        if self.follower != nil {
            map["Follower"] = self.follower!
        }
        if self.followerId != nil {
            map["FollowerId"] = self.followerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlarmMode"] as? Int32 {
            self.alarmMode = value
        }
        if let value = dict["Follower"] as? String {
            self.follower = value
        }
        if let value = dict["FollowerId"] as? Int64 {
            self.followerId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
    }
}

public class UpdateQualityFollowerResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateQualityFollowerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateQualityFollowerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateQualityFollowerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateQualityRuleRequest : Tea.TeaModel {
    public var blockType: Int32?

    public var checker: Int32?

    public var comment: String?

    public var criticalThreshold: String?

    public var entityId: Int64?

    public var expectValue: String?

    public var id: Int64?

    public var methodName: String?

    public var openSwitch: Bool?

    public var operator_: String?

    public var predictType: Int32?

    public var projectId: Int64?

    public var projectName: String?

    public var property: String?

    public var propertyType: String?

    public var ruleName: String?

    public var ruleType: Int32?

    public var taskSetting: String?

    public var templateId: Int32?

    public var trend: String?

    public var warningThreshold: String?

    public var whereCondition: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.blockType != nil {
            map["BlockType"] = self.blockType!
        }
        if self.checker != nil {
            map["Checker"] = self.checker!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.criticalThreshold != nil {
            map["CriticalThreshold"] = self.criticalThreshold!
        }
        if self.entityId != nil {
            map["EntityId"] = self.entityId!
        }
        if self.expectValue != nil {
            map["ExpectValue"] = self.expectValue!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.methodName != nil {
            map["MethodName"] = self.methodName!
        }
        if self.openSwitch != nil {
            map["OpenSwitch"] = self.openSwitch!
        }
        if self.operator_ != nil {
            map["Operator"] = self.operator_!
        }
        if self.predictType != nil {
            map["PredictType"] = self.predictType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.property != nil {
            map["Property"] = self.property!
        }
        if self.propertyType != nil {
            map["PropertyType"] = self.propertyType!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        if self.taskSetting != nil {
            map["TaskSetting"] = self.taskSetting!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.trend != nil {
            map["Trend"] = self.trend!
        }
        if self.warningThreshold != nil {
            map["WarningThreshold"] = self.warningThreshold!
        }
        if self.whereCondition != nil {
            map["WhereCondition"] = self.whereCondition!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BlockType"] as? Int32 {
            self.blockType = value
        }
        if let value = dict["Checker"] as? Int32 {
            self.checker = value
        }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["CriticalThreshold"] as? String {
            self.criticalThreshold = value
        }
        if let value = dict["EntityId"] as? Int64 {
            self.entityId = value
        }
        if let value = dict["ExpectValue"] as? String {
            self.expectValue = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["MethodName"] as? String {
            self.methodName = value
        }
        if let value = dict["OpenSwitch"] as? Bool {
            self.openSwitch = value
        }
        if let value = dict["Operator"] as? String {
            self.operator_ = value
        }
        if let value = dict["PredictType"] as? Int32 {
            self.predictType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
        if let value = dict["Property"] as? String {
            self.property = value
        }
        if let value = dict["PropertyType"] as? String {
            self.propertyType = value
        }
        if let value = dict["RuleName"] as? String {
            self.ruleName = value
        }
        if let value = dict["RuleType"] as? Int32 {
            self.ruleType = value
        }
        if let value = dict["TaskSetting"] as? String {
            self.taskSetting = value
        }
        if let value = dict["TemplateId"] as? Int32 {
            self.templateId = value
        }
        if let value = dict["Trend"] as? String {
            self.trend = value
        }
        if let value = dict["WarningThreshold"] as? String {
            self.warningThreshold = value
        }
        if let value = dict["WhereCondition"] as? String {
            self.whereCondition = value
        }
    }
}

public class UpdateQualityRuleResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateQualityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateQualityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateQualityRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRemindRequest : Tea.TeaModel {
    public var alertInterval: Int32?

    public var alertMethods: String?

    public var alertTargets: String?

    public var alertUnit: String?

    public var baselineIds: String?

    public var bizProcessIds: String?

    public var detail: String?

    public var dndEnd: String?

    public var maxAlertTimes: Int32?

    public var nodeIds: String?

    public var projectId: Int64?

    public var remindId: Int64?

    public var remindName: String?

    public var remindType: String?

    public var remindUnit: String?

    public var robotUrls: String?

    public var useFlag: Bool?

    public var webhooks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertInterval != nil {
            map["AlertInterval"] = self.alertInterval!
        }
        if self.alertMethods != nil {
            map["AlertMethods"] = self.alertMethods!
        }
        if self.alertTargets != nil {
            map["AlertTargets"] = self.alertTargets!
        }
        if self.alertUnit != nil {
            map["AlertUnit"] = self.alertUnit!
        }
        if self.baselineIds != nil {
            map["BaselineIds"] = self.baselineIds!
        }
        if self.bizProcessIds != nil {
            map["BizProcessIds"] = self.bizProcessIds!
        }
        if self.detail != nil {
            map["Detail"] = self.detail!
        }
        if self.dndEnd != nil {
            map["DndEnd"] = self.dndEnd!
        }
        if self.maxAlertTimes != nil {
            map["MaxAlertTimes"] = self.maxAlertTimes!
        }
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.remindId != nil {
            map["RemindId"] = self.remindId!
        }
        if self.remindName != nil {
            map["RemindName"] = self.remindName!
        }
        if self.remindType != nil {
            map["RemindType"] = self.remindType!
        }
        if self.remindUnit != nil {
            map["RemindUnit"] = self.remindUnit!
        }
        if self.robotUrls != nil {
            map["RobotUrls"] = self.robotUrls!
        }
        if self.useFlag != nil {
            map["UseFlag"] = self.useFlag!
        }
        if self.webhooks != nil {
            map["Webhooks"] = self.webhooks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlertInterval"] as? Int32 {
            self.alertInterval = value
        }
        if let value = dict["AlertMethods"] as? String {
            self.alertMethods = value
        }
        if let value = dict["AlertTargets"] as? String {
            self.alertTargets = value
        }
        if let value = dict["AlertUnit"] as? String {
            self.alertUnit = value
        }
        if let value = dict["BaselineIds"] as? String {
            self.baselineIds = value
        }
        if let value = dict["BizProcessIds"] as? String {
            self.bizProcessIds = value
        }
        if let value = dict["Detail"] as? String {
            self.detail = value
        }
        if let value = dict["DndEnd"] as? String {
            self.dndEnd = value
        }
        if let value = dict["MaxAlertTimes"] as? Int32 {
            self.maxAlertTimes = value
        }
        if let value = dict["NodeIds"] as? String {
            self.nodeIds = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RemindId"] as? Int64 {
            self.remindId = value
        }
        if let value = dict["RemindName"] as? String {
            self.remindName = value
        }
        if let value = dict["RemindType"] as? String {
            self.remindType = value
        }
        if let value = dict["RemindUnit"] as? String {
            self.remindUnit = value
        }
        if let value = dict["RobotUrls"] as? String {
            self.robotUrls = value
        }
        if let value = dict["UseFlag"] as? Bool {
            self.useFlag = value
        }
        if let value = dict["Webhooks"] as? String {
            self.webhooks = value
        }
    }
}

public class UpdateRemindResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateRemindResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRemindResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRemindResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateTableRequest : Tea.TeaModel {
    public class Columns : Tea.TeaModel {
        public var columnName: String?

        public var columnNameCn: String?

        public var columnType: String?

        public var comment: String?

        public var isPartitionCol: Bool?

        public var length: Int32?

        public var seqNumber: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columnName != nil {
                map["ColumnName"] = self.columnName!
            }
            if self.columnNameCn != nil {
                map["ColumnNameCn"] = self.columnNameCn!
            }
            if self.columnType != nil {
                map["ColumnType"] = self.columnType!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.isPartitionCol != nil {
                map["IsPartitionCol"] = self.isPartitionCol!
            }
            if self.length != nil {
                map["Length"] = self.length!
            }
            if self.seqNumber != nil {
                map["SeqNumber"] = self.seqNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ColumnName"] as? String {
                self.columnName = value
            }
            if let value = dict["ColumnNameCn"] as? String {
                self.columnNameCn = value
            }
            if let value = dict["ColumnType"] as? String {
                self.columnType = value
            }
            if let value = dict["Comment"] as? String {
                self.comment = value
            }
            if let value = dict["IsPartitionCol"] as? Bool {
                self.isPartitionCol = value
            }
            if let value = dict["Length"] as? Int32 {
                self.length = value
            }
            if let value = dict["SeqNumber"] as? Int32 {
                self.seqNumber = value
            }
        }
    }
    public class Themes : Tea.TeaModel {
        public var themeId: Int64?

        public var themeLevel: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.themeId != nil {
                map["ThemeId"] = self.themeId!
            }
            if self.themeLevel != nil {
                map["ThemeLevel"] = self.themeLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ThemeId"] as? Int64 {
                self.themeId = value
            }
            if let value = dict["ThemeLevel"] as? Int32 {
                self.themeLevel = value
            }
        }
    }
    public var appGuid: String?

    public var categoryId: Int64?

    public var columns: [UpdateTableRequest.Columns]?

    public var comment: String?

    public var createIfNotExists: Bool?

    public var endpoint: String?

    public var envType: Int32?

    public var externalTableType: String?

    public var hasPart: Int32?

    public var isView: Int32?

    public var lifeCycle: Int32?

    public var location: String?

    public var logicalLevelId: Int64?

    public var ownerId: String?

    public var physicsLevelId: Int64?

    public var projectId: Int64?

    public var schema: String?

    public var tableName: String?

    public var themes: [UpdateTableRequest.Themes]?

    public var visibility: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGuid != nil {
            map["AppGuid"] = self.appGuid!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.columns != nil {
            var tmp : [Any] = []
            for k in self.columns! {
                tmp.append(k.toMap())
            }
            map["Columns"] = tmp
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.createIfNotExists != nil {
            map["CreateIfNotExists"] = self.createIfNotExists!
        }
        if self.endpoint != nil {
            map["Endpoint"] = self.endpoint!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.externalTableType != nil {
            map["ExternalTableType"] = self.externalTableType!
        }
        if self.hasPart != nil {
            map["HasPart"] = self.hasPart!
        }
        if self.isView != nil {
            map["IsView"] = self.isView!
        }
        if self.lifeCycle != nil {
            map["LifeCycle"] = self.lifeCycle!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.logicalLevelId != nil {
            map["LogicalLevelId"] = self.logicalLevelId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicsLevelId != nil {
            map["PhysicsLevelId"] = self.physicsLevelId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.themes != nil {
            var tmp : [Any] = []
            for k in self.themes! {
                tmp.append(k.toMap())
            }
            map["Themes"] = tmp
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppGuid"] as? String {
            self.appGuid = value
        }
        if let value = dict["CategoryId"] as? Int64 {
            self.categoryId = value
        }
        if let value = dict["Columns"] as? [Any?] {
            var tmp : [UpdateTableRequest.Columns] = []
            for v in value {
                if v != nil {
                    var model = UpdateTableRequest.Columns()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.columns = tmp
        }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["CreateIfNotExists"] as? Bool {
            self.createIfNotExists = value
        }
        if let value = dict["Endpoint"] as? String {
            self.endpoint = value
        }
        if let value = dict["EnvType"] as? Int32 {
            self.envType = value
        }
        if let value = dict["ExternalTableType"] as? String {
            self.externalTableType = value
        }
        if let value = dict["HasPart"] as? Int32 {
            self.hasPart = value
        }
        if let value = dict["IsView"] as? Int32 {
            self.isView = value
        }
        if let value = dict["LifeCycle"] as? Int32 {
            self.lifeCycle = value
        }
        if let value = dict["Location"] as? String {
            self.location = value
        }
        if let value = dict["LogicalLevelId"] as? Int64 {
            self.logicalLevelId = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["PhysicsLevelId"] as? Int64 {
            self.physicsLevelId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Schema"] as? String {
            self.schema = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["Themes"] as? [Any?] {
            var tmp : [UpdateTableRequest.Themes] = []
            for v in value {
                if v != nil {
                    var model = UpdateTableRequest.Themes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.themes = tmp
        }
        if let value = dict["Visibility"] as? Int32 {
            self.visibility = value
        }
    }
}

public class UpdateTableResponseBody : Tea.TeaModel {
    public class TaskInfo : Tea.TeaModel {
        public var content: String?

        public var nextTaskId: String?

        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.nextTaskId != nil {
                map["NextTaskId"] = self.nextTaskId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Content"] as? String {
                self.content = value
            }
            if let value = dict["NextTaskId"] as? String {
                self.nextTaskId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
        }
    }
    public var requestId: String?

    public var taskInfo: UpdateTableResponseBody.TaskInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskInfo != nil {
            map["TaskInfo"] = self.taskInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskInfo"] as? [String: Any?] {
            var model = UpdateTableResponseBody.TaskInfo()
            model.fromMap(value)
            self.taskInfo = model
        }
    }
}

public class UpdateTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateTableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateTableAddColumnRequest : Tea.TeaModel {
    public class Column : Tea.TeaModel {
        public var columnName: String?

        public var columnNameCn: String?

        public var columnType: String?

        public var comment: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columnName != nil {
                map["ColumnName"] = self.columnName!
            }
            if self.columnNameCn != nil {
                map["ColumnNameCn"] = self.columnNameCn!
            }
            if self.columnType != nil {
                map["ColumnType"] = self.columnType!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ColumnName"] as? String {
                self.columnName = value
            }
            if let value = dict["ColumnNameCn"] as? String {
                self.columnNameCn = value
            }
            if let value = dict["ColumnType"] as? String {
                self.columnType = value
            }
            if let value = dict["Comment"] as? String {
                self.comment = value
            }
        }
    }
    public var column: [UpdateTableAddColumnRequest.Column]?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            var tmp : [Any] = []
            for k in self.column! {
                tmp.append(k.toMap())
            }
            map["Column"] = tmp
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Column"] as? [Any?] {
            var tmp : [UpdateTableAddColumnRequest.Column] = []
            for v in value {
                if v != nil {
                    var model = UpdateTableAddColumnRequest.Column()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.column = tmp
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
    }
}

public class UpdateTableAddColumnResponseBody : Tea.TeaModel {
    public class TaskInfo : Tea.TeaModel {
        public var content: String?

        public var nextTaskId: String?

        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.nextTaskId != nil {
                map["NextTaskId"] = self.nextTaskId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Content"] as? String {
                self.content = value
            }
            if let value = dict["NextTaskId"] as? String {
                self.nextTaskId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
        }
    }
    public var requestId: String?

    public var taskInfo: UpdateTableAddColumnResponseBody.TaskInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskInfo != nil {
            map["TaskInfo"] = self.taskInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskInfo"] as? [String: Any?] {
            var model = UpdateTableAddColumnResponseBody.TaskInfo()
            model.fromMap(value)
            self.taskInfo = model
        }
    }
}

public class UpdateTableAddColumnResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTableAddColumnResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateTableAddColumnResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateTableLevelRequest : Tea.TeaModel {
    public var description_: String?

    public var levelId: Int64?

    public var levelType: Int32?

    public var name: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.levelId != nil {
            map["LevelId"] = self.levelId!
        }
        if self.levelType != nil {
            map["LevelType"] = self.levelType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["LevelId"] as? Int64 {
            self.levelId = value
        }
        if let value = dict["LevelType"] as? Int32 {
            self.levelType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class UpdateTableLevelResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public var updateResult: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.updateResult != nil {
            map["UpdateResult"] = self.updateResult!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["UpdateResult"] as? Bool {
            self.updateResult = value
        }
    }
}

public class UpdateTableLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTableLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateTableLevelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateTableModelInfoRequest : Tea.TeaModel {
    public var firstLevelThemeId: Int64?

    public var levelId: Int64?

    public var levelType: Int32?

    public var secondLevelThemeId: Int64?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.firstLevelThemeId != nil {
            map["FirstLevelThemeId"] = self.firstLevelThemeId!
        }
        if self.levelId != nil {
            map["LevelId"] = self.levelId!
        }
        if self.levelType != nil {
            map["LevelType"] = self.levelType!
        }
        if self.secondLevelThemeId != nil {
            map["SecondLevelThemeId"] = self.secondLevelThemeId!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FirstLevelThemeId"] as? Int64 {
            self.firstLevelThemeId = value
        }
        if let value = dict["LevelId"] as? Int64 {
            self.levelId = value
        }
        if let value = dict["LevelType"] as? Int32 {
            self.levelType = value
        }
        if let value = dict["SecondLevelThemeId"] as? Int64 {
            self.secondLevelThemeId = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
    }
}

public class UpdateTableModelInfoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var updateResult: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.updateResult != nil {
            map["UpdateResult"] = self.updateResult!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UpdateResult"] as? Bool {
            self.updateResult = value
        }
    }
}

public class UpdateTableModelInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTableModelInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateTableModelInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateTableThemeRequest : Tea.TeaModel {
    public var name: String?

    public var projectId: Int64?

    public var themeId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.themeId != nil {
            map["ThemeId"] = self.themeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ThemeId"] as? Int64 {
            self.themeId = value
        }
    }
}

public class UpdateTableThemeResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public var updateResult: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.updateResult != nil {
            map["UpdateResult"] = self.updateResult!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["UpdateResult"] as? Bool {
            self.updateResult = value
        }
    }
}

public class UpdateTableThemeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTableThemeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateTableThemeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateUdfFileRequest : Tea.TeaModel {
    public var className: String?

    public var cmdDescription: String?

    public var example: String?

    public var fileFolderPath: String?

    public var fileId: String?

    public var functionType: String?

    public var parameterDescription: String?

    public var projectId: Int64?

    public var projectIdentifier: String?

    public var resources: String?

    public var returnValue: String?

    public var udfDescription: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.className != nil {
            map["ClassName"] = self.className!
        }
        if self.cmdDescription != nil {
            map["CmdDescription"] = self.cmdDescription!
        }
        if self.example != nil {
            map["Example"] = self.example!
        }
        if self.fileFolderPath != nil {
            map["FileFolderPath"] = self.fileFolderPath!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.functionType != nil {
            map["FunctionType"] = self.functionType!
        }
        if self.parameterDescription != nil {
            map["ParameterDescription"] = self.parameterDescription!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectIdentifier != nil {
            map["ProjectIdentifier"] = self.projectIdentifier!
        }
        if self.resources != nil {
            map["Resources"] = self.resources!
        }
        if self.returnValue != nil {
            map["ReturnValue"] = self.returnValue!
        }
        if self.udfDescription != nil {
            map["UdfDescription"] = self.udfDescription!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClassName"] as? String {
            self.className = value
        }
        if let value = dict["CmdDescription"] as? String {
            self.cmdDescription = value
        }
        if let value = dict["Example"] as? String {
            self.example = value
        }
        if let value = dict["FileFolderPath"] as? String {
            self.fileFolderPath = value
        }
        if let value = dict["FileId"] as? String {
            self.fileId = value
        }
        if let value = dict["FunctionType"] as? String {
            self.functionType = value
        }
        if let value = dict["ParameterDescription"] as? String {
            self.parameterDescription = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ProjectIdentifier"] as? String {
            self.projectIdentifier = value
        }
        if let value = dict["Resources"] as? String {
            self.resources = value
        }
        if let value = dict["ReturnValue"] as? String {
            self.returnValue = value
        }
        if let value = dict["UdfDescription"] as? String {
            self.udfDescription = value
        }
    }
}

public class UpdateUdfFileResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateUdfFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateUdfFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateUdfFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateWorkbenchEventResultRequest : Tea.TeaModel {
    public var checkResult: String?

    public var checkResultTip: String?

    public var extensionCode: String?

    public var messageId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkResult != nil {
            map["CheckResult"] = self.checkResult!
        }
        if self.checkResultTip != nil {
            map["CheckResultTip"] = self.checkResultTip!
        }
        if self.extensionCode != nil {
            map["ExtensionCode"] = self.extensionCode!
        }
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CheckResult"] as? String {
            self.checkResult = value
        }
        if let value = dict["CheckResultTip"] as? String {
            self.checkResultTip = value
        }
        if let value = dict["ExtensionCode"] as? String {
            self.extensionCode = value
        }
        if let value = dict["MessageId"] as? String {
            self.messageId = value
        }
    }
}

public class UpdateWorkbenchEventResultResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateWorkbenchEventResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkbenchEventResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateWorkbenchEventResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}
