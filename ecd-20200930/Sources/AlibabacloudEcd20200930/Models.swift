import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class CdsFileShareLinkModel : Tea.TeaModel {
    public var accessCount: Int64?

    public var createTime: String?

    public var creator: String?

    public var description_: String?

    public var disableDownload: Bool?

    public var disablePreview: Bool?

    public var disableSave: Bool?

    public var downloadCount: Int64?

    public var downloadLimit: Int64?

    public var driveId: String?

    public var expiration: String?

    public var expired: Bool?

    public var fileIds: String?

    public var modifiyTime: String?

    public var previewCount: Int64?

    public var previewLimit: Int64?

    public var reportCount: Int64?

    public var saveCount: Int64?

    public var saveLimit: Int64?

    public var shareId: String?

    public var shareLink: String?

    public var shareName: String?

    public var sharePwd: String?

    public var status: String?

    public var videoPreviewCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessCount != nil {
            map["AccessCount"] = self.accessCount!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableDownload != nil {
            map["DisableDownload"] = self.disableDownload!
        }
        if self.disablePreview != nil {
            map["DisablePreview"] = self.disablePreview!
        }
        if self.disableSave != nil {
            map["DisableSave"] = self.disableSave!
        }
        if self.downloadCount != nil {
            map["DownloadCount"] = self.downloadCount!
        }
        if self.downloadLimit != nil {
            map["DownloadLimit"] = self.downloadLimit!
        }
        if self.driveId != nil {
            map["DriveId"] = self.driveId!
        }
        if self.expiration != nil {
            map["Expiration"] = self.expiration!
        }
        if self.expired != nil {
            map["Expired"] = self.expired!
        }
        if self.fileIds != nil {
            map["FileIds"] = self.fileIds!
        }
        if self.modifiyTime != nil {
            map["ModifiyTime"] = self.modifiyTime!
        }
        if self.previewCount != nil {
            map["PreviewCount"] = self.previewCount!
        }
        if self.previewLimit != nil {
            map["PreviewLimit"] = self.previewLimit!
        }
        if self.reportCount != nil {
            map["ReportCount"] = self.reportCount!
        }
        if self.saveCount != nil {
            map["SaveCount"] = self.saveCount!
        }
        if self.saveLimit != nil {
            map["SaveLimit"] = self.saveLimit!
        }
        if self.shareId != nil {
            map["ShareId"] = self.shareId!
        }
        if self.shareLink != nil {
            map["ShareLink"] = self.shareLink!
        }
        if self.shareName != nil {
            map["ShareName"] = self.shareName!
        }
        if self.sharePwd != nil {
            map["SharePwd"] = self.sharePwd!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.videoPreviewCount != nil {
            map["VideoPreviewCount"] = self.videoPreviewCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessCount") {
            self.accessCount = dict["AccessCount"] as! Int64
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("Creator") {
            self.creator = dict["Creator"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableDownload") {
            self.disableDownload = dict["DisableDownload"] as! Bool
        }
        if dict.keys.contains("DisablePreview") {
            self.disablePreview = dict["DisablePreview"] as! Bool
        }
        if dict.keys.contains("DisableSave") {
            self.disableSave = dict["DisableSave"] as! Bool
        }
        if dict.keys.contains("DownloadCount") {
            self.downloadCount = dict["DownloadCount"] as! Int64
        }
        if dict.keys.contains("DownloadLimit") {
            self.downloadLimit = dict["DownloadLimit"] as! Int64
        }
        if dict.keys.contains("DriveId") {
            self.driveId = dict["DriveId"] as! String
        }
        if dict.keys.contains("Expiration") {
            self.expiration = dict["Expiration"] as! String
        }
        if dict.keys.contains("Expired") {
            self.expired = dict["Expired"] as! Bool
        }
        if dict.keys.contains("FileIds") {
            self.fileIds = dict["FileIds"] as! String
        }
        if dict.keys.contains("ModifiyTime") {
            self.modifiyTime = dict["ModifiyTime"] as! String
        }
        if dict.keys.contains("PreviewCount") {
            self.previewCount = dict["PreviewCount"] as! Int64
        }
        if dict.keys.contains("PreviewLimit") {
            self.previewLimit = dict["PreviewLimit"] as! Int64
        }
        if dict.keys.contains("ReportCount") {
            self.reportCount = dict["ReportCount"] as! Int64
        }
        if dict.keys.contains("SaveCount") {
            self.saveCount = dict["SaveCount"] as! Int64
        }
        if dict.keys.contains("SaveLimit") {
            self.saveLimit = dict["SaveLimit"] as! Int64
        }
        if dict.keys.contains("ShareId") {
            self.shareId = dict["ShareId"] as! String
        }
        if dict.keys.contains("ShareLink") {
            self.shareLink = dict["ShareLink"] as! String
        }
        if dict.keys.contains("ShareName") {
            self.shareName = dict["ShareName"] as! String
        }
        if dict.keys.contains("SharePwd") {
            self.sharePwd = dict["SharePwd"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("VideoPreviewCount") {
            self.videoPreviewCount = dict["VideoPreviewCount"] as! Int64
        }
    }
}

public class FilePermissionMember : Tea.TeaModel {
    public class CdsIdentity : Tea.TeaModel {
        public var id: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var cdsIdentity: FilePermissionMember.CdsIdentity?

    public var disinheritSubGroup: Bool?

    public var expireTime: Int64?

    public var roleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cdsIdentity?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsIdentity != nil {
            map["CdsIdentity"] = self.cdsIdentity?.toMap()
        }
        if self.disinheritSubGroup != nil {
            map["DisinheritSubGroup"] = self.disinheritSubGroup!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.roleId != nil {
            map["RoleId"] = self.roleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsIdentity") {
            var model = FilePermissionMember.CdsIdentity()
            model.fromMap(dict["CdsIdentity"] as! [String: Any])
            self.cdsIdentity = model
        }
        if dict.keys.contains("DisinheritSubGroup") {
            self.disinheritSubGroup = dict["DisinheritSubGroup"] as! Bool
        }
        if dict.keys.contains("ExpireTime") {
            self.expireTime = dict["ExpireTime"] as! Int64
        }
        if dict.keys.contains("RoleId") {
            self.roleId = dict["RoleId"] as! String
        }
    }
}

public class Permission : Tea.TeaModel {
    public var createTime: String?

    public var description_: String?

    public var destCidrIp: String?

    public var ipProtocol: String?

    public var nicType: String?

    public var policy: String?

    public var portRange: String?

    public var priority: String?

    public var sourceCidrIp: String?

    public var sourcePortRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.nicType != nil {
            map["NicType"] = self.nicType!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestCidrIp") {
            self.destCidrIp = dict["DestCidrIp"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("NicType") {
            self.nicType = dict["NicType"] as! String
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("SourceCidrIp") {
            self.sourceCidrIp = dict["SourceCidrIp"] as! String
        }
        if dict.keys.contains("SourcePortRange") {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
    }
}

public class ActivateOfficeSiteRequest : Tea.TeaModel {
    public var officeSiteId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ActivateOfficeSiteResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ActivateOfficeSiteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ActivateOfficeSiteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ActivateOfficeSiteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDesktopOversoldUserGroupRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var imageId: String?

    public var name: String?

    public var oversoldGroupId: String?

    public var policyGroupId: String?

    public var tag: [AddDesktopOversoldUserGroupRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.oversoldGroupId != nil {
            map["OversoldGroupId"] = self.oversoldGroupId!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OversoldGroupId") {
            self.oversoldGroupId = dict["OversoldGroupId"] as! String
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [AddDesktopOversoldUserGroupRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = AddDesktopOversoldUserGroupRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class AddDesktopOversoldUserGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var userGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userGroupId != nil {
                map["UserGroupId"] = self.userGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserGroupId") {
                self.userGroupId = dict["UserGroupId"] as! String
            }
        }
    }
    public var data: AddDesktopOversoldUserGroupResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = AddDesktopOversoldUserGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDesktopOversoldUserGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDesktopOversoldUserGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDesktopOversoldUserGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDevicesRequest : Tea.TeaModel {
    public var clientType: Int32?

    public var deviceIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientType != nil {
            map["ClientType"] = self.clientType!
        }
        if self.deviceIds != nil {
            map["DeviceIds"] = self.deviceIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientType") {
            self.clientType = dict["ClientType"] as! Int32
        }
        if dict.keys.contains("DeviceIds") {
            self.deviceIds = dict["DeviceIds"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AddDevicesResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddFilePermissionRequest : Tea.TeaModel {
    public class MemberList : Tea.TeaModel {
        public class CdsIdentity : Tea.TeaModel {
            public var id: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var cdsIdentity: AddFilePermissionRequest.MemberList.CdsIdentity?

        public var disinheritSubGroup: Bool?

        public var expireTime: Int64?

        public var roleId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cdsIdentity?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cdsIdentity != nil {
                map["CdsIdentity"] = self.cdsIdentity?.toMap()
            }
            if self.disinheritSubGroup != nil {
                map["DisinheritSubGroup"] = self.disinheritSubGroup!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.roleId != nil {
                map["RoleId"] = self.roleId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CdsIdentity") {
                var model = AddFilePermissionRequest.MemberList.CdsIdentity()
                model.fromMap(dict["CdsIdentity"] as! [String: Any])
                self.cdsIdentity = model
            }
            if dict.keys.contains("DisinheritSubGroup") {
                self.disinheritSubGroup = dict["DisinheritSubGroup"] as! Bool
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! Int64
            }
            if dict.keys.contains("RoleId") {
                self.roleId = dict["RoleId"] as! String
            }
        }
    }
    public var cdsId: String?

    public var endUserId: String?

    public var fileId: String?

    public var groupId: String?

    public var memberList: [AddFilePermissionRequest.MemberList]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.memberList != nil {
            var tmp : [Any] = []
            for k in self.memberList! {
                tmp.append(k.toMap())
            }
            map["MemberList"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("MemberList") {
            var tmp : [AddFilePermissionRequest.MemberList] = []
            for v in dict["MemberList"] as! [Any] {
                var model = AddFilePermissionRequest.MemberList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.memberList = tmp
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AddFilePermissionShrinkRequest : Tea.TeaModel {
    public var cdsId: String?

    public var endUserId: String?

    public var fileId: String?

    public var groupId: String?

    public var memberListShrink: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.memberListShrink != nil {
            map["MemberList"] = self.memberListShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("MemberList") {
            self.memberListShrink = dict["MemberList"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AddFilePermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddFilePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddFilePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddFilePermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddUserToDesktopGroupRequest : Tea.TeaModel {
    public var clientToken: String?

    public var desktopGroupId: String?

    public var desktopGroupIds: [String]?

    public var endUserIds: [String]?

    public var regionId: String?

    public var userOuPath: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.desktopGroupIds != nil {
            map["DesktopGroupIds"] = self.desktopGroupIds!
        }
        if self.endUserIds != nil {
            map["EndUserIds"] = self.endUserIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.userOuPath != nil {
            map["UserOuPath"] = self.userOuPath!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("DesktopGroupIds") {
            self.desktopGroupIds = dict["DesktopGroupIds"] as! [String]
        }
        if dict.keys.contains("EndUserIds") {
            self.endUserIds = dict["EndUserIds"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("UserOuPath") {
            self.userOuPath = dict["UserOuPath"] as! String
        }
    }
}

public class AddUserToDesktopGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddUserToDesktopGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddUserToDesktopGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddUserToDesktopGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddUserToDesktopOversoldUserGroupRequest : Tea.TeaModel {
    public var addUserAmount: Int32?

    public var endUserId: String?

    public var oversoldGroupId: String?

    public var userGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addUserAmount != nil {
            map["AddUserAmount"] = self.addUserAmount!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.oversoldGroupId != nil {
            map["OversoldGroupId"] = self.oversoldGroupId!
        }
        if self.userGroupId != nil {
            map["UserGroupId"] = self.userGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddUserAmount") {
            self.addUserAmount = dict["AddUserAmount"] as! Int32
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("OversoldGroupId") {
            self.oversoldGroupId = dict["OversoldGroupId"] as! String
        }
        if dict.keys.contains("UserGroupId") {
            self.userGroupId = dict["UserGroupId"] as! String
        }
    }
}

public class AddUserToDesktopOversoldUserGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddUserToDesktopOversoldUserGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddUserToDesktopOversoldUserGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddUserToDesktopOversoldUserGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyAutoSnapshotPolicyRequest : Tea.TeaModel {
    public var desktopId: [String]?

    public var policyId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("PolicyId") {
            self.policyId = dict["PolicyId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ApplyAutoSnapshotPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ApplyAutoSnapshotPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyAutoSnapshotPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyAutoSnapshotPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyCoordinatePrivilegeRequest : Tea.TeaModel {
    public var coId: String?

    public var endUserId: String?

    public var regionId: String?

    public var userType: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coId != nil {
            map["CoId"] = self.coId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.userType != nil {
            map["UserType"] = self.userType!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoId") {
            self.coId = dict["CoId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("UserType") {
            self.userType = dict["UserType"] as! String
        }
        if dict.keys.contains("Uuid") {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class ApplyCoordinatePrivilegeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ApplyCoordinatePrivilegeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyCoordinatePrivilegeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyCoordinatePrivilegeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyCoordinationForMonitoringRequest : Tea.TeaModel {
    public class ResourceCandidates : Tea.TeaModel {
        public var ownerAliUid: Int64?

        public var ownerEndUserId: String?

        public var resourceId: String?

        public var resourceName: String?

        public var resourceProperties: String?

        public var resourceRegionId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ownerAliUid != nil {
                map["OwnerAliUid"] = self.ownerAliUid!
            }
            if self.ownerEndUserId != nil {
                map["OwnerEndUserId"] = self.ownerEndUserId!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceName != nil {
                map["ResourceName"] = self.resourceName!
            }
            if self.resourceProperties != nil {
                map["ResourceProperties"] = self.resourceProperties!
            }
            if self.resourceRegionId != nil {
                map["ResourceRegionId"] = self.resourceRegionId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OwnerAliUid") {
                self.ownerAliUid = dict["OwnerAliUid"] as! Int64
            }
            if dict.keys.contains("OwnerEndUserId") {
                self.ownerEndUserId = dict["OwnerEndUserId"] as! String
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceName") {
                self.resourceName = dict["ResourceName"] as! String
            }
            if dict.keys.contains("ResourceProperties") {
                self.resourceProperties = dict["ResourceProperties"] as! String
            }
            if dict.keys.contains("ResourceRegionId") {
                self.resourceRegionId = dict["ResourceRegionId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
        }
    }
    public var coordinatePolicyType: String?

    public var endUserId: String?

    public var initiatorType: String?

    public var regionId: String?

    public var resourceCandidates: [ApplyCoordinationForMonitoringRequest.ResourceCandidates]?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coordinatePolicyType != nil {
            map["CoordinatePolicyType"] = self.coordinatePolicyType!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.initiatorType != nil {
            map["InitiatorType"] = self.initiatorType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceCandidates != nil {
            var tmp : [Any] = []
            for k in self.resourceCandidates! {
                tmp.append(k.toMap())
            }
            map["ResourceCandidates"] = tmp
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoordinatePolicyType") {
            self.coordinatePolicyType = dict["CoordinatePolicyType"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("InitiatorType") {
            self.initiatorType = dict["InitiatorType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceCandidates") {
            var tmp : [ApplyCoordinationForMonitoringRequest.ResourceCandidates] = []
            for v in dict["ResourceCandidates"] as! [Any] {
                var model = ApplyCoordinationForMonitoringRequest.ResourceCandidates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceCandidates = tmp
        }
        if dict.keys.contains("Uuid") {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class ApplyCoordinationForMonitoringResponseBody : Tea.TeaModel {
    public class CoordinateFlowModels : Tea.TeaModel {
        public var coId: String?

        public var coordinateStatus: String?

        public var coordinateTicket: String?

        public var initiatorType: String?

        public var ownerUserId: String?

        public var resourceId: String?

        public var resourceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coId != nil {
                map["CoId"] = self.coId!
            }
            if self.coordinateStatus != nil {
                map["CoordinateStatus"] = self.coordinateStatus!
            }
            if self.coordinateTicket != nil {
                map["CoordinateTicket"] = self.coordinateTicket!
            }
            if self.initiatorType != nil {
                map["InitiatorType"] = self.initiatorType!
            }
            if self.ownerUserId != nil {
                map["OwnerUserId"] = self.ownerUserId!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceName != nil {
                map["ResourceName"] = self.resourceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CoId") {
                self.coId = dict["CoId"] as! String
            }
            if dict.keys.contains("CoordinateStatus") {
                self.coordinateStatus = dict["CoordinateStatus"] as! String
            }
            if dict.keys.contains("CoordinateTicket") {
                self.coordinateTicket = dict["CoordinateTicket"] as! String
            }
            if dict.keys.contains("InitiatorType") {
                self.initiatorType = dict["InitiatorType"] as! String
            }
            if dict.keys.contains("OwnerUserId") {
                self.ownerUserId = dict["OwnerUserId"] as! String
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceName") {
                self.resourceName = dict["ResourceName"] as! String
            }
        }
    }
    public var coordinateFlowModels: [ApplyCoordinationForMonitoringResponseBody.CoordinateFlowModels]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coordinateFlowModels != nil {
            var tmp : [Any] = []
            for k in self.coordinateFlowModels! {
                tmp.append(k.toMap())
            }
            map["CoordinateFlowModels"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoordinateFlowModels") {
            var tmp : [ApplyCoordinationForMonitoringResponseBody.CoordinateFlowModels] = []
            for v in dict["CoordinateFlowModels"] as! [Any] {
                var model = ApplyCoordinationForMonitoringResponseBody.CoordinateFlowModels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.coordinateFlowModels = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ApplyCoordinationForMonitoringResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyCoordinationForMonitoringResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyCoordinationForMonitoringResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApproveFotaUpdateRequest : Tea.TeaModel {
    public var appVersion: String?

    public var desktopId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appVersion != nil {
            map["AppVersion"] = self.appVersion!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppVersion") {
            self.appVersion = dict["AppVersion"] as! String
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ApproveFotaUpdateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ApproveFotaUpdateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApproveFotaUpdateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApproveFotaUpdateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateNetworkPackageRequest : Tea.TeaModel {
    public var networkPackageId: String?

    public var officeSiteId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkPackageId != nil {
            map["NetworkPackageId"] = self.networkPackageId!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkPackageId") {
            self.networkPackageId = dict["NetworkPackageId"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AssociateNetworkPackageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateNetworkPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateNetworkPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssociateNetworkPackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachCenRequest : Tea.TeaModel {
    public var cenId: String?

    public var cenOwnerId: Int64?

    public var officeSiteId: String?

    public var regionId: String?

    public var verifyCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cenId != nil {
            map["CenId"] = self.cenId!
        }
        if self.cenOwnerId != nil {
            map["CenOwnerId"] = self.cenOwnerId!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.verifyCode != nil {
            map["VerifyCode"] = self.verifyCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CenId") {
            self.cenId = dict["CenId"] as! String
        }
        if dict.keys.contains("CenOwnerId") {
            self.cenOwnerId = dict["CenOwnerId"] as! Int64
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("VerifyCode") {
            self.verifyCode = dict["VerifyCode"] as! String
        }
    }
}

public class AttachCenResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachCenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachCenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachCenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachEndUserRequest : Tea.TeaModel {
    public var adDomain: String?

    public var clientType: Int32?

    public var deviceId: String?

    public var directoryId: String?

    public var endUserId: String?

    public var regionId: String?

    public var userType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adDomain != nil {
            map["AdDomain"] = self.adDomain!
        }
        if self.clientType != nil {
            map["ClientType"] = self.clientType!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.userType != nil {
            map["UserType"] = self.userType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdDomain") {
            self.adDomain = dict["AdDomain"] as! String
        }
        if dict.keys.contains("ClientType") {
            self.clientType = dict["ClientType"] as! Int32
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("UserType") {
            self.userType = dict["UserType"] as! String
        }
    }
}

public class AttachEndUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachEndUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachEndUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachEndUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindConfigGroupRequest : Tea.TeaModel {
    public class ResourceInfos : Tea.TeaModel {
        public var productType: String?

        public var resourceId: String?

        public var resourceRegionId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.productType != nil {
                map["ProductType"] = self.productType!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceRegionId != nil {
                map["ResourceRegionId"] = self.resourceRegionId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ProductType") {
                self.productType = dict["ProductType"] as! String
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceRegionId") {
                self.resourceRegionId = dict["ResourceRegionId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
        }
    }
    public var groupId: String?

    public var regionId: String?

    public var resourceInfos: [BindConfigGroupRequest.ResourceInfos]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceInfos != nil {
            var tmp : [Any] = []
            for k in self.resourceInfos! {
                tmp.append(k.toMap())
            }
            map["ResourceInfos"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceInfos") {
            var tmp : [BindConfigGroupRequest.ResourceInfos] = []
            for v in dict["ResourceInfos"] as! [Any] {
                var model = BindConfigGroupRequest.ResourceInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceInfos = tmp
        }
    }
}

public class BindConfigGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BindConfigGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindConfigGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BindConfigGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelAutoSnapshotPolicyRequest : Tea.TeaModel {
    public var desktopId: [String]?

    public var policyId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("PolicyId") {
            self.policyId = dict["PolicyId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CancelAutoSnapshotPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelAutoSnapshotPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelAutoSnapshotPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelAutoSnapshotPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelCdsFileShareLinkRequest : Tea.TeaModel {
    public var cdsId: String?

    public var shareId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.shareId != nil {
            map["ShareId"] = self.shareId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("ShareId") {
            self.shareId = dict["ShareId"] as! String
        }
    }
}

public class CancelCdsFileShareLinkResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CancelCdsFileShareLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelCdsFileShareLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelCdsFileShareLinkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelCoordinationForMonitoringRequest : Tea.TeaModel {
    public var coIds: [String]?

    public var endUserId: String?

    public var regionId: String?

    public var userType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coIds != nil {
            map["CoIds"] = self.coIds!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.userType != nil {
            map["UserType"] = self.userType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoIds") {
            self.coIds = dict["CoIds"] as! [String]
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("UserType") {
            self.userType = dict["UserType"] as! String
        }
    }
}

public class CancelCoordinationForMonitoringResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelCoordinationForMonitoringResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelCoordinationForMonitoringResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelCoordinationForMonitoringResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelCopyImageRequest : Tea.TeaModel {
    public var imageId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CancelCopyImageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelCopyImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelCopyImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelCopyImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloneCenterPolicyRequest : Tea.TeaModel {
    public var businessType: Int32?

    public var name: String?

    public var policyGroupId: String?

    public var regionId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class CloneCenterPolicyResponseBody : Tea.TeaModel {
    public var policyGroupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CloneCenterPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloneCenterPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CloneCenterPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ClonePolicyGroupRequest : Tea.TeaModel {
    public var name: String?

    public var policyGroupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ClonePolicyGroupResponseBody : Tea.TeaModel {
    public var policyGroupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ClonePolicyGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ClonePolicyGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ClonePolicyGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CompleteCdsFileRequest : Tea.TeaModel {
    public var cdsId: String?

    public var endUserId: String?

    public var fileId: String?

    public var groupId: String?

    public var regionId: String?

    public var uploadId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.uploadId != nil {
            map["UploadId"] = self.uploadId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("UploadId") {
            self.uploadId = dict["UploadId"] as! String
        }
    }
}

public class CompleteCdsFileResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CompleteCdsFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CompleteCdsFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CompleteCdsFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfigADConnectorTrustRequest : Tea.TeaModel {
    public var officeSiteId: String?

    public var rdsLicenseDomain: Bool?

    public var regionId: String?

    public var trustKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.rdsLicenseDomain != nil {
            map["RdsLicenseDomain"] = self.rdsLicenseDomain!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.trustKey != nil {
            map["TrustKey"] = self.trustKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RdsLicenseDomain") {
            self.rdsLicenseDomain = dict["RdsLicenseDomain"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TrustKey") {
            self.trustKey = dict["TrustKey"] as! String
        }
    }
}

public class ConfigADConnectorTrustResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ConfigADConnectorTrustResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfigADConnectorTrustResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfigADConnectorTrustResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfigADConnectorUserRequest : Tea.TeaModel {
    public var domainPassword: String?

    public var domainUserName: String?

    public var OUName: String?

    public var officeSiteId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainPassword != nil {
            map["DomainPassword"] = self.domainPassword!
        }
        if self.domainUserName != nil {
            map["DomainUserName"] = self.domainUserName!
        }
        if self.OUName != nil {
            map["OUName"] = self.OUName!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainPassword") {
            self.domainPassword = dict["DomainPassword"] as! String
        }
        if dict.keys.contains("DomainUserName") {
            self.domainUserName = dict["DomainUserName"] as! String
        }
        if dict.keys.contains("OUName") {
            self.OUName = dict["OUName"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ConfigADConnectorUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ConfigADConnectorUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfigADConnectorUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfigADConnectorUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CopyCdsFileRequest : Tea.TeaModel {
    public var autoRename: Bool?

    public var cdsId: String?

    public var endUserId: String?

    public var fileId: String?

    public var fileReceiverId: String?

    public var fileReceiverType: String?

    public var groupId: String?

    public var parentFolderId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRename != nil {
            map["AutoRename"] = self.autoRename!
        }
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.fileReceiverId != nil {
            map["FileReceiverId"] = self.fileReceiverId!
        }
        if self.fileReceiverType != nil {
            map["FileReceiverType"] = self.fileReceiverType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.parentFolderId != nil {
            map["ParentFolderId"] = self.parentFolderId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRename") {
            self.autoRename = dict["AutoRename"] as! Bool
        }
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! String
        }
        if dict.keys.contains("FileReceiverId") {
            self.fileReceiverId = dict["FileReceiverId"] as! String
        }
        if dict.keys.contains("FileReceiverType") {
            self.fileReceiverType = dict["FileReceiverType"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ParentFolderId") {
            self.parentFolderId = dict["ParentFolderId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CopyCdsFileResponseBody : Tea.TeaModel {
    public class CopyCdsFileModel : Tea.TeaModel {
        public var asyncTaskId: String?

        public var fileId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.asyncTaskId != nil {
                map["AsyncTaskId"] = self.asyncTaskId!
            }
            if self.fileId != nil {
                map["FileId"] = self.fileId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AsyncTaskId") {
                self.asyncTaskId = dict["AsyncTaskId"] as! String
            }
            if dict.keys.contains("FileId") {
                self.fileId = dict["FileId"] as! String
            }
        }
    }
    public var code: String?

    public var copyCdsFileModel: CopyCdsFileResponseBody.CopyCdsFileModel?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.copyCdsFileModel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.copyCdsFileModel != nil {
            map["CopyCdsFileModel"] = self.copyCdsFileModel?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("CopyCdsFileModel") {
            var model = CopyCdsFileResponseBody.CopyCdsFileModel()
            model.fromMap(dict["CopyCdsFileModel"] as! [String: Any])
            self.copyCdsFileModel = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CopyCdsFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyCdsFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CopyCdsFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CopyImageRequest : Tea.TeaModel {
    public var destinationDescription: String?

    public var destinationImageName: String?

    public var destinationRegionId: String?

    public var imageId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationDescription != nil {
            map["DestinationDescription"] = self.destinationDescription!
        }
        if self.destinationImageName != nil {
            map["DestinationImageName"] = self.destinationImageName!
        }
        if self.destinationRegionId != nil {
            map["DestinationRegionId"] = self.destinationRegionId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationDescription") {
            self.destinationDescription = dict["DestinationDescription"] as! String
        }
        if dict.keys.contains("DestinationImageName") {
            self.destinationImageName = dict["DestinationImageName"] as! String
        }
        if dict.keys.contains("DestinationRegionId") {
            self.destinationRegionId = dict["DestinationRegionId"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CopyImageResponseBody : Tea.TeaModel {
    public var imageId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CopyImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CopyImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateADConnectorDirectoryRequest : Tea.TeaModel {
    public var desktopAccessType: String?

    public var directoryName: String?

    public var dnsAddress: [String]?

    public var domainName: String?

    public var domainPassword: String?

    public var domainUserName: String?

    public var enableAdminAccess: Bool?

    public var mfaEnabled: Bool?

    public var regionId: String?

    public var specification: Int64?

    public var subDomainDnsAddress: [String]?

    public var subDomainName: String?

    public var vSwitchId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopAccessType != nil {
            map["DesktopAccessType"] = self.desktopAccessType!
        }
        if self.directoryName != nil {
            map["DirectoryName"] = self.directoryName!
        }
        if self.dnsAddress != nil {
            map["DnsAddress"] = self.dnsAddress!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainPassword != nil {
            map["DomainPassword"] = self.domainPassword!
        }
        if self.domainUserName != nil {
            map["DomainUserName"] = self.domainUserName!
        }
        if self.enableAdminAccess != nil {
            map["EnableAdminAccess"] = self.enableAdminAccess!
        }
        if self.mfaEnabled != nil {
            map["MfaEnabled"] = self.mfaEnabled!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.specification != nil {
            map["Specification"] = self.specification!
        }
        if self.subDomainDnsAddress != nil {
            map["SubDomainDnsAddress"] = self.subDomainDnsAddress!
        }
        if self.subDomainName != nil {
            map["SubDomainName"] = self.subDomainName!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopAccessType") {
            self.desktopAccessType = dict["DesktopAccessType"] as! String
        }
        if dict.keys.contains("DirectoryName") {
            self.directoryName = dict["DirectoryName"] as! String
        }
        if dict.keys.contains("DnsAddress") {
            self.dnsAddress = dict["DnsAddress"] as! [String]
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainPassword") {
            self.domainPassword = dict["DomainPassword"] as! String
        }
        if dict.keys.contains("DomainUserName") {
            self.domainUserName = dict["DomainUserName"] as! String
        }
        if dict.keys.contains("EnableAdminAccess") {
            self.enableAdminAccess = dict["EnableAdminAccess"] as! Bool
        }
        if dict.keys.contains("MfaEnabled") {
            self.mfaEnabled = dict["MfaEnabled"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Specification") {
            self.specification = dict["Specification"] as! Int64
        }
        if dict.keys.contains("SubDomainDnsAddress") {
            self.subDomainDnsAddress = dict["SubDomainDnsAddress"] as! [String]
        }
        if dict.keys.contains("SubDomainName") {
            self.subDomainName = dict["SubDomainName"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! [String]
        }
    }
}

public class CreateADConnectorDirectoryResponseBody : Tea.TeaModel {
    public class AdConnectors : Tea.TeaModel {
        public var address: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") {
                self.address = dict["Address"] as! String
            }
        }
    }
    public var adConnectors: [CreateADConnectorDirectoryResponseBody.AdConnectors]?

    public var directoryId: String?

    public var requestId: String?

    public var trustPassword: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adConnectors != nil {
            var tmp : [Any] = []
            for k in self.adConnectors! {
                tmp.append(k.toMap())
            }
            map["AdConnectors"] = tmp
        }
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.trustPassword != nil {
            map["TrustPassword"] = self.trustPassword!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdConnectors") {
            var tmp : [CreateADConnectorDirectoryResponseBody.AdConnectors] = []
            for v in dict["AdConnectors"] as! [Any] {
                var model = CreateADConnectorDirectoryResponseBody.AdConnectors()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.adConnectors = tmp
        }
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TrustPassword") {
            self.trustPassword = dict["TrustPassword"] as! String
        }
    }
}

public class CreateADConnectorDirectoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateADConnectorDirectoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateADConnectorDirectoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateADConnectorOfficeSiteRequest : Tea.TeaModel {
    public var adHostname: String?

    public var backupDCHostname: String?

    public var backupDns: String?

    public var bandwidth: Int32?

    public var cenId: String?

    public var cenOwnerId: Int64?

    public var cidrBlock: String?

    public var desktopAccessType: String?

    public var dnsAddress: [String]?

    public var domainName: String?

    public var domainPassword: String?

    public var domainUserName: String?

    public var enableAdminAccess: Bool?

    public var enableInternetAccess: Bool?

    public var mfaEnabled: Bool?

    public var officeSiteName: String?

    public var protocolType: String?

    public var regionId: String?

    public var specification: Int64?

    public var subDomainDnsAddress: [String]?

    public var subDomainName: String?

    public var vSwitchId: [String]?

    public var verifyCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adHostname != nil {
            map["AdHostname"] = self.adHostname!
        }
        if self.backupDCHostname != nil {
            map["BackupDCHostname"] = self.backupDCHostname!
        }
        if self.backupDns != nil {
            map["BackupDns"] = self.backupDns!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.cenId != nil {
            map["CenId"] = self.cenId!
        }
        if self.cenOwnerId != nil {
            map["CenOwnerId"] = self.cenOwnerId!
        }
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.desktopAccessType != nil {
            map["DesktopAccessType"] = self.desktopAccessType!
        }
        if self.dnsAddress != nil {
            map["DnsAddress"] = self.dnsAddress!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainPassword != nil {
            map["DomainPassword"] = self.domainPassword!
        }
        if self.domainUserName != nil {
            map["DomainUserName"] = self.domainUserName!
        }
        if self.enableAdminAccess != nil {
            map["EnableAdminAccess"] = self.enableAdminAccess!
        }
        if self.enableInternetAccess != nil {
            map["EnableInternetAccess"] = self.enableInternetAccess!
        }
        if self.mfaEnabled != nil {
            map["MfaEnabled"] = self.mfaEnabled!
        }
        if self.officeSiteName != nil {
            map["OfficeSiteName"] = self.officeSiteName!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.specification != nil {
            map["Specification"] = self.specification!
        }
        if self.subDomainDnsAddress != nil {
            map["SubDomainDnsAddress"] = self.subDomainDnsAddress!
        }
        if self.subDomainName != nil {
            map["SubDomainName"] = self.subDomainName!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.verifyCode != nil {
            map["VerifyCode"] = self.verifyCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdHostname") {
            self.adHostname = dict["AdHostname"] as! String
        }
        if dict.keys.contains("BackupDCHostname") {
            self.backupDCHostname = dict["BackupDCHostname"] as! String
        }
        if dict.keys.contains("BackupDns") {
            self.backupDns = dict["BackupDns"] as! String
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("CenId") {
            self.cenId = dict["CenId"] as! String
        }
        if dict.keys.contains("CenOwnerId") {
            self.cenOwnerId = dict["CenOwnerId"] as! Int64
        }
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("DesktopAccessType") {
            self.desktopAccessType = dict["DesktopAccessType"] as! String
        }
        if dict.keys.contains("DnsAddress") {
            self.dnsAddress = dict["DnsAddress"] as! [String]
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainPassword") {
            self.domainPassword = dict["DomainPassword"] as! String
        }
        if dict.keys.contains("DomainUserName") {
            self.domainUserName = dict["DomainUserName"] as! String
        }
        if dict.keys.contains("EnableAdminAccess") {
            self.enableAdminAccess = dict["EnableAdminAccess"] as! Bool
        }
        if dict.keys.contains("EnableInternetAccess") {
            self.enableInternetAccess = dict["EnableInternetAccess"] as! Bool
        }
        if dict.keys.contains("MfaEnabled") {
            self.mfaEnabled = dict["MfaEnabled"] as! Bool
        }
        if dict.keys.contains("OfficeSiteName") {
            self.officeSiteName = dict["OfficeSiteName"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Specification") {
            self.specification = dict["Specification"] as! Int64
        }
        if dict.keys.contains("SubDomainDnsAddress") {
            self.subDomainDnsAddress = dict["SubDomainDnsAddress"] as! [String]
        }
        if dict.keys.contains("SubDomainName") {
            self.subDomainName = dict["SubDomainName"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! [String]
        }
        if dict.keys.contains("VerifyCode") {
            self.verifyCode = dict["VerifyCode"] as! String
        }
    }
}

public class CreateADConnectorOfficeSiteResponseBody : Tea.TeaModel {
    public var officeSiteId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateADConnectorOfficeSiteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateADConnectorOfficeSiteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateADConnectorOfficeSiteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAndBindNasFileSystemRequest : Tea.TeaModel {
    public var description_: String?

    public var desktopGroupId: String?

    public var encryptType: Int32?

    public var endUserIds: [String]?

    public var fileSystemName: String?

    public var officeSiteId: String?

    public var regionId: String?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.encryptType != nil {
            map["EncryptType"] = self.encryptType!
        }
        if self.endUserIds != nil {
            map["EndUserIds"] = self.endUserIds!
        }
        if self.fileSystemName != nil {
            map["FileSystemName"] = self.fileSystemName!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("EncryptType") {
            self.encryptType = dict["EncryptType"] as! Int32
        }
        if dict.keys.contains("EndUserIds") {
            self.endUserIds = dict["EndUserIds"] as! [String]
        }
        if dict.keys.contains("FileSystemName") {
            self.fileSystemName = dict["FileSystemName"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StorageType") {
            self.storageType = dict["StorageType"] as! String
        }
    }
}

public class CreateAndBindNasFileSystemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAndBindNasFileSystemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAndBindNasFileSystemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAndBindNasFileSystemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAutoSnapshotPolicyRequest : Tea.TeaModel {
    public var cronExpression: String?

    public var policyName: String?

    public var regionId: String?

    public var retentionDays: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cronExpression != nil {
            map["CronExpression"] = self.cronExpression!
        }
        if self.policyName != nil {
            map["PolicyName"] = self.policyName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.retentionDays != nil {
            map["RetentionDays"] = self.retentionDays!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CronExpression") {
            self.cronExpression = dict["CronExpression"] as! String
        }
        if dict.keys.contains("PolicyName") {
            self.policyName = dict["PolicyName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RetentionDays") {
            self.retentionDays = dict["RetentionDays"] as! Int32
        }
    }
}

public class CreateAutoSnapshotPolicyResponseBody : Tea.TeaModel {
    public var policyId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyId") {
            self.policyId = dict["PolicyId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAutoSnapshotPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAutoSnapshotPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAutoSnapshotPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBandwidthResourcePackagesRequest : Tea.TeaModel {
    public var amount: Int32?

    public var autoPay: Bool?

    public var packageSize: Int32?

    public var period: Int32?

    public var periodUnit: String?

    public var promotionId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.packageSize != nil {
            map["PackageSize"] = self.packageSize!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.promotionId != nil {
            map["PromotionId"] = self.promotionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("PackageSize") {
            self.packageSize = dict["PackageSize"] as! Int32
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PromotionId") {
            self.promotionId = dict["PromotionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateBandwidthResourcePackagesResponseBody : Tea.TeaModel {
    public var orderId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBandwidthResourcePackagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBandwidthResourcePackagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateBandwidthResourcePackagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBundleRequest : Tea.TeaModel {
    public var bundleName: String?

    public var description_: String?

    public var desktopType: String?

    public var imageId: String?

    public var language: String?

    public var regionId: String?

    public var rootDiskPerformanceLevel: String?

    public var rootDiskSizeGib: Int32?

    public var userDiskPerformanceLevel: String?

    public var userDiskSizeGib: [Int32]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bundleName != nil {
            map["BundleName"] = self.bundleName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.desktopType != nil {
            map["DesktopType"] = self.desktopType!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.rootDiskPerformanceLevel != nil {
            map["RootDiskPerformanceLevel"] = self.rootDiskPerformanceLevel!
        }
        if self.rootDiskSizeGib != nil {
            map["RootDiskSizeGib"] = self.rootDiskSizeGib!
        }
        if self.userDiskPerformanceLevel != nil {
            map["UserDiskPerformanceLevel"] = self.userDiskPerformanceLevel!
        }
        if self.userDiskSizeGib != nil {
            map["UserDiskSizeGib"] = self.userDiskSizeGib!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BundleName") {
            self.bundleName = dict["BundleName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DesktopType") {
            self.desktopType = dict["DesktopType"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RootDiskPerformanceLevel") {
            self.rootDiskPerformanceLevel = dict["RootDiskPerformanceLevel"] as! String
        }
        if dict.keys.contains("RootDiskSizeGib") {
            self.rootDiskSizeGib = dict["RootDiskSizeGib"] as! Int32
        }
        if dict.keys.contains("UserDiskPerformanceLevel") {
            self.userDiskPerformanceLevel = dict["UserDiskPerformanceLevel"] as! String
        }
        if dict.keys.contains("UserDiskSizeGib") {
            self.userDiskSizeGib = dict["UserDiskSizeGib"] as! [Int32]
        }
    }
}

public class CreateBundleResponseBody : Tea.TeaModel {
    public var bundleId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bundleId != nil {
            map["BundleId"] = self.bundleId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BundleId") {
            self.bundleId = dict["BundleId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBundleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBundleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateBundleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCdsFileRequest : Tea.TeaModel {
    public var cdsId: String?

    public var conflictPolicy: String?

    public var endUserId: String?

    public var fileHash: String?

    public var fileLength: Int64?

    public var fileName: String?

    public var fileType: String?

    public var groupId: String?

    public var parentFileId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.conflictPolicy != nil {
            map["ConflictPolicy"] = self.conflictPolicy!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.fileHash != nil {
            map["FileHash"] = self.fileHash!
        }
        if self.fileLength != nil {
            map["FileLength"] = self.fileLength!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileType != nil {
            map["FileType"] = self.fileType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.parentFileId != nil {
            map["ParentFileId"] = self.parentFileId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("ConflictPolicy") {
            self.conflictPolicy = dict["ConflictPolicy"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("FileHash") {
            self.fileHash = dict["FileHash"] as! String
        }
        if dict.keys.contains("FileLength") {
            self.fileLength = dict["FileLength"] as! Int64
        }
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileType") {
            self.fileType = dict["FileType"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ParentFileId") {
            self.parentFileId = dict["ParentFileId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateCdsFileResponseBody : Tea.TeaModel {
    public class FileModel : Tea.TeaModel {
        public var fileId: String?

        public var uploadId: String?

        public var uploadUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileId != nil {
                map["FileId"] = self.fileId!
            }
            if self.uploadId != nil {
                map["UploadId"] = self.uploadId!
            }
            if self.uploadUrl != nil {
                map["UploadUrl"] = self.uploadUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileId") {
                self.fileId = dict["FileId"] as! String
            }
            if dict.keys.contains("UploadId") {
                self.uploadId = dict["UploadId"] as! String
            }
            if dict.keys.contains("UploadUrl") {
                self.uploadUrl = dict["UploadUrl"] as! String
            }
        }
    }
    public var fileModel: CreateCdsFileResponseBody.FileModel?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.fileModel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileModel != nil {
            map["FileModel"] = self.fileModel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileModel") {
            var model = CreateCdsFileResponseBody.FileModel()
            model.fromMap(dict["FileModel"] as! [String: Any])
            self.fileModel = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCdsFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCdsFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCdsFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCdsFileShareLinkRequest : Tea.TeaModel {
    public var cdsId: String?

    public var description_: String?

    public var disableDownload: Bool?

    public var disablePreview: Bool?

    public var disableSave: Bool?

    public var downloadLimit: Int64?

    public var endUserId: String?

    public var expiration: String?

    public var fileIds: [String]?

    public var groupId: String?

    public var previewLimit: Int64?

    public var saveLimit: Int64?

    public var shareName: String?

    public var sharePwd: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableDownload != nil {
            map["DisableDownload"] = self.disableDownload!
        }
        if self.disablePreview != nil {
            map["DisablePreview"] = self.disablePreview!
        }
        if self.disableSave != nil {
            map["DisableSave"] = self.disableSave!
        }
        if self.downloadLimit != nil {
            map["DownloadLimit"] = self.downloadLimit!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.expiration != nil {
            map["Expiration"] = self.expiration!
        }
        if self.fileIds != nil {
            map["FileIds"] = self.fileIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.previewLimit != nil {
            map["PreviewLimit"] = self.previewLimit!
        }
        if self.saveLimit != nil {
            map["SaveLimit"] = self.saveLimit!
        }
        if self.shareName != nil {
            map["ShareName"] = self.shareName!
        }
        if self.sharePwd != nil {
            map["SharePwd"] = self.sharePwd!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableDownload") {
            self.disableDownload = dict["DisableDownload"] as! Bool
        }
        if dict.keys.contains("DisablePreview") {
            self.disablePreview = dict["DisablePreview"] as! Bool
        }
        if dict.keys.contains("DisableSave") {
            self.disableSave = dict["DisableSave"] as! Bool
        }
        if dict.keys.contains("DownloadLimit") {
            self.downloadLimit = dict["DownloadLimit"] as! Int64
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("Expiration") {
            self.expiration = dict["Expiration"] as! String
        }
        if dict.keys.contains("FileIds") {
            self.fileIds = dict["FileIds"] as! [String]
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PreviewLimit") {
            self.previewLimit = dict["PreviewLimit"] as! Int64
        }
        if dict.keys.contains("SaveLimit") {
            self.saveLimit = dict["SaveLimit"] as! Int64
        }
        if dict.keys.contains("ShareName") {
            self.shareName = dict["ShareName"] as! String
        }
        if dict.keys.contains("SharePwd") {
            self.sharePwd = dict["SharePwd"] as! String
        }
    }
}

public class CreateCdsFileShareLinkResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: CdsFileShareLinkModel?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CdsFileShareLinkModel()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateCdsFileShareLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCdsFileShareLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCdsFileShareLinkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCenterPolicyRequest : Tea.TeaModel {
    public class AuthorizeAccessPolicyRule : Tea.TeaModel {
        public var cidrIp: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrIp != nil {
                map["CidrIp"] = self.cidrIp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrIp") {
                self.cidrIp = dict["CidrIp"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
        }
    }
    public class AuthorizeSecurityPolicyRule : Tea.TeaModel {
        public var cidrIp: String?

        public var description_: String?

        public var ipProtocol: String?

        public var policy: String?

        public var portRange: String?

        public var priority: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrIp != nil {
                map["CidrIp"] = self.cidrIp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrIp") {
                self.cidrIp = dict["CidrIp"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ClientType : Tea.TeaModel {
        public var clientType: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientType != nil {
                map["ClientType"] = self.clientType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientType") {
                self.clientType = dict["ClientType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class DeviceRedirects : Tea.TeaModel {
        public var deviceType: String?

        public var redirectType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceType != nil {
                map["DeviceType"] = self.deviceType!
            }
            if self.redirectType != nil {
                map["RedirectType"] = self.redirectType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceType") {
                self.deviceType = dict["DeviceType"] as! String
            }
            if dict.keys.contains("RedirectType") {
                self.redirectType = dict["RedirectType"] as! String
            }
        }
    }
    public class DeviceRules : Tea.TeaModel {
        public var deviceName: String?

        public var devicePid: String?

        public var deviceType: String?

        public var deviceVid: String?

        public var optCommand: String?

        public var redirectType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceName != nil {
                map["DeviceName"] = self.deviceName!
            }
            if self.devicePid != nil {
                map["DevicePid"] = self.devicePid!
            }
            if self.deviceType != nil {
                map["DeviceType"] = self.deviceType!
            }
            if self.deviceVid != nil {
                map["DeviceVid"] = self.deviceVid!
            }
            if self.optCommand != nil {
                map["OptCommand"] = self.optCommand!
            }
            if self.redirectType != nil {
                map["RedirectType"] = self.redirectType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceName") {
                self.deviceName = dict["DeviceName"] as! String
            }
            if dict.keys.contains("DevicePid") {
                self.devicePid = dict["DevicePid"] as! String
            }
            if dict.keys.contains("DeviceType") {
                self.deviceType = dict["DeviceType"] as! String
            }
            if dict.keys.contains("DeviceVid") {
                self.deviceVid = dict["DeviceVid"] as! String
            }
            if dict.keys.contains("OptCommand") {
                self.optCommand = dict["OptCommand"] as! String
            }
            if dict.keys.contains("RedirectType") {
                self.redirectType = dict["RedirectType"] as! String
            }
        }
    }
    public class DomainResolveRule : Tea.TeaModel {
        public var description_: String?

        public var domain: String?

        public var policy: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
        }
    }
    public class NetRedirectRule : Tea.TeaModel {
        public var domain: String?

        public var policy: String?

        public var ruleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.ruleType != nil {
                map["RuleType"] = self.ruleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("RuleType") {
                self.ruleType = dict["RuleType"] as! String
            }
        }
    }
    public class UsbSupplyRedirectRule : Tea.TeaModel {
        public var description_: String?

        public var productId: String?

        public var usbRedirectType: String?

        public var usbRuleType: String?

        public var vendorId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.productId != nil {
                map["ProductId"] = self.productId!
            }
            if self.usbRedirectType != nil {
                map["UsbRedirectType"] = self.usbRedirectType!
            }
            if self.usbRuleType != nil {
                map["UsbRuleType"] = self.usbRuleType!
            }
            if self.vendorId != nil {
                map["VendorId"] = self.vendorId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ProductId") {
                self.productId = dict["ProductId"] as! String
            }
            if dict.keys.contains("UsbRedirectType") {
                self.usbRedirectType = dict["UsbRedirectType"] as! String
            }
            if dict.keys.contains("UsbRuleType") {
                self.usbRuleType = dict["UsbRuleType"] as! String
            }
            if dict.keys.contains("VendorId") {
                self.vendorId = dict["VendorId"] as! String
            }
        }
    }
    public var adminAccess: String?

    public var appContentProtection: String?

    public var authorizeAccessPolicyRule: [CreateCenterPolicyRequest.AuthorizeAccessPolicyRule]?

    public var authorizeSecurityPolicyRule: [CreateCenterPolicyRequest.AuthorizeSecurityPolicyRule]?

    public var businessType: Int32?

    public var cameraRedirect: String?

    public var clientType: [CreateCenterPolicyRequest.ClientType]?

    public var clipboard: String?

    public var colorEnhancement: String?

    public var cpuDownGradeDuration: Int32?

    public var cpuProcessors: [String]?

    public var cpuProtectedMode: String?

    public var cpuRateLimit: Int32?

    public var cpuSampleDuration: Int32?

    public var cpuSingleRateLimit: Int32?

    public var deviceConnectHint: String?

    public var deviceRedirects: [CreateCenterPolicyRequest.DeviceRedirects]?

    public var deviceRules: [CreateCenterPolicyRequest.DeviceRules]?

    public var disconnectKeepSession: String?

    public var disconnectKeepSessionTime: Int32?

    public var displayMode: String?

    public var domainResolveRule: [CreateCenterPolicyRequest.DomainResolveRule]?

    public var domainResolveRuleType: String?

    public var enableSessionRateLimiting: String?

    public var endUserApplyAdminCoordinate: String?

    public var endUserGroupCoordinate: String?

    public var fileMigrate: String?

    public var gpuAcceleration: String?

    public var html5FileTransfer: String?

    public var internetCommunicationProtocol: String?

    public var localDrive: String?

    public var maxReconnectTime: Int32?

    public var memoryDownGradeDuration: Int32?

    public var memoryProcessors: [String]?

    public var memoryProtectedMode: String?

    public var memoryRateLimit: Int32?

    public var memorySampleDuration: Int32?

    public var memorySingleRateLimit: Int32?

    public var mobileRestart: String?

    public var mobileShutdown: String?

    public var name: String?

    public var netRedirect: String?

    public var netRedirectRule: [CreateCenterPolicyRequest.NetRedirectRule]?

    public var noOperationDisconnect: String?

    public var noOperationDisconnectTime: Int32?

    public var printerRedirect: String?

    public var qualityEnhancement: String?

    public var recordEventDuration: Int32?

    public var recordEventFilePaths: [String]?

    public var recordEventRegisters: [String]?

    public var recordEvents: [String]?

    public var recording: String?

    public var recordingAudio: String?

    public var recordingDuration: Int32?

    public var recordingEndTime: String?

    public var recordingExpires: Int32?

    public var recordingFps: String?

    public var recordingStartTime: String?

    public var recordingUserNotify: String?

    public var recordingUserNotifyMessage: String?

    public var regionId: String?

    public var remoteCoordinate: String?

    public var resetDesktop: String?

    public var resolutionHeight: Int32?

    public var resolutionModel: String?

    public var resolutionWidth: Int32?

    public var resourceType: String?

    public var scope: String?

    public var scopeValue: [String]?

    public var sessionMaxRateKbps: Int32?

    public var smoothEnhancement: String?

    public var statusMonitor: String?

    public var streamingMode: String?

    public var targetFps: Int32?

    public var taskbar: String?

    public var usbRedirect: String?

    public var usbSupplyRedirectRule: [CreateCenterPolicyRequest.UsbSupplyRedirectRule]?

    public var videoEncAvgKbps: Int32?

    public var videoEncMaxQP: Int32?

    public var videoEncMinQP: Int32?

    public var videoEncPeakKbps: Int32?

    public var videoEncPolicy: String?

    public var videoRedirect: String?

    public var visualQuality: String?

    public var watermark: String?

    public var watermarkAntiCam: String?

    public var watermarkColor: Int32?

    public var watermarkColumnAmount: Int32?

    public var watermarkCustomText: String?

    public var watermarkDegree: Double?

    public var watermarkFontSize: Int32?

    public var watermarkFontStyle: String?

    public var watermarkPower: String?

    public var watermarkRowAmount: Int32?

    public var watermarkSecurity: String?

    public var watermarkTransparencyValue: Int32?

    public var watermarkType: String?

    public var wuyingKeeper: String?

    public var wyAssistant: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adminAccess != nil {
            map["AdminAccess"] = self.adminAccess!
        }
        if self.appContentProtection != nil {
            map["AppContentProtection"] = self.appContentProtection!
        }
        if self.authorizeAccessPolicyRule != nil {
            var tmp : [Any] = []
            for k in self.authorizeAccessPolicyRule! {
                tmp.append(k.toMap())
            }
            map["AuthorizeAccessPolicyRule"] = tmp
        }
        if self.authorizeSecurityPolicyRule != nil {
            var tmp : [Any] = []
            for k in self.authorizeSecurityPolicyRule! {
                tmp.append(k.toMap())
            }
            map["AuthorizeSecurityPolicyRule"] = tmp
        }
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.cameraRedirect != nil {
            map["CameraRedirect"] = self.cameraRedirect!
        }
        if self.clientType != nil {
            var tmp : [Any] = []
            for k in self.clientType! {
                tmp.append(k.toMap())
            }
            map["ClientType"] = tmp
        }
        if self.clipboard != nil {
            map["Clipboard"] = self.clipboard!
        }
        if self.colorEnhancement != nil {
            map["ColorEnhancement"] = self.colorEnhancement!
        }
        if self.cpuDownGradeDuration != nil {
            map["CpuDownGradeDuration"] = self.cpuDownGradeDuration!
        }
        if self.cpuProcessors != nil {
            map["CpuProcessors"] = self.cpuProcessors!
        }
        if self.cpuProtectedMode != nil {
            map["CpuProtectedMode"] = self.cpuProtectedMode!
        }
        if self.cpuRateLimit != nil {
            map["CpuRateLimit"] = self.cpuRateLimit!
        }
        if self.cpuSampleDuration != nil {
            map["CpuSampleDuration"] = self.cpuSampleDuration!
        }
        if self.cpuSingleRateLimit != nil {
            map["CpuSingleRateLimit"] = self.cpuSingleRateLimit!
        }
        if self.deviceConnectHint != nil {
            map["DeviceConnectHint"] = self.deviceConnectHint!
        }
        if self.deviceRedirects != nil {
            var tmp : [Any] = []
            for k in self.deviceRedirects! {
                tmp.append(k.toMap())
            }
            map["DeviceRedirects"] = tmp
        }
        if self.deviceRules != nil {
            var tmp : [Any] = []
            for k in self.deviceRules! {
                tmp.append(k.toMap())
            }
            map["DeviceRules"] = tmp
        }
        if self.disconnectKeepSession != nil {
            map["DisconnectKeepSession"] = self.disconnectKeepSession!
        }
        if self.disconnectKeepSessionTime != nil {
            map["DisconnectKeepSessionTime"] = self.disconnectKeepSessionTime!
        }
        if self.displayMode != nil {
            map["DisplayMode"] = self.displayMode!
        }
        if self.domainResolveRule != nil {
            var tmp : [Any] = []
            for k in self.domainResolveRule! {
                tmp.append(k.toMap())
            }
            map["DomainResolveRule"] = tmp
        }
        if self.domainResolveRuleType != nil {
            map["DomainResolveRuleType"] = self.domainResolveRuleType!
        }
        if self.enableSessionRateLimiting != nil {
            map["EnableSessionRateLimiting"] = self.enableSessionRateLimiting!
        }
        if self.endUserApplyAdminCoordinate != nil {
            map["EndUserApplyAdminCoordinate"] = self.endUserApplyAdminCoordinate!
        }
        if self.endUserGroupCoordinate != nil {
            map["EndUserGroupCoordinate"] = self.endUserGroupCoordinate!
        }
        if self.fileMigrate != nil {
            map["FileMigrate"] = self.fileMigrate!
        }
        if self.gpuAcceleration != nil {
            map["GpuAcceleration"] = self.gpuAcceleration!
        }
        if self.html5FileTransfer != nil {
            map["Html5FileTransfer"] = self.html5FileTransfer!
        }
        if self.internetCommunicationProtocol != nil {
            map["InternetCommunicationProtocol"] = self.internetCommunicationProtocol!
        }
        if self.localDrive != nil {
            map["LocalDrive"] = self.localDrive!
        }
        if self.maxReconnectTime != nil {
            map["MaxReconnectTime"] = self.maxReconnectTime!
        }
        if self.memoryDownGradeDuration != nil {
            map["MemoryDownGradeDuration"] = self.memoryDownGradeDuration!
        }
        if self.memoryProcessors != nil {
            map["MemoryProcessors"] = self.memoryProcessors!
        }
        if self.memoryProtectedMode != nil {
            map["MemoryProtectedMode"] = self.memoryProtectedMode!
        }
        if self.memoryRateLimit != nil {
            map["MemoryRateLimit"] = self.memoryRateLimit!
        }
        if self.memorySampleDuration != nil {
            map["MemorySampleDuration"] = self.memorySampleDuration!
        }
        if self.memorySingleRateLimit != nil {
            map["MemorySingleRateLimit"] = self.memorySingleRateLimit!
        }
        if self.mobileRestart != nil {
            map["MobileRestart"] = self.mobileRestart!
        }
        if self.mobileShutdown != nil {
            map["MobileShutdown"] = self.mobileShutdown!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.netRedirect != nil {
            map["NetRedirect"] = self.netRedirect!
        }
        if self.netRedirectRule != nil {
            var tmp : [Any] = []
            for k in self.netRedirectRule! {
                tmp.append(k.toMap())
            }
            map["NetRedirectRule"] = tmp
        }
        if self.noOperationDisconnect != nil {
            map["NoOperationDisconnect"] = self.noOperationDisconnect!
        }
        if self.noOperationDisconnectTime != nil {
            map["NoOperationDisconnectTime"] = self.noOperationDisconnectTime!
        }
        if self.printerRedirect != nil {
            map["PrinterRedirect"] = self.printerRedirect!
        }
        if self.qualityEnhancement != nil {
            map["QualityEnhancement"] = self.qualityEnhancement!
        }
        if self.recordEventDuration != nil {
            map["RecordEventDuration"] = self.recordEventDuration!
        }
        if self.recordEventFilePaths != nil {
            map["RecordEventFilePaths"] = self.recordEventFilePaths!
        }
        if self.recordEventRegisters != nil {
            map["RecordEventRegisters"] = self.recordEventRegisters!
        }
        if self.recordEvents != nil {
            map["RecordEvents"] = self.recordEvents!
        }
        if self.recording != nil {
            map["Recording"] = self.recording!
        }
        if self.recordingAudio != nil {
            map["RecordingAudio"] = self.recordingAudio!
        }
        if self.recordingDuration != nil {
            map["RecordingDuration"] = self.recordingDuration!
        }
        if self.recordingEndTime != nil {
            map["RecordingEndTime"] = self.recordingEndTime!
        }
        if self.recordingExpires != nil {
            map["RecordingExpires"] = self.recordingExpires!
        }
        if self.recordingFps != nil {
            map["RecordingFps"] = self.recordingFps!
        }
        if self.recordingStartTime != nil {
            map["RecordingStartTime"] = self.recordingStartTime!
        }
        if self.recordingUserNotify != nil {
            map["RecordingUserNotify"] = self.recordingUserNotify!
        }
        if self.recordingUserNotifyMessage != nil {
            map["RecordingUserNotifyMessage"] = self.recordingUserNotifyMessage!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteCoordinate != nil {
            map["RemoteCoordinate"] = self.remoteCoordinate!
        }
        if self.resetDesktop != nil {
            map["ResetDesktop"] = self.resetDesktop!
        }
        if self.resolutionHeight != nil {
            map["ResolutionHeight"] = self.resolutionHeight!
        }
        if self.resolutionModel != nil {
            map["ResolutionModel"] = self.resolutionModel!
        }
        if self.resolutionWidth != nil {
            map["ResolutionWidth"] = self.resolutionWidth!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.scopeValue != nil {
            map["ScopeValue"] = self.scopeValue!
        }
        if self.sessionMaxRateKbps != nil {
            map["SessionMaxRateKbps"] = self.sessionMaxRateKbps!
        }
        if self.smoothEnhancement != nil {
            map["SmoothEnhancement"] = self.smoothEnhancement!
        }
        if self.statusMonitor != nil {
            map["StatusMonitor"] = self.statusMonitor!
        }
        if self.streamingMode != nil {
            map["StreamingMode"] = self.streamingMode!
        }
        if self.targetFps != nil {
            map["TargetFps"] = self.targetFps!
        }
        if self.taskbar != nil {
            map["Taskbar"] = self.taskbar!
        }
        if self.usbRedirect != nil {
            map["UsbRedirect"] = self.usbRedirect!
        }
        if self.usbSupplyRedirectRule != nil {
            var tmp : [Any] = []
            for k in self.usbSupplyRedirectRule! {
                tmp.append(k.toMap())
            }
            map["UsbSupplyRedirectRule"] = tmp
        }
        if self.videoEncAvgKbps != nil {
            map["VideoEncAvgKbps"] = self.videoEncAvgKbps!
        }
        if self.videoEncMaxQP != nil {
            map["VideoEncMaxQP"] = self.videoEncMaxQP!
        }
        if self.videoEncMinQP != nil {
            map["VideoEncMinQP"] = self.videoEncMinQP!
        }
        if self.videoEncPeakKbps != nil {
            map["VideoEncPeakKbps"] = self.videoEncPeakKbps!
        }
        if self.videoEncPolicy != nil {
            map["VideoEncPolicy"] = self.videoEncPolicy!
        }
        if self.videoRedirect != nil {
            map["VideoRedirect"] = self.videoRedirect!
        }
        if self.visualQuality != nil {
            map["VisualQuality"] = self.visualQuality!
        }
        if self.watermark != nil {
            map["Watermark"] = self.watermark!
        }
        if self.watermarkAntiCam != nil {
            map["WatermarkAntiCam"] = self.watermarkAntiCam!
        }
        if self.watermarkColor != nil {
            map["WatermarkColor"] = self.watermarkColor!
        }
        if self.watermarkColumnAmount != nil {
            map["WatermarkColumnAmount"] = self.watermarkColumnAmount!
        }
        if self.watermarkCustomText != nil {
            map["WatermarkCustomText"] = self.watermarkCustomText!
        }
        if self.watermarkDegree != nil {
            map["WatermarkDegree"] = self.watermarkDegree!
        }
        if self.watermarkFontSize != nil {
            map["WatermarkFontSize"] = self.watermarkFontSize!
        }
        if self.watermarkFontStyle != nil {
            map["WatermarkFontStyle"] = self.watermarkFontStyle!
        }
        if self.watermarkPower != nil {
            map["WatermarkPower"] = self.watermarkPower!
        }
        if self.watermarkRowAmount != nil {
            map["WatermarkRowAmount"] = self.watermarkRowAmount!
        }
        if self.watermarkSecurity != nil {
            map["WatermarkSecurity"] = self.watermarkSecurity!
        }
        if self.watermarkTransparencyValue != nil {
            map["WatermarkTransparencyValue"] = self.watermarkTransparencyValue!
        }
        if self.watermarkType != nil {
            map["WatermarkType"] = self.watermarkType!
        }
        if self.wuyingKeeper != nil {
            map["WuyingKeeper"] = self.wuyingKeeper!
        }
        if self.wyAssistant != nil {
            map["WyAssistant"] = self.wyAssistant!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdminAccess") {
            self.adminAccess = dict["AdminAccess"] as! String
        }
        if dict.keys.contains("AppContentProtection") {
            self.appContentProtection = dict["AppContentProtection"] as! String
        }
        if dict.keys.contains("AuthorizeAccessPolicyRule") {
            var tmp : [CreateCenterPolicyRequest.AuthorizeAccessPolicyRule] = []
            for v in dict["AuthorizeAccessPolicyRule"] as! [Any] {
                var model = CreateCenterPolicyRequest.AuthorizeAccessPolicyRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.authorizeAccessPolicyRule = tmp
        }
        if dict.keys.contains("AuthorizeSecurityPolicyRule") {
            var tmp : [CreateCenterPolicyRequest.AuthorizeSecurityPolicyRule] = []
            for v in dict["AuthorizeSecurityPolicyRule"] as! [Any] {
                var model = CreateCenterPolicyRequest.AuthorizeSecurityPolicyRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.authorizeSecurityPolicyRule = tmp
        }
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! Int32
        }
        if dict.keys.contains("CameraRedirect") {
            self.cameraRedirect = dict["CameraRedirect"] as! String
        }
        if dict.keys.contains("ClientType") {
            var tmp : [CreateCenterPolicyRequest.ClientType] = []
            for v in dict["ClientType"] as! [Any] {
                var model = CreateCenterPolicyRequest.ClientType()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.clientType = tmp
        }
        if dict.keys.contains("Clipboard") {
            self.clipboard = dict["Clipboard"] as! String
        }
        if dict.keys.contains("ColorEnhancement") {
            self.colorEnhancement = dict["ColorEnhancement"] as! String
        }
        if dict.keys.contains("CpuDownGradeDuration") {
            self.cpuDownGradeDuration = dict["CpuDownGradeDuration"] as! Int32
        }
        if dict.keys.contains("CpuProcessors") {
            self.cpuProcessors = dict["CpuProcessors"] as! [String]
        }
        if dict.keys.contains("CpuProtectedMode") {
            self.cpuProtectedMode = dict["CpuProtectedMode"] as! String
        }
        if dict.keys.contains("CpuRateLimit") {
            self.cpuRateLimit = dict["CpuRateLimit"] as! Int32
        }
        if dict.keys.contains("CpuSampleDuration") {
            self.cpuSampleDuration = dict["CpuSampleDuration"] as! Int32
        }
        if dict.keys.contains("CpuSingleRateLimit") {
            self.cpuSingleRateLimit = dict["CpuSingleRateLimit"] as! Int32
        }
        if dict.keys.contains("DeviceConnectHint") {
            self.deviceConnectHint = dict["DeviceConnectHint"] as! String
        }
        if dict.keys.contains("DeviceRedirects") {
            var tmp : [CreateCenterPolicyRequest.DeviceRedirects] = []
            for v in dict["DeviceRedirects"] as! [Any] {
                var model = CreateCenterPolicyRequest.DeviceRedirects()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deviceRedirects = tmp
        }
        if dict.keys.contains("DeviceRules") {
            var tmp : [CreateCenterPolicyRequest.DeviceRules] = []
            for v in dict["DeviceRules"] as! [Any] {
                var model = CreateCenterPolicyRequest.DeviceRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deviceRules = tmp
        }
        if dict.keys.contains("DisconnectKeepSession") {
            self.disconnectKeepSession = dict["DisconnectKeepSession"] as! String
        }
        if dict.keys.contains("DisconnectKeepSessionTime") {
            self.disconnectKeepSessionTime = dict["DisconnectKeepSessionTime"] as! Int32
        }
        if dict.keys.contains("DisplayMode") {
            self.displayMode = dict["DisplayMode"] as! String
        }
        if dict.keys.contains("DomainResolveRule") {
            var tmp : [CreateCenterPolicyRequest.DomainResolveRule] = []
            for v in dict["DomainResolveRule"] as! [Any] {
                var model = CreateCenterPolicyRequest.DomainResolveRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.domainResolveRule = tmp
        }
        if dict.keys.contains("DomainResolveRuleType") {
            self.domainResolveRuleType = dict["DomainResolveRuleType"] as! String
        }
        if dict.keys.contains("EnableSessionRateLimiting") {
            self.enableSessionRateLimiting = dict["EnableSessionRateLimiting"] as! String
        }
        if dict.keys.contains("EndUserApplyAdminCoordinate") {
            self.endUserApplyAdminCoordinate = dict["EndUserApplyAdminCoordinate"] as! String
        }
        if dict.keys.contains("EndUserGroupCoordinate") {
            self.endUserGroupCoordinate = dict["EndUserGroupCoordinate"] as! String
        }
        if dict.keys.contains("FileMigrate") {
            self.fileMigrate = dict["FileMigrate"] as! String
        }
        if dict.keys.contains("GpuAcceleration") {
            self.gpuAcceleration = dict["GpuAcceleration"] as! String
        }
        if dict.keys.contains("Html5FileTransfer") {
            self.html5FileTransfer = dict["Html5FileTransfer"] as! String
        }
        if dict.keys.contains("InternetCommunicationProtocol") {
            self.internetCommunicationProtocol = dict["InternetCommunicationProtocol"] as! String
        }
        if dict.keys.contains("LocalDrive") {
            self.localDrive = dict["LocalDrive"] as! String
        }
        if dict.keys.contains("MaxReconnectTime") {
            self.maxReconnectTime = dict["MaxReconnectTime"] as! Int32
        }
        if dict.keys.contains("MemoryDownGradeDuration") {
            self.memoryDownGradeDuration = dict["MemoryDownGradeDuration"] as! Int32
        }
        if dict.keys.contains("MemoryProcessors") {
            self.memoryProcessors = dict["MemoryProcessors"] as! [String]
        }
        if dict.keys.contains("MemoryProtectedMode") {
            self.memoryProtectedMode = dict["MemoryProtectedMode"] as! String
        }
        if dict.keys.contains("MemoryRateLimit") {
            self.memoryRateLimit = dict["MemoryRateLimit"] as! Int32
        }
        if dict.keys.contains("MemorySampleDuration") {
            self.memorySampleDuration = dict["MemorySampleDuration"] as! Int32
        }
        if dict.keys.contains("MemorySingleRateLimit") {
            self.memorySingleRateLimit = dict["MemorySingleRateLimit"] as! Int32
        }
        if dict.keys.contains("MobileRestart") {
            self.mobileRestart = dict["MobileRestart"] as! String
        }
        if dict.keys.contains("MobileShutdown") {
            self.mobileShutdown = dict["MobileShutdown"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NetRedirect") {
            self.netRedirect = dict["NetRedirect"] as! String
        }
        if dict.keys.contains("NetRedirectRule") {
            var tmp : [CreateCenterPolicyRequest.NetRedirectRule] = []
            for v in dict["NetRedirectRule"] as! [Any] {
                var model = CreateCenterPolicyRequest.NetRedirectRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.netRedirectRule = tmp
        }
        if dict.keys.contains("NoOperationDisconnect") {
            self.noOperationDisconnect = dict["NoOperationDisconnect"] as! String
        }
        if dict.keys.contains("NoOperationDisconnectTime") {
            self.noOperationDisconnectTime = dict["NoOperationDisconnectTime"] as! Int32
        }
        if dict.keys.contains("PrinterRedirect") {
            self.printerRedirect = dict["PrinterRedirect"] as! String
        }
        if dict.keys.contains("QualityEnhancement") {
            self.qualityEnhancement = dict["QualityEnhancement"] as! String
        }
        if dict.keys.contains("RecordEventDuration") {
            self.recordEventDuration = dict["RecordEventDuration"] as! Int32
        }
        if dict.keys.contains("RecordEventFilePaths") {
            self.recordEventFilePaths = dict["RecordEventFilePaths"] as! [String]
        }
        if dict.keys.contains("RecordEventRegisters") {
            self.recordEventRegisters = dict["RecordEventRegisters"] as! [String]
        }
        if dict.keys.contains("RecordEvents") {
            self.recordEvents = dict["RecordEvents"] as! [String]
        }
        if dict.keys.contains("Recording") {
            self.recording = dict["Recording"] as! String
        }
        if dict.keys.contains("RecordingAudio") {
            self.recordingAudio = dict["RecordingAudio"] as! String
        }
        if dict.keys.contains("RecordingDuration") {
            self.recordingDuration = dict["RecordingDuration"] as! Int32
        }
        if dict.keys.contains("RecordingEndTime") {
            self.recordingEndTime = dict["RecordingEndTime"] as! String
        }
        if dict.keys.contains("RecordingExpires") {
            self.recordingExpires = dict["RecordingExpires"] as! Int32
        }
        if dict.keys.contains("RecordingFps") {
            self.recordingFps = dict["RecordingFps"] as! String
        }
        if dict.keys.contains("RecordingStartTime") {
            self.recordingStartTime = dict["RecordingStartTime"] as! String
        }
        if dict.keys.contains("RecordingUserNotify") {
            self.recordingUserNotify = dict["RecordingUserNotify"] as! String
        }
        if dict.keys.contains("RecordingUserNotifyMessage") {
            self.recordingUserNotifyMessage = dict["RecordingUserNotifyMessage"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoteCoordinate") {
            self.remoteCoordinate = dict["RemoteCoordinate"] as! String
        }
        if dict.keys.contains("ResetDesktop") {
            self.resetDesktop = dict["ResetDesktop"] as! String
        }
        if dict.keys.contains("ResolutionHeight") {
            self.resolutionHeight = dict["ResolutionHeight"] as! Int32
        }
        if dict.keys.contains("ResolutionModel") {
            self.resolutionModel = dict["ResolutionModel"] as! String
        }
        if dict.keys.contains("ResolutionWidth") {
            self.resolutionWidth = dict["ResolutionWidth"] as! Int32
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("ScopeValue") {
            self.scopeValue = dict["ScopeValue"] as! [String]
        }
        if dict.keys.contains("SessionMaxRateKbps") {
            self.sessionMaxRateKbps = dict["SessionMaxRateKbps"] as! Int32
        }
        if dict.keys.contains("SmoothEnhancement") {
            self.smoothEnhancement = dict["SmoothEnhancement"] as! String
        }
        if dict.keys.contains("StatusMonitor") {
            self.statusMonitor = dict["StatusMonitor"] as! String
        }
        if dict.keys.contains("StreamingMode") {
            self.streamingMode = dict["StreamingMode"] as! String
        }
        if dict.keys.contains("TargetFps") {
            self.targetFps = dict["TargetFps"] as! Int32
        }
        if dict.keys.contains("Taskbar") {
            self.taskbar = dict["Taskbar"] as! String
        }
        if dict.keys.contains("UsbRedirect") {
            self.usbRedirect = dict["UsbRedirect"] as! String
        }
        if dict.keys.contains("UsbSupplyRedirectRule") {
            var tmp : [CreateCenterPolicyRequest.UsbSupplyRedirectRule] = []
            for v in dict["UsbSupplyRedirectRule"] as! [Any] {
                var model = CreateCenterPolicyRequest.UsbSupplyRedirectRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.usbSupplyRedirectRule = tmp
        }
        if dict.keys.contains("VideoEncAvgKbps") {
            self.videoEncAvgKbps = dict["VideoEncAvgKbps"] as! Int32
        }
        if dict.keys.contains("VideoEncMaxQP") {
            self.videoEncMaxQP = dict["VideoEncMaxQP"] as! Int32
        }
        if dict.keys.contains("VideoEncMinQP") {
            self.videoEncMinQP = dict["VideoEncMinQP"] as! Int32
        }
        if dict.keys.contains("VideoEncPeakKbps") {
            self.videoEncPeakKbps = dict["VideoEncPeakKbps"] as! Int32
        }
        if dict.keys.contains("VideoEncPolicy") {
            self.videoEncPolicy = dict["VideoEncPolicy"] as! String
        }
        if dict.keys.contains("VideoRedirect") {
            self.videoRedirect = dict["VideoRedirect"] as! String
        }
        if dict.keys.contains("VisualQuality") {
            self.visualQuality = dict["VisualQuality"] as! String
        }
        if dict.keys.contains("Watermark") {
            self.watermark = dict["Watermark"] as! String
        }
        if dict.keys.contains("WatermarkAntiCam") {
            self.watermarkAntiCam = dict["WatermarkAntiCam"] as! String
        }
        if dict.keys.contains("WatermarkColor") {
            self.watermarkColor = dict["WatermarkColor"] as! Int32
        }
        if dict.keys.contains("WatermarkColumnAmount") {
            self.watermarkColumnAmount = dict["WatermarkColumnAmount"] as! Int32
        }
        if dict.keys.contains("WatermarkCustomText") {
            self.watermarkCustomText = dict["WatermarkCustomText"] as! String
        }
        if dict.keys.contains("WatermarkDegree") {
            self.watermarkDegree = dict["WatermarkDegree"] as! Double
        }
        if dict.keys.contains("WatermarkFontSize") {
            self.watermarkFontSize = dict["WatermarkFontSize"] as! Int32
        }
        if dict.keys.contains("WatermarkFontStyle") {
            self.watermarkFontStyle = dict["WatermarkFontStyle"] as! String
        }
        if dict.keys.contains("WatermarkPower") {
            self.watermarkPower = dict["WatermarkPower"] as! String
        }
        if dict.keys.contains("WatermarkRowAmount") {
            self.watermarkRowAmount = dict["WatermarkRowAmount"] as! Int32
        }
        if dict.keys.contains("WatermarkSecurity") {
            self.watermarkSecurity = dict["WatermarkSecurity"] as! String
        }
        if dict.keys.contains("WatermarkTransparencyValue") {
            self.watermarkTransparencyValue = dict["WatermarkTransparencyValue"] as! Int32
        }
        if dict.keys.contains("WatermarkType") {
            self.watermarkType = dict["WatermarkType"] as! String
        }
        if dict.keys.contains("WuyingKeeper") {
            self.wuyingKeeper = dict["WuyingKeeper"] as! String
        }
        if dict.keys.contains("WyAssistant") {
            self.wyAssistant = dict["WyAssistant"] as! String
        }
    }
}

public class CreateCenterPolicyResponseBody : Tea.TeaModel {
    public var policyGroupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCenterPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCenterPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCenterPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCloudDriveServiceRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var bizType: Int32?

    public var cdsChargeType: String?

    public var cenId: String?

    public var domainName: String?

    public var endUserId: [String]?

    public var maxSize: Int64?

    public var name: String?

    public var officeSiteId: String?

    public var officeSiteType: String?

    public var period: Int64?

    public var periodUnit: String?

    public var regionId: String?

    public var solutionId: String?

    public var userCount: Int64?

    public var userMaxSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.cdsChargeType != nil {
            map["CdsChargeType"] = self.cdsChargeType!
        }
        if self.cenId != nil {
            map["CenId"] = self.cenId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.maxSize != nil {
            map["MaxSize"] = self.maxSize!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.officeSiteType != nil {
            map["OfficeSiteType"] = self.officeSiteType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.solutionId != nil {
            map["SolutionId"] = self.solutionId!
        }
        if self.userCount != nil {
            map["UserCount"] = self.userCount!
        }
        if self.userMaxSize != nil {
            map["UserMaxSize"] = self.userMaxSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("BizType") {
            self.bizType = dict["BizType"] as! Int32
        }
        if dict.keys.contains("CdsChargeType") {
            self.cdsChargeType = dict["CdsChargeType"] as! String
        }
        if dict.keys.contains("CenId") {
            self.cenId = dict["CenId"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! [String]
        }
        if dict.keys.contains("MaxSize") {
            self.maxSize = dict["MaxSize"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("OfficeSiteType") {
            self.officeSiteType = dict["OfficeSiteType"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int64
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SolutionId") {
            self.solutionId = dict["SolutionId"] as! String
        }
        if dict.keys.contains("UserCount") {
            self.userCount = dict["UserCount"] as! Int64
        }
        if dict.keys.contains("UserMaxSize") {
            self.userMaxSize = dict["UserMaxSize"] as! Int64
        }
    }
}

public class CreateCloudDriveServiceResponseBody : Tea.TeaModel {
    public class ConflictCdsAndOrder : Tea.TeaModel {
        public class ConflictCds : Tea.TeaModel {
            public var cdsId: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cdsId != nil {
                    map["CdsId"] = self.cdsId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CdsId") {
                    self.cdsId = dict["CdsId"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public class ConflictOrder : Tea.TeaModel {
            public var cdsId: String?

            public var orderId: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cdsId != nil {
                    map["CdsId"] = self.cdsId!
                }
                if self.orderId != nil {
                    map["OrderId"] = self.orderId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CdsId") {
                    self.cdsId = dict["CdsId"] as! String
                }
                if dict.keys.contains("OrderId") {
                    self.orderId = dict["OrderId"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var conflictCds: [CreateCloudDriveServiceResponseBody.ConflictCdsAndOrder.ConflictCds]?

        public var conflictOrder: [CreateCloudDriveServiceResponseBody.ConflictCdsAndOrder.ConflictOrder]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conflictCds != nil {
                var tmp : [Any] = []
                for k in self.conflictCds! {
                    tmp.append(k.toMap())
                }
                map["ConflictCds"] = tmp
            }
            if self.conflictOrder != nil {
                var tmp : [Any] = []
                for k in self.conflictOrder! {
                    tmp.append(k.toMap())
                }
                map["ConflictOrder"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConflictCds") {
                var tmp : [CreateCloudDriveServiceResponseBody.ConflictCdsAndOrder.ConflictCds] = []
                for v in dict["ConflictCds"] as! [Any] {
                    var model = CreateCloudDriveServiceResponseBody.ConflictCdsAndOrder.ConflictCds()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.conflictCds = tmp
            }
            if dict.keys.contains("ConflictOrder") {
                var tmp : [CreateCloudDriveServiceResponseBody.ConflictCdsAndOrder.ConflictOrder] = []
                for v in dict["ConflictOrder"] as! [Any] {
                    var model = CreateCloudDriveServiceResponseBody.ConflictCdsAndOrder.ConflictOrder()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.conflictOrder = tmp
            }
        }
    }
    public var cdsId: String?

    public var cdsName: String?

    public var cenId: String?

    public var conflictCdsAndOrder: CreateCloudDriveServiceResponseBody.ConflictCdsAndOrder?

    public var domainName: String?

    public var errorCode: String?

    public var maxSize: String?

    public var officeSiteType: String?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.conflictCdsAndOrder?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.cdsName != nil {
            map["CdsName"] = self.cdsName!
        }
        if self.cenId != nil {
            map["CenId"] = self.cenId!
        }
        if self.conflictCdsAndOrder != nil {
            map["ConflictCdsAndOrder"] = self.conflictCdsAndOrder?.toMap()
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.maxSize != nil {
            map["MaxSize"] = self.maxSize!
        }
        if self.officeSiteType != nil {
            map["OfficeSiteType"] = self.officeSiteType!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("CdsName") {
            self.cdsName = dict["CdsName"] as! String
        }
        if dict.keys.contains("CenId") {
            self.cenId = dict["CenId"] as! String
        }
        if dict.keys.contains("ConflictCdsAndOrder") {
            var model = CreateCloudDriveServiceResponseBody.ConflictCdsAndOrder()
            model.fromMap(dict["ConflictCdsAndOrder"] as! [String: Any])
            self.conflictCdsAndOrder = model
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("MaxSize") {
            self.maxSize = dict["MaxSize"] as! String
        }
        if dict.keys.contains("OfficeSiteType") {
            self.officeSiteType = dict["OfficeSiteType"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCloudDriveServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudDriveServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCloudDriveServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCloudDriveUsersRequest : Tea.TeaModel {
    public var cdsId: String?

    public var endUserId: [String]?

    public var regionId: String?

    public var userMaxSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.userMaxSize != nil {
            map["UserMaxSize"] = self.userMaxSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("UserMaxSize") {
            self.userMaxSize = dict["UserMaxSize"] as! Int64
        }
    }
}

public class CreateCloudDriveUsersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCloudDriveUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudDriveUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCloudDriveUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateConfigGroupRequest : Tea.TeaModel {
    public class ConfigTimers : Tea.TeaModel {
        public var allowClientSetting: Bool?

        public var cronExpression: String?

        public var enforce: Bool?

        public var interval: Int32?

        public var notificationTime: Int32?

        public var operationType: String?

        public var processWhitelist: [String]?

        public var resetType: String?

        public var timerType: String?

        public var triggerType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowClientSetting != nil {
                map["AllowClientSetting"] = self.allowClientSetting!
            }
            if self.cronExpression != nil {
                map["CronExpression"] = self.cronExpression!
            }
            if self.enforce != nil {
                map["Enforce"] = self.enforce!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.notificationTime != nil {
                map["NotificationTime"] = self.notificationTime!
            }
            if self.operationType != nil {
                map["OperationType"] = self.operationType!
            }
            if self.processWhitelist != nil {
                map["ProcessWhitelist"] = self.processWhitelist!
            }
            if self.resetType != nil {
                map["ResetType"] = self.resetType!
            }
            if self.timerType != nil {
                map["TimerType"] = self.timerType!
            }
            if self.triggerType != nil {
                map["TriggerType"] = self.triggerType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowClientSetting") {
                self.allowClientSetting = dict["AllowClientSetting"] as! Bool
            }
            if dict.keys.contains("CronExpression") {
                self.cronExpression = dict["CronExpression"] as! String
            }
            if dict.keys.contains("Enforce") {
                self.enforce = dict["Enforce"] as! Bool
            }
            if dict.keys.contains("Interval") {
                self.interval = dict["Interval"] as! Int32
            }
            if dict.keys.contains("NotificationTime") {
                self.notificationTime = dict["NotificationTime"] as! Int32
            }
            if dict.keys.contains("OperationType") {
                self.operationType = dict["OperationType"] as! String
            }
            if dict.keys.contains("ProcessWhitelist") {
                self.processWhitelist = dict["ProcessWhitelist"] as! [String]
            }
            if dict.keys.contains("ResetType") {
                self.resetType = dict["ResetType"] as! String
            }
            if dict.keys.contains("TimerType") {
                self.timerType = dict["TimerType"] as! String
            }
            if dict.keys.contains("TriggerType") {
                self.triggerType = dict["TriggerType"] as! String
            }
        }
    }
    public var configTimers: [CreateConfigGroupRequest.ConfigTimers]?

    public var description_: String?

    public var name: String?

    public var productType: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configTimers != nil {
            var tmp : [Any] = []
            for k in self.configTimers! {
                tmp.append(k.toMap())
            }
            map["ConfigTimers"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.productType != nil {
            map["ProductType"] = self.productType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigTimers") {
            var tmp : [CreateConfigGroupRequest.ConfigTimers] = []
            for v in dict["ConfigTimers"] as! [Any] {
                var model = CreateConfigGroupRequest.ConfigTimers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.configTimers = tmp
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProductType") {
            self.productType = dict["ProductType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateConfigGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateConfigGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateConfigGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateConfigGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDesktopGroupRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var allClassifyUsers: Bool?

    public var allowAutoSetup: Int32?

    public var allowBufferCount: Int32?

    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var bindAmount: Int64?

    public var bundleId: String?

    public var buyDesktopsCount: Int32?

    public var chargeType: String?

    public var classify: String?

    public var clientToken: String?

    public var comments: String?

    public var connectDuration: Int64?

    public var dataDiskCategory: String?

    public var dataDiskPerLevel: String?

    public var dataDiskSize: Int32?

    public var defaultInitDesktopCount: Int32?

    public var defaultLanguage: String?

    public var desktopGroupName: String?

    public var desktopType: String?

    public var directoryId: String?

    public var endUserIds: [String]?

    public var exclusiveType: String?

    public var fileSystemId: String?

    public var groupAmount: Int32?

    public var groupVersion: Int32?

    public var hostname: String?

    public var idleDisconnectDuration: Int64?

    public var imageId: String?

    public var keepDuration: Int64?

    public var loadPolicy: Int64?

    public var maxDesktopsCount: Int32?

    public var minDesktopsCount: Int32?

    public var multiResource: Bool?

    public var officeSiteId: String?

    public var ownType: Int32?

    public var period: Int32?

    public var periodUnit: String?

    public var policyGroupId: String?

    public var profileFollowSwitch: Bool?

    public var promotionId: String?

    public var ratioThreshold: Double?

    public var regionId: String?

    public var resetType: Int64?

    public var scaleStrategyId: String?

    public var sessionType: String?

    public var snapshotPolicyId: String?

    public var stopDuration: Int64?

    public var systemDiskCategory: String?

    public var systemDiskPerLevel: String?

    public var systemDiskSize: Int32?

    public var tag: [CreateDesktopGroupRequest.Tag]?

    public var timerGroupId: String?

    public var userOuPath: String?

    public var volumeEncryptionEnabled: Bool?

    public var volumeEncryptionKey: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allClassifyUsers != nil {
            map["AllClassifyUsers"] = self.allClassifyUsers!
        }
        if self.allowAutoSetup != nil {
            map["AllowAutoSetup"] = self.allowAutoSetup!
        }
        if self.allowBufferCount != nil {
            map["AllowBufferCount"] = self.allowBufferCount!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.bindAmount != nil {
            map["BindAmount"] = self.bindAmount!
        }
        if self.bundleId != nil {
            map["BundleId"] = self.bundleId!
        }
        if self.buyDesktopsCount != nil {
            map["BuyDesktopsCount"] = self.buyDesktopsCount!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.classify != nil {
            map["Classify"] = self.classify!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.comments != nil {
            map["Comments"] = self.comments!
        }
        if self.connectDuration != nil {
            map["ConnectDuration"] = self.connectDuration!
        }
        if self.dataDiskCategory != nil {
            map["DataDiskCategory"] = self.dataDiskCategory!
        }
        if self.dataDiskPerLevel != nil {
            map["DataDiskPerLevel"] = self.dataDiskPerLevel!
        }
        if self.dataDiskSize != nil {
            map["DataDiskSize"] = self.dataDiskSize!
        }
        if self.defaultInitDesktopCount != nil {
            map["DefaultInitDesktopCount"] = self.defaultInitDesktopCount!
        }
        if self.defaultLanguage != nil {
            map["DefaultLanguage"] = self.defaultLanguage!
        }
        if self.desktopGroupName != nil {
            map["DesktopGroupName"] = self.desktopGroupName!
        }
        if self.desktopType != nil {
            map["DesktopType"] = self.desktopType!
        }
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.endUserIds != nil {
            map["EndUserIds"] = self.endUserIds!
        }
        if self.exclusiveType != nil {
            map["ExclusiveType"] = self.exclusiveType!
        }
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        if self.groupAmount != nil {
            map["GroupAmount"] = self.groupAmount!
        }
        if self.groupVersion != nil {
            map["GroupVersion"] = self.groupVersion!
        }
        if self.hostname != nil {
            map["Hostname"] = self.hostname!
        }
        if self.idleDisconnectDuration != nil {
            map["IdleDisconnectDuration"] = self.idleDisconnectDuration!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.keepDuration != nil {
            map["KeepDuration"] = self.keepDuration!
        }
        if self.loadPolicy != nil {
            map["LoadPolicy"] = self.loadPolicy!
        }
        if self.maxDesktopsCount != nil {
            map["MaxDesktopsCount"] = self.maxDesktopsCount!
        }
        if self.minDesktopsCount != nil {
            map["MinDesktopsCount"] = self.minDesktopsCount!
        }
        if self.multiResource != nil {
            map["MultiResource"] = self.multiResource!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.ownType != nil {
            map["OwnType"] = self.ownType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.profileFollowSwitch != nil {
            map["ProfileFollowSwitch"] = self.profileFollowSwitch!
        }
        if self.promotionId != nil {
            map["PromotionId"] = self.promotionId!
        }
        if self.ratioThreshold != nil {
            map["RatioThreshold"] = self.ratioThreshold!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resetType != nil {
            map["ResetType"] = self.resetType!
        }
        if self.scaleStrategyId != nil {
            map["ScaleStrategyId"] = self.scaleStrategyId!
        }
        if self.sessionType != nil {
            map["SessionType"] = self.sessionType!
        }
        if self.snapshotPolicyId != nil {
            map["SnapshotPolicyId"] = self.snapshotPolicyId!
        }
        if self.stopDuration != nil {
            map["StopDuration"] = self.stopDuration!
        }
        if self.systemDiskCategory != nil {
            map["SystemDiskCategory"] = self.systemDiskCategory!
        }
        if self.systemDiskPerLevel != nil {
            map["SystemDiskPerLevel"] = self.systemDiskPerLevel!
        }
        if self.systemDiskSize != nil {
            map["SystemDiskSize"] = self.systemDiskSize!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.timerGroupId != nil {
            map["TimerGroupId"] = self.timerGroupId!
        }
        if self.userOuPath != nil {
            map["UserOuPath"] = self.userOuPath!
        }
        if self.volumeEncryptionEnabled != nil {
            map["VolumeEncryptionEnabled"] = self.volumeEncryptionEnabled!
        }
        if self.volumeEncryptionKey != nil {
            map["VolumeEncryptionKey"] = self.volumeEncryptionKey!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllClassifyUsers") {
            self.allClassifyUsers = dict["AllClassifyUsers"] as! Bool
        }
        if dict.keys.contains("AllowAutoSetup") {
            self.allowAutoSetup = dict["AllowAutoSetup"] as! Int32
        }
        if dict.keys.contains("AllowBufferCount") {
            self.allowBufferCount = dict["AllowBufferCount"] as! Int32
        }
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("BindAmount") {
            self.bindAmount = dict["BindAmount"] as! Int64
        }
        if dict.keys.contains("BundleId") {
            self.bundleId = dict["BundleId"] as! String
        }
        if dict.keys.contains("BuyDesktopsCount") {
            self.buyDesktopsCount = dict["BuyDesktopsCount"] as! Int32
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("Classify") {
            self.classify = dict["Classify"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Comments") {
            self.comments = dict["Comments"] as! String
        }
        if dict.keys.contains("ConnectDuration") {
            self.connectDuration = dict["ConnectDuration"] as! Int64
        }
        if dict.keys.contains("DataDiskCategory") {
            self.dataDiskCategory = dict["DataDiskCategory"] as! String
        }
        if dict.keys.contains("DataDiskPerLevel") {
            self.dataDiskPerLevel = dict["DataDiskPerLevel"] as! String
        }
        if dict.keys.contains("DataDiskSize") {
            self.dataDiskSize = dict["DataDiskSize"] as! Int32
        }
        if dict.keys.contains("DefaultInitDesktopCount") {
            self.defaultInitDesktopCount = dict["DefaultInitDesktopCount"] as! Int32
        }
        if dict.keys.contains("DefaultLanguage") {
            self.defaultLanguage = dict["DefaultLanguage"] as! String
        }
        if dict.keys.contains("DesktopGroupName") {
            self.desktopGroupName = dict["DesktopGroupName"] as! String
        }
        if dict.keys.contains("DesktopType") {
            self.desktopType = dict["DesktopType"] as! String
        }
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("EndUserIds") {
            self.endUserIds = dict["EndUserIds"] as! [String]
        }
        if dict.keys.contains("ExclusiveType") {
            self.exclusiveType = dict["ExclusiveType"] as! String
        }
        if dict.keys.contains("FileSystemId") {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
        if dict.keys.contains("GroupAmount") {
            self.groupAmount = dict["GroupAmount"] as! Int32
        }
        if dict.keys.contains("GroupVersion") {
            self.groupVersion = dict["GroupVersion"] as! Int32
        }
        if dict.keys.contains("Hostname") {
            self.hostname = dict["Hostname"] as! String
        }
        if dict.keys.contains("IdleDisconnectDuration") {
            self.idleDisconnectDuration = dict["IdleDisconnectDuration"] as! Int64
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("KeepDuration") {
            self.keepDuration = dict["KeepDuration"] as! Int64
        }
        if dict.keys.contains("LoadPolicy") {
            self.loadPolicy = dict["LoadPolicy"] as! Int64
        }
        if dict.keys.contains("MaxDesktopsCount") {
            self.maxDesktopsCount = dict["MaxDesktopsCount"] as! Int32
        }
        if dict.keys.contains("MinDesktopsCount") {
            self.minDesktopsCount = dict["MinDesktopsCount"] as! Int32
        }
        if dict.keys.contains("MultiResource") {
            self.multiResource = dict["MultiResource"] as! Bool
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("OwnType") {
            self.ownType = dict["OwnType"] as! Int32
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("ProfileFollowSwitch") {
            self.profileFollowSwitch = dict["ProfileFollowSwitch"] as! Bool
        }
        if dict.keys.contains("PromotionId") {
            self.promotionId = dict["PromotionId"] as! String
        }
        if dict.keys.contains("RatioThreshold") {
            self.ratioThreshold = dict["RatioThreshold"] as! Double
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResetType") {
            self.resetType = dict["ResetType"] as! Int64
        }
        if dict.keys.contains("ScaleStrategyId") {
            self.scaleStrategyId = dict["ScaleStrategyId"] as! String
        }
        if dict.keys.contains("SessionType") {
            self.sessionType = dict["SessionType"] as! String
        }
        if dict.keys.contains("SnapshotPolicyId") {
            self.snapshotPolicyId = dict["SnapshotPolicyId"] as! String
        }
        if dict.keys.contains("StopDuration") {
            self.stopDuration = dict["StopDuration"] as! Int64
        }
        if dict.keys.contains("SystemDiskCategory") {
            self.systemDiskCategory = dict["SystemDiskCategory"] as! String
        }
        if dict.keys.contains("SystemDiskPerLevel") {
            self.systemDiskPerLevel = dict["SystemDiskPerLevel"] as! String
        }
        if dict.keys.contains("SystemDiskSize") {
            self.systemDiskSize = dict["SystemDiskSize"] as! Int32
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateDesktopGroupRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateDesktopGroupRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TimerGroupId") {
            self.timerGroupId = dict["TimerGroupId"] as! String
        }
        if dict.keys.contains("UserOuPath") {
            self.userOuPath = dict["UserOuPath"] as! String
        }
        if dict.keys.contains("VolumeEncryptionEnabled") {
            self.volumeEncryptionEnabled = dict["VolumeEncryptionEnabled"] as! Bool
        }
        if dict.keys.contains("VolumeEncryptionKey") {
            self.volumeEncryptionKey = dict["VolumeEncryptionKey"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateDesktopGroupResponseBody : Tea.TeaModel {
    public var desktopGroupId: String?

    public var desktopGroupIds: [String]?

    public var orderIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.desktopGroupIds != nil {
            map["DesktopGroupIds"] = self.desktopGroupIds!
        }
        if self.orderIds != nil {
            map["OrderIds"] = self.orderIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("DesktopGroupIds") {
            self.desktopGroupIds = dict["DesktopGroupIds"] as! [String]
        }
        if dict.keys.contains("OrderIds") {
            self.orderIds = dict["OrderIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDesktopGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDesktopGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDesktopGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDesktopOversoldGroupRequest : Tea.TeaModel {
    public var concurrenceCount: Int32?

    public var dataDiskSize: Int32?

    public var description_: String?

    public var desktopType: String?

    public var directoryId: String?

    public var idleDisconnectDuration: Int64?

    public var imageId: String?

    public var keepDuration: Int32?

    public var name: String?

    public var oversoldUserCount: Int32?

    public var oversoldWarn: Int32?

    public var period: Int32?

    public var periodUnit: String?

    public var policyGroupId: String?

    public var stopDuration: Int32?

    public var systemDiskSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.concurrenceCount != nil {
            map["ConcurrenceCount"] = self.concurrenceCount!
        }
        if self.dataDiskSize != nil {
            map["DataDiskSize"] = self.dataDiskSize!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.desktopType != nil {
            map["DesktopType"] = self.desktopType!
        }
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.idleDisconnectDuration != nil {
            map["IdleDisconnectDuration"] = self.idleDisconnectDuration!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.keepDuration != nil {
            map["KeepDuration"] = self.keepDuration!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.oversoldUserCount != nil {
            map["OversoldUserCount"] = self.oversoldUserCount!
        }
        if self.oversoldWarn != nil {
            map["OversoldWarn"] = self.oversoldWarn!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.stopDuration != nil {
            map["StopDuration"] = self.stopDuration!
        }
        if self.systemDiskSize != nil {
            map["SystemDiskSize"] = self.systemDiskSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConcurrenceCount") {
            self.concurrenceCount = dict["ConcurrenceCount"] as! Int32
        }
        if dict.keys.contains("DataDiskSize") {
            self.dataDiskSize = dict["DataDiskSize"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DesktopType") {
            self.desktopType = dict["DesktopType"] as! String
        }
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("IdleDisconnectDuration") {
            self.idleDisconnectDuration = dict["IdleDisconnectDuration"] as! Int64
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("KeepDuration") {
            self.keepDuration = dict["KeepDuration"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OversoldUserCount") {
            self.oversoldUserCount = dict["OversoldUserCount"] as! Int32
        }
        if dict.keys.contains("OversoldWarn") {
            self.oversoldWarn = dict["OversoldWarn"] as! Int32
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("StopDuration") {
            self.stopDuration = dict["StopDuration"] as! Int32
        }
        if dict.keys.contains("SystemDiskSize") {
            self.systemDiskSize = dict["SystemDiskSize"] as! Int32
        }
    }
}

public class CreateDesktopOversoldGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var orderId: Int64?

        public var oversoldGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.oversoldGroupId != nil {
                map["OversoldGroupId"] = self.oversoldGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OrderId") {
                self.orderId = dict["OrderId"] as! Int64
            }
            if dict.keys.contains("OversoldGroupId") {
                self.oversoldGroupId = dict["OversoldGroupId"] as! String
            }
        }
    }
    public var data: CreateDesktopOversoldGroupResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = CreateDesktopOversoldGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDesktopOversoldGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDesktopOversoldGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDesktopOversoldGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDesktopsRequest : Tea.TeaModel {
    public class BundleModels : Tea.TeaModel {
        public var amount: Int32?

        public var bundleId: String?

        public var desktopName: String?

        public var endUserIds: [String]?

        public var hostname: String?

        public var volumeEncryptionEnabled: Bool?

        public var volumeEncryptionKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.amount != nil {
                map["Amount"] = self.amount!
            }
            if self.bundleId != nil {
                map["BundleId"] = self.bundleId!
            }
            if self.desktopName != nil {
                map["DesktopName"] = self.desktopName!
            }
            if self.endUserIds != nil {
                map["EndUserIds"] = self.endUserIds!
            }
            if self.hostname != nil {
                map["Hostname"] = self.hostname!
            }
            if self.volumeEncryptionEnabled != nil {
                map["VolumeEncryptionEnabled"] = self.volumeEncryptionEnabled!
            }
            if self.volumeEncryptionKey != nil {
                map["VolumeEncryptionKey"] = self.volumeEncryptionKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Amount") {
                self.amount = dict["Amount"] as! Int32
            }
            if dict.keys.contains("BundleId") {
                self.bundleId = dict["BundleId"] as! String
            }
            if dict.keys.contains("DesktopName") {
                self.desktopName = dict["DesktopName"] as! String
            }
            if dict.keys.contains("EndUserIds") {
                self.endUserIds = dict["EndUserIds"] as! [String]
            }
            if dict.keys.contains("Hostname") {
                self.hostname = dict["Hostname"] as! String
            }
            if dict.keys.contains("VolumeEncryptionEnabled") {
                self.volumeEncryptionEnabled = dict["VolumeEncryptionEnabled"] as! Bool
            }
            if dict.keys.contains("VolumeEncryptionKey") {
                self.volumeEncryptionKey = dict["VolumeEncryptionKey"] as! String
            }
        }
    }
    public class DesktopAttachment : Tea.TeaModel {
        public var dataDiskCategory: String?

        public var dataDiskPerLevel: String?

        public var dataDiskSize: Int32?

        public var defaultLanguage: String?

        public var desktopType: String?

        public var imageId: String?

        public var systemDiskCategory: String?

        public var systemDiskPerLevel: String?

        public var systemDiskSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataDiskCategory != nil {
                map["DataDiskCategory"] = self.dataDiskCategory!
            }
            if self.dataDiskPerLevel != nil {
                map["DataDiskPerLevel"] = self.dataDiskPerLevel!
            }
            if self.dataDiskSize != nil {
                map["DataDiskSize"] = self.dataDiskSize!
            }
            if self.defaultLanguage != nil {
                map["DefaultLanguage"] = self.defaultLanguage!
            }
            if self.desktopType != nil {
                map["DesktopType"] = self.desktopType!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.systemDiskCategory != nil {
                map["SystemDiskCategory"] = self.systemDiskCategory!
            }
            if self.systemDiskPerLevel != nil {
                map["SystemDiskPerLevel"] = self.systemDiskPerLevel!
            }
            if self.systemDiskSize != nil {
                map["SystemDiskSize"] = self.systemDiskSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataDiskCategory") {
                self.dataDiskCategory = dict["DataDiskCategory"] as! String
            }
            if dict.keys.contains("DataDiskPerLevel") {
                self.dataDiskPerLevel = dict["DataDiskPerLevel"] as! String
            }
            if dict.keys.contains("DataDiskSize") {
                self.dataDiskSize = dict["DataDiskSize"] as! Int32
            }
            if dict.keys.contains("DefaultLanguage") {
                self.defaultLanguage = dict["DefaultLanguage"] as! String
            }
            if dict.keys.contains("DesktopType") {
                self.desktopType = dict["DesktopType"] as! String
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("SystemDiskCategory") {
                self.systemDiskCategory = dict["SystemDiskCategory"] as! String
            }
            if dict.keys.contains("SystemDiskPerLevel") {
                self.systemDiskPerLevel = dict["SystemDiskPerLevel"] as! String
            }
            if dict.keys.contains("SystemDiskSize") {
                self.systemDiskSize = dict["SystemDiskSize"] as! Int32
            }
        }
    }
    public class DesktopTimers : Tea.TeaModel {
        public var allowClientSetting: Bool?

        public var cronExpression: String?

        public var enforce: Bool?

        public var interval: Int32?

        public var operationType: String?

        public var resetType: String?

        public var timerType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowClientSetting != nil {
                map["AllowClientSetting"] = self.allowClientSetting!
            }
            if self.cronExpression != nil {
                map["CronExpression"] = self.cronExpression!
            }
            if self.enforce != nil {
                map["Enforce"] = self.enforce!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.operationType != nil {
                map["OperationType"] = self.operationType!
            }
            if self.resetType != nil {
                map["ResetType"] = self.resetType!
            }
            if self.timerType != nil {
                map["TimerType"] = self.timerType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowClientSetting") {
                self.allowClientSetting = dict["AllowClientSetting"] as! Bool
            }
            if dict.keys.contains("CronExpression") {
                self.cronExpression = dict["CronExpression"] as! String
            }
            if dict.keys.contains("Enforce") {
                self.enforce = dict["Enforce"] as! Bool
            }
            if dict.keys.contains("Interval") {
                self.interval = dict["Interval"] as! Int32
            }
            if dict.keys.contains("OperationType") {
                self.operationType = dict["OperationType"] as! String
            }
            if dict.keys.contains("ResetType") {
                self.resetType = dict["ResetType"] as! String
            }
            if dict.keys.contains("TimerType") {
                self.timerType = dict["TimerType"] as! String
            }
        }
    }
    public class MonthDesktopSetting : Tea.TeaModel {
        public var buyerId: Int64?

        public var desktopId: String?

        public var useDuration: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.buyerId != nil {
                map["BuyerId"] = self.buyerId!
            }
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.useDuration != nil {
                map["UseDuration"] = self.useDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BuyerId") {
                self.buyerId = dict["BuyerId"] as! Int64
            }
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("UseDuration") {
                self.useDuration = dict["UseDuration"] as! Int32
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class UserCommands : Tea.TeaModel {
        public var content: String?

        public var contentEncoding: String?

        public var contentType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.contentEncoding != nil {
                map["ContentEncoding"] = self.contentEncoding!
            }
            if self.contentType != nil {
                map["ContentType"] = self.contentType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("ContentEncoding") {
                self.contentEncoding = dict["ContentEncoding"] as! String
            }
            if dict.keys.contains("ContentType") {
                self.contentType = dict["ContentType"] as! String
            }
        }
    }
    public var amount: Int32?

    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var bundleId: String?

    public var bundleModels: [CreateDesktopsRequest.BundleModels]?

    public var chargeType: String?

    public var desktopAttachment: CreateDesktopsRequest.DesktopAttachment?

    public var desktopMemberIp: String?

    public var desktopName: String?

    public var desktopNameSuffix: Bool?

    public var desktopTimers: [CreateDesktopsRequest.DesktopTimers]?

    public var directoryId: String?

    public var endUserId: [String]?

    public var extendInfo: String?

    public var groupId: String?

    public var hostname: String?

    public var monthDesktopSetting: CreateDesktopsRequest.MonthDesktopSetting?

    public var officeSiteId: String?

    public var period: Int32?

    public var periodUnit: String?

    public var policyGroupId: String?

    public var promotionId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var savingPlanId: String?

    public var snapshotPolicyId: String?

    public var tag: [CreateDesktopsRequest.Tag]?

    public var timerGroupId: String?

    public var userAssignMode: String?

    public var userCommands: [CreateDesktopsRequest.UserCommands]?

    public var userName: String?

    public var volumeEncryptionEnabled: Bool?

    public var volumeEncryptionKey: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.desktopAttachment?.validate()
        try self.monthDesktopSetting?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.bundleId != nil {
            map["BundleId"] = self.bundleId!
        }
        if self.bundleModels != nil {
            var tmp : [Any] = []
            for k in self.bundleModels! {
                tmp.append(k.toMap())
            }
            map["BundleModels"] = tmp
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.desktopAttachment != nil {
            map["DesktopAttachment"] = self.desktopAttachment?.toMap()
        }
        if self.desktopMemberIp != nil {
            map["DesktopMemberIp"] = self.desktopMemberIp!
        }
        if self.desktopName != nil {
            map["DesktopName"] = self.desktopName!
        }
        if self.desktopNameSuffix != nil {
            map["DesktopNameSuffix"] = self.desktopNameSuffix!
        }
        if self.desktopTimers != nil {
            var tmp : [Any] = []
            for k in self.desktopTimers! {
                tmp.append(k.toMap())
            }
            map["DesktopTimers"] = tmp
        }
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.hostname != nil {
            map["Hostname"] = self.hostname!
        }
        if self.monthDesktopSetting != nil {
            map["MonthDesktopSetting"] = self.monthDesktopSetting?.toMap()
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.promotionId != nil {
            map["PromotionId"] = self.promotionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.savingPlanId != nil {
            map["SavingPlanId"] = self.savingPlanId!
        }
        if self.snapshotPolicyId != nil {
            map["SnapshotPolicyId"] = self.snapshotPolicyId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.timerGroupId != nil {
            map["TimerGroupId"] = self.timerGroupId!
        }
        if self.userAssignMode != nil {
            map["UserAssignMode"] = self.userAssignMode!
        }
        if self.userCommands != nil {
            var tmp : [Any] = []
            for k in self.userCommands! {
                tmp.append(k.toMap())
            }
            map["UserCommands"] = tmp
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.volumeEncryptionEnabled != nil {
            map["VolumeEncryptionEnabled"] = self.volumeEncryptionEnabled!
        }
        if self.volumeEncryptionKey != nil {
            map["VolumeEncryptionKey"] = self.volumeEncryptionKey!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("BundleId") {
            self.bundleId = dict["BundleId"] as! String
        }
        if dict.keys.contains("BundleModels") {
            var tmp : [CreateDesktopsRequest.BundleModels] = []
            for v in dict["BundleModels"] as! [Any] {
                var model = CreateDesktopsRequest.BundleModels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bundleModels = tmp
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("DesktopAttachment") {
            var model = CreateDesktopsRequest.DesktopAttachment()
            model.fromMap(dict["DesktopAttachment"] as! [String: Any])
            self.desktopAttachment = model
        }
        if dict.keys.contains("DesktopMemberIp") {
            self.desktopMemberIp = dict["DesktopMemberIp"] as! String
        }
        if dict.keys.contains("DesktopName") {
            self.desktopName = dict["DesktopName"] as! String
        }
        if dict.keys.contains("DesktopNameSuffix") {
            self.desktopNameSuffix = dict["DesktopNameSuffix"] as! Bool
        }
        if dict.keys.contains("DesktopTimers") {
            var tmp : [CreateDesktopsRequest.DesktopTimers] = []
            for v in dict["DesktopTimers"] as! [Any] {
                var model = CreateDesktopsRequest.DesktopTimers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.desktopTimers = tmp
        }
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! [String]
        }
        if dict.keys.contains("ExtendInfo") {
            self.extendInfo = dict["ExtendInfo"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Hostname") {
            self.hostname = dict["Hostname"] as! String
        }
        if dict.keys.contains("MonthDesktopSetting") {
            var model = CreateDesktopsRequest.MonthDesktopSetting()
            model.fromMap(dict["MonthDesktopSetting"] as! [String: Any])
            self.monthDesktopSetting = model
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("PromotionId") {
            self.promotionId = dict["PromotionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SavingPlanId") {
            self.savingPlanId = dict["SavingPlanId"] as! String
        }
        if dict.keys.contains("SnapshotPolicyId") {
            self.snapshotPolicyId = dict["SnapshotPolicyId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateDesktopsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateDesktopsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TimerGroupId") {
            self.timerGroupId = dict["TimerGroupId"] as! String
        }
        if dict.keys.contains("UserAssignMode") {
            self.userAssignMode = dict["UserAssignMode"] as! String
        }
        if dict.keys.contains("UserCommands") {
            var tmp : [CreateDesktopsRequest.UserCommands] = []
            for v in dict["UserCommands"] as! [Any] {
                var model = CreateDesktopsRequest.UserCommands()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.userCommands = tmp
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
        if dict.keys.contains("VolumeEncryptionEnabled") {
            self.volumeEncryptionEnabled = dict["VolumeEncryptionEnabled"] as! Bool
        }
        if dict.keys.contains("VolumeEncryptionKey") {
            self.volumeEncryptionKey = dict["VolumeEncryptionKey"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateDesktopsShrinkRequest : Tea.TeaModel {
    public class BundleModels : Tea.TeaModel {
        public var amount: Int32?

        public var bundleId: String?

        public var desktopName: String?

        public var endUserIds: [String]?

        public var hostname: String?

        public var volumeEncryptionEnabled: Bool?

        public var volumeEncryptionKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.amount != nil {
                map["Amount"] = self.amount!
            }
            if self.bundleId != nil {
                map["BundleId"] = self.bundleId!
            }
            if self.desktopName != nil {
                map["DesktopName"] = self.desktopName!
            }
            if self.endUserIds != nil {
                map["EndUserIds"] = self.endUserIds!
            }
            if self.hostname != nil {
                map["Hostname"] = self.hostname!
            }
            if self.volumeEncryptionEnabled != nil {
                map["VolumeEncryptionEnabled"] = self.volumeEncryptionEnabled!
            }
            if self.volumeEncryptionKey != nil {
                map["VolumeEncryptionKey"] = self.volumeEncryptionKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Amount") {
                self.amount = dict["Amount"] as! Int32
            }
            if dict.keys.contains("BundleId") {
                self.bundleId = dict["BundleId"] as! String
            }
            if dict.keys.contains("DesktopName") {
                self.desktopName = dict["DesktopName"] as! String
            }
            if dict.keys.contains("EndUserIds") {
                self.endUserIds = dict["EndUserIds"] as! [String]
            }
            if dict.keys.contains("Hostname") {
                self.hostname = dict["Hostname"] as! String
            }
            if dict.keys.contains("VolumeEncryptionEnabled") {
                self.volumeEncryptionEnabled = dict["VolumeEncryptionEnabled"] as! Bool
            }
            if dict.keys.contains("VolumeEncryptionKey") {
                self.volumeEncryptionKey = dict["VolumeEncryptionKey"] as! String
            }
        }
    }
    public class DesktopTimers : Tea.TeaModel {
        public var allowClientSetting: Bool?

        public var cronExpression: String?

        public var enforce: Bool?

        public var interval: Int32?

        public var operationType: String?

        public var resetType: String?

        public var timerType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowClientSetting != nil {
                map["AllowClientSetting"] = self.allowClientSetting!
            }
            if self.cronExpression != nil {
                map["CronExpression"] = self.cronExpression!
            }
            if self.enforce != nil {
                map["Enforce"] = self.enforce!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.operationType != nil {
                map["OperationType"] = self.operationType!
            }
            if self.resetType != nil {
                map["ResetType"] = self.resetType!
            }
            if self.timerType != nil {
                map["TimerType"] = self.timerType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowClientSetting") {
                self.allowClientSetting = dict["AllowClientSetting"] as! Bool
            }
            if dict.keys.contains("CronExpression") {
                self.cronExpression = dict["CronExpression"] as! String
            }
            if dict.keys.contains("Enforce") {
                self.enforce = dict["Enforce"] as! Bool
            }
            if dict.keys.contains("Interval") {
                self.interval = dict["Interval"] as! Int32
            }
            if dict.keys.contains("OperationType") {
                self.operationType = dict["OperationType"] as! String
            }
            if dict.keys.contains("ResetType") {
                self.resetType = dict["ResetType"] as! String
            }
            if dict.keys.contains("TimerType") {
                self.timerType = dict["TimerType"] as! String
            }
        }
    }
    public class MonthDesktopSetting : Tea.TeaModel {
        public var buyerId: Int64?

        public var desktopId: String?

        public var useDuration: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.buyerId != nil {
                map["BuyerId"] = self.buyerId!
            }
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.useDuration != nil {
                map["UseDuration"] = self.useDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BuyerId") {
                self.buyerId = dict["BuyerId"] as! Int64
            }
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("UseDuration") {
                self.useDuration = dict["UseDuration"] as! Int32
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class UserCommands : Tea.TeaModel {
        public var content: String?

        public var contentEncoding: String?

        public var contentType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.contentEncoding != nil {
                map["ContentEncoding"] = self.contentEncoding!
            }
            if self.contentType != nil {
                map["ContentType"] = self.contentType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("ContentEncoding") {
                self.contentEncoding = dict["ContentEncoding"] as! String
            }
            if dict.keys.contains("ContentType") {
                self.contentType = dict["ContentType"] as! String
            }
        }
    }
    public var amount: Int32?

    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var bundleId: String?

    public var bundleModels: [CreateDesktopsShrinkRequest.BundleModels]?

    public var chargeType: String?

    public var desktopAttachmentShrink: String?

    public var desktopMemberIp: String?

    public var desktopName: String?

    public var desktopNameSuffix: Bool?

    public var desktopTimers: [CreateDesktopsShrinkRequest.DesktopTimers]?

    public var directoryId: String?

    public var endUserId: [String]?

    public var extendInfo: String?

    public var groupId: String?

    public var hostname: String?

    public var monthDesktopSetting: CreateDesktopsShrinkRequest.MonthDesktopSetting?

    public var officeSiteId: String?

    public var period: Int32?

    public var periodUnit: String?

    public var policyGroupId: String?

    public var promotionId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var savingPlanId: String?

    public var snapshotPolicyId: String?

    public var tag: [CreateDesktopsShrinkRequest.Tag]?

    public var timerGroupId: String?

    public var userAssignMode: String?

    public var userCommands: [CreateDesktopsShrinkRequest.UserCommands]?

    public var userName: String?

    public var volumeEncryptionEnabled: Bool?

    public var volumeEncryptionKey: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monthDesktopSetting?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.bundleId != nil {
            map["BundleId"] = self.bundleId!
        }
        if self.bundleModels != nil {
            var tmp : [Any] = []
            for k in self.bundleModels! {
                tmp.append(k.toMap())
            }
            map["BundleModels"] = tmp
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.desktopAttachmentShrink != nil {
            map["DesktopAttachment"] = self.desktopAttachmentShrink!
        }
        if self.desktopMemberIp != nil {
            map["DesktopMemberIp"] = self.desktopMemberIp!
        }
        if self.desktopName != nil {
            map["DesktopName"] = self.desktopName!
        }
        if self.desktopNameSuffix != nil {
            map["DesktopNameSuffix"] = self.desktopNameSuffix!
        }
        if self.desktopTimers != nil {
            var tmp : [Any] = []
            for k in self.desktopTimers! {
                tmp.append(k.toMap())
            }
            map["DesktopTimers"] = tmp
        }
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.hostname != nil {
            map["Hostname"] = self.hostname!
        }
        if self.monthDesktopSetting != nil {
            map["MonthDesktopSetting"] = self.monthDesktopSetting?.toMap()
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.promotionId != nil {
            map["PromotionId"] = self.promotionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.savingPlanId != nil {
            map["SavingPlanId"] = self.savingPlanId!
        }
        if self.snapshotPolicyId != nil {
            map["SnapshotPolicyId"] = self.snapshotPolicyId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.timerGroupId != nil {
            map["TimerGroupId"] = self.timerGroupId!
        }
        if self.userAssignMode != nil {
            map["UserAssignMode"] = self.userAssignMode!
        }
        if self.userCommands != nil {
            var tmp : [Any] = []
            for k in self.userCommands! {
                tmp.append(k.toMap())
            }
            map["UserCommands"] = tmp
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.volumeEncryptionEnabled != nil {
            map["VolumeEncryptionEnabled"] = self.volumeEncryptionEnabled!
        }
        if self.volumeEncryptionKey != nil {
            map["VolumeEncryptionKey"] = self.volumeEncryptionKey!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("BundleId") {
            self.bundleId = dict["BundleId"] as! String
        }
        if dict.keys.contains("BundleModels") {
            var tmp : [CreateDesktopsShrinkRequest.BundleModels] = []
            for v in dict["BundleModels"] as! [Any] {
                var model = CreateDesktopsShrinkRequest.BundleModels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bundleModels = tmp
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("DesktopAttachment") {
            self.desktopAttachmentShrink = dict["DesktopAttachment"] as! String
        }
        if dict.keys.contains("DesktopMemberIp") {
            self.desktopMemberIp = dict["DesktopMemberIp"] as! String
        }
        if dict.keys.contains("DesktopName") {
            self.desktopName = dict["DesktopName"] as! String
        }
        if dict.keys.contains("DesktopNameSuffix") {
            self.desktopNameSuffix = dict["DesktopNameSuffix"] as! Bool
        }
        if dict.keys.contains("DesktopTimers") {
            var tmp : [CreateDesktopsShrinkRequest.DesktopTimers] = []
            for v in dict["DesktopTimers"] as! [Any] {
                var model = CreateDesktopsShrinkRequest.DesktopTimers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.desktopTimers = tmp
        }
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! [String]
        }
        if dict.keys.contains("ExtendInfo") {
            self.extendInfo = dict["ExtendInfo"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Hostname") {
            self.hostname = dict["Hostname"] as! String
        }
        if dict.keys.contains("MonthDesktopSetting") {
            var model = CreateDesktopsShrinkRequest.MonthDesktopSetting()
            model.fromMap(dict["MonthDesktopSetting"] as! [String: Any])
            self.monthDesktopSetting = model
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("PromotionId") {
            self.promotionId = dict["PromotionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SavingPlanId") {
            self.savingPlanId = dict["SavingPlanId"] as! String
        }
        if dict.keys.contains("SnapshotPolicyId") {
            self.snapshotPolicyId = dict["SnapshotPolicyId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateDesktopsShrinkRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateDesktopsShrinkRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TimerGroupId") {
            self.timerGroupId = dict["TimerGroupId"] as! String
        }
        if dict.keys.contains("UserAssignMode") {
            self.userAssignMode = dict["UserAssignMode"] as! String
        }
        if dict.keys.contains("UserCommands") {
            var tmp : [CreateDesktopsShrinkRequest.UserCommands] = []
            for v in dict["UserCommands"] as! [Any] {
                var model = CreateDesktopsShrinkRequest.UserCommands()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.userCommands = tmp
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
        if dict.keys.contains("VolumeEncryptionEnabled") {
            self.volumeEncryptionEnabled = dict["VolumeEncryptionEnabled"] as! Bool
        }
        if dict.keys.contains("VolumeEncryptionKey") {
            self.volumeEncryptionKey = dict["VolumeEncryptionKey"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateDesktopsResponseBody : Tea.TeaModel {
    public var desktopId: [String]?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDesktopsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDesktopsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDesktopsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDiskEncryptionServiceRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateDiskEncryptionServiceResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDiskEncryptionServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDiskEncryptionServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDiskEncryptionServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateImageRequest : Tea.TeaModel {
    public var autoCleanUserdata: Bool?

    public var dataSnapshotIds: [String]?

    public var description_: String?

    public var desktopId: String?

    public var diskType: String?

    public var imageName: String?

    public var imageResourceType: String?

    public var regionId: String?

    public var snapshotId: String?

    public var snapshotIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoCleanUserdata != nil {
            map["AutoCleanUserdata"] = self.autoCleanUserdata!
        }
        if self.dataSnapshotIds != nil {
            map["DataSnapshotIds"] = self.dataSnapshotIds!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.diskType != nil {
            map["DiskType"] = self.diskType!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.imageResourceType != nil {
            map["ImageResourceType"] = self.imageResourceType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.snapshotIds != nil {
            map["SnapshotIds"] = self.snapshotIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoCleanUserdata") {
            self.autoCleanUserdata = dict["AutoCleanUserdata"] as! Bool
        }
        if dict.keys.contains("DataSnapshotIds") {
            self.dataSnapshotIds = dict["DataSnapshotIds"] as! [String]
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("DiskType") {
            self.diskType = dict["DiskType"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("ImageResourceType") {
            self.imageResourceType = dict["ImageResourceType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("SnapshotIds") {
            self.snapshotIds = dict["SnapshotIds"] as! [String]
        }
    }
}

public class CreateImageResponseBody : Tea.TeaModel {
    public var imageId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNASFileSystemRequest : Tea.TeaModel {
    public var description_: String?

    public var encryptType: String?

    public var name: String?

    public var officeSiteId: String?

    public var regionId: String?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.encryptType != nil {
            map["EncryptType"] = self.encryptType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EncryptType") {
            self.encryptType = dict["EncryptType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StorageType") {
            self.storageType = dict["StorageType"] as! String
        }
    }
}

public class CreateNASFileSystemResponseBody : Tea.TeaModel {
    public var fileSystemId: String?

    public var fileSystemName: String?

    public var mountTargetDomain: String?

    public var officeSiteId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        if self.fileSystemName != nil {
            map["FileSystemName"] = self.fileSystemName!
        }
        if self.mountTargetDomain != nil {
            map["MountTargetDomain"] = self.mountTargetDomain!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileSystemId") {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
        if dict.keys.contains("FileSystemName") {
            self.fileSystemName = dict["FileSystemName"] as! String
        }
        if dict.keys.contains("MountTargetDomain") {
            self.mountTargetDomain = dict["MountTargetDomain"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNASFileSystemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNASFileSystemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNASFileSystemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNetworkPackageRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var bandwidth: Int32?

    public var internetChargeType: String?

    public var officeSiteId: String?

    public var payType: String?

    public var period: Int32?

    public var periodUnit: String?

    public var promotionId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.promotionId != nil {
            map["PromotionId"] = self.promotionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PromotionId") {
            self.promotionId = dict["PromotionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateNetworkPackageResponseBody : Tea.TeaModel {
    public var networkPackageId: String?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkPackageId != nil {
            map["NetworkPackageId"] = self.networkPackageId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkPackageId") {
            self.networkPackageId = dict["NetworkPackageId"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNetworkPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNetworkPackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePolicyGroupRequest : Tea.TeaModel {
    public class AuthorizeAccessPolicyRule : Tea.TeaModel {
        public var cidrIp: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrIp != nil {
                map["CidrIp"] = self.cidrIp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrIp") {
                self.cidrIp = dict["CidrIp"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
        }
    }
    public class AuthorizeSecurityPolicyRule : Tea.TeaModel {
        public var cidrIp: String?

        public var description_: String?

        public var ipProtocol: String?

        public var policy: String?

        public var portRange: String?

        public var priority: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrIp != nil {
                map["CidrIp"] = self.cidrIp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrIp") {
                self.cidrIp = dict["CidrIp"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ClientType : Tea.TeaModel {
        public var clientType: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientType != nil {
                map["ClientType"] = self.clientType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientType") {
                self.clientType = dict["ClientType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class DeviceRedirects : Tea.TeaModel {
        public var deviceType: String?

        public var redirectType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceType != nil {
                map["DeviceType"] = self.deviceType!
            }
            if self.redirectType != nil {
                map["RedirectType"] = self.redirectType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceType") {
                self.deviceType = dict["DeviceType"] as! String
            }
            if dict.keys.contains("RedirectType") {
                self.redirectType = dict["RedirectType"] as! String
            }
        }
    }
    public class DeviceRules : Tea.TeaModel {
        public var deviceName: String?

        public var devicePid: String?

        public var deviceType: String?

        public var deviceVid: String?

        public var optCommand: String?

        public var redirectType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceName != nil {
                map["DeviceName"] = self.deviceName!
            }
            if self.devicePid != nil {
                map["DevicePid"] = self.devicePid!
            }
            if self.deviceType != nil {
                map["DeviceType"] = self.deviceType!
            }
            if self.deviceVid != nil {
                map["DeviceVid"] = self.deviceVid!
            }
            if self.optCommand != nil {
                map["OptCommand"] = self.optCommand!
            }
            if self.redirectType != nil {
                map["RedirectType"] = self.redirectType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceName") {
                self.deviceName = dict["DeviceName"] as! String
            }
            if dict.keys.contains("DevicePid") {
                self.devicePid = dict["DevicePid"] as! String
            }
            if dict.keys.contains("DeviceType") {
                self.deviceType = dict["DeviceType"] as! String
            }
            if dict.keys.contains("DeviceVid") {
                self.deviceVid = dict["DeviceVid"] as! String
            }
            if dict.keys.contains("OptCommand") {
                self.optCommand = dict["OptCommand"] as! String
            }
            if dict.keys.contains("RedirectType") {
                self.redirectType = dict["RedirectType"] as! String
            }
        }
    }
    public class DomainResolveRule : Tea.TeaModel {
        public var description_: String?

        public var domain: String?

        public var policy: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
        }
    }
    public class UsbSupplyRedirectRule : Tea.TeaModel {
        public var description_: String?

        public var deviceClass: String?

        public var deviceSubclass: String?

        public var productId: String?

        public var usbRedirectType: Int64?

        public var usbRuleType: Int64?

        public var vendorId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.deviceClass != nil {
                map["DeviceClass"] = self.deviceClass!
            }
            if self.deviceSubclass != nil {
                map["DeviceSubclass"] = self.deviceSubclass!
            }
            if self.productId != nil {
                map["ProductId"] = self.productId!
            }
            if self.usbRedirectType != nil {
                map["UsbRedirectType"] = self.usbRedirectType!
            }
            if self.usbRuleType != nil {
                map["UsbRuleType"] = self.usbRuleType!
            }
            if self.vendorId != nil {
                map["VendorId"] = self.vendorId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DeviceClass") {
                self.deviceClass = dict["DeviceClass"] as! String
            }
            if dict.keys.contains("DeviceSubclass") {
                self.deviceSubclass = dict["DeviceSubclass"] as! String
            }
            if dict.keys.contains("ProductId") {
                self.productId = dict["ProductId"] as! String
            }
            if dict.keys.contains("UsbRedirectType") {
                self.usbRedirectType = dict["UsbRedirectType"] as! Int64
            }
            if dict.keys.contains("UsbRuleType") {
                self.usbRuleType = dict["UsbRuleType"] as! Int64
            }
            if dict.keys.contains("VendorId") {
                self.vendorId = dict["VendorId"] as! String
            }
        }
    }
    public var adminAccess: String?

    public var appContentProtection: String?

    public var authorizeAccessPolicyRule: [CreatePolicyGroupRequest.AuthorizeAccessPolicyRule]?

    public var authorizeSecurityPolicyRule: [CreatePolicyGroupRequest.AuthorizeSecurityPolicyRule]?

    public var cameraRedirect: String?

    public var clientType: [CreatePolicyGroupRequest.ClientType]?

    public var clipboard: String?

    public var deviceRedirects: [CreatePolicyGroupRequest.DeviceRedirects]?

    public var deviceRules: [CreatePolicyGroupRequest.DeviceRules]?

    public var domainList: String?

    public var domainResolveRule: [CreatePolicyGroupRequest.DomainResolveRule]?

    public var domainResolveRuleType: String?

    public var endUserApplyAdminCoordinate: String?

    public var endUserGroupCoordinate: String?

    public var gpuAcceleration: String?

    public var html5Access: String?

    public var html5FileTransfer: String?

    public var internetCommunicationProtocol: String?

    public var localDrive: String?

    public var maxReconnectTime: Int32?

    public var name: String?

    public var netRedirect: String?

    public var preemptLogin: String?

    public var preemptLoginUser: [String]?

    public var printerRedirection: String?

    public var recordContent: String?

    public var recordContentExpires: Int64?

    public var recording: String?

    public var recordingAudio: String?

    public var recordingDuration: Int32?

    public var recordingEndTime: String?

    public var recordingExpires: Int64?

    public var recordingFps: Int64?

    public var recordingStartTime: String?

    public var recordingUserNotify: String?

    public var recordingUserNotifyMessage: String?

    public var regionId: String?

    public var remoteCoordinate: String?

    public var scope: String?

    public var scopeValue: [String]?

    public var usbRedirect: String?

    public var usbSupplyRedirectRule: [CreatePolicyGroupRequest.UsbSupplyRedirectRule]?

    public var videoRedirect: String?

    public var visualQuality: String?

    public var watermark: String?

    public var watermarkAntiCam: String?

    public var watermarkColor: Int32?

    public var watermarkDegree: Double?

    public var watermarkFontSize: Int32?

    public var watermarkFontStyle: String?

    public var watermarkPower: String?

    public var watermarkRowAmount: Int32?

    public var watermarkSecurity: String?

    public var watermarkTransparency: String?

    public var watermarkTransparencyValue: Int32?

    public var watermarkType: String?

    public var wyAssistant: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adminAccess != nil {
            map["AdminAccess"] = self.adminAccess!
        }
        if self.appContentProtection != nil {
            map["AppContentProtection"] = self.appContentProtection!
        }
        if self.authorizeAccessPolicyRule != nil {
            var tmp : [Any] = []
            for k in self.authorizeAccessPolicyRule! {
                tmp.append(k.toMap())
            }
            map["AuthorizeAccessPolicyRule"] = tmp
        }
        if self.authorizeSecurityPolicyRule != nil {
            var tmp : [Any] = []
            for k in self.authorizeSecurityPolicyRule! {
                tmp.append(k.toMap())
            }
            map["AuthorizeSecurityPolicyRule"] = tmp
        }
        if self.cameraRedirect != nil {
            map["CameraRedirect"] = self.cameraRedirect!
        }
        if self.clientType != nil {
            var tmp : [Any] = []
            for k in self.clientType! {
                tmp.append(k.toMap())
            }
            map["ClientType"] = tmp
        }
        if self.clipboard != nil {
            map["Clipboard"] = self.clipboard!
        }
        if self.deviceRedirects != nil {
            var tmp : [Any] = []
            for k in self.deviceRedirects! {
                tmp.append(k.toMap())
            }
            map["DeviceRedirects"] = tmp
        }
        if self.deviceRules != nil {
            var tmp : [Any] = []
            for k in self.deviceRules! {
                tmp.append(k.toMap())
            }
            map["DeviceRules"] = tmp
        }
        if self.domainList != nil {
            map["DomainList"] = self.domainList!
        }
        if self.domainResolveRule != nil {
            var tmp : [Any] = []
            for k in self.domainResolveRule! {
                tmp.append(k.toMap())
            }
            map["DomainResolveRule"] = tmp
        }
        if self.domainResolveRuleType != nil {
            map["DomainResolveRuleType"] = self.domainResolveRuleType!
        }
        if self.endUserApplyAdminCoordinate != nil {
            map["EndUserApplyAdminCoordinate"] = self.endUserApplyAdminCoordinate!
        }
        if self.endUserGroupCoordinate != nil {
            map["EndUserGroupCoordinate"] = self.endUserGroupCoordinate!
        }
        if self.gpuAcceleration != nil {
            map["GpuAcceleration"] = self.gpuAcceleration!
        }
        if self.html5Access != nil {
            map["Html5Access"] = self.html5Access!
        }
        if self.html5FileTransfer != nil {
            map["Html5FileTransfer"] = self.html5FileTransfer!
        }
        if self.internetCommunicationProtocol != nil {
            map["InternetCommunicationProtocol"] = self.internetCommunicationProtocol!
        }
        if self.localDrive != nil {
            map["LocalDrive"] = self.localDrive!
        }
        if self.maxReconnectTime != nil {
            map["MaxReconnectTime"] = self.maxReconnectTime!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.netRedirect != nil {
            map["NetRedirect"] = self.netRedirect!
        }
        if self.preemptLogin != nil {
            map["PreemptLogin"] = self.preemptLogin!
        }
        if self.preemptLoginUser != nil {
            map["PreemptLoginUser"] = self.preemptLoginUser!
        }
        if self.printerRedirection != nil {
            map["PrinterRedirection"] = self.printerRedirection!
        }
        if self.recordContent != nil {
            map["RecordContent"] = self.recordContent!
        }
        if self.recordContentExpires != nil {
            map["RecordContentExpires"] = self.recordContentExpires!
        }
        if self.recording != nil {
            map["Recording"] = self.recording!
        }
        if self.recordingAudio != nil {
            map["RecordingAudio"] = self.recordingAudio!
        }
        if self.recordingDuration != nil {
            map["RecordingDuration"] = self.recordingDuration!
        }
        if self.recordingEndTime != nil {
            map["RecordingEndTime"] = self.recordingEndTime!
        }
        if self.recordingExpires != nil {
            map["RecordingExpires"] = self.recordingExpires!
        }
        if self.recordingFps != nil {
            map["RecordingFps"] = self.recordingFps!
        }
        if self.recordingStartTime != nil {
            map["RecordingStartTime"] = self.recordingStartTime!
        }
        if self.recordingUserNotify != nil {
            map["RecordingUserNotify"] = self.recordingUserNotify!
        }
        if self.recordingUserNotifyMessage != nil {
            map["RecordingUserNotifyMessage"] = self.recordingUserNotifyMessage!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteCoordinate != nil {
            map["RemoteCoordinate"] = self.remoteCoordinate!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.scopeValue != nil {
            map["ScopeValue"] = self.scopeValue!
        }
        if self.usbRedirect != nil {
            map["UsbRedirect"] = self.usbRedirect!
        }
        if self.usbSupplyRedirectRule != nil {
            var tmp : [Any] = []
            for k in self.usbSupplyRedirectRule! {
                tmp.append(k.toMap())
            }
            map["UsbSupplyRedirectRule"] = tmp
        }
        if self.videoRedirect != nil {
            map["VideoRedirect"] = self.videoRedirect!
        }
        if self.visualQuality != nil {
            map["VisualQuality"] = self.visualQuality!
        }
        if self.watermark != nil {
            map["Watermark"] = self.watermark!
        }
        if self.watermarkAntiCam != nil {
            map["WatermarkAntiCam"] = self.watermarkAntiCam!
        }
        if self.watermarkColor != nil {
            map["WatermarkColor"] = self.watermarkColor!
        }
        if self.watermarkDegree != nil {
            map["WatermarkDegree"] = self.watermarkDegree!
        }
        if self.watermarkFontSize != nil {
            map["WatermarkFontSize"] = self.watermarkFontSize!
        }
        if self.watermarkFontStyle != nil {
            map["WatermarkFontStyle"] = self.watermarkFontStyle!
        }
        if self.watermarkPower != nil {
            map["WatermarkPower"] = self.watermarkPower!
        }
        if self.watermarkRowAmount != nil {
            map["WatermarkRowAmount"] = self.watermarkRowAmount!
        }
        if self.watermarkSecurity != nil {
            map["WatermarkSecurity"] = self.watermarkSecurity!
        }
        if self.watermarkTransparency != nil {
            map["WatermarkTransparency"] = self.watermarkTransparency!
        }
        if self.watermarkTransparencyValue != nil {
            map["WatermarkTransparencyValue"] = self.watermarkTransparencyValue!
        }
        if self.watermarkType != nil {
            map["WatermarkType"] = self.watermarkType!
        }
        if self.wyAssistant != nil {
            map["WyAssistant"] = self.wyAssistant!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdminAccess") {
            self.adminAccess = dict["AdminAccess"] as! String
        }
        if dict.keys.contains("AppContentProtection") {
            self.appContentProtection = dict["AppContentProtection"] as! String
        }
        if dict.keys.contains("AuthorizeAccessPolicyRule") {
            var tmp : [CreatePolicyGroupRequest.AuthorizeAccessPolicyRule] = []
            for v in dict["AuthorizeAccessPolicyRule"] as! [Any] {
                var model = CreatePolicyGroupRequest.AuthorizeAccessPolicyRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.authorizeAccessPolicyRule = tmp
        }
        if dict.keys.contains("AuthorizeSecurityPolicyRule") {
            var tmp : [CreatePolicyGroupRequest.AuthorizeSecurityPolicyRule] = []
            for v in dict["AuthorizeSecurityPolicyRule"] as! [Any] {
                var model = CreatePolicyGroupRequest.AuthorizeSecurityPolicyRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.authorizeSecurityPolicyRule = tmp
        }
        if dict.keys.contains("CameraRedirect") {
            self.cameraRedirect = dict["CameraRedirect"] as! String
        }
        if dict.keys.contains("ClientType") {
            var tmp : [CreatePolicyGroupRequest.ClientType] = []
            for v in dict["ClientType"] as! [Any] {
                var model = CreatePolicyGroupRequest.ClientType()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.clientType = tmp
        }
        if dict.keys.contains("Clipboard") {
            self.clipboard = dict["Clipboard"] as! String
        }
        if dict.keys.contains("DeviceRedirects") {
            var tmp : [CreatePolicyGroupRequest.DeviceRedirects] = []
            for v in dict["DeviceRedirects"] as! [Any] {
                var model = CreatePolicyGroupRequest.DeviceRedirects()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deviceRedirects = tmp
        }
        if dict.keys.contains("DeviceRules") {
            var tmp : [CreatePolicyGroupRequest.DeviceRules] = []
            for v in dict["DeviceRules"] as! [Any] {
                var model = CreatePolicyGroupRequest.DeviceRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deviceRules = tmp
        }
        if dict.keys.contains("DomainList") {
            self.domainList = dict["DomainList"] as! String
        }
        if dict.keys.contains("DomainResolveRule") {
            var tmp : [CreatePolicyGroupRequest.DomainResolveRule] = []
            for v in dict["DomainResolveRule"] as! [Any] {
                var model = CreatePolicyGroupRequest.DomainResolveRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.domainResolveRule = tmp
        }
        if dict.keys.contains("DomainResolveRuleType") {
            self.domainResolveRuleType = dict["DomainResolveRuleType"] as! String
        }
        if dict.keys.contains("EndUserApplyAdminCoordinate") {
            self.endUserApplyAdminCoordinate = dict["EndUserApplyAdminCoordinate"] as! String
        }
        if dict.keys.contains("EndUserGroupCoordinate") {
            self.endUserGroupCoordinate = dict["EndUserGroupCoordinate"] as! String
        }
        if dict.keys.contains("GpuAcceleration") {
            self.gpuAcceleration = dict["GpuAcceleration"] as! String
        }
        if dict.keys.contains("Html5Access") {
            self.html5Access = dict["Html5Access"] as! String
        }
        if dict.keys.contains("Html5FileTransfer") {
            self.html5FileTransfer = dict["Html5FileTransfer"] as! String
        }
        if dict.keys.contains("InternetCommunicationProtocol") {
            self.internetCommunicationProtocol = dict["InternetCommunicationProtocol"] as! String
        }
        if dict.keys.contains("LocalDrive") {
            self.localDrive = dict["LocalDrive"] as! String
        }
        if dict.keys.contains("MaxReconnectTime") {
            self.maxReconnectTime = dict["MaxReconnectTime"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NetRedirect") {
            self.netRedirect = dict["NetRedirect"] as! String
        }
        if dict.keys.contains("PreemptLogin") {
            self.preemptLogin = dict["PreemptLogin"] as! String
        }
        if dict.keys.contains("PreemptLoginUser") {
            self.preemptLoginUser = dict["PreemptLoginUser"] as! [String]
        }
        if dict.keys.contains("PrinterRedirection") {
            self.printerRedirection = dict["PrinterRedirection"] as! String
        }
        if dict.keys.contains("RecordContent") {
            self.recordContent = dict["RecordContent"] as! String
        }
        if dict.keys.contains("RecordContentExpires") {
            self.recordContentExpires = dict["RecordContentExpires"] as! Int64
        }
        if dict.keys.contains("Recording") {
            self.recording = dict["Recording"] as! String
        }
        if dict.keys.contains("RecordingAudio") {
            self.recordingAudio = dict["RecordingAudio"] as! String
        }
        if dict.keys.contains("RecordingDuration") {
            self.recordingDuration = dict["RecordingDuration"] as! Int32
        }
        if dict.keys.contains("RecordingEndTime") {
            self.recordingEndTime = dict["RecordingEndTime"] as! String
        }
        if dict.keys.contains("RecordingExpires") {
            self.recordingExpires = dict["RecordingExpires"] as! Int64
        }
        if dict.keys.contains("RecordingFps") {
            self.recordingFps = dict["RecordingFps"] as! Int64
        }
        if dict.keys.contains("RecordingStartTime") {
            self.recordingStartTime = dict["RecordingStartTime"] as! String
        }
        if dict.keys.contains("RecordingUserNotify") {
            self.recordingUserNotify = dict["RecordingUserNotify"] as! String
        }
        if dict.keys.contains("RecordingUserNotifyMessage") {
            self.recordingUserNotifyMessage = dict["RecordingUserNotifyMessage"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoteCoordinate") {
            self.remoteCoordinate = dict["RemoteCoordinate"] as! String
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("ScopeValue") {
            self.scopeValue = dict["ScopeValue"] as! [String]
        }
        if dict.keys.contains("UsbRedirect") {
            self.usbRedirect = dict["UsbRedirect"] as! String
        }
        if dict.keys.contains("UsbSupplyRedirectRule") {
            var tmp : [CreatePolicyGroupRequest.UsbSupplyRedirectRule] = []
            for v in dict["UsbSupplyRedirectRule"] as! [Any] {
                var model = CreatePolicyGroupRequest.UsbSupplyRedirectRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.usbSupplyRedirectRule = tmp
        }
        if dict.keys.contains("VideoRedirect") {
            self.videoRedirect = dict["VideoRedirect"] as! String
        }
        if dict.keys.contains("VisualQuality") {
            self.visualQuality = dict["VisualQuality"] as! String
        }
        if dict.keys.contains("Watermark") {
            self.watermark = dict["Watermark"] as! String
        }
        if dict.keys.contains("WatermarkAntiCam") {
            self.watermarkAntiCam = dict["WatermarkAntiCam"] as! String
        }
        if dict.keys.contains("WatermarkColor") {
            self.watermarkColor = dict["WatermarkColor"] as! Int32
        }
        if dict.keys.contains("WatermarkDegree") {
            self.watermarkDegree = dict["WatermarkDegree"] as! Double
        }
        if dict.keys.contains("WatermarkFontSize") {
            self.watermarkFontSize = dict["WatermarkFontSize"] as! Int32
        }
        if dict.keys.contains("WatermarkFontStyle") {
            self.watermarkFontStyle = dict["WatermarkFontStyle"] as! String
        }
        if dict.keys.contains("WatermarkPower") {
            self.watermarkPower = dict["WatermarkPower"] as! String
        }
        if dict.keys.contains("WatermarkRowAmount") {
            self.watermarkRowAmount = dict["WatermarkRowAmount"] as! Int32
        }
        if dict.keys.contains("WatermarkSecurity") {
            self.watermarkSecurity = dict["WatermarkSecurity"] as! String
        }
        if dict.keys.contains("WatermarkTransparency") {
            self.watermarkTransparency = dict["WatermarkTransparency"] as! String
        }
        if dict.keys.contains("WatermarkTransparencyValue") {
            self.watermarkTransparencyValue = dict["WatermarkTransparencyValue"] as! Int32
        }
        if dict.keys.contains("WatermarkType") {
            self.watermarkType = dict["WatermarkType"] as! String
        }
        if dict.keys.contains("WyAssistant") {
            self.wyAssistant = dict["WyAssistant"] as! String
        }
    }
}

public class CreatePolicyGroupResponseBody : Tea.TeaModel {
    public var policyGroupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePolicyGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePolicyGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePolicyGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRAMDirectoryRequest : Tea.TeaModel {
    public var desktopAccessType: String?

    public var directoryName: String?

    public var enableAdminAccess: Bool?

    public var enableInternetAccess: Bool?

    public var regionId: String?

    public var vSwitchId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopAccessType != nil {
            map["DesktopAccessType"] = self.desktopAccessType!
        }
        if self.directoryName != nil {
            map["DirectoryName"] = self.directoryName!
        }
        if self.enableAdminAccess != nil {
            map["EnableAdminAccess"] = self.enableAdminAccess!
        }
        if self.enableInternetAccess != nil {
            map["EnableInternetAccess"] = self.enableInternetAccess!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopAccessType") {
            self.desktopAccessType = dict["DesktopAccessType"] as! String
        }
        if dict.keys.contains("DirectoryName") {
            self.directoryName = dict["DirectoryName"] as! String
        }
        if dict.keys.contains("EnableAdminAccess") {
            self.enableAdminAccess = dict["EnableAdminAccess"] as! Bool
        }
        if dict.keys.contains("EnableInternetAccess") {
            self.enableInternetAccess = dict["EnableInternetAccess"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! [String]
        }
    }
}

public class CreateRAMDirectoryResponseBody : Tea.TeaModel {
    public var directoryId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateRAMDirectoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRAMDirectoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRAMDirectoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSimpleOfficeSiteRequest : Tea.TeaModel {
    public var bandwidth: Int32?

    public var cenId: String?

    public var cenOwnerId: Int64?

    public var cidrBlock: String?

    public var cloudBoxOfficeSite: Bool?

    public var desktopAccessType: String?

    public var enableAdminAccess: Bool?

    public var enableInternetAccess: Bool?

    public var needVerifyZeroDevice: Bool?

    public var officeSiteName: String?

    public var regionId: String?

    public var vSwitchId: [String]?

    public var verifyCode: String?

    public var vpcType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.cenId != nil {
            map["CenId"] = self.cenId!
        }
        if self.cenOwnerId != nil {
            map["CenOwnerId"] = self.cenOwnerId!
        }
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.cloudBoxOfficeSite != nil {
            map["CloudBoxOfficeSite"] = self.cloudBoxOfficeSite!
        }
        if self.desktopAccessType != nil {
            map["DesktopAccessType"] = self.desktopAccessType!
        }
        if self.enableAdminAccess != nil {
            map["EnableAdminAccess"] = self.enableAdminAccess!
        }
        if self.enableInternetAccess != nil {
            map["EnableInternetAccess"] = self.enableInternetAccess!
        }
        if self.needVerifyZeroDevice != nil {
            map["NeedVerifyZeroDevice"] = self.needVerifyZeroDevice!
        }
        if self.officeSiteName != nil {
            map["OfficeSiteName"] = self.officeSiteName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.verifyCode != nil {
            map["VerifyCode"] = self.verifyCode!
        }
        if self.vpcType != nil {
            map["VpcType"] = self.vpcType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("CenId") {
            self.cenId = dict["CenId"] as! String
        }
        if dict.keys.contains("CenOwnerId") {
            self.cenOwnerId = dict["CenOwnerId"] as! Int64
        }
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("CloudBoxOfficeSite") {
            self.cloudBoxOfficeSite = dict["CloudBoxOfficeSite"] as! Bool
        }
        if dict.keys.contains("DesktopAccessType") {
            self.desktopAccessType = dict["DesktopAccessType"] as! String
        }
        if dict.keys.contains("EnableAdminAccess") {
            self.enableAdminAccess = dict["EnableAdminAccess"] as! Bool
        }
        if dict.keys.contains("EnableInternetAccess") {
            self.enableInternetAccess = dict["EnableInternetAccess"] as! Bool
        }
        if dict.keys.contains("NeedVerifyZeroDevice") {
            self.needVerifyZeroDevice = dict["NeedVerifyZeroDevice"] as! Bool
        }
        if dict.keys.contains("OfficeSiteName") {
            self.officeSiteName = dict["OfficeSiteName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! [String]
        }
        if dict.keys.contains("VerifyCode") {
            self.verifyCode = dict["VerifyCode"] as! String
        }
        if dict.keys.contains("VpcType") {
            self.vpcType = dict["VpcType"] as! String
        }
    }
}

public class CreateSimpleOfficeSiteResponseBody : Tea.TeaModel {
    public var officeSiteId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateSimpleOfficeSiteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSimpleOfficeSiteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSimpleOfficeSiteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSnapshotRequest : Tea.TeaModel {
    public var description_: String?

    public var desktopId: String?

    public var regionId: String?

    public var snapshotName: String?

    public var sourceDiskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.snapshotName != nil {
            map["SnapshotName"] = self.snapshotName!
        }
        if self.sourceDiskType != nil {
            map["SourceDiskType"] = self.sourceDiskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SnapshotName") {
            self.snapshotName = dict["SnapshotName"] as! String
        }
        if dict.keys.contains("SourceDiskType") {
            self.sourceDiskType = dict["SourceDiskType"] as! String
        }
    }
}

public class CreateSnapshotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
    }
}

public class CreateSnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSnapshotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAutoSnapshotPolicyRequest : Tea.TeaModel {
    public var policyId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyId") {
            self.policyId = dict["PolicyId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteAutoSnapshotPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAutoSnapshotPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAutoSnapshotPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAutoSnapshotPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBundlesRequest : Tea.TeaModel {
    public var bundleId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bundleId != nil {
            map["BundleId"] = self.bundleId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BundleId") {
            self.bundleId = dict["BundleId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteBundlesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBundlesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBundlesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteBundlesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCdsFileRequest : Tea.TeaModel {
    public var cdsId: String?

    public var endUserId: String?

    public var fileId: String?

    public var groupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteCdsFileResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteCdsFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCdsFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCdsFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCenterPolicyRequest : Tea.TeaModel {
    public var businessType: Int32?

    public var policyGroupIds: [String]?

    public var regionId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.policyGroupIds != nil {
            map["PolicyGroupIds"] = self.policyGroupIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! Int32
        }
        if dict.keys.contains("PolicyGroupIds") {
            self.policyGroupIds = dict["PolicyGroupIds"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DeleteCenterPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCenterPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCenterPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCenterPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCloudDriveGroupsRequest : Tea.TeaModel {
    public var cdsId: String?

    public var groupId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteCloudDriveGroupsResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteCloudDriveGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCloudDriveGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCloudDriveGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCloudDriveUsersRequest : Tea.TeaModel {
    public var cdsId: String?

    public var endUserId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteCloudDriveUsersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCloudDriveUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCloudDriveUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCloudDriveUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteConfigGroupRequest : Tea.TeaModel {
    public var groupIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupIds != nil {
            map["GroupIds"] = self.groupIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupIds") {
            self.groupIds = dict["GroupIds"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteConfigGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteConfigGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteConfigGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteConfigGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDesktopGroupRequest : Tea.TeaModel {
    public var desktopGroupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteDesktopGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDesktopGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDesktopGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDesktopGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDesktopsRequest : Tea.TeaModel {
    public var desktopId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteDesktopsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDesktopsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDesktopsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDesktopsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDevicesRequest : Tea.TeaModel {
    public var clientType: Int32?

    public var deviceIds: [String]?

    public var force: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientType != nil {
            map["ClientType"] = self.clientType!
        }
        if self.deviceIds != nil {
            map["DeviceIds"] = self.deviceIds!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientType") {
            self.clientType = dict["ClientType"] as! Int32
        }
        if dict.keys.contains("DeviceIds") {
            self.deviceIds = dict["DeviceIds"] as! [String]
        }
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteDevicesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDirectoriesRequest : Tea.TeaModel {
    public var directoryId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteDirectoriesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDirectoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDirectoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDirectoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEduRoomRequest : Tea.TeaModel {
    public var eduRoomId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eduRoomId != nil {
            map["EduRoomId"] = self.eduRoomId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EduRoomId") {
            self.eduRoomId = dict["EduRoomId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteEduRoomResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEduRoomResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEduRoomResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEduRoomResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteImagesRequest : Tea.TeaModel {
    public var deleteCascadedBundle: Bool?

    public var imageId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteCascadedBundle != nil {
            map["DeleteCascadedBundle"] = self.deleteCascadedBundle!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteCascadedBundle") {
            self.deleteCascadedBundle = dict["DeleteCascadedBundle"] as! Bool
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteImagesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteImagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteImagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteImagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNASFileSystemsRequest : Tea.TeaModel {
    public var fileSystemId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileSystemId") {
            self.fileSystemId = dict["FileSystemId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteNASFileSystemsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNASFileSystemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNASFileSystemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNASFileSystemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNetworkPackagesRequest : Tea.TeaModel {
    public var networkPackageId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkPackageId != nil {
            map["NetworkPackageId"] = self.networkPackageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkPackageId") {
            self.networkPackageId = dict["NetworkPackageId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteNetworkPackagesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNetworkPackagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkPackagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNetworkPackagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteOfficeSitesRequest : Tea.TeaModel {
    public var officeSiteId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteOfficeSitesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteOfficeSitesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteOfficeSitesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteOfficeSitesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePolicyGroupsRequest : Tea.TeaModel {
    public var policyGroupId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeletePolicyGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePolicyGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePolicyGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePolicyGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSnapshotRequest : Tea.TeaModel {
    public var regionId: String?

    public var snapshotId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! [String]
        }
    }
}

public class DeleteSnapshotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSnapshotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVirtualMFADeviceRequest : Tea.TeaModel {
    public var regionId: String?

    public var serialNumber: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.serialNumber != nil {
            map["SerialNumber"] = self.serialNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SerialNumber") {
            self.serialNumber = dict["SerialNumber"] as! String
        }
    }
}

public class DeleteVirtualMFADeviceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVirtualMFADeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVirtualMFADeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVirtualMFADeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAclEntriesRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var officeSiteId: String?

    public var regionId: String?

    public var sourceId: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sourceId != nil {
            map["SourceId"] = self.sourceId!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SourceId") {
            self.sourceId = dict["SourceId"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class DescribeAclEntriesResponseBody : Tea.TeaModel {
    public class AclEntries : Tea.TeaModel {
        public var policy: String?

        public var sourceId: String?

        public var sourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.sourceId != nil {
                map["SourceId"] = self.sourceId!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("SourceId") {
                self.sourceId = dict["SourceId"] as! String
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
        }
    }
    public var aclEntries: [DescribeAclEntriesResponseBody.AclEntries]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntries != nil {
            var tmp : [Any] = []
            for k in self.aclEntries! {
                tmp.append(k.toMap())
            }
            map["AclEntries"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclEntries") {
            var tmp : [DescribeAclEntriesResponseBody.AclEntries] = []
            for v in dict["AclEntries"] as! [Any] {
                var model = DescribeAclEntriesResponseBody.AclEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aclEntries = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAclEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAclEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAclEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAutoSnapshotPolicyRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var policyId: String?

    public var policyName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        if self.policyName != nil {
            map["PolicyName"] = self.policyName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PolicyId") {
            self.policyId = dict["PolicyId"] as! String
        }
        if dict.keys.contains("PolicyName") {
            self.policyName = dict["PolicyName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeAutoSnapshotPolicyResponseBody : Tea.TeaModel {
    public class AutoSnapshotPolicies : Tea.TeaModel {
        public var creationTime: String?

        public var cronExpression: String?

        public var desktopNum: Int32?

        public var policyId: String?

        public var policyName: String?

        public var regionId: String?

        public var retentionDays: String?

        public var status: String?

        public var timePoints: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.cronExpression != nil {
                map["CronExpression"] = self.cronExpression!
            }
            if self.desktopNum != nil {
                map["DesktopNum"] = self.desktopNum!
            }
            if self.policyId != nil {
                map["PolicyId"] = self.policyId!
            }
            if self.policyName != nil {
                map["PolicyName"] = self.policyName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.retentionDays != nil {
                map["RetentionDays"] = self.retentionDays!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.timePoints != nil {
                map["TimePoints"] = self.timePoints!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("CronExpression") {
                self.cronExpression = dict["CronExpression"] as! String
            }
            if dict.keys.contains("DesktopNum") {
                self.desktopNum = dict["DesktopNum"] as! Int32
            }
            if dict.keys.contains("PolicyId") {
                self.policyId = dict["PolicyId"] as! String
            }
            if dict.keys.contains("PolicyName") {
                self.policyName = dict["PolicyName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RetentionDays") {
                self.retentionDays = dict["RetentionDays"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TimePoints") {
                self.timePoints = dict["TimePoints"] as! String
            }
        }
    }
    public var autoSnapshotPolicies: [DescribeAutoSnapshotPolicyResponseBody.AutoSnapshotPolicies]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoSnapshotPolicies != nil {
            var tmp : [Any] = []
            for k in self.autoSnapshotPolicies! {
                tmp.append(k.toMap())
            }
            map["AutoSnapshotPolicies"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoSnapshotPolicies") {
            var tmp : [DescribeAutoSnapshotPolicyResponseBody.AutoSnapshotPolicies] = []
            for v in dict["AutoSnapshotPolicies"] as! [Any] {
                var model = DescribeAutoSnapshotPolicyResponseBody.AutoSnapshotPolicies()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.autoSnapshotPolicies = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAutoSnapshotPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoSnapshotPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAutoSnapshotPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBundlesRequest : Tea.TeaModel {
    public var bundleId: [String]?

    public var bundleType: String?

    public var checkStock: Bool?

    public var cpuCount: Int32?

    public var desktopTypeFamily: String?

    public var fotaChannel: String?

    public var fromDesktopGroup: Bool?

    public var gpuCount: Double?

    public var gpuDriverType: String?

    public var imageId: [String]?

    public var maxResults: Int32?

    public var memorySize: Int32?

    public var nextToken: String?

    public var osType: String?

    public var protocolType: String?

    public var regionId: String?

    public var scope: String?

    public var selectedBundle: Bool?

    public var sessionType: String?

    public var supportMultiSession: Bool?

    public var volumeEncryptionEnabled: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bundleId != nil {
            map["BundleId"] = self.bundleId!
        }
        if self.bundleType != nil {
            map["BundleType"] = self.bundleType!
        }
        if self.checkStock != nil {
            map["CheckStock"] = self.checkStock!
        }
        if self.cpuCount != nil {
            map["CpuCount"] = self.cpuCount!
        }
        if self.desktopTypeFamily != nil {
            map["DesktopTypeFamily"] = self.desktopTypeFamily!
        }
        if self.fotaChannel != nil {
            map["FotaChannel"] = self.fotaChannel!
        }
        if self.fromDesktopGroup != nil {
            map["FromDesktopGroup"] = self.fromDesktopGroup!
        }
        if self.gpuCount != nil {
            map["GpuCount"] = self.gpuCount!
        }
        if self.gpuDriverType != nil {
            map["GpuDriverType"] = self.gpuDriverType!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.memorySize != nil {
            map["MemorySize"] = self.memorySize!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.osType != nil {
            map["OsType"] = self.osType!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.selectedBundle != nil {
            map["SelectedBundle"] = self.selectedBundle!
        }
        if self.sessionType != nil {
            map["SessionType"] = self.sessionType!
        }
        if self.supportMultiSession != nil {
            map["SupportMultiSession"] = self.supportMultiSession!
        }
        if self.volumeEncryptionEnabled != nil {
            map["VolumeEncryptionEnabled"] = self.volumeEncryptionEnabled!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BundleId") {
            self.bundleId = dict["BundleId"] as! [String]
        }
        if dict.keys.contains("BundleType") {
            self.bundleType = dict["BundleType"] as! String
        }
        if dict.keys.contains("CheckStock") {
            self.checkStock = dict["CheckStock"] as! Bool
        }
        if dict.keys.contains("CpuCount") {
            self.cpuCount = dict["CpuCount"] as! Int32
        }
        if dict.keys.contains("DesktopTypeFamily") {
            self.desktopTypeFamily = dict["DesktopTypeFamily"] as! String
        }
        if dict.keys.contains("FotaChannel") {
            self.fotaChannel = dict["FotaChannel"] as! String
        }
        if dict.keys.contains("FromDesktopGroup") {
            self.fromDesktopGroup = dict["FromDesktopGroup"] as! Bool
        }
        if dict.keys.contains("GpuCount") {
            self.gpuCount = dict["GpuCount"] as! Double
        }
        if dict.keys.contains("GpuDriverType") {
            self.gpuDriverType = dict["GpuDriverType"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! [String]
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MemorySize") {
            self.memorySize = dict["MemorySize"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OsType") {
            self.osType = dict["OsType"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("SelectedBundle") {
            self.selectedBundle = dict["SelectedBundle"] as! Bool
        }
        if dict.keys.contains("SessionType") {
            self.sessionType = dict["SessionType"] as! String
        }
        if dict.keys.contains("SupportMultiSession") {
            self.supportMultiSession = dict["SupportMultiSession"] as! Bool
        }
        if dict.keys.contains("VolumeEncryptionEnabled") {
            self.volumeEncryptionEnabled = dict["VolumeEncryptionEnabled"] as! Bool
        }
    }
}

public class DescribeBundlesResponseBody : Tea.TeaModel {
    public class Bundles : Tea.TeaModel {
        public class DesktopTypeAttribute : Tea.TeaModel {
            public var cpuCount: Int32?

            public var gpuCount: Double?

            public var gpuSpec: String?

            public var memorySize: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpuCount != nil {
                    map["CpuCount"] = self.cpuCount!
                }
                if self.gpuCount != nil {
                    map["GpuCount"] = self.gpuCount!
                }
                if self.gpuSpec != nil {
                    map["GpuSpec"] = self.gpuSpec!
                }
                if self.memorySize != nil {
                    map["MemorySize"] = self.memorySize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CpuCount") {
                    self.cpuCount = dict["CpuCount"] as! Int32
                }
                if dict.keys.contains("GpuCount") {
                    self.gpuCount = dict["GpuCount"] as! Double
                }
                if dict.keys.contains("GpuSpec") {
                    self.gpuSpec = dict["GpuSpec"] as! String
                }
                if dict.keys.contains("MemorySize") {
                    self.memorySize = dict["MemorySize"] as! Int32
                }
            }
        }
        public class Disks : Tea.TeaModel {
            public var diskPerformanceLevel: String?

            public var diskSize: Int32?

            public var diskType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskPerformanceLevel != nil {
                    map["DiskPerformanceLevel"] = self.diskPerformanceLevel!
                }
                if self.diskSize != nil {
                    map["DiskSize"] = self.diskSize!
                }
                if self.diskType != nil {
                    map["DiskType"] = self.diskType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiskPerformanceLevel") {
                    self.diskPerformanceLevel = dict["DiskPerformanceLevel"] as! String
                }
                if dict.keys.contains("DiskSize") {
                    self.diskSize = dict["DiskSize"] as! Int32
                }
                if dict.keys.contains("DiskType") {
                    self.diskType = dict["DiskType"] as! String
                }
            }
        }
        public var bundleId: String?

        public var bundleName: String?

        public var bundleType: String?

        public var creationTime: String?

        public var dataDiskCategory: String?

        public var description_: String?

        public var desktopType: String?

        public var desktopTypeAttribute: DescribeBundlesResponseBody.Bundles.DesktopTypeAttribute?

        public var desktopTypeFamily: String?

        public var disks: [DescribeBundlesResponseBody.Bundles.Disks]?

        public var imageId: String?

        public var imageName: String?

        public var imageStatus: String?

        public var language: String?

        public var osType: String?

        public var platform: String?

        public var protocolType: String?

        public var sessionType: String?

        public var stockState: String?

        public var systemDiskCategory: String?

        public var volumeEncryptionEnabled: Bool?

        public var volumeEncryptionKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.desktopTypeAttribute?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bundleId != nil {
                map["BundleId"] = self.bundleId!
            }
            if self.bundleName != nil {
                map["BundleName"] = self.bundleName!
            }
            if self.bundleType != nil {
                map["BundleType"] = self.bundleType!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.dataDiskCategory != nil {
                map["DataDiskCategory"] = self.dataDiskCategory!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.desktopType != nil {
                map["DesktopType"] = self.desktopType!
            }
            if self.desktopTypeAttribute != nil {
                map["DesktopTypeAttribute"] = self.desktopTypeAttribute?.toMap()
            }
            if self.desktopTypeFamily != nil {
                map["DesktopTypeFamily"] = self.desktopTypeFamily!
            }
            if self.disks != nil {
                var tmp : [Any] = []
                for k in self.disks! {
                    tmp.append(k.toMap())
                }
                map["Disks"] = tmp
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.imageStatus != nil {
                map["ImageStatus"] = self.imageStatus!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.osType != nil {
                map["OsType"] = self.osType!
            }
            if self.platform != nil {
                map["Platform"] = self.platform!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.sessionType != nil {
                map["SessionType"] = self.sessionType!
            }
            if self.stockState != nil {
                map["StockState"] = self.stockState!
            }
            if self.systemDiskCategory != nil {
                map["SystemDiskCategory"] = self.systemDiskCategory!
            }
            if self.volumeEncryptionEnabled != nil {
                map["VolumeEncryptionEnabled"] = self.volumeEncryptionEnabled!
            }
            if self.volumeEncryptionKey != nil {
                map["VolumeEncryptionKey"] = self.volumeEncryptionKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BundleId") {
                self.bundleId = dict["BundleId"] as! String
            }
            if dict.keys.contains("BundleName") {
                self.bundleName = dict["BundleName"] as! String
            }
            if dict.keys.contains("BundleType") {
                self.bundleType = dict["BundleType"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DataDiskCategory") {
                self.dataDiskCategory = dict["DataDiskCategory"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DesktopType") {
                self.desktopType = dict["DesktopType"] as! String
            }
            if dict.keys.contains("DesktopTypeAttribute") {
                var model = DescribeBundlesResponseBody.Bundles.DesktopTypeAttribute()
                model.fromMap(dict["DesktopTypeAttribute"] as! [String: Any])
                self.desktopTypeAttribute = model
            }
            if dict.keys.contains("DesktopTypeFamily") {
                self.desktopTypeFamily = dict["DesktopTypeFamily"] as! String
            }
            if dict.keys.contains("Disks") {
                var tmp : [DescribeBundlesResponseBody.Bundles.Disks] = []
                for v in dict["Disks"] as! [Any] {
                    var model = DescribeBundlesResponseBody.Bundles.Disks()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.disks = tmp
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageName") {
                self.imageName = dict["ImageName"] as! String
            }
            if dict.keys.contains("ImageStatus") {
                self.imageStatus = dict["ImageStatus"] as! String
            }
            if dict.keys.contains("Language") {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("OsType") {
                self.osType = dict["OsType"] as! String
            }
            if dict.keys.contains("Platform") {
                self.platform = dict["Platform"] as! String
            }
            if dict.keys.contains("ProtocolType") {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("SessionType") {
                self.sessionType = dict["SessionType"] as! String
            }
            if dict.keys.contains("StockState") {
                self.stockState = dict["StockState"] as! String
            }
            if dict.keys.contains("SystemDiskCategory") {
                self.systemDiskCategory = dict["SystemDiskCategory"] as! String
            }
            if dict.keys.contains("VolumeEncryptionEnabled") {
                self.volumeEncryptionEnabled = dict["VolumeEncryptionEnabled"] as! Bool
            }
            if dict.keys.contains("VolumeEncryptionKey") {
                self.volumeEncryptionKey = dict["VolumeEncryptionKey"] as! String
            }
        }
    }
    public var bundles: [DescribeBundlesResponseBody.Bundles]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bundles != nil {
            var tmp : [Any] = []
            for k in self.bundles! {
                tmp.append(k.toMap())
            }
            map["Bundles"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bundles") {
            var tmp : [DescribeBundlesResponseBody.Bundles] = []
            for v in dict["Bundles"] as! [Any] {
                var model = DescribeBundlesResponseBody.Bundles()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bundles = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBundlesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBundlesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBundlesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCdsFileShareLinksRequest : Tea.TeaModel {
    public var cdsId: String?

    public var creators: [String]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var shareId: String?

    public var shareName: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.creators != nil {
            map["Creators"] = self.creators!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.shareId != nil {
            map["ShareId"] = self.shareId!
        }
        if self.shareName != nil {
            map["ShareName"] = self.shareName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("Creators") {
            self.creators = dict["Creators"] as! [String]
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ShareId") {
            self.shareId = dict["ShareId"] as! String
        }
        if dict.keys.contains("ShareName") {
            self.shareName = dict["ShareName"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeCdsFileShareLinksResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: [CdsFileShareLinkModel]?

    public var message: String?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [CdsFileShareLinkModel] = []
            for v in dict["Data"] as! [Any] {
                var model = CdsFileShareLinkModel()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeCdsFileShareLinksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCdsFileShareLinksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCdsFileShareLinksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCensRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeCensResponseBody : Tea.TeaModel {
    public class Cens : Tea.TeaModel {
        public class PackageIds : Tea.TeaModel {
            public var packageId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.packageId != nil {
                    map["PackageId"] = self.packageId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PackageId") {
                    self.packageId = dict["PackageId"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var cenId: String?

        public var creationTime: String?

        public var description_: String?

        public var ipv6Level: String?

        public var name: String?

        public var packageIds: [DescribeCensResponseBody.Cens.PackageIds]?

        public var protectionLevel: String?

        public var status: String?

        public var tags: [DescribeCensResponseBody.Cens.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cenId != nil {
                map["CenId"] = self.cenId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ipv6Level != nil {
                map["Ipv6Level"] = self.ipv6Level!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.packageIds != nil {
                var tmp : [Any] = []
                for k in self.packageIds! {
                    tmp.append(k.toMap())
                }
                map["PackageIds"] = tmp
            }
            if self.protectionLevel != nil {
                map["ProtectionLevel"] = self.protectionLevel!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CenId") {
                self.cenId = dict["CenId"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Ipv6Level") {
                self.ipv6Level = dict["Ipv6Level"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PackageIds") {
                var tmp : [DescribeCensResponseBody.Cens.PackageIds] = []
                for v in dict["PackageIds"] as! [Any] {
                    var model = DescribeCensResponseBody.Cens.PackageIds()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.packageIds = tmp
            }
            if dict.keys.contains("ProtectionLevel") {
                self.protectionLevel = dict["ProtectionLevel"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeCensResponseBody.Cens.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeCensResponseBody.Cens.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var cens: [DescribeCensResponseBody.Cens]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cens != nil {
            var tmp : [Any] = []
            for k in self.cens! {
                tmp.append(k.toMap())
            }
            map["Cens"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cens") {
            var tmp : [DescribeCensResponseBody.Cens] = []
            for v in dict["Cens"] as! [Any] {
                var model = DescribeCensResponseBody.Cens()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.cens = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeCensResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCensResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCensResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCenterPolicyListRequest : Tea.TeaModel {
    public var businessType: Int32?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var policyGroupId: [String]?

    public var resourceType: String?

    public var scope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! Int32
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
    }
}

public class DescribeCenterPolicyListResponseBody : Tea.TeaModel {
    public class DescribePolicyGroups : Tea.TeaModel {
        public class AuthorizeAccessPolicyRules : Tea.TeaModel {
            public var cidrIp: String?

            public var description_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidrIp != nil {
                    map["CidrIp"] = self.cidrIp!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CidrIp") {
                    self.cidrIp = dict["CidrIp"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
            }
        }
        public class AuthorizeSecurityPolicyRules : Tea.TeaModel {
            public var cidrIp: String?

            public var description_: String?

            public var ipProtocol: String?

            public var policy: String?

            public var portRange: String?

            public var priority: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidrIp != nil {
                    map["CidrIp"] = self.cidrIp!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ipProtocol != nil {
                    map["IpProtocol"] = self.ipProtocol!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                if self.portRange != nil {
                    map["PortRange"] = self.portRange!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CidrIp") {
                    self.cidrIp = dict["CidrIp"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("IpProtocol") {
                    self.ipProtocol = dict["IpProtocol"] as! String
                }
                if dict.keys.contains("Policy") {
                    self.policy = dict["Policy"] as! String
                }
                if dict.keys.contains("PortRange") {
                    self.portRange = dict["PortRange"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class ClientTypes : Tea.TeaModel {
            public var clientType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clientType != nil {
                    map["ClientType"] = self.clientType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClientType") {
                    self.clientType = dict["ClientType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DeviceRedirects : Tea.TeaModel {
            public var deviceType: String?

            public var redirectType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deviceType != nil {
                    map["DeviceType"] = self.deviceType!
                }
                if self.redirectType != nil {
                    map["RedirectType"] = self.redirectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeviceType") {
                    self.deviceType = dict["DeviceType"] as! String
                }
                if dict.keys.contains("RedirectType") {
                    self.redirectType = dict["RedirectType"] as! String
                }
            }
        }
        public class DeviceRules : Tea.TeaModel {
            public var deviceName: String?

            public var devicePid: String?

            public var deviceType: String?

            public var deviceVid: String?

            public var optCommand: String?

            public var redirectType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deviceName != nil {
                    map["DeviceName"] = self.deviceName!
                }
                if self.devicePid != nil {
                    map["DevicePid"] = self.devicePid!
                }
                if self.deviceType != nil {
                    map["DeviceType"] = self.deviceType!
                }
                if self.deviceVid != nil {
                    map["DeviceVid"] = self.deviceVid!
                }
                if self.optCommand != nil {
                    map["OptCommand"] = self.optCommand!
                }
                if self.redirectType != nil {
                    map["RedirectType"] = self.redirectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeviceName") {
                    self.deviceName = dict["DeviceName"] as! String
                }
                if dict.keys.contains("DevicePid") {
                    self.devicePid = dict["DevicePid"] as! String
                }
                if dict.keys.contains("DeviceType") {
                    self.deviceType = dict["DeviceType"] as! String
                }
                if dict.keys.contains("DeviceVid") {
                    self.deviceVid = dict["DeviceVid"] as! String
                }
                if dict.keys.contains("OptCommand") {
                    self.optCommand = dict["OptCommand"] as! String
                }
                if dict.keys.contains("RedirectType") {
                    self.redirectType = dict["RedirectType"] as! String
                }
            }
        }
        public class DomainResolveRule : Tea.TeaModel {
            public var description_: String?

            public var domain: String?

            public var policy: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("Policy") {
                    self.policy = dict["Policy"] as! String
                }
            }
        }
        public class NetRedirectRule : Tea.TeaModel {
            public var domain: String?

            public var policy: String?

            public var ruleType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                if self.ruleType != nil {
                    map["RuleType"] = self.ruleType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("Policy") {
                    self.policy = dict["Policy"] as! String
                }
                if dict.keys.contains("RuleType") {
                    self.ruleType = dict["RuleType"] as! String
                }
            }
        }
        public class UsbSupplyRedirectRule : Tea.TeaModel {
            public var description_: String?

            public var productId: String?

            public var usbRedirectType: Int64?

            public var usbRuleType: Int64?

            public var vendorId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.productId != nil {
                    map["ProductId"] = self.productId!
                }
                if self.usbRedirectType != nil {
                    map["UsbRedirectType"] = self.usbRedirectType!
                }
                if self.usbRuleType != nil {
                    map["UsbRuleType"] = self.usbRuleType!
                }
                if self.vendorId != nil {
                    map["VendorId"] = self.vendorId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ProductId") {
                    self.productId = dict["ProductId"] as! String
                }
                if dict.keys.contains("UsbRedirectType") {
                    self.usbRedirectType = dict["UsbRedirectType"] as! Int64
                }
                if dict.keys.contains("UsbRuleType") {
                    self.usbRuleType = dict["UsbRuleType"] as! Int64
                }
                if dict.keys.contains("VendorId") {
                    self.vendorId = dict["VendorId"] as! String
                }
            }
        }
        public var adminAccess: String?

        public var appContentProtection: String?

        public var authorizeAccessPolicyRules: [DescribeCenterPolicyListResponseBody.DescribePolicyGroups.AuthorizeAccessPolicyRules]?

        public var authorizeSecurityPolicyRules: [DescribeCenterPolicyListResponseBody.DescribePolicyGroups.AuthorizeSecurityPolicyRules]?

        public var cameraRedirect: String?

        public var clientTypes: [DescribeCenterPolicyListResponseBody.DescribePolicyGroups.ClientTypes]?

        public var clipboard: String?

        public var colorEnhancement: String?

        public var cpuDownGradeDuration: Int32?

        public var cpuProcessors: [String]?

        public var cpuProtectedMode: String?

        public var cpuRateLimit: Int32?

        public var cpuSampleDuration: Int32?

        public var cpuSingleRateLimit: Int32?

        public var desktopCount: Int32?

        public var desktopGroupCount: Int32?

        public var deviceRedirects: [DescribeCenterPolicyListResponseBody.DescribePolicyGroups.DeviceRedirects]?

        public var deviceRules: [DescribeCenterPolicyListResponseBody.DescribePolicyGroups.DeviceRules]?

        public var disconnectKeepSession: String?

        public var disconnectKeepSessionTime: Int32?

        public var displayMode: String?

        public var domainRegisterValue: String?

        public var domainResolveRule: [DescribeCenterPolicyListResponseBody.DescribePolicyGroups.DomainResolveRule]?

        public var domainResolveRuleType: String?

        public var endUserApplyAdminCoordinate: String?

        public var endUserGroupCoordinate: String?

        public var gpuAcceleration: String?

        public var html5Access: String?

        public var html5FileTransfer: String?

        public var internetCommunicationProtocol: String?

        public var localDrive: String?

        public var maxReconnectTime: Int32?

        public var memoryDownGradeDuration: Int32?

        public var memoryProcessors: [String]?

        public var memoryProtectedMode: String?

        public var memoryRateLimit: Int32?

        public var memorySampleDuration: Int32?

        public var memorySingleRateLimit: Int32?

        public var mobileRestart: String?

        public var mobileShutdown: String?

        public var name: String?

        public var netRedirect: String?

        public var netRedirectRule: [DescribeCenterPolicyListResponseBody.DescribePolicyGroups.NetRedirectRule]?

        public var noOperationDisconnect: String?

        public var noOperationDisconnectTime: Int32?

        public var policyGroupId: String?

        public var policyGroupType: String?

        public var policyStatus: String?

        public var printerRedirection: String?

        public var qualityEnhancement: String?

        public var recordContent: String?

        public var recordContentExpires: Int64?

        public var recordEventDuration: Int32?

        public var recordEventFilePaths: [String]?

        public var recordEventRegisters: [String]?

        public var recording: String?

        public var recordingAudio: String?

        public var recordingDuration: Int32?

        public var recordingEndTime: String?

        public var recordingExpires: Int64?

        public var recordingFps: Int64?

        public var recordingStartTime: String?

        public var recordingUserNotify: String?

        public var recordingUserNotifyMessage: String?

        public var remoteCoordinate: String?

        public var resolutionHeight: Int32?

        public var resolutionModel: String?

        public var resolutionWidth: Int32?

        public var resourceGroupCount: Int32?

        public var scope: String?

        public var scopeValue: [String]?

        public var smoothEnhancement: String?

        public var statusMonitor: String?

        public var streamingMode: String?

        public var targetFps: Int32?

        public var taskbar: String?

        public var usbRedirect: String?

        public var usbSupplyRedirectRule: [DescribeCenterPolicyListResponseBody.DescribePolicyGroups.UsbSupplyRedirectRule]?

        public var videoEncAvgKbps: Int32?

        public var videoEncMaxQP: Int32?

        public var videoEncMinQP: Int32?

        public var videoEncPeakKbps: Int32?

        public var videoEncPolicy: String?

        public var videoRedirect: String?

        public var visualQuality: String?

        public var watermark: String?

        public var watermarkAntiCam: String?

        public var watermarkColor: Int32?

        public var watermarkCustomText: String?

        public var watermarkDegree: Double?

        public var watermarkFontSize: Int32?

        public var watermarkFontStyle: String?

        public var watermarkPower: String?

        public var watermarkRowAmount: Int32?

        public var watermarkSecurity: String?

        public var watermarkTransparencyValue: Int32?

        public var watermarkType: String?

        public var wyAssistant: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.adminAccess != nil {
                map["AdminAccess"] = self.adminAccess!
            }
            if self.appContentProtection != nil {
                map["AppContentProtection"] = self.appContentProtection!
            }
            if self.authorizeAccessPolicyRules != nil {
                var tmp : [Any] = []
                for k in self.authorizeAccessPolicyRules! {
                    tmp.append(k.toMap())
                }
                map["AuthorizeAccessPolicyRules"] = tmp
            }
            if self.authorizeSecurityPolicyRules != nil {
                var tmp : [Any] = []
                for k in self.authorizeSecurityPolicyRules! {
                    tmp.append(k.toMap())
                }
                map["AuthorizeSecurityPolicyRules"] = tmp
            }
            if self.cameraRedirect != nil {
                map["CameraRedirect"] = self.cameraRedirect!
            }
            if self.clientTypes != nil {
                var tmp : [Any] = []
                for k in self.clientTypes! {
                    tmp.append(k.toMap())
                }
                map["ClientTypes"] = tmp
            }
            if self.clipboard != nil {
                map["Clipboard"] = self.clipboard!
            }
            if self.colorEnhancement != nil {
                map["ColorEnhancement"] = self.colorEnhancement!
            }
            if self.cpuDownGradeDuration != nil {
                map["CpuDownGradeDuration"] = self.cpuDownGradeDuration!
            }
            if self.cpuProcessors != nil {
                map["CpuProcessors"] = self.cpuProcessors!
            }
            if self.cpuProtectedMode != nil {
                map["CpuProtectedMode"] = self.cpuProtectedMode!
            }
            if self.cpuRateLimit != nil {
                map["CpuRateLimit"] = self.cpuRateLimit!
            }
            if self.cpuSampleDuration != nil {
                map["CpuSampleDuration"] = self.cpuSampleDuration!
            }
            if self.cpuSingleRateLimit != nil {
                map["CpuSingleRateLimit"] = self.cpuSingleRateLimit!
            }
            if self.desktopCount != nil {
                map["DesktopCount"] = self.desktopCount!
            }
            if self.desktopGroupCount != nil {
                map["DesktopGroupCount"] = self.desktopGroupCount!
            }
            if self.deviceRedirects != nil {
                var tmp : [Any] = []
                for k in self.deviceRedirects! {
                    tmp.append(k.toMap())
                }
                map["DeviceRedirects"] = tmp
            }
            if self.deviceRules != nil {
                var tmp : [Any] = []
                for k in self.deviceRules! {
                    tmp.append(k.toMap())
                }
                map["DeviceRules"] = tmp
            }
            if self.disconnectKeepSession != nil {
                map["DisconnectKeepSession"] = self.disconnectKeepSession!
            }
            if self.disconnectKeepSessionTime != nil {
                map["DisconnectKeepSessionTime"] = self.disconnectKeepSessionTime!
            }
            if self.displayMode != nil {
                map["DisplayMode"] = self.displayMode!
            }
            if self.domainRegisterValue != nil {
                map["DomainRegisterValue"] = self.domainRegisterValue!
            }
            if self.domainResolveRule != nil {
                var tmp : [Any] = []
                for k in self.domainResolveRule! {
                    tmp.append(k.toMap())
                }
                map["DomainResolveRule"] = tmp
            }
            if self.domainResolveRuleType != nil {
                map["DomainResolveRuleType"] = self.domainResolveRuleType!
            }
            if self.endUserApplyAdminCoordinate != nil {
                map["EndUserApplyAdminCoordinate"] = self.endUserApplyAdminCoordinate!
            }
            if self.endUserGroupCoordinate != nil {
                map["EndUserGroupCoordinate"] = self.endUserGroupCoordinate!
            }
            if self.gpuAcceleration != nil {
                map["GpuAcceleration"] = self.gpuAcceleration!
            }
            if self.html5Access != nil {
                map["Html5Access"] = self.html5Access!
            }
            if self.html5FileTransfer != nil {
                map["Html5FileTransfer"] = self.html5FileTransfer!
            }
            if self.internetCommunicationProtocol != nil {
                map["InternetCommunicationProtocol"] = self.internetCommunicationProtocol!
            }
            if self.localDrive != nil {
                map["LocalDrive"] = self.localDrive!
            }
            if self.maxReconnectTime != nil {
                map["MaxReconnectTime"] = self.maxReconnectTime!
            }
            if self.memoryDownGradeDuration != nil {
                map["MemoryDownGradeDuration"] = self.memoryDownGradeDuration!
            }
            if self.memoryProcessors != nil {
                map["MemoryProcessors"] = self.memoryProcessors!
            }
            if self.memoryProtectedMode != nil {
                map["MemoryProtectedMode"] = self.memoryProtectedMode!
            }
            if self.memoryRateLimit != nil {
                map["MemoryRateLimit"] = self.memoryRateLimit!
            }
            if self.memorySampleDuration != nil {
                map["MemorySampleDuration"] = self.memorySampleDuration!
            }
            if self.memorySingleRateLimit != nil {
                map["MemorySingleRateLimit"] = self.memorySingleRateLimit!
            }
            if self.mobileRestart != nil {
                map["MobileRestart"] = self.mobileRestart!
            }
            if self.mobileShutdown != nil {
                map["MobileShutdown"] = self.mobileShutdown!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.netRedirect != nil {
                map["NetRedirect"] = self.netRedirect!
            }
            if self.netRedirectRule != nil {
                var tmp : [Any] = []
                for k in self.netRedirectRule! {
                    tmp.append(k.toMap())
                }
                map["NetRedirectRule"] = tmp
            }
            if self.noOperationDisconnect != nil {
                map["NoOperationDisconnect"] = self.noOperationDisconnect!
            }
            if self.noOperationDisconnectTime != nil {
                map["NoOperationDisconnectTime"] = self.noOperationDisconnectTime!
            }
            if self.policyGroupId != nil {
                map["PolicyGroupId"] = self.policyGroupId!
            }
            if self.policyGroupType != nil {
                map["PolicyGroupType"] = self.policyGroupType!
            }
            if self.policyStatus != nil {
                map["PolicyStatus"] = self.policyStatus!
            }
            if self.printerRedirection != nil {
                map["PrinterRedirection"] = self.printerRedirection!
            }
            if self.qualityEnhancement != nil {
                map["QualityEnhancement"] = self.qualityEnhancement!
            }
            if self.recordContent != nil {
                map["RecordContent"] = self.recordContent!
            }
            if self.recordContentExpires != nil {
                map["RecordContentExpires"] = self.recordContentExpires!
            }
            if self.recordEventDuration != nil {
                map["RecordEventDuration"] = self.recordEventDuration!
            }
            if self.recordEventFilePaths != nil {
                map["RecordEventFilePaths"] = self.recordEventFilePaths!
            }
            if self.recordEventRegisters != nil {
                map["RecordEventRegisters"] = self.recordEventRegisters!
            }
            if self.recording != nil {
                map["Recording"] = self.recording!
            }
            if self.recordingAudio != nil {
                map["RecordingAudio"] = self.recordingAudio!
            }
            if self.recordingDuration != nil {
                map["RecordingDuration"] = self.recordingDuration!
            }
            if self.recordingEndTime != nil {
                map["RecordingEndTime"] = self.recordingEndTime!
            }
            if self.recordingExpires != nil {
                map["RecordingExpires"] = self.recordingExpires!
            }
            if self.recordingFps != nil {
                map["RecordingFps"] = self.recordingFps!
            }
            if self.recordingStartTime != nil {
                map["RecordingStartTime"] = self.recordingStartTime!
            }
            if self.recordingUserNotify != nil {
                map["RecordingUserNotify"] = self.recordingUserNotify!
            }
            if self.recordingUserNotifyMessage != nil {
                map["RecordingUserNotifyMessage"] = self.recordingUserNotifyMessage!
            }
            if self.remoteCoordinate != nil {
                map["RemoteCoordinate"] = self.remoteCoordinate!
            }
            if self.resolutionHeight != nil {
                map["ResolutionHeight"] = self.resolutionHeight!
            }
            if self.resolutionModel != nil {
                map["ResolutionModel"] = self.resolutionModel!
            }
            if self.resolutionWidth != nil {
                map["ResolutionWidth"] = self.resolutionWidth!
            }
            if self.resourceGroupCount != nil {
                map["ResourceGroupCount"] = self.resourceGroupCount!
            }
            if self.scope != nil {
                map["Scope"] = self.scope!
            }
            if self.scopeValue != nil {
                map["ScopeValue"] = self.scopeValue!
            }
            if self.smoothEnhancement != nil {
                map["SmoothEnhancement"] = self.smoothEnhancement!
            }
            if self.statusMonitor != nil {
                map["StatusMonitor"] = self.statusMonitor!
            }
            if self.streamingMode != nil {
                map["StreamingMode"] = self.streamingMode!
            }
            if self.targetFps != nil {
                map["TargetFps"] = self.targetFps!
            }
            if self.taskbar != nil {
                map["Taskbar"] = self.taskbar!
            }
            if self.usbRedirect != nil {
                map["UsbRedirect"] = self.usbRedirect!
            }
            if self.usbSupplyRedirectRule != nil {
                var tmp : [Any] = []
                for k in self.usbSupplyRedirectRule! {
                    tmp.append(k.toMap())
                }
                map["UsbSupplyRedirectRule"] = tmp
            }
            if self.videoEncAvgKbps != nil {
                map["VideoEncAvgKbps"] = self.videoEncAvgKbps!
            }
            if self.videoEncMaxQP != nil {
                map["VideoEncMaxQP"] = self.videoEncMaxQP!
            }
            if self.videoEncMinQP != nil {
                map["VideoEncMinQP"] = self.videoEncMinQP!
            }
            if self.videoEncPeakKbps != nil {
                map["VideoEncPeakKbps"] = self.videoEncPeakKbps!
            }
            if self.videoEncPolicy != nil {
                map["VideoEncPolicy"] = self.videoEncPolicy!
            }
            if self.videoRedirect != nil {
                map["VideoRedirect"] = self.videoRedirect!
            }
            if self.visualQuality != nil {
                map["VisualQuality"] = self.visualQuality!
            }
            if self.watermark != nil {
                map["Watermark"] = self.watermark!
            }
            if self.watermarkAntiCam != nil {
                map["WatermarkAntiCam"] = self.watermarkAntiCam!
            }
            if self.watermarkColor != nil {
                map["WatermarkColor"] = self.watermarkColor!
            }
            if self.watermarkCustomText != nil {
                map["WatermarkCustomText"] = self.watermarkCustomText!
            }
            if self.watermarkDegree != nil {
                map["WatermarkDegree"] = self.watermarkDegree!
            }
            if self.watermarkFontSize != nil {
                map["WatermarkFontSize"] = self.watermarkFontSize!
            }
            if self.watermarkFontStyle != nil {
                map["WatermarkFontStyle"] = self.watermarkFontStyle!
            }
            if self.watermarkPower != nil {
                map["WatermarkPower"] = self.watermarkPower!
            }
            if self.watermarkRowAmount != nil {
                map["WatermarkRowAmount"] = self.watermarkRowAmount!
            }
            if self.watermarkSecurity != nil {
                map["WatermarkSecurity"] = self.watermarkSecurity!
            }
            if self.watermarkTransparencyValue != nil {
                map["WatermarkTransparencyValue"] = self.watermarkTransparencyValue!
            }
            if self.watermarkType != nil {
                map["WatermarkType"] = self.watermarkType!
            }
            if self.wyAssistant != nil {
                map["WyAssistant"] = self.wyAssistant!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AdminAccess") {
                self.adminAccess = dict["AdminAccess"] as! String
            }
            if dict.keys.contains("AppContentProtection") {
                self.appContentProtection = dict["AppContentProtection"] as! String
            }
            if dict.keys.contains("AuthorizeAccessPolicyRules") {
                var tmp : [DescribeCenterPolicyListResponseBody.DescribePolicyGroups.AuthorizeAccessPolicyRules] = []
                for v in dict["AuthorizeAccessPolicyRules"] as! [Any] {
                    var model = DescribeCenterPolicyListResponseBody.DescribePolicyGroups.AuthorizeAccessPolicyRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authorizeAccessPolicyRules = tmp
            }
            if dict.keys.contains("AuthorizeSecurityPolicyRules") {
                var tmp : [DescribeCenterPolicyListResponseBody.DescribePolicyGroups.AuthorizeSecurityPolicyRules] = []
                for v in dict["AuthorizeSecurityPolicyRules"] as! [Any] {
                    var model = DescribeCenterPolicyListResponseBody.DescribePolicyGroups.AuthorizeSecurityPolicyRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authorizeSecurityPolicyRules = tmp
            }
            if dict.keys.contains("CameraRedirect") {
                self.cameraRedirect = dict["CameraRedirect"] as! String
            }
            if dict.keys.contains("ClientTypes") {
                var tmp : [DescribeCenterPolicyListResponseBody.DescribePolicyGroups.ClientTypes] = []
                for v in dict["ClientTypes"] as! [Any] {
                    var model = DescribeCenterPolicyListResponseBody.DescribePolicyGroups.ClientTypes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clientTypes = tmp
            }
            if dict.keys.contains("Clipboard") {
                self.clipboard = dict["Clipboard"] as! String
            }
            if dict.keys.contains("ColorEnhancement") {
                self.colorEnhancement = dict["ColorEnhancement"] as! String
            }
            if dict.keys.contains("CpuDownGradeDuration") {
                self.cpuDownGradeDuration = dict["CpuDownGradeDuration"] as! Int32
            }
            if dict.keys.contains("CpuProcessors") {
                self.cpuProcessors = dict["CpuProcessors"] as! [String]
            }
            if dict.keys.contains("CpuProtectedMode") {
                self.cpuProtectedMode = dict["CpuProtectedMode"] as! String
            }
            if dict.keys.contains("CpuRateLimit") {
                self.cpuRateLimit = dict["CpuRateLimit"] as! Int32
            }
            if dict.keys.contains("CpuSampleDuration") {
                self.cpuSampleDuration = dict["CpuSampleDuration"] as! Int32
            }
            if dict.keys.contains("CpuSingleRateLimit") {
                self.cpuSingleRateLimit = dict["CpuSingleRateLimit"] as! Int32
            }
            if dict.keys.contains("DesktopCount") {
                self.desktopCount = dict["DesktopCount"] as! Int32
            }
            if dict.keys.contains("DesktopGroupCount") {
                self.desktopGroupCount = dict["DesktopGroupCount"] as! Int32
            }
            if dict.keys.contains("DeviceRedirects") {
                var tmp : [DescribeCenterPolicyListResponseBody.DescribePolicyGroups.DeviceRedirects] = []
                for v in dict["DeviceRedirects"] as! [Any] {
                    var model = DescribeCenterPolicyListResponseBody.DescribePolicyGroups.DeviceRedirects()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deviceRedirects = tmp
            }
            if dict.keys.contains("DeviceRules") {
                var tmp : [DescribeCenterPolicyListResponseBody.DescribePolicyGroups.DeviceRules] = []
                for v in dict["DeviceRules"] as! [Any] {
                    var model = DescribeCenterPolicyListResponseBody.DescribePolicyGroups.DeviceRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deviceRules = tmp
            }
            if dict.keys.contains("DisconnectKeepSession") {
                self.disconnectKeepSession = dict["DisconnectKeepSession"] as! String
            }
            if dict.keys.contains("DisconnectKeepSessionTime") {
                self.disconnectKeepSessionTime = dict["DisconnectKeepSessionTime"] as! Int32
            }
            if dict.keys.contains("DisplayMode") {
                self.displayMode = dict["DisplayMode"] as! String
            }
            if dict.keys.contains("DomainRegisterValue") {
                self.domainRegisterValue = dict["DomainRegisterValue"] as! String
            }
            if dict.keys.contains("DomainResolveRule") {
                var tmp : [DescribeCenterPolicyListResponseBody.DescribePolicyGroups.DomainResolveRule] = []
                for v in dict["DomainResolveRule"] as! [Any] {
                    var model = DescribeCenterPolicyListResponseBody.DescribePolicyGroups.DomainResolveRule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.domainResolveRule = tmp
            }
            if dict.keys.contains("DomainResolveRuleType") {
                self.domainResolveRuleType = dict["DomainResolveRuleType"] as! String
            }
            if dict.keys.contains("EndUserApplyAdminCoordinate") {
                self.endUserApplyAdminCoordinate = dict["EndUserApplyAdminCoordinate"] as! String
            }
            if dict.keys.contains("EndUserGroupCoordinate") {
                self.endUserGroupCoordinate = dict["EndUserGroupCoordinate"] as! String
            }
            if dict.keys.contains("GpuAcceleration") {
                self.gpuAcceleration = dict["GpuAcceleration"] as! String
            }
            if dict.keys.contains("Html5Access") {
                self.html5Access = dict["Html5Access"] as! String
            }
            if dict.keys.contains("Html5FileTransfer") {
                self.html5FileTransfer = dict["Html5FileTransfer"] as! String
            }
            if dict.keys.contains("InternetCommunicationProtocol") {
                self.internetCommunicationProtocol = dict["InternetCommunicationProtocol"] as! String
            }
            if dict.keys.contains("LocalDrive") {
                self.localDrive = dict["LocalDrive"] as! String
            }
            if dict.keys.contains("MaxReconnectTime") {
                self.maxReconnectTime = dict["MaxReconnectTime"] as! Int32
            }
            if dict.keys.contains("MemoryDownGradeDuration") {
                self.memoryDownGradeDuration = dict["MemoryDownGradeDuration"] as! Int32
            }
            if dict.keys.contains("MemoryProcessors") {
                self.memoryProcessors = dict["MemoryProcessors"] as! [String]
            }
            if dict.keys.contains("MemoryProtectedMode") {
                self.memoryProtectedMode = dict["MemoryProtectedMode"] as! String
            }
            if dict.keys.contains("MemoryRateLimit") {
                self.memoryRateLimit = dict["MemoryRateLimit"] as! Int32
            }
            if dict.keys.contains("MemorySampleDuration") {
                self.memorySampleDuration = dict["MemorySampleDuration"] as! Int32
            }
            if dict.keys.contains("MemorySingleRateLimit") {
                self.memorySingleRateLimit = dict["MemorySingleRateLimit"] as! Int32
            }
            if dict.keys.contains("MobileRestart") {
                self.mobileRestart = dict["MobileRestart"] as! String
            }
            if dict.keys.contains("MobileShutdown") {
                self.mobileShutdown = dict["MobileShutdown"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NetRedirect") {
                self.netRedirect = dict["NetRedirect"] as! String
            }
            if dict.keys.contains("NetRedirectRule") {
                var tmp : [DescribeCenterPolicyListResponseBody.DescribePolicyGroups.NetRedirectRule] = []
                for v in dict["NetRedirectRule"] as! [Any] {
                    var model = DescribeCenterPolicyListResponseBody.DescribePolicyGroups.NetRedirectRule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.netRedirectRule = tmp
            }
            if dict.keys.contains("NoOperationDisconnect") {
                self.noOperationDisconnect = dict["NoOperationDisconnect"] as! String
            }
            if dict.keys.contains("NoOperationDisconnectTime") {
                self.noOperationDisconnectTime = dict["NoOperationDisconnectTime"] as! Int32
            }
            if dict.keys.contains("PolicyGroupId") {
                self.policyGroupId = dict["PolicyGroupId"] as! String
            }
            if dict.keys.contains("PolicyGroupType") {
                self.policyGroupType = dict["PolicyGroupType"] as! String
            }
            if dict.keys.contains("PolicyStatus") {
                self.policyStatus = dict["PolicyStatus"] as! String
            }
            if dict.keys.contains("PrinterRedirection") {
                self.printerRedirection = dict["PrinterRedirection"] as! String
            }
            if dict.keys.contains("QualityEnhancement") {
                self.qualityEnhancement = dict["QualityEnhancement"] as! String
            }
            if dict.keys.contains("RecordContent") {
                self.recordContent = dict["RecordContent"] as! String
            }
            if dict.keys.contains("RecordContentExpires") {
                self.recordContentExpires = dict["RecordContentExpires"] as! Int64
            }
            if dict.keys.contains("RecordEventDuration") {
                self.recordEventDuration = dict["RecordEventDuration"] as! Int32
            }
            if dict.keys.contains("RecordEventFilePaths") {
                self.recordEventFilePaths = dict["RecordEventFilePaths"] as! [String]
            }
            if dict.keys.contains("RecordEventRegisters") {
                self.recordEventRegisters = dict["RecordEventRegisters"] as! [String]
            }
            if dict.keys.contains("Recording") {
                self.recording = dict["Recording"] as! String
            }
            if dict.keys.contains("RecordingAudio") {
                self.recordingAudio = dict["RecordingAudio"] as! String
            }
            if dict.keys.contains("RecordingDuration") {
                self.recordingDuration = dict["RecordingDuration"] as! Int32
            }
            if dict.keys.contains("RecordingEndTime") {
                self.recordingEndTime = dict["RecordingEndTime"] as! String
            }
            if dict.keys.contains("RecordingExpires") {
                self.recordingExpires = dict["RecordingExpires"] as! Int64
            }
            if dict.keys.contains("RecordingFps") {
                self.recordingFps = dict["RecordingFps"] as! Int64
            }
            if dict.keys.contains("RecordingStartTime") {
                self.recordingStartTime = dict["RecordingStartTime"] as! String
            }
            if dict.keys.contains("RecordingUserNotify") {
                self.recordingUserNotify = dict["RecordingUserNotify"] as! String
            }
            if dict.keys.contains("RecordingUserNotifyMessage") {
                self.recordingUserNotifyMessage = dict["RecordingUserNotifyMessage"] as! String
            }
            if dict.keys.contains("RemoteCoordinate") {
                self.remoteCoordinate = dict["RemoteCoordinate"] as! String
            }
            if dict.keys.contains("ResolutionHeight") {
                self.resolutionHeight = dict["ResolutionHeight"] as! Int32
            }
            if dict.keys.contains("ResolutionModel") {
                self.resolutionModel = dict["ResolutionModel"] as! String
            }
            if dict.keys.contains("ResolutionWidth") {
                self.resolutionWidth = dict["ResolutionWidth"] as! Int32
            }
            if dict.keys.contains("ResourceGroupCount") {
                self.resourceGroupCount = dict["ResourceGroupCount"] as! Int32
            }
            if dict.keys.contains("Scope") {
                self.scope = dict["Scope"] as! String
            }
            if dict.keys.contains("ScopeValue") {
                self.scopeValue = dict["ScopeValue"] as! [String]
            }
            if dict.keys.contains("SmoothEnhancement") {
                self.smoothEnhancement = dict["SmoothEnhancement"] as! String
            }
            if dict.keys.contains("StatusMonitor") {
                self.statusMonitor = dict["StatusMonitor"] as! String
            }
            if dict.keys.contains("StreamingMode") {
                self.streamingMode = dict["StreamingMode"] as! String
            }
            if dict.keys.contains("TargetFps") {
                self.targetFps = dict["TargetFps"] as! Int32
            }
            if dict.keys.contains("Taskbar") {
                self.taskbar = dict["Taskbar"] as! String
            }
            if dict.keys.contains("UsbRedirect") {
                self.usbRedirect = dict["UsbRedirect"] as! String
            }
            if dict.keys.contains("UsbSupplyRedirectRule") {
                var tmp : [DescribeCenterPolicyListResponseBody.DescribePolicyGroups.UsbSupplyRedirectRule] = []
                for v in dict["UsbSupplyRedirectRule"] as! [Any] {
                    var model = DescribeCenterPolicyListResponseBody.DescribePolicyGroups.UsbSupplyRedirectRule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.usbSupplyRedirectRule = tmp
            }
            if dict.keys.contains("VideoEncAvgKbps") {
                self.videoEncAvgKbps = dict["VideoEncAvgKbps"] as! Int32
            }
            if dict.keys.contains("VideoEncMaxQP") {
                self.videoEncMaxQP = dict["VideoEncMaxQP"] as! Int32
            }
            if dict.keys.contains("VideoEncMinQP") {
                self.videoEncMinQP = dict["VideoEncMinQP"] as! Int32
            }
            if dict.keys.contains("VideoEncPeakKbps") {
                self.videoEncPeakKbps = dict["VideoEncPeakKbps"] as! Int32
            }
            if dict.keys.contains("VideoEncPolicy") {
                self.videoEncPolicy = dict["VideoEncPolicy"] as! String
            }
            if dict.keys.contains("VideoRedirect") {
                self.videoRedirect = dict["VideoRedirect"] as! String
            }
            if dict.keys.contains("VisualQuality") {
                self.visualQuality = dict["VisualQuality"] as! String
            }
            if dict.keys.contains("Watermark") {
                self.watermark = dict["Watermark"] as! String
            }
            if dict.keys.contains("WatermarkAntiCam") {
                self.watermarkAntiCam = dict["WatermarkAntiCam"] as! String
            }
            if dict.keys.contains("WatermarkColor") {
                self.watermarkColor = dict["WatermarkColor"] as! Int32
            }
            if dict.keys.contains("WatermarkCustomText") {
                self.watermarkCustomText = dict["WatermarkCustomText"] as! String
            }
            if dict.keys.contains("WatermarkDegree") {
                self.watermarkDegree = dict["WatermarkDegree"] as! Double
            }
            if dict.keys.contains("WatermarkFontSize") {
                self.watermarkFontSize = dict["WatermarkFontSize"] as! Int32
            }
            if dict.keys.contains("WatermarkFontStyle") {
                self.watermarkFontStyle = dict["WatermarkFontStyle"] as! String
            }
            if dict.keys.contains("WatermarkPower") {
                self.watermarkPower = dict["WatermarkPower"] as! String
            }
            if dict.keys.contains("WatermarkRowAmount") {
                self.watermarkRowAmount = dict["WatermarkRowAmount"] as! Int32
            }
            if dict.keys.contains("WatermarkSecurity") {
                self.watermarkSecurity = dict["WatermarkSecurity"] as! String
            }
            if dict.keys.contains("WatermarkTransparencyValue") {
                self.watermarkTransparencyValue = dict["WatermarkTransparencyValue"] as! Int32
            }
            if dict.keys.contains("WatermarkType") {
                self.watermarkType = dict["WatermarkType"] as! String
            }
            if dict.keys.contains("WyAssistant") {
                self.wyAssistant = dict["WyAssistant"] as! String
            }
        }
    }
    public var describePolicyGroups: [DescribeCenterPolicyListResponseBody.DescribePolicyGroups]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.describePolicyGroups != nil {
            var tmp : [Any] = []
            for k in self.describePolicyGroups! {
                tmp.append(k.toMap())
            }
            map["DescribePolicyGroups"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DescribePolicyGroups") {
            var tmp : [DescribeCenterPolicyListResponseBody.DescribePolicyGroups] = []
            for v in dict["DescribePolicyGroups"] as! [Any] {
                var model = DescribeCenterPolicyListResponseBody.DescribePolicyGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.describePolicyGroups = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeCenterPolicyListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCenterPolicyListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCenterPolicyListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClientEventsRequest : Tea.TeaModel {
    public var desktopId: String?

    public var desktopIp: String?

    public var desktopName: String?

    public var directoryId: String?

    public var endTime: String?

    public var endUserId: String?

    public var eventType: String?

    public var eventTypes: [String]?

    public var fillHardwareInfo: Bool?

    public var language: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var officeSiteId: String?

    public var officeSiteName: String?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.desktopIp != nil {
            map["DesktopIp"] = self.desktopIp!
        }
        if self.desktopName != nil {
            map["DesktopName"] = self.desktopName!
        }
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.eventTypes != nil {
            map["EventTypes"] = self.eventTypes!
        }
        if self.fillHardwareInfo != nil {
            map["FillHardwareInfo"] = self.fillHardwareInfo!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.officeSiteName != nil {
            map["OfficeSiteName"] = self.officeSiteName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("DesktopIp") {
            self.desktopIp = dict["DesktopIp"] as! String
        }
        if dict.keys.contains("DesktopName") {
            self.desktopName = dict["DesktopName"] as! String
        }
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("EventType") {
            self.eventType = dict["EventType"] as! String
        }
        if dict.keys.contains("EventTypes") {
            self.eventTypes = dict["EventTypes"] as! [String]
        }
        if dict.keys.contains("FillHardwareInfo") {
            self.fillHardwareInfo = dict["FillHardwareInfo"] as! Bool
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("OfficeSiteName") {
            self.officeSiteName = dict["OfficeSiteName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeClientEventsResponseBody : Tea.TeaModel {
    public class Events : Tea.TeaModel {
        public class TerminalInfo : Tea.TeaModel {
            public var model: String?

            public var productName: String?

            public var serialNumber: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.model != nil {
                    map["Model"] = self.model!
                }
                if self.productName != nil {
                    map["ProductName"] = self.productName!
                }
                if self.serialNumber != nil {
                    map["SerialNumber"] = self.serialNumber!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Model") {
                    self.model = dict["Model"] as! String
                }
                if dict.keys.contains("ProductName") {
                    self.productName = dict["ProductName"] as! String
                }
                if dict.keys.contains("SerialNumber") {
                    self.serialNumber = dict["SerialNumber"] as! String
                }
            }
        }
        public var aliUid: String?

        public var bytesReceived: String?

        public var bytesSend: String?

        public var clientIp: String?

        public var clientOS: String?

        public var clientVersion: String?

        public var description_: String?

        public var desktopGroupId: String?

        public var desktopGroupName: String?

        public var desktopId: String?

        public var desktopIp: String?

        public var desktopName: String?

        public var directoryId: String?

        public var directoryType: String?

        public var endUserId: String?

        public var eventId: String?

        public var eventTime: String?

        public var eventType: String?

        public var officeSiteId: String?

        public var officeSiteName: String?

        public var officeSiteType: String?

        public var regionId: String?

        public var status: String?

        public var terminalInfo: DescribeClientEventsResponseBody.Events.TerminalInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.terminalInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliUid != nil {
                map["AliUid"] = self.aliUid!
            }
            if self.bytesReceived != nil {
                map["BytesReceived"] = self.bytesReceived!
            }
            if self.bytesSend != nil {
                map["BytesSend"] = self.bytesSend!
            }
            if self.clientIp != nil {
                map["ClientIp"] = self.clientIp!
            }
            if self.clientOS != nil {
                map["ClientOS"] = self.clientOS!
            }
            if self.clientVersion != nil {
                map["ClientVersion"] = self.clientVersion!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.desktopGroupId != nil {
                map["DesktopGroupId"] = self.desktopGroupId!
            }
            if self.desktopGroupName != nil {
                map["DesktopGroupName"] = self.desktopGroupName!
            }
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.desktopIp != nil {
                map["DesktopIp"] = self.desktopIp!
            }
            if self.desktopName != nil {
                map["DesktopName"] = self.desktopName!
            }
            if self.directoryId != nil {
                map["DirectoryId"] = self.directoryId!
            }
            if self.directoryType != nil {
                map["DirectoryType"] = self.directoryType!
            }
            if self.endUserId != nil {
                map["EndUserId"] = self.endUserId!
            }
            if self.eventId != nil {
                map["EventId"] = self.eventId!
            }
            if self.eventTime != nil {
                map["EventTime"] = self.eventTime!
            }
            if self.eventType != nil {
                map["EventType"] = self.eventType!
            }
            if self.officeSiteId != nil {
                map["OfficeSiteId"] = self.officeSiteId!
            }
            if self.officeSiteName != nil {
                map["OfficeSiteName"] = self.officeSiteName!
            }
            if self.officeSiteType != nil {
                map["OfficeSiteType"] = self.officeSiteType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.terminalInfo != nil {
                map["TerminalInfo"] = self.terminalInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliUid") {
                self.aliUid = dict["AliUid"] as! String
            }
            if dict.keys.contains("BytesReceived") {
                self.bytesReceived = dict["BytesReceived"] as! String
            }
            if dict.keys.contains("BytesSend") {
                self.bytesSend = dict["BytesSend"] as! String
            }
            if dict.keys.contains("ClientIp") {
                self.clientIp = dict["ClientIp"] as! String
            }
            if dict.keys.contains("ClientOS") {
                self.clientOS = dict["ClientOS"] as! String
            }
            if dict.keys.contains("ClientVersion") {
                self.clientVersion = dict["ClientVersion"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DesktopGroupId") {
                self.desktopGroupId = dict["DesktopGroupId"] as! String
            }
            if dict.keys.contains("DesktopGroupName") {
                self.desktopGroupName = dict["DesktopGroupName"] as! String
            }
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("DesktopIp") {
                self.desktopIp = dict["DesktopIp"] as! String
            }
            if dict.keys.contains("DesktopName") {
                self.desktopName = dict["DesktopName"] as! String
            }
            if dict.keys.contains("DirectoryId") {
                self.directoryId = dict["DirectoryId"] as! String
            }
            if dict.keys.contains("DirectoryType") {
                self.directoryType = dict["DirectoryType"] as! String
            }
            if dict.keys.contains("EndUserId") {
                self.endUserId = dict["EndUserId"] as! String
            }
            if dict.keys.contains("EventId") {
                self.eventId = dict["EventId"] as! String
            }
            if dict.keys.contains("EventTime") {
                self.eventTime = dict["EventTime"] as! String
            }
            if dict.keys.contains("EventType") {
                self.eventType = dict["EventType"] as! String
            }
            if dict.keys.contains("OfficeSiteId") {
                self.officeSiteId = dict["OfficeSiteId"] as! String
            }
            if dict.keys.contains("OfficeSiteName") {
                self.officeSiteName = dict["OfficeSiteName"] as! String
            }
            if dict.keys.contains("OfficeSiteType") {
                self.officeSiteType = dict["OfficeSiteType"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TerminalInfo") {
                var model = DescribeClientEventsResponseBody.Events.TerminalInfo()
                model.fromMap(dict["TerminalInfo"] as! [String: Any])
                self.terminalInfo = model
            }
        }
    }
    public var events: [DescribeClientEventsResponseBody.Events]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.events != nil {
            var tmp : [Any] = []
            for k in self.events! {
                tmp.append(k.toMap())
            }
            map["Events"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Events") {
            var tmp : [DescribeClientEventsResponseBody.Events] = []
            for v in dict["Events"] as! [Any] {
                var model = DescribeClientEventsResponseBody.Events()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.events = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeClientEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClientEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeClientEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudDriveGroupsRequest : Tea.TeaModel {
    public var cdsId: String?

    public var directoryId: String?

    public var directoryName: String?

    public var driveStatus: String?

    public var driveType: String?

    public var groupId: [String]?

    public var groupName: String?

    public var groupType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var parentGroupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.directoryName != nil {
            map["DirectoryName"] = self.directoryName!
        }
        if self.driveStatus != nil {
            map["DriveStatus"] = self.driveStatus!
        }
        if self.driveType != nil {
            map["DriveType"] = self.driveType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.groupType != nil {
            map["GroupType"] = self.groupType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.parentGroupId != nil {
            map["ParentGroupId"] = self.parentGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("DirectoryName") {
            self.directoryName = dict["DirectoryName"] as! String
        }
        if dict.keys.contains("DriveStatus") {
            self.driveStatus = dict["DriveStatus"] as! String
        }
        if dict.keys.contains("DriveType") {
            self.driveType = dict["DriveType"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! [String]
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("GroupType") {
            self.groupType = dict["GroupType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ParentGroupId") {
            self.parentGroupId = dict["ParentGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeCloudDriveGroupsResponseBody : Tea.TeaModel {
    public class CloudDriveGroups : Tea.TeaModel {
        public class AdminUserInfos : Tea.TeaModel {
            public var email: String?

            public var endUserId: String?

            public var jobNumber: String?

            public var nickName: String?

            public var phone: String?

            public var realNickName: String?

            public var remark: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.endUserId != nil {
                    map["EndUserId"] = self.endUserId!
                }
                if self.jobNumber != nil {
                    map["JobNumber"] = self.jobNumber!
                }
                if self.nickName != nil {
                    map["NickName"] = self.nickName!
                }
                if self.phone != nil {
                    map["Phone"] = self.phone!
                }
                if self.realNickName != nil {
                    map["RealNickName"] = self.realNickName!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Email") {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("EndUserId") {
                    self.endUserId = dict["EndUserId"] as! String
                }
                if dict.keys.contains("JobNumber") {
                    self.jobNumber = dict["JobNumber"] as! String
                }
                if dict.keys.contains("NickName") {
                    self.nickName = dict["NickName"] as! String
                }
                if dict.keys.contains("Phone") {
                    self.phone = dict["Phone"] as! String
                }
                if dict.keys.contains("RealNickName") {
                    self.realNickName = dict["RealNickName"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
            }
        }
        public var adminUserIds: String?

        public var adminUserInfos: [DescribeCloudDriveGroupsResponseBody.CloudDriveGroups.AdminUserInfos]?

        public var createTime: String?

        public var directoryId: String?

        public var driveId: String?

        public var groupId: String?

        public var groupName: String?

        public var orgId: String?

        public var recycleBinSize: String?

        public var status: String?

        public var totalSize: Int64?

        public var usedSize: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.adminUserIds != nil {
                map["AdminUserIds"] = self.adminUserIds!
            }
            if self.adminUserInfos != nil {
                var tmp : [Any] = []
                for k in self.adminUserInfos! {
                    tmp.append(k.toMap())
                }
                map["AdminUserInfos"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.directoryId != nil {
                map["DirectoryId"] = self.directoryId!
            }
            if self.driveId != nil {
                map["DriveId"] = self.driveId!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.orgId != nil {
                map["OrgId"] = self.orgId!
            }
            if self.recycleBinSize != nil {
                map["RecycleBinSize"] = self.recycleBinSize!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            if self.usedSize != nil {
                map["UsedSize"] = self.usedSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AdminUserIds") {
                self.adminUserIds = dict["AdminUserIds"] as! String
            }
            if dict.keys.contains("AdminUserInfos") {
                var tmp : [DescribeCloudDriveGroupsResponseBody.CloudDriveGroups.AdminUserInfos] = []
                for v in dict["AdminUserInfos"] as! [Any] {
                    var model = DescribeCloudDriveGroupsResponseBody.CloudDriveGroups.AdminUserInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.adminUserInfos = tmp
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DirectoryId") {
                self.directoryId = dict["DirectoryId"] as! String
            }
            if dict.keys.contains("DriveId") {
                self.driveId = dict["DriveId"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("OrgId") {
                self.orgId = dict["OrgId"] as! String
            }
            if dict.keys.contains("RecycleBinSize") {
                self.recycleBinSize = dict["RecycleBinSize"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int64
            }
            if dict.keys.contains("UsedSize") {
                self.usedSize = dict["UsedSize"] as! String
            }
        }
    }
    public var cloudDriveGroups: [DescribeCloudDriveGroupsResponseBody.CloudDriveGroups]?

    public var count: Int64?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cloudDriveGroups != nil {
            var tmp : [Any] = []
            for k in self.cloudDriveGroups! {
                tmp.append(k.toMap())
            }
            map["CloudDriveGroups"] = tmp
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CloudDriveGroups") {
            var tmp : [DescribeCloudDriveGroupsResponseBody.CloudDriveGroups] = []
            for v in dict["CloudDriveGroups"] as! [Any] {
                var model = DescribeCloudDriveGroupsResponseBody.CloudDriveGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.cloudDriveGroups = tmp
        }
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeCloudDriveGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudDriveGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudDriveGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudDrivePermissionsRequest : Tea.TeaModel {
    public var cdsId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeCloudDrivePermissionsResponseBody : Tea.TeaModel {
    public class CloudDrivePermissionModels : Tea.TeaModel {
        public var endUsers: [String]?

        public var permission: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endUsers != nil {
                map["EndUsers"] = self.endUsers!
            }
            if self.permission != nil {
                map["Permission"] = self.permission!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndUsers") {
                self.endUsers = dict["EndUsers"] as! [String]
            }
            if dict.keys.contains("Permission") {
                self.permission = dict["Permission"] as! String
            }
        }
    }
    public var cloudDrivePermissionModels: [DescribeCloudDrivePermissionsResponseBody.CloudDrivePermissionModels]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cloudDrivePermissionModels != nil {
            var tmp : [Any] = []
            for k in self.cloudDrivePermissionModels! {
                tmp.append(k.toMap())
            }
            map["CloudDrivePermissionModels"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CloudDrivePermissionModels") {
            var tmp : [DescribeCloudDrivePermissionsResponseBody.CloudDrivePermissionModels] = []
            for v in dict["CloudDrivePermissionModels"] as! [Any] {
                var model = DescribeCloudDrivePermissionsResponseBody.CloudDrivePermissionModels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.cloudDrivePermissionModels = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCloudDrivePermissionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudDrivePermissionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudDrivePermissionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudDriveUsersRequest : Tea.TeaModel {
    public var cdsId: String?

    public var endUserId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeCloudDriveUsersResponseBody : Tea.TeaModel {
    public class CloudDriveUsers : Tea.TeaModel {
        public var driveId: String?

        public var endUserId: String?

        public var status: String?

        public var totalSize: Int64?

        public var usedSize: Int64?

        public var userId: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.driveId != nil {
                map["DriveId"] = self.driveId!
            }
            if self.endUserId != nil {
                map["EndUserId"] = self.endUserId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            if self.usedSize != nil {
                map["UsedSize"] = self.usedSize!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DriveId") {
                self.driveId = dict["DriveId"] as! String
            }
            if dict.keys.contains("EndUserId") {
                self.endUserId = dict["EndUserId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int64
            }
            if dict.keys.contains("UsedSize") {
                self.usedSize = dict["UsedSize"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var cloudDriveUsers: [DescribeCloudDriveUsersResponseBody.CloudDriveUsers]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cloudDriveUsers != nil {
            var tmp : [Any] = []
            for k in self.cloudDriveUsers! {
                tmp.append(k.toMap())
            }
            map["CloudDriveUsers"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CloudDriveUsers") {
            var tmp : [DescribeCloudDriveUsersResponseBody.CloudDriveUsers] = []
            for v in dict["CloudDriveUsers"] as! [Any] {
                var model = DescribeCloudDriveUsersResponseBody.CloudDriveUsers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.cloudDriveUsers = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCloudDriveUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudDriveUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudDriveUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConfigGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var groupIds: [String]?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var productType: String?

    public var regionId: String?

    public var statuses: [String]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupIds != nil {
            map["GroupIds"] = self.groupIds!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.productType != nil {
            map["ProductType"] = self.productType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.statuses != nil {
            map["Statuses"] = self.statuses!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupIds") {
            self.groupIds = dict["GroupIds"] as! [String]
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProductType") {
            self.productType = dict["ProductType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Statuses") {
            self.statuses = dict["Statuses"] as! [String]
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeConfigGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var bindCount: Int32?

        public var bindCountMap: [String: Int32]?

        public var description_: String?

        public var groupId: String?

        public var name: String?

        public var productType: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bindCount != nil {
                map["BindCount"] = self.bindCount!
            }
            if self.bindCountMap != nil {
                map["BindCountMap"] = self.bindCountMap!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.productType != nil {
                map["ProductType"] = self.productType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BindCount") {
                self.bindCount = dict["BindCount"] as! Int32
            }
            if dict.keys.contains("BindCountMap") {
                self.bindCountMap = dict["BindCountMap"] as! [String: Int32]
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ProductType") {
                self.productType = dict["ProductType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var data: [DescribeConfigGroupResponseBody.Data]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeConfigGroupResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeConfigGroupResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeConfigGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConfigGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConfigGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomizedListHeadersRequest : Tea.TeaModel {
    public var langType: String?

    public var listType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.langType != nil {
            map["LangType"] = self.langType!
        }
        if self.listType != nil {
            map["ListType"] = self.listType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LangType") {
            self.langType = dict["LangType"] as! String
        }
        if dict.keys.contains("ListType") {
            self.listType = dict["ListType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeCustomizedListHeadersResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var displayType: String?

        public var headerKey: String?

        public var headerName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayType != nil {
                map["DisplayType"] = self.displayType!
            }
            if self.headerKey != nil {
                map["HeaderKey"] = self.headerKey!
            }
            if self.headerName != nil {
                map["HeaderName"] = self.headerName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayType") {
                self.displayType = dict["DisplayType"] as! String
            }
            if dict.keys.contains("HeaderKey") {
                self.headerKey = dict["HeaderKey"] as! String
            }
            if dict.keys.contains("HeaderName") {
                self.headerName = dict["HeaderName"] as! String
            }
        }
    }
    public var headers: [DescribeCustomizedListHeadersResponseBody.Headers]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            var tmp : [Any] = []
            for k in self.headers! {
                tmp.append(k.toMap())
            }
            map["Headers"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var tmp : [DescribeCustomizedListHeadersResponseBody.Headers] = []
            for v in dict["Headers"] as! [Any] {
                var model = DescribeCustomizedListHeadersResponseBody.Headers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.headers = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCustomizedListHeadersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomizedListHeadersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCustomizedListHeadersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDesktopGroupSessionsRequest : Tea.TeaModel {
    public var endTime: String?

    public var endUserId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownType: Int32?

    public var regionId: String?

    public var sessionStatus: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownType != nil {
            map["OwnType"] = self.ownType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sessionStatus != nil {
            map["SessionStatus"] = self.sessionStatus!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnType") {
            self.ownType = dict["OwnType"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SessionStatus") {
            self.sessionStatus = dict["SessionStatus"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeDesktopGroupSessionsResponseBody : Tea.TeaModel {
    public class Sessions : Tea.TeaModel {
        public var clientIp: String?

        public var clientOS: String?

        public var clientVersion: String?

        public var desktopGroupId: String?

        public var desktopGroupName: String?

        public var desktopId: String?

        public var endUserApplyCoordinateTime: Int64?

        public var endUserId: String?

        public var lastSessionEndTime: String?

        public var lastSessionStartTime: String?

        public var latestConnectionTime: Int64?

        public var officeSiteId: String?

        public var officeSiteName: String?

        public var osType: String?

        public var ownType: Int32?

        public var protocolType: String?

        public var sessionIdleTime: Int64?

        public var sessionStatus: String?

        public var totalConnectionDuration: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientIp != nil {
                map["ClientIp"] = self.clientIp!
            }
            if self.clientOS != nil {
                map["ClientOS"] = self.clientOS!
            }
            if self.clientVersion != nil {
                map["ClientVersion"] = self.clientVersion!
            }
            if self.desktopGroupId != nil {
                map["DesktopGroupId"] = self.desktopGroupId!
            }
            if self.desktopGroupName != nil {
                map["DesktopGroupName"] = self.desktopGroupName!
            }
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.endUserApplyCoordinateTime != nil {
                map["EndUserApplyCoordinateTime"] = self.endUserApplyCoordinateTime!
            }
            if self.endUserId != nil {
                map["EndUserId"] = self.endUserId!
            }
            if self.lastSessionEndTime != nil {
                map["LastSessionEndTime"] = self.lastSessionEndTime!
            }
            if self.lastSessionStartTime != nil {
                map["LastSessionStartTime"] = self.lastSessionStartTime!
            }
            if self.latestConnectionTime != nil {
                map["LatestConnectionTime"] = self.latestConnectionTime!
            }
            if self.officeSiteId != nil {
                map["OfficeSiteId"] = self.officeSiteId!
            }
            if self.officeSiteName != nil {
                map["OfficeSiteName"] = self.officeSiteName!
            }
            if self.osType != nil {
                map["OsType"] = self.osType!
            }
            if self.ownType != nil {
                map["OwnType"] = self.ownType!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.sessionIdleTime != nil {
                map["SessionIdleTime"] = self.sessionIdleTime!
            }
            if self.sessionStatus != nil {
                map["SessionStatus"] = self.sessionStatus!
            }
            if self.totalConnectionDuration != nil {
                map["TotalConnectionDuration"] = self.totalConnectionDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientIp") {
                self.clientIp = dict["ClientIp"] as! String
            }
            if dict.keys.contains("ClientOS") {
                self.clientOS = dict["ClientOS"] as! String
            }
            if dict.keys.contains("ClientVersion") {
                self.clientVersion = dict["ClientVersion"] as! String
            }
            if dict.keys.contains("DesktopGroupId") {
                self.desktopGroupId = dict["DesktopGroupId"] as! String
            }
            if dict.keys.contains("DesktopGroupName") {
                self.desktopGroupName = dict["DesktopGroupName"] as! String
            }
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("EndUserApplyCoordinateTime") {
                self.endUserApplyCoordinateTime = dict["EndUserApplyCoordinateTime"] as! Int64
            }
            if dict.keys.contains("EndUserId") {
                self.endUserId = dict["EndUserId"] as! String
            }
            if dict.keys.contains("LastSessionEndTime") {
                self.lastSessionEndTime = dict["LastSessionEndTime"] as! String
            }
            if dict.keys.contains("LastSessionStartTime") {
                self.lastSessionStartTime = dict["LastSessionStartTime"] as! String
            }
            if dict.keys.contains("LatestConnectionTime") {
                self.latestConnectionTime = dict["LatestConnectionTime"] as! Int64
            }
            if dict.keys.contains("OfficeSiteId") {
                self.officeSiteId = dict["OfficeSiteId"] as! String
            }
            if dict.keys.contains("OfficeSiteName") {
                self.officeSiteName = dict["OfficeSiteName"] as! String
            }
            if dict.keys.contains("OsType") {
                self.osType = dict["OsType"] as! String
            }
            if dict.keys.contains("OwnType") {
                self.ownType = dict["OwnType"] as! Int32
            }
            if dict.keys.contains("ProtocolType") {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("SessionIdleTime") {
                self.sessionIdleTime = dict["SessionIdleTime"] as! Int64
            }
            if dict.keys.contains("SessionStatus") {
                self.sessionStatus = dict["SessionStatus"] as! String
            }
            if dict.keys.contains("TotalConnectionDuration") {
                self.totalConnectionDuration = dict["TotalConnectionDuration"] as! Int64
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var sessions: [DescribeDesktopGroupSessionsResponseBody.Sessions]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sessions != nil {
            var tmp : [Any] = []
            for k in self.sessions! {
                tmp.append(k.toMap())
            }
            map["Sessions"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Sessions") {
            var tmp : [DescribeDesktopGroupSessionsResponseBody.Sessions] = []
            for v in dict["Sessions"] as! [Any] {
                var model = DescribeDesktopGroupSessionsResponseBody.Sessions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sessions = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDesktopGroupSessionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDesktopGroupSessionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDesktopGroupSessionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDesktopGroupsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var bundleId: [String]?

    public var desktopGroupId: String?

    public var desktopGroupIds: [String]?

    public var desktopGroupName: String?

    public var endUserIds: [String]?

    public var excludedEndUserIds: [String]?

    public var imageId: [String]?

    public var maxResults: Int32?

    public var multiResource: Bool?

    public var nextToken: String?

    public var officeSiteId: String?

    public var ownType: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var policyGroupId: String?

    public var protocolType: String?

    public var regionId: String?

    public var status: Int32?

    public var tag: [DescribeDesktopGroupsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bundleId != nil {
            map["BundleId"] = self.bundleId!
        }
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.desktopGroupIds != nil {
            map["DesktopGroupIds"] = self.desktopGroupIds!
        }
        if self.desktopGroupName != nil {
            map["DesktopGroupName"] = self.desktopGroupName!
        }
        if self.endUserIds != nil {
            map["EndUserIds"] = self.endUserIds!
        }
        if self.excludedEndUserIds != nil {
            map["ExcludedEndUserIds"] = self.excludedEndUserIds!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.multiResource != nil {
            map["MultiResource"] = self.multiResource!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.ownType != nil {
            map["OwnType"] = self.ownType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BundleId") {
            self.bundleId = dict["BundleId"] as! [String]
        }
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("DesktopGroupIds") {
            self.desktopGroupIds = dict["DesktopGroupIds"] as! [String]
        }
        if dict.keys.contains("DesktopGroupName") {
            self.desktopGroupName = dict["DesktopGroupName"] as! String
        }
        if dict.keys.contains("EndUserIds") {
            self.endUserIds = dict["EndUserIds"] as! [String]
        }
        if dict.keys.contains("ExcludedEndUserIds") {
            self.excludedEndUserIds = dict["ExcludedEndUserIds"] as! [String]
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! [String]
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MultiResource") {
            self.multiResource = dict["MultiResource"] as! Bool
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("OwnType") {
            self.ownType = dict["OwnType"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeDesktopGroupsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeDesktopGroupsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeDesktopGroupsResponseBody : Tea.TeaModel {
    public class DesktopGroups : Tea.TeaModel {
        public class CountPerStatus : Tea.TeaModel {
            public var count: Int32?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var bindAmount: Int64?

        public var buyDesktopsCount: Int32?

        public var comments: String?

        public var connectDuration: Int64?

        public var countPerStatus: [DescribeDesktopGroupsResponseBody.DesktopGroups.CountPerStatus]?

        public var cpu: Int32?

        public var createTime: String?

        public var creator: String?

        public var dataDiskCategory: String?

        public var dataDiskSize: String?

        public var desktopCount: Int32?

        public var desktopGroupId: String?

        public var desktopGroupName: String?

        public var desktopType: String?

        public var endUserCount: Int32?

        public var expiredTime: String?

        public var gpuCount: Double?

        public var gpuDriverVersion: String?

        public var gpuSpec: String?

        public var idleDisconnectDuration: Int64?

        public var imageId: String?

        public var isLdap: Bool?

        public var keepDuration: Int64?

        public var loadPolicy: Int64?

        public var maxDesktopsCount: Int32?

        public var memory: Int64?

        public var minDesktopsCount: Int32?

        public var officeSiteId: String?

        public var officeSiteName: String?

        public var officeSiteType: String?

        public var osType: String?

        public var ownBundleId: String?

        public var ownBundleName: String?

        public var ownType: Int64?

        public var payType: String?

        public var policyGroupId: String?

        public var policyGroupName: String?

        public var protocolType: String?

        public var ratioThreshold: Double?

        public var resetType: Int64?

        public var status: Int32?

        public var stopDuration: Int64?

        public var subnetId: String?

        public var systemDiskCategory: String?

        public var systemDiskSize: Int32?

        public var tags: [DescribeDesktopGroupsResponseBody.DesktopGroups.Tags]?

        public var userOuPath: String?

        public var version: Int32?

        public var volumeEncryptionEnabled: Bool?

        public var volumeEncryptionKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bindAmount != nil {
                map["BindAmount"] = self.bindAmount!
            }
            if self.buyDesktopsCount != nil {
                map["BuyDesktopsCount"] = self.buyDesktopsCount!
            }
            if self.comments != nil {
                map["Comments"] = self.comments!
            }
            if self.connectDuration != nil {
                map["ConnectDuration"] = self.connectDuration!
            }
            if self.countPerStatus != nil {
                var tmp : [Any] = []
                for k in self.countPerStatus! {
                    tmp.append(k.toMap())
                }
                map["CountPerStatus"] = tmp
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.dataDiskCategory != nil {
                map["DataDiskCategory"] = self.dataDiskCategory!
            }
            if self.dataDiskSize != nil {
                map["DataDiskSize"] = self.dataDiskSize!
            }
            if self.desktopCount != nil {
                map["DesktopCount"] = self.desktopCount!
            }
            if self.desktopGroupId != nil {
                map["DesktopGroupId"] = self.desktopGroupId!
            }
            if self.desktopGroupName != nil {
                map["DesktopGroupName"] = self.desktopGroupName!
            }
            if self.desktopType != nil {
                map["DesktopType"] = self.desktopType!
            }
            if self.endUserCount != nil {
                map["EndUserCount"] = self.endUserCount!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.gpuCount != nil {
                map["GpuCount"] = self.gpuCount!
            }
            if self.gpuDriverVersion != nil {
                map["GpuDriverVersion"] = self.gpuDriverVersion!
            }
            if self.gpuSpec != nil {
                map["GpuSpec"] = self.gpuSpec!
            }
            if self.idleDisconnectDuration != nil {
                map["IdleDisconnectDuration"] = self.idleDisconnectDuration!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.isLdap != nil {
                map["IsLdap"] = self.isLdap!
            }
            if self.keepDuration != nil {
                map["KeepDuration"] = self.keepDuration!
            }
            if self.loadPolicy != nil {
                map["LoadPolicy"] = self.loadPolicy!
            }
            if self.maxDesktopsCount != nil {
                map["MaxDesktopsCount"] = self.maxDesktopsCount!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.minDesktopsCount != nil {
                map["MinDesktopsCount"] = self.minDesktopsCount!
            }
            if self.officeSiteId != nil {
                map["OfficeSiteId"] = self.officeSiteId!
            }
            if self.officeSiteName != nil {
                map["OfficeSiteName"] = self.officeSiteName!
            }
            if self.officeSiteType != nil {
                map["OfficeSiteType"] = self.officeSiteType!
            }
            if self.osType != nil {
                map["OsType"] = self.osType!
            }
            if self.ownBundleId != nil {
                map["OwnBundleId"] = self.ownBundleId!
            }
            if self.ownBundleName != nil {
                map["OwnBundleName"] = self.ownBundleName!
            }
            if self.ownType != nil {
                map["OwnType"] = self.ownType!
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.policyGroupId != nil {
                map["PolicyGroupId"] = self.policyGroupId!
            }
            if self.policyGroupName != nil {
                map["PolicyGroupName"] = self.policyGroupName!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.ratioThreshold != nil {
                map["RatioThreshold"] = self.ratioThreshold!
            }
            if self.resetType != nil {
                map["ResetType"] = self.resetType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.stopDuration != nil {
                map["StopDuration"] = self.stopDuration!
            }
            if self.subnetId != nil {
                map["SubnetId"] = self.subnetId!
            }
            if self.systemDiskCategory != nil {
                map["SystemDiskCategory"] = self.systemDiskCategory!
            }
            if self.systemDiskSize != nil {
                map["SystemDiskSize"] = self.systemDiskSize!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.userOuPath != nil {
                map["UserOuPath"] = self.userOuPath!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.volumeEncryptionEnabled != nil {
                map["VolumeEncryptionEnabled"] = self.volumeEncryptionEnabled!
            }
            if self.volumeEncryptionKey != nil {
                map["VolumeEncryptionKey"] = self.volumeEncryptionKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BindAmount") {
                self.bindAmount = dict["BindAmount"] as! Int64
            }
            if dict.keys.contains("BuyDesktopsCount") {
                self.buyDesktopsCount = dict["BuyDesktopsCount"] as! Int32
            }
            if dict.keys.contains("Comments") {
                self.comments = dict["Comments"] as! String
            }
            if dict.keys.contains("ConnectDuration") {
                self.connectDuration = dict["ConnectDuration"] as! Int64
            }
            if dict.keys.contains("CountPerStatus") {
                var tmp : [DescribeDesktopGroupsResponseBody.DesktopGroups.CountPerStatus] = []
                for v in dict["CountPerStatus"] as! [Any] {
                    var model = DescribeDesktopGroupsResponseBody.DesktopGroups.CountPerStatus()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.countPerStatus = tmp
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("DataDiskCategory") {
                self.dataDiskCategory = dict["DataDiskCategory"] as! String
            }
            if dict.keys.contains("DataDiskSize") {
                self.dataDiskSize = dict["DataDiskSize"] as! String
            }
            if dict.keys.contains("DesktopCount") {
                self.desktopCount = dict["DesktopCount"] as! Int32
            }
            if dict.keys.contains("DesktopGroupId") {
                self.desktopGroupId = dict["DesktopGroupId"] as! String
            }
            if dict.keys.contains("DesktopGroupName") {
                self.desktopGroupName = dict["DesktopGroupName"] as! String
            }
            if dict.keys.contains("DesktopType") {
                self.desktopType = dict["DesktopType"] as! String
            }
            if dict.keys.contains("EndUserCount") {
                self.endUserCount = dict["EndUserCount"] as! Int32
            }
            if dict.keys.contains("ExpiredTime") {
                self.expiredTime = dict["ExpiredTime"] as! String
            }
            if dict.keys.contains("GpuCount") {
                self.gpuCount = dict["GpuCount"] as! Double
            }
            if dict.keys.contains("GpuDriverVersion") {
                self.gpuDriverVersion = dict["GpuDriverVersion"] as! String
            }
            if dict.keys.contains("GpuSpec") {
                self.gpuSpec = dict["GpuSpec"] as! String
            }
            if dict.keys.contains("IdleDisconnectDuration") {
                self.idleDisconnectDuration = dict["IdleDisconnectDuration"] as! Int64
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("IsLdap") {
                self.isLdap = dict["IsLdap"] as! Bool
            }
            if dict.keys.contains("KeepDuration") {
                self.keepDuration = dict["KeepDuration"] as! Int64
            }
            if dict.keys.contains("LoadPolicy") {
                self.loadPolicy = dict["LoadPolicy"] as! Int64
            }
            if dict.keys.contains("MaxDesktopsCount") {
                self.maxDesktopsCount = dict["MaxDesktopsCount"] as! Int32
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Int64
            }
            if dict.keys.contains("MinDesktopsCount") {
                self.minDesktopsCount = dict["MinDesktopsCount"] as! Int32
            }
            if dict.keys.contains("OfficeSiteId") {
                self.officeSiteId = dict["OfficeSiteId"] as! String
            }
            if dict.keys.contains("OfficeSiteName") {
                self.officeSiteName = dict["OfficeSiteName"] as! String
            }
            if dict.keys.contains("OfficeSiteType") {
                self.officeSiteType = dict["OfficeSiteType"] as! String
            }
            if dict.keys.contains("OsType") {
                self.osType = dict["OsType"] as! String
            }
            if dict.keys.contains("OwnBundleId") {
                self.ownBundleId = dict["OwnBundleId"] as! String
            }
            if dict.keys.contains("OwnBundleName") {
                self.ownBundleName = dict["OwnBundleName"] as! String
            }
            if dict.keys.contains("OwnType") {
                self.ownType = dict["OwnType"] as! Int64
            }
            if dict.keys.contains("PayType") {
                self.payType = dict["PayType"] as! String
            }
            if dict.keys.contains("PolicyGroupId") {
                self.policyGroupId = dict["PolicyGroupId"] as! String
            }
            if dict.keys.contains("PolicyGroupName") {
                self.policyGroupName = dict["PolicyGroupName"] as! String
            }
            if dict.keys.contains("ProtocolType") {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("RatioThreshold") {
                self.ratioThreshold = dict["RatioThreshold"] as! Double
            }
            if dict.keys.contains("ResetType") {
                self.resetType = dict["ResetType"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("StopDuration") {
                self.stopDuration = dict["StopDuration"] as! Int64
            }
            if dict.keys.contains("SubnetId") {
                self.subnetId = dict["SubnetId"] as! String
            }
            if dict.keys.contains("SystemDiskCategory") {
                self.systemDiskCategory = dict["SystemDiskCategory"] as! String
            }
            if dict.keys.contains("SystemDiskSize") {
                self.systemDiskSize = dict["SystemDiskSize"] as! Int32
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeDesktopGroupsResponseBody.DesktopGroups.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeDesktopGroupsResponseBody.DesktopGroups.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("UserOuPath") {
                self.userOuPath = dict["UserOuPath"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int32
            }
            if dict.keys.contains("VolumeEncryptionEnabled") {
                self.volumeEncryptionEnabled = dict["VolumeEncryptionEnabled"] as! Bool
            }
            if dict.keys.contains("VolumeEncryptionKey") {
                self.volumeEncryptionKey = dict["VolumeEncryptionKey"] as! String
            }
        }
    }
    public var desktopGroups: [DescribeDesktopGroupsResponseBody.DesktopGroups]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopGroups != nil {
            var tmp : [Any] = []
            for k in self.desktopGroups! {
                tmp.append(k.toMap())
            }
            map["DesktopGroups"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopGroups") {
            var tmp : [DescribeDesktopGroupsResponseBody.DesktopGroups] = []
            for v in dict["DesktopGroups"] as! [Any] {
                var model = DescribeDesktopGroupsResponseBody.DesktopGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.desktopGroups = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDesktopGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDesktopGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDesktopGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDesktopInfoRequest : Tea.TeaModel {
    public var desktopId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeDesktopInfoResponseBody : Tea.TeaModel {
    public class Desktops : Tea.TeaModel {
        public var connectionStatus: String?

        public var currentAppVersion: String?

        public var desktopGroupId: String?

        public var desktopId: String?

        public var desktopStatus: String?

        public var managementFlag: [String]?

        public var newAppSize: Int64?

        public var newAppVersion: String?

        public var releaseNote: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectionStatus != nil {
                map["ConnectionStatus"] = self.connectionStatus!
            }
            if self.currentAppVersion != nil {
                map["CurrentAppVersion"] = self.currentAppVersion!
            }
            if self.desktopGroupId != nil {
                map["DesktopGroupId"] = self.desktopGroupId!
            }
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.desktopStatus != nil {
                map["DesktopStatus"] = self.desktopStatus!
            }
            if self.managementFlag != nil {
                map["ManagementFlag"] = self.managementFlag!
            }
            if self.newAppSize != nil {
                map["NewAppSize"] = self.newAppSize!
            }
            if self.newAppVersion != nil {
                map["NewAppVersion"] = self.newAppVersion!
            }
            if self.releaseNote != nil {
                map["ReleaseNote"] = self.releaseNote!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConnectionStatus") {
                self.connectionStatus = dict["ConnectionStatus"] as! String
            }
            if dict.keys.contains("CurrentAppVersion") {
                self.currentAppVersion = dict["CurrentAppVersion"] as! String
            }
            if dict.keys.contains("DesktopGroupId") {
                self.desktopGroupId = dict["DesktopGroupId"] as! String
            }
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("DesktopStatus") {
                self.desktopStatus = dict["DesktopStatus"] as! String
            }
            if dict.keys.contains("ManagementFlag") {
                self.managementFlag = dict["ManagementFlag"] as! [String]
            }
            if dict.keys.contains("NewAppSize") {
                self.newAppSize = dict["NewAppSize"] as! Int64
            }
            if dict.keys.contains("NewAppVersion") {
                self.newAppVersion = dict["NewAppVersion"] as! String
            }
            if dict.keys.contains("ReleaseNote") {
                self.releaseNote = dict["ReleaseNote"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public var desktops: [DescribeDesktopInfoResponseBody.Desktops]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktops != nil {
            var tmp : [Any] = []
            for k in self.desktops! {
                tmp.append(k.toMap())
            }
            map["Desktops"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Desktops") {
            var tmp : [DescribeDesktopInfoResponseBody.Desktops] = []
            for v in dict["Desktops"] as! [Any] {
                var model = DescribeDesktopInfoResponseBody.Desktops()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.desktops = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDesktopInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDesktopInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDesktopInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDesktopOversoldGroupRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var oversoldGroupIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.oversoldGroupIds != nil {
            map["OversoldGroupIds"] = self.oversoldGroupIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OversoldGroupIds") {
            self.oversoldGroupIds = dict["OversoldGroupIds"] as! [String]
        }
    }
}

public class DescribeDesktopOversoldGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var concurrenceCount: Int32?

        public var curConcurrenceCount: Int32?

        public var dataDiskSize: Int32?

        public var description_: String?

        public var desktopType: String?

        public var directoryId: String?

        public var expireTime: String?

        public var idleDisconnectDuration: String?

        public var imageId: String?

        public var keepDuration: String?

        public var name: String?

        public var oversoldGroupId: String?

        public var oversoldUserCount: Int32?

        public var oversoldWarn: Int32?

        public var policyGroupId: String?

        public var saleStatus: String?

        public var status: String?

        public var stopDuration: Int64?

        public var systemDiskSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.concurrenceCount != nil {
                map["ConcurrenceCount"] = self.concurrenceCount!
            }
            if self.curConcurrenceCount != nil {
                map["CurConcurrenceCount"] = self.curConcurrenceCount!
            }
            if self.dataDiskSize != nil {
                map["DataDiskSize"] = self.dataDiskSize!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.desktopType != nil {
                map["DesktopType"] = self.desktopType!
            }
            if self.directoryId != nil {
                map["DirectoryId"] = self.directoryId!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.idleDisconnectDuration != nil {
                map["IdleDisconnectDuration"] = self.idleDisconnectDuration!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.keepDuration != nil {
                map["KeepDuration"] = self.keepDuration!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.oversoldGroupId != nil {
                map["OversoldGroupId"] = self.oversoldGroupId!
            }
            if self.oversoldUserCount != nil {
                map["OversoldUserCount"] = self.oversoldUserCount!
            }
            if self.oversoldWarn != nil {
                map["OversoldWarn"] = self.oversoldWarn!
            }
            if self.policyGroupId != nil {
                map["PolicyGroupId"] = self.policyGroupId!
            }
            if self.saleStatus != nil {
                map["SaleStatus"] = self.saleStatus!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.stopDuration != nil {
                map["StopDuration"] = self.stopDuration!
            }
            if self.systemDiskSize != nil {
                map["SystemDiskSize"] = self.systemDiskSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConcurrenceCount") {
                self.concurrenceCount = dict["ConcurrenceCount"] as! Int32
            }
            if dict.keys.contains("CurConcurrenceCount") {
                self.curConcurrenceCount = dict["CurConcurrenceCount"] as! Int32
            }
            if dict.keys.contains("DataDiskSize") {
                self.dataDiskSize = dict["DataDiskSize"] as! Int32
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DesktopType") {
                self.desktopType = dict["DesktopType"] as! String
            }
            if dict.keys.contains("DirectoryId") {
                self.directoryId = dict["DirectoryId"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("IdleDisconnectDuration") {
                self.idleDisconnectDuration = dict["IdleDisconnectDuration"] as! String
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("KeepDuration") {
                self.keepDuration = dict["KeepDuration"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OversoldGroupId") {
                self.oversoldGroupId = dict["OversoldGroupId"] as! String
            }
            if dict.keys.contains("OversoldUserCount") {
                self.oversoldUserCount = dict["OversoldUserCount"] as! Int32
            }
            if dict.keys.contains("OversoldWarn") {
                self.oversoldWarn = dict["OversoldWarn"] as! Int32
            }
            if dict.keys.contains("PolicyGroupId") {
                self.policyGroupId = dict["PolicyGroupId"] as! String
            }
            if dict.keys.contains("SaleStatus") {
                self.saleStatus = dict["SaleStatus"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StopDuration") {
                self.stopDuration = dict["StopDuration"] as! Int64
            }
            if dict.keys.contains("SystemDiskSize") {
                self.systemDiskSize = dict["SystemDiskSize"] as! Int32
            }
        }
    }
    public var count: Int32?

    public var data: [DescribeDesktopOversoldGroupResponseBody.Data]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [DescribeDesktopOversoldGroupResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeDesktopOversoldGroupResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDesktopOversoldGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDesktopOversoldGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDesktopOversoldGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDesktopOversoldUserRequest : Tea.TeaModel {
    public var clientToken: String?

    public var endUserId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var oversoldGroupId: String?

    public var userDesktopIds: [String]?

    public var userGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.oversoldGroupId != nil {
            map["OversoldGroupId"] = self.oversoldGroupId!
        }
        if self.userDesktopIds != nil {
            map["UserDesktopIds"] = self.userDesktopIds!
        }
        if self.userGroupId != nil {
            map["UserGroupId"] = self.userGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OversoldGroupId") {
            self.oversoldGroupId = dict["OversoldGroupId"] as! String
        }
        if dict.keys.contains("UserDesktopIds") {
            self.userDesktopIds = dict["UserDesktopIds"] as! [String]
        }
        if dict.keys.contains("UserGroupId") {
            self.userGroupId = dict["UserGroupId"] as! String
        }
    }
}

public class DescribeDesktopOversoldUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var endUserId: String?

        public var oversoldGroupId: String?

        public var userDesktopId: String?

        public var userGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endUserId != nil {
                map["EndUserId"] = self.endUserId!
            }
            if self.oversoldGroupId != nil {
                map["OversoldGroupId"] = self.oversoldGroupId!
            }
            if self.userDesktopId != nil {
                map["UserDesktopId"] = self.userDesktopId!
            }
            if self.userGroupId != nil {
                map["UserGroupId"] = self.userGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndUserId") {
                self.endUserId = dict["EndUserId"] as! String
            }
            if dict.keys.contains("OversoldGroupId") {
                self.oversoldGroupId = dict["OversoldGroupId"] as! String
            }
            if dict.keys.contains("UserDesktopId") {
                self.userDesktopId = dict["UserDesktopId"] as! String
            }
            if dict.keys.contains("UserGroupId") {
                self.userGroupId = dict["UserGroupId"] as! String
            }
        }
    }
    public var count: Int32?

    public var data: [DescribeDesktopOversoldUserResponseBody.Data]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [DescribeDesktopOversoldUserResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeDesktopOversoldUserResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDesktopOversoldUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDesktopOversoldUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDesktopOversoldUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDesktopOversoldUserGroupRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var oversoldGroupId: String?

    public var userGroupIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.oversoldGroupId != nil {
            map["OversoldGroupId"] = self.oversoldGroupId!
        }
        if self.userGroupIds != nil {
            map["UserGroupIds"] = self.userGroupIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OversoldGroupId") {
            self.oversoldGroupId = dict["OversoldGroupId"] as! String
        }
        if dict.keys.contains("UserGroupIds") {
            self.userGroupIds = dict["UserGroupIds"] as! [String]
        }
    }
}

public class DescribeDesktopOversoldUserGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var imageId: String?

        public var name: String?

        public var oversoldGroupId: String?

        public var policyGroupId: String?

        public var userGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.oversoldGroupId != nil {
                map["OversoldGroupId"] = self.oversoldGroupId!
            }
            if self.policyGroupId != nil {
                map["PolicyGroupId"] = self.policyGroupId!
            }
            if self.userGroupId != nil {
                map["UserGroupId"] = self.userGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OversoldGroupId") {
                self.oversoldGroupId = dict["OversoldGroupId"] as! String
            }
            if dict.keys.contains("PolicyGroupId") {
                self.policyGroupId = dict["PolicyGroupId"] as! String
            }
            if dict.keys.contains("UserGroupId") {
                self.userGroupId = dict["UserGroupId"] as! String
            }
        }
    }
    public var count: Int32?

    public var data: [DescribeDesktopOversoldUserGroupResponseBody.Data]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [DescribeDesktopOversoldUserGroupResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeDesktopOversoldUserGroupResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDesktopOversoldUserGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDesktopOversoldUserGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDesktopOversoldUserGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDesktopSessionsRequest : Tea.TeaModel {
    public var checkOsSession: Bool?

    public var desktopId: [String]?

    public var desktopName: String?

    public var endTime: String?

    public var endUserId: String?

    public var endUserIdFilter: String?

    public var officeSiteId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var sessionStatus: String?

    public var startTime: String?

    public var subPayType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkOsSession != nil {
            map["CheckOsSession"] = self.checkOsSession!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.desktopName != nil {
            map["DesktopName"] = self.desktopName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.endUserIdFilter != nil {
            map["EndUserIdFilter"] = self.endUserIdFilter!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sessionStatus != nil {
            map["SessionStatus"] = self.sessionStatus!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.subPayType != nil {
            map["SubPayType"] = self.subPayType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckOsSession") {
            self.checkOsSession = dict["CheckOsSession"] as! Bool
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("DesktopName") {
            self.desktopName = dict["DesktopName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("EndUserIdFilter") {
            self.endUserIdFilter = dict["EndUserIdFilter"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SessionStatus") {
            self.sessionStatus = dict["SessionStatus"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("SubPayType") {
            self.subPayType = dict["SubPayType"] as! String
        }
    }
}

public class DescribeDesktopSessionsResponseBody : Tea.TeaModel {
    public class Sessions : Tea.TeaModel {
        public var clientIp: String?

        public var clientOS: String?

        public var clientVersion: String?

        public var desktopId: String?

        public var desktopName: String?

        public var endUserApplyCoordinateTime: Int64?

        public var endUserId: String?

        public var latestConnectionTime: Int64?

        public var officeSiteId: String?

        public var officeSiteName: String?

        public var osSessionStatus: String?

        public var osType: String?

        public var protocolType: String?

        public var sessionEndTime: String?

        public var sessionIdleTime: Int64?

        public var sessionStartTime: String?

        public var sessionStatus: String?

        public var subPayType: String?

        public var totalConnectionTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientIp != nil {
                map["ClientIp"] = self.clientIp!
            }
            if self.clientOS != nil {
                map["ClientOS"] = self.clientOS!
            }
            if self.clientVersion != nil {
                map["ClientVersion"] = self.clientVersion!
            }
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.desktopName != nil {
                map["DesktopName"] = self.desktopName!
            }
            if self.endUserApplyCoordinateTime != nil {
                map["EndUserApplyCoordinateTime"] = self.endUserApplyCoordinateTime!
            }
            if self.endUserId != nil {
                map["EndUserId"] = self.endUserId!
            }
            if self.latestConnectionTime != nil {
                map["LatestConnectionTime"] = self.latestConnectionTime!
            }
            if self.officeSiteId != nil {
                map["OfficeSiteId"] = self.officeSiteId!
            }
            if self.officeSiteName != nil {
                map["OfficeSiteName"] = self.officeSiteName!
            }
            if self.osSessionStatus != nil {
                map["OsSessionStatus"] = self.osSessionStatus!
            }
            if self.osType != nil {
                map["OsType"] = self.osType!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.sessionEndTime != nil {
                map["SessionEndTime"] = self.sessionEndTime!
            }
            if self.sessionIdleTime != nil {
                map["SessionIdleTime"] = self.sessionIdleTime!
            }
            if self.sessionStartTime != nil {
                map["SessionStartTime"] = self.sessionStartTime!
            }
            if self.sessionStatus != nil {
                map["SessionStatus"] = self.sessionStatus!
            }
            if self.subPayType != nil {
                map["SubPayType"] = self.subPayType!
            }
            if self.totalConnectionTime != nil {
                map["TotalConnectionTime"] = self.totalConnectionTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientIp") {
                self.clientIp = dict["ClientIp"] as! String
            }
            if dict.keys.contains("ClientOS") {
                self.clientOS = dict["ClientOS"] as! String
            }
            if dict.keys.contains("ClientVersion") {
                self.clientVersion = dict["ClientVersion"] as! String
            }
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("DesktopName") {
                self.desktopName = dict["DesktopName"] as! String
            }
            if dict.keys.contains("EndUserApplyCoordinateTime") {
                self.endUserApplyCoordinateTime = dict["EndUserApplyCoordinateTime"] as! Int64
            }
            if dict.keys.contains("EndUserId") {
                self.endUserId = dict["EndUserId"] as! String
            }
            if dict.keys.contains("LatestConnectionTime") {
                self.latestConnectionTime = dict["LatestConnectionTime"] as! Int64
            }
            if dict.keys.contains("OfficeSiteId") {
                self.officeSiteId = dict["OfficeSiteId"] as! String
            }
            if dict.keys.contains("OfficeSiteName") {
                self.officeSiteName = dict["OfficeSiteName"] as! String
            }
            if dict.keys.contains("OsSessionStatus") {
                self.osSessionStatus = dict["OsSessionStatus"] as! String
            }
            if dict.keys.contains("OsType") {
                self.osType = dict["OsType"] as! String
            }
            if dict.keys.contains("ProtocolType") {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("SessionEndTime") {
                self.sessionEndTime = dict["SessionEndTime"] as! String
            }
            if dict.keys.contains("SessionIdleTime") {
                self.sessionIdleTime = dict["SessionIdleTime"] as! Int64
            }
            if dict.keys.contains("SessionStartTime") {
                self.sessionStartTime = dict["SessionStartTime"] as! String
            }
            if dict.keys.contains("SessionStatus") {
                self.sessionStatus = dict["SessionStatus"] as! String
            }
            if dict.keys.contains("SubPayType") {
                self.subPayType = dict["SubPayType"] as! String
            }
            if dict.keys.contains("TotalConnectionTime") {
                self.totalConnectionTime = dict["TotalConnectionTime"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var sessions: [DescribeDesktopSessionsResponseBody.Sessions]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sessions != nil {
            var tmp : [Any] = []
            for k in self.sessions! {
                tmp.append(k.toMap())
            }
            map["Sessions"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Sessions") {
            var tmp : [DescribeDesktopSessionsResponseBody.Sessions] = []
            for v in dict["Sessions"] as! [Any] {
                var model = DescribeDesktopSessionsResponseBody.Sessions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sessions = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDesktopSessionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDesktopSessionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDesktopSessionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDesktopTypesRequest : Tea.TeaModel {
    public var appliedScope: String?

    public var cpuCount: Int32?

    public var desktopGroupIdForModify: String?

    public var desktopIdForModify: String?

    public var desktopTypeId: String?

    public var desktopTypeIdList: [String]?

    public var gpuCount: Double?

    public var gpuDriverType: String?

    public var gpuMemory: Int32?

    public var instanceTypeFamily: String?

    public var memorySize: Int32?

    public var orderBy: String?

    public var orderType: String?

    public var regionId: String?

    public var scope: String?

    public var sortType: String?

    public var supportMinSessionCount: Int32?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appliedScope != nil {
            map["AppliedScope"] = self.appliedScope!
        }
        if self.cpuCount != nil {
            map["CpuCount"] = self.cpuCount!
        }
        if self.desktopGroupIdForModify != nil {
            map["DesktopGroupIdForModify"] = self.desktopGroupIdForModify!
        }
        if self.desktopIdForModify != nil {
            map["DesktopIdForModify"] = self.desktopIdForModify!
        }
        if self.desktopTypeId != nil {
            map["DesktopTypeId"] = self.desktopTypeId!
        }
        if self.desktopTypeIdList != nil {
            map["DesktopTypeIdList"] = self.desktopTypeIdList!
        }
        if self.gpuCount != nil {
            map["GpuCount"] = self.gpuCount!
        }
        if self.gpuDriverType != nil {
            map["GpuDriverType"] = self.gpuDriverType!
        }
        if self.gpuMemory != nil {
            map["GpuMemory"] = self.gpuMemory!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.memorySize != nil {
            map["MemorySize"] = self.memorySize!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        if self.supportMinSessionCount != nil {
            map["SupportMinSessionCount"] = self.supportMinSessionCount!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppliedScope") {
            self.appliedScope = dict["AppliedScope"] as! String
        }
        if dict.keys.contains("CpuCount") {
            self.cpuCount = dict["CpuCount"] as! Int32
        }
        if dict.keys.contains("DesktopGroupIdForModify") {
            self.desktopGroupIdForModify = dict["DesktopGroupIdForModify"] as! String
        }
        if dict.keys.contains("DesktopIdForModify") {
            self.desktopIdForModify = dict["DesktopIdForModify"] as! String
        }
        if dict.keys.contains("DesktopTypeId") {
            self.desktopTypeId = dict["DesktopTypeId"] as! String
        }
        if dict.keys.contains("DesktopTypeIdList") {
            self.desktopTypeIdList = dict["DesktopTypeIdList"] as! [String]
        }
        if dict.keys.contains("GpuCount") {
            self.gpuCount = dict["GpuCount"] as! Double
        }
        if dict.keys.contains("GpuDriverType") {
            self.gpuDriverType = dict["GpuDriverType"] as! String
        }
        if dict.keys.contains("GpuMemory") {
            self.gpuMemory = dict["GpuMemory"] as! Int32
        }
        if dict.keys.contains("InstanceTypeFamily") {
            self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
        }
        if dict.keys.contains("MemorySize") {
            self.memorySize = dict["MemorySize"] as! Int32
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("SortType") {
            self.sortType = dict["SortType"] as! String
        }
        if dict.keys.contains("SupportMinSessionCount") {
            self.supportMinSessionCount = dict["SupportMinSessionCount"] as! Int32
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeDesktopTypesResponseBody : Tea.TeaModel {
    public class DesktopTypes : Tea.TeaModel {
        public var cpuCount: String?

        public var dataDiskSize: String?

        public var desktopTypeId: String?

        public var desktopTypeStatus: String?

        public var gpuCount: Double?

        public var gpuMemory: Int32?

        public var gpuSpec: String?

        public var instanceTypeFamily: String?

        public var maxSessionCount: Int32?

        public var memorySize: String?

        public var scopes: [String]?

        public var stockState: String?

        public var systemDiskSize: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cpuCount != nil {
                map["CpuCount"] = self.cpuCount!
            }
            if self.dataDiskSize != nil {
                map["DataDiskSize"] = self.dataDiskSize!
            }
            if self.desktopTypeId != nil {
                map["DesktopTypeId"] = self.desktopTypeId!
            }
            if self.desktopTypeStatus != nil {
                map["DesktopTypeStatus"] = self.desktopTypeStatus!
            }
            if self.gpuCount != nil {
                map["GpuCount"] = self.gpuCount!
            }
            if self.gpuMemory != nil {
                map["GpuMemory"] = self.gpuMemory!
            }
            if self.gpuSpec != nil {
                map["GpuSpec"] = self.gpuSpec!
            }
            if self.instanceTypeFamily != nil {
                map["InstanceTypeFamily"] = self.instanceTypeFamily!
            }
            if self.maxSessionCount != nil {
                map["MaxSessionCount"] = self.maxSessionCount!
            }
            if self.memorySize != nil {
                map["MemorySize"] = self.memorySize!
            }
            if self.scopes != nil {
                map["Scopes"] = self.scopes!
            }
            if self.stockState != nil {
                map["StockState"] = self.stockState!
            }
            if self.systemDiskSize != nil {
                map["SystemDiskSize"] = self.systemDiskSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CpuCount") {
                self.cpuCount = dict["CpuCount"] as! String
            }
            if dict.keys.contains("DataDiskSize") {
                self.dataDiskSize = dict["DataDiskSize"] as! String
            }
            if dict.keys.contains("DesktopTypeId") {
                self.desktopTypeId = dict["DesktopTypeId"] as! String
            }
            if dict.keys.contains("DesktopTypeStatus") {
                self.desktopTypeStatus = dict["DesktopTypeStatus"] as! String
            }
            if dict.keys.contains("GpuCount") {
                self.gpuCount = dict["GpuCount"] as! Double
            }
            if dict.keys.contains("GpuMemory") {
                self.gpuMemory = dict["GpuMemory"] as! Int32
            }
            if dict.keys.contains("GpuSpec") {
                self.gpuSpec = dict["GpuSpec"] as! String
            }
            if dict.keys.contains("InstanceTypeFamily") {
                self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
            }
            if dict.keys.contains("MaxSessionCount") {
                self.maxSessionCount = dict["MaxSessionCount"] as! Int32
            }
            if dict.keys.contains("MemorySize") {
                self.memorySize = dict["MemorySize"] as! String
            }
            if dict.keys.contains("Scopes") {
                self.scopes = dict["Scopes"] as! [String]
            }
            if dict.keys.contains("StockState") {
                self.stockState = dict["StockState"] as! String
            }
            if dict.keys.contains("SystemDiskSize") {
                self.systemDiskSize = dict["SystemDiskSize"] as! String
            }
        }
    }
    public var desktopTypes: [DescribeDesktopTypesResponseBody.DesktopTypes]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopTypes != nil {
            var tmp : [Any] = []
            for k in self.desktopTypes! {
                tmp.append(k.toMap())
            }
            map["DesktopTypes"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopTypes") {
            var tmp : [DescribeDesktopTypesResponseBody.DesktopTypes] = []
            for v in dict["DesktopTypes"] as! [Any] {
                var model = DescribeDesktopTypesResponseBody.DesktopTypes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.desktopTypes = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDesktopTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDesktopTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDesktopTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDesktopsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var chargeType: String?

    public var desktopGroupId: String?

    public var desktopId: [String]?

    public var desktopName: String?

    public var desktopStatus: String?

    public var desktopStatusList: [String]?

    public var desktopType: String?

    public var directoryId: String?

    public var endUserId: [String]?

    public var excludedEndUserId: [String]?

    public var expiredTime: String?

    public var fillResourceGroup: Bool?

    public var filterDesktopGroup: Bool?

    public var gpuInstanceGroupId: String?

    public var groupId: String?

    public var imageId: [String]?

    public var managementFlag: String?

    public var maxResults: Int32?

    public var multiResource: Bool?

    public var nextToken: String?

    public var officeSiteId: String?

    public var officeSiteName: String?

    public var onlyDesktopGroup: Bool?

    public var osTypes: [String]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var policyGroupId: String?

    public var protocolType: String?

    public var qosRuleId: String?

    public var queryFotaUpdate: Bool?

    public var regionId: String?

    public var resourceGroupId: String?

    public var snapshotPolicyId: String?

    public var subPayType: String?

    public var tag: [DescribeDesktopsRequest.Tag]?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.desktopName != nil {
            map["DesktopName"] = self.desktopName!
        }
        if self.desktopStatus != nil {
            map["DesktopStatus"] = self.desktopStatus!
        }
        if self.desktopStatusList != nil {
            map["DesktopStatusList"] = self.desktopStatusList!
        }
        if self.desktopType != nil {
            map["DesktopType"] = self.desktopType!
        }
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.excludedEndUserId != nil {
            map["ExcludedEndUserId"] = self.excludedEndUserId!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.fillResourceGroup != nil {
            map["FillResourceGroup"] = self.fillResourceGroup!
        }
        if self.filterDesktopGroup != nil {
            map["FilterDesktopGroup"] = self.filterDesktopGroup!
        }
        if self.gpuInstanceGroupId != nil {
            map["GpuInstanceGroupId"] = self.gpuInstanceGroupId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.managementFlag != nil {
            map["ManagementFlag"] = self.managementFlag!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.multiResource != nil {
            map["MultiResource"] = self.multiResource!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.officeSiteName != nil {
            map["OfficeSiteName"] = self.officeSiteName!
        }
        if self.onlyDesktopGroup != nil {
            map["OnlyDesktopGroup"] = self.onlyDesktopGroup!
        }
        if self.osTypes != nil {
            map["OsTypes"] = self.osTypes!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.qosRuleId != nil {
            map["QosRuleId"] = self.qosRuleId!
        }
        if self.queryFotaUpdate != nil {
            map["QueryFotaUpdate"] = self.queryFotaUpdate!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.snapshotPolicyId != nil {
            map["SnapshotPolicyId"] = self.snapshotPolicyId!
        }
        if self.subPayType != nil {
            map["SubPayType"] = self.subPayType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("DesktopName") {
            self.desktopName = dict["DesktopName"] as! String
        }
        if dict.keys.contains("DesktopStatus") {
            self.desktopStatus = dict["DesktopStatus"] as! String
        }
        if dict.keys.contains("DesktopStatusList") {
            self.desktopStatusList = dict["DesktopStatusList"] as! [String]
        }
        if dict.keys.contains("DesktopType") {
            self.desktopType = dict["DesktopType"] as! String
        }
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! [String]
        }
        if dict.keys.contains("ExcludedEndUserId") {
            self.excludedEndUserId = dict["ExcludedEndUserId"] as! [String]
        }
        if dict.keys.contains("ExpiredTime") {
            self.expiredTime = dict["ExpiredTime"] as! String
        }
        if dict.keys.contains("FillResourceGroup") {
            self.fillResourceGroup = dict["FillResourceGroup"] as! Bool
        }
        if dict.keys.contains("FilterDesktopGroup") {
            self.filterDesktopGroup = dict["FilterDesktopGroup"] as! Bool
        }
        if dict.keys.contains("GpuInstanceGroupId") {
            self.gpuInstanceGroupId = dict["GpuInstanceGroupId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! [String]
        }
        if dict.keys.contains("ManagementFlag") {
            self.managementFlag = dict["ManagementFlag"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MultiResource") {
            self.multiResource = dict["MultiResource"] as! Bool
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("OfficeSiteName") {
            self.officeSiteName = dict["OfficeSiteName"] as! String
        }
        if dict.keys.contains("OnlyDesktopGroup") {
            self.onlyDesktopGroup = dict["OnlyDesktopGroup"] as! Bool
        }
        if dict.keys.contains("OsTypes") {
            self.osTypes = dict["OsTypes"] as! [String]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("QosRuleId") {
            self.qosRuleId = dict["QosRuleId"] as! String
        }
        if dict.keys.contains("QueryFotaUpdate") {
            self.queryFotaUpdate = dict["QueryFotaUpdate"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SnapshotPolicyId") {
            self.snapshotPolicyId = dict["SnapshotPolicyId"] as! String
        }
        if dict.keys.contains("SubPayType") {
            self.subPayType = dict["SubPayType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeDesktopsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeDesktopsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class DescribeDesktopsResponseBody : Tea.TeaModel {
    public class Desktops : Tea.TeaModel {
        public class DesktopDurationList : Tea.TeaModel {
            public var orderInstanceId: String?

            public var packageCreationTime: String?

            public var packageExpiredTime: String?

            public var packageId: String?

            public var packageStatus: String?

            public var packageType: String?

            public var packageUsedUpStrategy: String?

            public var periodEndTime: String?

            public var periodStartTime: String?

            public var postPaidLimitFee: Double?

            public var totalDuration: Int64?

            public var usedDuration: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.orderInstanceId != nil {
                    map["OrderInstanceId"] = self.orderInstanceId!
                }
                if self.packageCreationTime != nil {
                    map["PackageCreationTime"] = self.packageCreationTime!
                }
                if self.packageExpiredTime != nil {
                    map["PackageExpiredTime"] = self.packageExpiredTime!
                }
                if self.packageId != nil {
                    map["PackageId"] = self.packageId!
                }
                if self.packageStatus != nil {
                    map["PackageStatus"] = self.packageStatus!
                }
                if self.packageType != nil {
                    map["PackageType"] = self.packageType!
                }
                if self.packageUsedUpStrategy != nil {
                    map["PackageUsedUpStrategy"] = self.packageUsedUpStrategy!
                }
                if self.periodEndTime != nil {
                    map["PeriodEndTime"] = self.periodEndTime!
                }
                if self.periodStartTime != nil {
                    map["PeriodStartTime"] = self.periodStartTime!
                }
                if self.postPaidLimitFee != nil {
                    map["PostPaidLimitFee"] = self.postPaidLimitFee!
                }
                if self.totalDuration != nil {
                    map["TotalDuration"] = self.totalDuration!
                }
                if self.usedDuration != nil {
                    map["UsedDuration"] = self.usedDuration!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OrderInstanceId") {
                    self.orderInstanceId = dict["OrderInstanceId"] as! String
                }
                if dict.keys.contains("PackageCreationTime") {
                    self.packageCreationTime = dict["PackageCreationTime"] as! String
                }
                if dict.keys.contains("PackageExpiredTime") {
                    self.packageExpiredTime = dict["PackageExpiredTime"] as! String
                }
                if dict.keys.contains("PackageId") {
                    self.packageId = dict["PackageId"] as! String
                }
                if dict.keys.contains("PackageStatus") {
                    self.packageStatus = dict["PackageStatus"] as! String
                }
                if dict.keys.contains("PackageType") {
                    self.packageType = dict["PackageType"] as! String
                }
                if dict.keys.contains("PackageUsedUpStrategy") {
                    self.packageUsedUpStrategy = dict["PackageUsedUpStrategy"] as! String
                }
                if dict.keys.contains("PeriodEndTime") {
                    self.periodEndTime = dict["PeriodEndTime"] as! String
                }
                if dict.keys.contains("PeriodStartTime") {
                    self.periodStartTime = dict["PeriodStartTime"] as! String
                }
                if dict.keys.contains("PostPaidLimitFee") {
                    self.postPaidLimitFee = dict["PostPaidLimitFee"] as! Double
                }
                if dict.keys.contains("TotalDuration") {
                    self.totalDuration = dict["TotalDuration"] as! Int64
                }
                if dict.keys.contains("UsedDuration") {
                    self.usedDuration = dict["UsedDuration"] as! Int64
                }
            }
        }
        public class Disks : Tea.TeaModel {
            public var diskCategory: String?

            public var diskId: String?

            public var diskSize: Int32?

            public var diskType: String?

            public var performanceLevel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskCategory != nil {
                    map["DiskCategory"] = self.diskCategory!
                }
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.diskSize != nil {
                    map["DiskSize"] = self.diskSize!
                }
                if self.diskType != nil {
                    map["DiskType"] = self.diskType!
                }
                if self.performanceLevel != nil {
                    map["PerformanceLevel"] = self.performanceLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiskCategory") {
                    self.diskCategory = dict["DiskCategory"] as! String
                }
                if dict.keys.contains("DiskId") {
                    self.diskId = dict["DiskId"] as! String
                }
                if dict.keys.contains("DiskSize") {
                    self.diskSize = dict["DiskSize"] as! Int32
                }
                if dict.keys.contains("DiskType") {
                    self.diskType = dict["DiskType"] as! String
                }
                if dict.keys.contains("PerformanceLevel") {
                    self.performanceLevel = dict["PerformanceLevel"] as! String
                }
            }
        }
        public class FotaUpdate : Tea.TeaModel {
            public var currentAppVersion: String?

            public var newAppVersion: String?

            public var releaseNote: String?

            public var releaseNoteEn: String?

            public var releaseNoteJp: String?

            public var size: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currentAppVersion != nil {
                    map["CurrentAppVersion"] = self.currentAppVersion!
                }
                if self.newAppVersion != nil {
                    map["NewAppVersion"] = self.newAppVersion!
                }
                if self.releaseNote != nil {
                    map["ReleaseNote"] = self.releaseNote!
                }
                if self.releaseNoteEn != nil {
                    map["ReleaseNoteEn"] = self.releaseNoteEn!
                }
                if self.releaseNoteJp != nil {
                    map["ReleaseNoteJp"] = self.releaseNoteJp!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CurrentAppVersion") {
                    self.currentAppVersion = dict["CurrentAppVersion"] as! String
                }
                if dict.keys.contains("NewAppVersion") {
                    self.newAppVersion = dict["NewAppVersion"] as! String
                }
                if dict.keys.contains("ReleaseNote") {
                    self.releaseNote = dict["ReleaseNote"] as! String
                }
                if dict.keys.contains("ReleaseNoteEn") {
                    self.releaseNoteEn = dict["ReleaseNoteEn"] as! String
                }
                if dict.keys.contains("ReleaseNoteJp") {
                    self.releaseNoteJp = dict["ReleaseNoteJp"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int64
                }
            }
        }
        public class OsUpdate : Tea.TeaModel {
            public class Packages : Tea.TeaModel {
                public var description_: String?

                public var kb: String?

                public var title: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.kb != nil {
                        map["Kb"] = self.kb!
                    }
                    if self.title != nil {
                        map["Title"] = self.title!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Kb") {
                        self.kb = dict["Kb"] as! String
                    }
                    if dict.keys.contains("Title") {
                        self.title = dict["Title"] as! String
                    }
                }
            }
            public var checkId: String?

            public var packageCount: Int32?

            public var packages: [DescribeDesktopsResponseBody.Desktops.OsUpdate.Packages]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkId != nil {
                    map["CheckId"] = self.checkId!
                }
                if self.packageCount != nil {
                    map["PackageCount"] = self.packageCount!
                }
                if self.packages != nil {
                    var tmp : [Any] = []
                    for k in self.packages! {
                        tmp.append(k.toMap())
                    }
                    map["Packages"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CheckId") {
                    self.checkId = dict["CheckId"] as! String
                }
                if dict.keys.contains("PackageCount") {
                    self.packageCount = dict["PackageCount"] as! Int32
                }
                if dict.keys.contains("Packages") {
                    var tmp : [DescribeDesktopsResponseBody.Desktops.OsUpdate.Packages] = []
                    for v in dict["Packages"] as! [Any] {
                        var model = DescribeDesktopsResponseBody.Desktops.OsUpdate.Packages()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.packages = tmp
                }
            }
        }
        public class ResourceGroups : Tea.TeaModel {
            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public class Sessions : Tea.TeaModel {
            public var endUserId: String?

            public var establishmentTime: String?

            public var externalUserName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endUserId != nil {
                    map["EndUserId"] = self.endUserId!
                }
                if self.establishmentTime != nil {
                    map["EstablishmentTime"] = self.establishmentTime!
                }
                if self.externalUserName != nil {
                    map["ExternalUserName"] = self.externalUserName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndUserId") {
                    self.endUserId = dict["EndUserId"] as! String
                }
                if dict.keys.contains("EstablishmentTime") {
                    self.establishmentTime = dict["EstablishmentTime"] as! String
                }
                if dict.keys.contains("ExternalUserName") {
                    self.externalUserName = dict["ExternalUserName"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var bindAmount: Int32?

        public var bundleId: String?

        public var bundleName: String?

        public var chargeType: String?

        public var connectionStatus: String?

        public var cpu: Int32?

        public var creationTime: String?

        public var dataDiskCategory: String?

        public var dataDiskSize: String?

        public var desktopDurationList: [DescribeDesktopsResponseBody.Desktops.DesktopDurationList]?

        public var desktopGroupId: String?

        public var desktopId: String?

        public var desktopName: String?

        public var desktopStatus: String?

        public var desktopType: String?

        public var directoryId: String?

        public var directoryType: String?

        public var disks: [DescribeDesktopsResponseBody.Desktops.Disks]?

        public var downgradeQuota: Int64?

        public var downgradedTimes: Int64?

        public var endUserIds: [String]?

        public var expiredTime: String?

        public var fotaUpdate: DescribeDesktopsResponseBody.Desktops.FotaUpdate?

        public var gpuCategory: Int64?

        public var gpuCount: Double?

        public var gpuDriverVersion: String?

        public var gpuSpec: String?

        public var hibernationBeta: Bool?

        public var hibernationOptionsConfigured: Bool?

        public var hostName: String?

        public var imageId: String?

        public var isLdap: Bool?

        public var managementFlag: String?

        public var managementFlags: [String]?

        public var memory: Int64?

        public var networkInterfaceId: String?

        public var networkInterfaceIp: String?

        public var officeSiteId: String?

        public var officeSiteName: String?

        public var officeSiteType: String?

        public var officeSiteVpcType: String?

        public var osType: String?

        public var osUpdate: DescribeDesktopsResponseBody.Desktops.OsUpdate?

        public var platform: String?

        public var policyGroupId: String?

        public var policyGroupIdList: [String]?

        public var policyGroupName: String?

        public var policyGroupNameList: [String]?

        public var progress: String?

        public var protocolType: String?

        public var resourceGroups: [DescribeDesktopsResponseBody.Desktops.ResourceGroups]?

        public var sessionType: String?

        public var sessions: [DescribeDesktopsResponseBody.Desktops.Sessions]?

        public var snapshotPolicyId: String?

        public var snapshotPolicyName: String?

        public var standardStartTime: String?

        public var startTime: String?

        public var supportHibernation: Bool?

        public var systemDiskCategory: String?

        public var systemDiskSize: Int32?

        public var tags: [DescribeDesktopsResponseBody.Desktops.Tags]?

        public var volumeEncryptionEnabled: Bool?

        public var volumeEncryptionKey: String?

        public var zoneType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.fotaUpdate?.validate()
            try self.osUpdate?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bindAmount != nil {
                map["BindAmount"] = self.bindAmount!
            }
            if self.bundleId != nil {
                map["BundleId"] = self.bundleId!
            }
            if self.bundleName != nil {
                map["BundleName"] = self.bundleName!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.connectionStatus != nil {
                map["ConnectionStatus"] = self.connectionStatus!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.dataDiskCategory != nil {
                map["DataDiskCategory"] = self.dataDiskCategory!
            }
            if self.dataDiskSize != nil {
                map["DataDiskSize"] = self.dataDiskSize!
            }
            if self.desktopDurationList != nil {
                var tmp : [Any] = []
                for k in self.desktopDurationList! {
                    tmp.append(k.toMap())
                }
                map["DesktopDurationList"] = tmp
            }
            if self.desktopGroupId != nil {
                map["DesktopGroupId"] = self.desktopGroupId!
            }
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.desktopName != nil {
                map["DesktopName"] = self.desktopName!
            }
            if self.desktopStatus != nil {
                map["DesktopStatus"] = self.desktopStatus!
            }
            if self.desktopType != nil {
                map["DesktopType"] = self.desktopType!
            }
            if self.directoryId != nil {
                map["DirectoryId"] = self.directoryId!
            }
            if self.directoryType != nil {
                map["DirectoryType"] = self.directoryType!
            }
            if self.disks != nil {
                var tmp : [Any] = []
                for k in self.disks! {
                    tmp.append(k.toMap())
                }
                map["Disks"] = tmp
            }
            if self.downgradeQuota != nil {
                map["DowngradeQuota"] = self.downgradeQuota!
            }
            if self.downgradedTimes != nil {
                map["DowngradedTimes"] = self.downgradedTimes!
            }
            if self.endUserIds != nil {
                map["EndUserIds"] = self.endUserIds!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.fotaUpdate != nil {
                map["FotaUpdate"] = self.fotaUpdate?.toMap()
            }
            if self.gpuCategory != nil {
                map["GpuCategory"] = self.gpuCategory!
            }
            if self.gpuCount != nil {
                map["GpuCount"] = self.gpuCount!
            }
            if self.gpuDriverVersion != nil {
                map["GpuDriverVersion"] = self.gpuDriverVersion!
            }
            if self.gpuSpec != nil {
                map["GpuSpec"] = self.gpuSpec!
            }
            if self.hibernationBeta != nil {
                map["HibernationBeta"] = self.hibernationBeta!
            }
            if self.hibernationOptionsConfigured != nil {
                map["HibernationOptionsConfigured"] = self.hibernationOptionsConfigured!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.isLdap != nil {
                map["IsLdap"] = self.isLdap!
            }
            if self.managementFlag != nil {
                map["ManagementFlag"] = self.managementFlag!
            }
            if self.managementFlags != nil {
                map["ManagementFlags"] = self.managementFlags!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.networkInterfaceId != nil {
                map["NetworkInterfaceId"] = self.networkInterfaceId!
            }
            if self.networkInterfaceIp != nil {
                map["NetworkInterfaceIp"] = self.networkInterfaceIp!
            }
            if self.officeSiteId != nil {
                map["OfficeSiteId"] = self.officeSiteId!
            }
            if self.officeSiteName != nil {
                map["OfficeSiteName"] = self.officeSiteName!
            }
            if self.officeSiteType != nil {
                map["OfficeSiteType"] = self.officeSiteType!
            }
            if self.officeSiteVpcType != nil {
                map["OfficeSiteVpcType"] = self.officeSiteVpcType!
            }
            if self.osType != nil {
                map["OsType"] = self.osType!
            }
            if self.osUpdate != nil {
                map["OsUpdate"] = self.osUpdate?.toMap()
            }
            if self.platform != nil {
                map["Platform"] = self.platform!
            }
            if self.policyGroupId != nil {
                map["PolicyGroupId"] = self.policyGroupId!
            }
            if self.policyGroupIdList != nil {
                map["PolicyGroupIdList"] = self.policyGroupIdList!
            }
            if self.policyGroupName != nil {
                map["PolicyGroupName"] = self.policyGroupName!
            }
            if self.policyGroupNameList != nil {
                map["PolicyGroupNameList"] = self.policyGroupNameList!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.resourceGroups != nil {
                var tmp : [Any] = []
                for k in self.resourceGroups! {
                    tmp.append(k.toMap())
                }
                map["ResourceGroups"] = tmp
            }
            if self.sessionType != nil {
                map["SessionType"] = self.sessionType!
            }
            if self.sessions != nil {
                var tmp : [Any] = []
                for k in self.sessions! {
                    tmp.append(k.toMap())
                }
                map["Sessions"] = tmp
            }
            if self.snapshotPolicyId != nil {
                map["SnapshotPolicyId"] = self.snapshotPolicyId!
            }
            if self.snapshotPolicyName != nil {
                map["SnapshotPolicyName"] = self.snapshotPolicyName!
            }
            if self.standardStartTime != nil {
                map["StandardStartTime"] = self.standardStartTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.supportHibernation != nil {
                map["SupportHibernation"] = self.supportHibernation!
            }
            if self.systemDiskCategory != nil {
                map["SystemDiskCategory"] = self.systemDiskCategory!
            }
            if self.systemDiskSize != nil {
                map["SystemDiskSize"] = self.systemDiskSize!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.volumeEncryptionEnabled != nil {
                map["VolumeEncryptionEnabled"] = self.volumeEncryptionEnabled!
            }
            if self.volumeEncryptionKey != nil {
                map["VolumeEncryptionKey"] = self.volumeEncryptionKey!
            }
            if self.zoneType != nil {
                map["ZoneType"] = self.zoneType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BindAmount") {
                self.bindAmount = dict["BindAmount"] as! Int32
            }
            if dict.keys.contains("BundleId") {
                self.bundleId = dict["BundleId"] as! String
            }
            if dict.keys.contains("BundleName") {
                self.bundleName = dict["BundleName"] as! String
            }
            if dict.keys.contains("ChargeType") {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("ConnectionStatus") {
                self.connectionStatus = dict["ConnectionStatus"] as! String
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DataDiskCategory") {
                self.dataDiskCategory = dict["DataDiskCategory"] as! String
            }
            if dict.keys.contains("DataDiskSize") {
                self.dataDiskSize = dict["DataDiskSize"] as! String
            }
            if dict.keys.contains("DesktopDurationList") {
                var tmp : [DescribeDesktopsResponseBody.Desktops.DesktopDurationList] = []
                for v in dict["DesktopDurationList"] as! [Any] {
                    var model = DescribeDesktopsResponseBody.Desktops.DesktopDurationList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.desktopDurationList = tmp
            }
            if dict.keys.contains("DesktopGroupId") {
                self.desktopGroupId = dict["DesktopGroupId"] as! String
            }
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("DesktopName") {
                self.desktopName = dict["DesktopName"] as! String
            }
            if dict.keys.contains("DesktopStatus") {
                self.desktopStatus = dict["DesktopStatus"] as! String
            }
            if dict.keys.contains("DesktopType") {
                self.desktopType = dict["DesktopType"] as! String
            }
            if dict.keys.contains("DirectoryId") {
                self.directoryId = dict["DirectoryId"] as! String
            }
            if dict.keys.contains("DirectoryType") {
                self.directoryType = dict["DirectoryType"] as! String
            }
            if dict.keys.contains("Disks") {
                var tmp : [DescribeDesktopsResponseBody.Desktops.Disks] = []
                for v in dict["Disks"] as! [Any] {
                    var model = DescribeDesktopsResponseBody.Desktops.Disks()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.disks = tmp
            }
            if dict.keys.contains("DowngradeQuota") {
                self.downgradeQuota = dict["DowngradeQuota"] as! Int64
            }
            if dict.keys.contains("DowngradedTimes") {
                self.downgradedTimes = dict["DowngradedTimes"] as! Int64
            }
            if dict.keys.contains("EndUserIds") {
                self.endUserIds = dict["EndUserIds"] as! [String]
            }
            if dict.keys.contains("ExpiredTime") {
                self.expiredTime = dict["ExpiredTime"] as! String
            }
            if dict.keys.contains("FotaUpdate") {
                var model = DescribeDesktopsResponseBody.Desktops.FotaUpdate()
                model.fromMap(dict["FotaUpdate"] as! [String: Any])
                self.fotaUpdate = model
            }
            if dict.keys.contains("GpuCategory") {
                self.gpuCategory = dict["GpuCategory"] as! Int64
            }
            if dict.keys.contains("GpuCount") {
                self.gpuCount = dict["GpuCount"] as! Double
            }
            if dict.keys.contains("GpuDriverVersion") {
                self.gpuDriverVersion = dict["GpuDriverVersion"] as! String
            }
            if dict.keys.contains("GpuSpec") {
                self.gpuSpec = dict["GpuSpec"] as! String
            }
            if dict.keys.contains("HibernationBeta") {
                self.hibernationBeta = dict["HibernationBeta"] as! Bool
            }
            if dict.keys.contains("HibernationOptionsConfigured") {
                self.hibernationOptionsConfigured = dict["HibernationOptionsConfigured"] as! Bool
            }
            if dict.keys.contains("HostName") {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("IsLdap") {
                self.isLdap = dict["IsLdap"] as! Bool
            }
            if dict.keys.contains("ManagementFlag") {
                self.managementFlag = dict["ManagementFlag"] as! String
            }
            if dict.keys.contains("ManagementFlags") {
                self.managementFlags = dict["ManagementFlags"] as! [String]
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Int64
            }
            if dict.keys.contains("NetworkInterfaceId") {
                self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
            }
            if dict.keys.contains("NetworkInterfaceIp") {
                self.networkInterfaceIp = dict["NetworkInterfaceIp"] as! String
            }
            if dict.keys.contains("OfficeSiteId") {
                self.officeSiteId = dict["OfficeSiteId"] as! String
            }
            if dict.keys.contains("OfficeSiteName") {
                self.officeSiteName = dict["OfficeSiteName"] as! String
            }
            if dict.keys.contains("OfficeSiteType") {
                self.officeSiteType = dict["OfficeSiteType"] as! String
            }
            if dict.keys.contains("OfficeSiteVpcType") {
                self.officeSiteVpcType = dict["OfficeSiteVpcType"] as! String
            }
            if dict.keys.contains("OsType") {
                self.osType = dict["OsType"] as! String
            }
            if dict.keys.contains("OsUpdate") {
                var model = DescribeDesktopsResponseBody.Desktops.OsUpdate()
                model.fromMap(dict["OsUpdate"] as! [String: Any])
                self.osUpdate = model
            }
            if dict.keys.contains("Platform") {
                self.platform = dict["Platform"] as! String
            }
            if dict.keys.contains("PolicyGroupId") {
                self.policyGroupId = dict["PolicyGroupId"] as! String
            }
            if dict.keys.contains("PolicyGroupIdList") {
                self.policyGroupIdList = dict["PolicyGroupIdList"] as! [String]
            }
            if dict.keys.contains("PolicyGroupName") {
                self.policyGroupName = dict["PolicyGroupName"] as! String
            }
            if dict.keys.contains("PolicyGroupNameList") {
                self.policyGroupNameList = dict["PolicyGroupNameList"] as! [String]
            }
            if dict.keys.contains("Progress") {
                self.progress = dict["Progress"] as! String
            }
            if dict.keys.contains("ProtocolType") {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("ResourceGroups") {
                var tmp : [DescribeDesktopsResponseBody.Desktops.ResourceGroups] = []
                for v in dict["ResourceGroups"] as! [Any] {
                    var model = DescribeDesktopsResponseBody.Desktops.ResourceGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resourceGroups = tmp
            }
            if dict.keys.contains("SessionType") {
                self.sessionType = dict["SessionType"] as! String
            }
            if dict.keys.contains("Sessions") {
                var tmp : [DescribeDesktopsResponseBody.Desktops.Sessions] = []
                for v in dict["Sessions"] as! [Any] {
                    var model = DescribeDesktopsResponseBody.Desktops.Sessions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sessions = tmp
            }
            if dict.keys.contains("SnapshotPolicyId") {
                self.snapshotPolicyId = dict["SnapshotPolicyId"] as! String
            }
            if dict.keys.contains("SnapshotPolicyName") {
                self.snapshotPolicyName = dict["SnapshotPolicyName"] as! String
            }
            if dict.keys.contains("StandardStartTime") {
                self.standardStartTime = dict["StandardStartTime"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("SupportHibernation") {
                self.supportHibernation = dict["SupportHibernation"] as! Bool
            }
            if dict.keys.contains("SystemDiskCategory") {
                self.systemDiskCategory = dict["SystemDiskCategory"] as! String
            }
            if dict.keys.contains("SystemDiskSize") {
                self.systemDiskSize = dict["SystemDiskSize"] as! Int32
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeDesktopsResponseBody.Desktops.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeDesktopsResponseBody.Desktops.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("VolumeEncryptionEnabled") {
                self.volumeEncryptionEnabled = dict["VolumeEncryptionEnabled"] as! Bool
            }
            if dict.keys.contains("VolumeEncryptionKey") {
                self.volumeEncryptionKey = dict["VolumeEncryptionKey"] as! String
            }
            if dict.keys.contains("ZoneType") {
                self.zoneType = dict["ZoneType"] as! String
            }
        }
    }
    public var desktops: [DescribeDesktopsResponseBody.Desktops]?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktops != nil {
            var tmp : [Any] = []
            for k in self.desktops! {
                tmp.append(k.toMap())
            }
            map["Desktops"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Desktops") {
            var tmp : [DescribeDesktopsResponseBody.Desktops] = []
            for v in dict["Desktops"] as! [Any] {
                var model = DescribeDesktopsResponseBody.Desktops()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.desktops = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDesktopsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDesktopsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDesktopsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDesktopsInGroupRequest : Tea.TeaModel {
    public var customEndTimePeriod: Int64?

    public var customStartTimePeriod: Int64?

    public var desktopGroupId: String?

    public var ignoreDeleted: Bool?

    public var maxResults: Int32?

    public var nextToken: String?

    public var payType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customEndTimePeriod != nil {
            map["CustomEndTimePeriod"] = self.customEndTimePeriod!
        }
        if self.customStartTimePeriod != nil {
            map["CustomStartTimePeriod"] = self.customStartTimePeriod!
        }
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.ignoreDeleted != nil {
            map["IgnoreDeleted"] = self.ignoreDeleted!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomEndTimePeriod") {
            self.customEndTimePeriod = dict["CustomEndTimePeriod"] as! Int64
        }
        if dict.keys.contains("CustomStartTimePeriod") {
            self.customStartTimePeriod = dict["CustomStartTimePeriod"] as! Int64
        }
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("IgnoreDeleted") {
            self.ignoreDeleted = dict["IgnoreDeleted"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeDesktopsInGroupResponseBody : Tea.TeaModel {
    public class PaidDesktops : Tea.TeaModel {
        public var connectionStatus: String?

        public var desktopId: String?

        public var desktopName: String?

        public var desktopStatus: String?

        public var diskType: String?

        public var endUserId: String?

        public var endUserIds: [String]?

        public var endUserName: String?

        public var endUserNames: [String]?

        public var fotaVersion: String?

        public var gpuDriverVersion: String?

        public var imageId: String?

        public var imageName: String?

        public var managementFlag: String?

        public var managementFlags: [String]?

        public var memberEniIp: String?

        public var osType: String?

        public var primaryEniIp: String?

        public var protocolType: String?

        public var resetTime: String?

        public var systemDiskSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectionStatus != nil {
                map["ConnectionStatus"] = self.connectionStatus!
            }
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.desktopName != nil {
                map["DesktopName"] = self.desktopName!
            }
            if self.desktopStatus != nil {
                map["DesktopStatus"] = self.desktopStatus!
            }
            if self.diskType != nil {
                map["DiskType"] = self.diskType!
            }
            if self.endUserId != nil {
                map["EndUserId"] = self.endUserId!
            }
            if self.endUserIds != nil {
                map["EndUserIds"] = self.endUserIds!
            }
            if self.endUserName != nil {
                map["EndUserName"] = self.endUserName!
            }
            if self.endUserNames != nil {
                map["EndUserNames"] = self.endUserNames!
            }
            if self.fotaVersion != nil {
                map["FotaVersion"] = self.fotaVersion!
            }
            if self.gpuDriverVersion != nil {
                map["GpuDriverVersion"] = self.gpuDriverVersion!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.managementFlag != nil {
                map["ManagementFlag"] = self.managementFlag!
            }
            if self.managementFlags != nil {
                map["ManagementFlags"] = self.managementFlags!
            }
            if self.memberEniIp != nil {
                map["MemberEniIp"] = self.memberEniIp!
            }
            if self.osType != nil {
                map["OsType"] = self.osType!
            }
            if self.primaryEniIp != nil {
                map["PrimaryEniIp"] = self.primaryEniIp!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.resetTime != nil {
                map["ResetTime"] = self.resetTime!
            }
            if self.systemDiskSize != nil {
                map["SystemDiskSize"] = self.systemDiskSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConnectionStatus") {
                self.connectionStatus = dict["ConnectionStatus"] as! String
            }
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("DesktopName") {
                self.desktopName = dict["DesktopName"] as! String
            }
            if dict.keys.contains("DesktopStatus") {
                self.desktopStatus = dict["DesktopStatus"] as! String
            }
            if dict.keys.contains("DiskType") {
                self.diskType = dict["DiskType"] as! String
            }
            if dict.keys.contains("EndUserId") {
                self.endUserId = dict["EndUserId"] as! String
            }
            if dict.keys.contains("EndUserIds") {
                self.endUserIds = dict["EndUserIds"] as! [String]
            }
            if dict.keys.contains("EndUserName") {
                self.endUserName = dict["EndUserName"] as! String
            }
            if dict.keys.contains("EndUserNames") {
                self.endUserNames = dict["EndUserNames"] as! [String]
            }
            if dict.keys.contains("FotaVersion") {
                self.fotaVersion = dict["FotaVersion"] as! String
            }
            if dict.keys.contains("GpuDriverVersion") {
                self.gpuDriverVersion = dict["GpuDriverVersion"] as! String
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageName") {
                self.imageName = dict["ImageName"] as! String
            }
            if dict.keys.contains("ManagementFlag") {
                self.managementFlag = dict["ManagementFlag"] as! String
            }
            if dict.keys.contains("ManagementFlags") {
                self.managementFlags = dict["ManagementFlags"] as! [String]
            }
            if dict.keys.contains("MemberEniIp") {
                self.memberEniIp = dict["MemberEniIp"] as! String
            }
            if dict.keys.contains("OsType") {
                self.osType = dict["OsType"] as! String
            }
            if dict.keys.contains("PrimaryEniIp") {
                self.primaryEniIp = dict["PrimaryEniIp"] as! String
            }
            if dict.keys.contains("ProtocolType") {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("ResetTime") {
                self.resetTime = dict["ResetTime"] as! String
            }
            if dict.keys.contains("SystemDiskSize") {
                self.systemDiskSize = dict["SystemDiskSize"] as! Int32
            }
        }
    }
    public class PostPaidDesktops : Tea.TeaModel {
        public var connectionStatus: String?

        public var createDuration: String?

        public var createTime: String?

        public var desktopId: String?

        public var desktopName: String?

        public var desktopStatus: String?

        public var diskType: String?

        public var endUserId: String?

        public var endUserIds: [String]?

        public var endUserName: String?

        public var endUserNames: [String]?

        public var fotaVersion: String?

        public var gpuDriverVersion: String?

        public var imageId: String?

        public var imageName: String?

        public var managementFlag: String?

        public var managementFlags: [String]?

        public var memberEniIp: String?

        public var osType: String?

        public var primaryEniIp: String?

        public var protocolType: String?

        public var releaseTime: String?

        public var resetTime: String?

        public var systemDiskSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectionStatus != nil {
                map["ConnectionStatus"] = self.connectionStatus!
            }
            if self.createDuration != nil {
                map["CreateDuration"] = self.createDuration!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.desktopName != nil {
                map["DesktopName"] = self.desktopName!
            }
            if self.desktopStatus != nil {
                map["DesktopStatus"] = self.desktopStatus!
            }
            if self.diskType != nil {
                map["DiskType"] = self.diskType!
            }
            if self.endUserId != nil {
                map["EndUserId"] = self.endUserId!
            }
            if self.endUserIds != nil {
                map["EndUserIds"] = self.endUserIds!
            }
            if self.endUserName != nil {
                map["EndUserName"] = self.endUserName!
            }
            if self.endUserNames != nil {
                map["EndUserNames"] = self.endUserNames!
            }
            if self.fotaVersion != nil {
                map["FotaVersion"] = self.fotaVersion!
            }
            if self.gpuDriverVersion != nil {
                map["GpuDriverVersion"] = self.gpuDriverVersion!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.managementFlag != nil {
                map["ManagementFlag"] = self.managementFlag!
            }
            if self.managementFlags != nil {
                map["ManagementFlags"] = self.managementFlags!
            }
            if self.memberEniIp != nil {
                map["MemberEniIp"] = self.memberEniIp!
            }
            if self.osType != nil {
                map["OsType"] = self.osType!
            }
            if self.primaryEniIp != nil {
                map["PrimaryEniIp"] = self.primaryEniIp!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.releaseTime != nil {
                map["ReleaseTime"] = self.releaseTime!
            }
            if self.resetTime != nil {
                map["ResetTime"] = self.resetTime!
            }
            if self.systemDiskSize != nil {
                map["SystemDiskSize"] = self.systemDiskSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConnectionStatus") {
                self.connectionStatus = dict["ConnectionStatus"] as! String
            }
            if dict.keys.contains("CreateDuration") {
                self.createDuration = dict["CreateDuration"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("DesktopName") {
                self.desktopName = dict["DesktopName"] as! String
            }
            if dict.keys.contains("DesktopStatus") {
                self.desktopStatus = dict["DesktopStatus"] as! String
            }
            if dict.keys.contains("DiskType") {
                self.diskType = dict["DiskType"] as! String
            }
            if dict.keys.contains("EndUserId") {
                self.endUserId = dict["EndUserId"] as! String
            }
            if dict.keys.contains("EndUserIds") {
                self.endUserIds = dict["EndUserIds"] as! [String]
            }
            if dict.keys.contains("EndUserName") {
                self.endUserName = dict["EndUserName"] as! String
            }
            if dict.keys.contains("EndUserNames") {
                self.endUserNames = dict["EndUserNames"] as! [String]
            }
            if dict.keys.contains("FotaVersion") {
                self.fotaVersion = dict["FotaVersion"] as! String
            }
            if dict.keys.contains("GpuDriverVersion") {
                self.gpuDriverVersion = dict["GpuDriverVersion"] as! String
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageName") {
                self.imageName = dict["ImageName"] as! String
            }
            if dict.keys.contains("ManagementFlag") {
                self.managementFlag = dict["ManagementFlag"] as! String
            }
            if dict.keys.contains("ManagementFlags") {
                self.managementFlags = dict["ManagementFlags"] as! [String]
            }
            if dict.keys.contains("MemberEniIp") {
                self.memberEniIp = dict["MemberEniIp"] as! String
            }
            if dict.keys.contains("OsType") {
                self.osType = dict["OsType"] as! String
            }
            if dict.keys.contains("PrimaryEniIp") {
                self.primaryEniIp = dict["PrimaryEniIp"] as! String
            }
            if dict.keys.contains("ProtocolType") {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("ReleaseTime") {
                self.releaseTime = dict["ReleaseTime"] as! String
            }
            if dict.keys.contains("ResetTime") {
                self.resetTime = dict["ResetTime"] as! String
            }
            if dict.keys.contains("SystemDiskSize") {
                self.systemDiskSize = dict["SystemDiskSize"] as! Int32
            }
        }
    }
    public var nextToken: String?

    public var onlinePrePaidDesktopsCount: Int32?

    public var paidDesktops: [DescribeDesktopsInGroupResponseBody.PaidDesktops]?

    public var paidDesktopsCount: Int32?

    public var postPaidDesktops: [DescribeDesktopsInGroupResponseBody.PostPaidDesktops]?

    public var postPaidDesktopsCount: Int32?

    public var postPaidDesktopsTotalAmount: Int32?

    public var requestId: String?

    public var runningPrePaidDesktopsCount: Int32?

    public var stopedPrePaidDesktopsCount: Int32?

    public var stoppedPrePaidDesktopsCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.onlinePrePaidDesktopsCount != nil {
            map["OnlinePrePaidDesktopsCount"] = self.onlinePrePaidDesktopsCount!
        }
        if self.paidDesktops != nil {
            var tmp : [Any] = []
            for k in self.paidDesktops! {
                tmp.append(k.toMap())
            }
            map["PaidDesktops"] = tmp
        }
        if self.paidDesktopsCount != nil {
            map["PaidDesktopsCount"] = self.paidDesktopsCount!
        }
        if self.postPaidDesktops != nil {
            var tmp : [Any] = []
            for k in self.postPaidDesktops! {
                tmp.append(k.toMap())
            }
            map["PostPaidDesktops"] = tmp
        }
        if self.postPaidDesktopsCount != nil {
            map["PostPaidDesktopsCount"] = self.postPaidDesktopsCount!
        }
        if self.postPaidDesktopsTotalAmount != nil {
            map["PostPaidDesktopsTotalAmount"] = self.postPaidDesktopsTotalAmount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.runningPrePaidDesktopsCount != nil {
            map["RunningPrePaidDesktopsCount"] = self.runningPrePaidDesktopsCount!
        }
        if self.stopedPrePaidDesktopsCount != nil {
            map["StopedPrePaidDesktopsCount"] = self.stopedPrePaidDesktopsCount!
        }
        if self.stoppedPrePaidDesktopsCount != nil {
            map["StoppedPrePaidDesktopsCount"] = self.stoppedPrePaidDesktopsCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OnlinePrePaidDesktopsCount") {
            self.onlinePrePaidDesktopsCount = dict["OnlinePrePaidDesktopsCount"] as! Int32
        }
        if dict.keys.contains("PaidDesktops") {
            var tmp : [DescribeDesktopsInGroupResponseBody.PaidDesktops] = []
            for v in dict["PaidDesktops"] as! [Any] {
                var model = DescribeDesktopsInGroupResponseBody.PaidDesktops()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.paidDesktops = tmp
        }
        if dict.keys.contains("PaidDesktopsCount") {
            self.paidDesktopsCount = dict["PaidDesktopsCount"] as! Int32
        }
        if dict.keys.contains("PostPaidDesktops") {
            var tmp : [DescribeDesktopsInGroupResponseBody.PostPaidDesktops] = []
            for v in dict["PostPaidDesktops"] as! [Any] {
                var model = DescribeDesktopsInGroupResponseBody.PostPaidDesktops()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.postPaidDesktops = tmp
        }
        if dict.keys.contains("PostPaidDesktopsCount") {
            self.postPaidDesktopsCount = dict["PostPaidDesktopsCount"] as! Int32
        }
        if dict.keys.contains("PostPaidDesktopsTotalAmount") {
            self.postPaidDesktopsTotalAmount = dict["PostPaidDesktopsTotalAmount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RunningPrePaidDesktopsCount") {
            self.runningPrePaidDesktopsCount = dict["RunningPrePaidDesktopsCount"] as! Int32
        }
        if dict.keys.contains("StopedPrePaidDesktopsCount") {
            self.stopedPrePaidDesktopsCount = dict["StopedPrePaidDesktopsCount"] as! Int32
        }
        if dict.keys.contains("StoppedPrePaidDesktopsCount") {
            self.stoppedPrePaidDesktopsCount = dict["StoppedPrePaidDesktopsCount"] as! Int32
        }
    }
}

public class DescribeDesktopsInGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDesktopsInGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDesktopsInGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDevicesRequest : Tea.TeaModel {
    public var adDomain: String?

    public var clientType: String?

    public var deviceId: String?

    public var directoryId: String?

    public var endUserId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var region: String?

    public var userType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adDomain != nil {
            map["AdDomain"] = self.adDomain!
        }
        if self.clientType != nil {
            map["ClientType"] = self.clientType!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.userType != nil {
            map["UserType"] = self.userType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdDomain") {
            self.adDomain = dict["AdDomain"] as! String
        }
        if dict.keys.contains("ClientType") {
            self.clientType = dict["ClientType"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("UserType") {
            self.userType = dict["UserType"] as! String
        }
    }
}

public class DescribeDevicesResponseBody : Tea.TeaModel {
    public class Devices : Tea.TeaModel {
        public class EndUserList : Tea.TeaModel {
            public var adDomain: String?

            public var directoryId: String?

            public var endUserId: String?

            public var userType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adDomain != nil {
                    map["AdDomain"] = self.adDomain!
                }
                if self.directoryId != nil {
                    map["DirectoryId"] = self.directoryId!
                }
                if self.endUserId != nil {
                    map["EndUserId"] = self.endUserId!
                }
                if self.userType != nil {
                    map["UserType"] = self.userType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdDomain") {
                    self.adDomain = dict["AdDomain"] as! String
                }
                if dict.keys.contains("DirectoryId") {
                    self.directoryId = dict["DirectoryId"] as! String
                }
                if dict.keys.contains("EndUserId") {
                    self.endUserId = dict["EndUserId"] as! String
                }
                if dict.keys.contains("UserType") {
                    self.userType = dict["UserType"] as! String
                }
            }
        }
        public var deviceId: String?

        public var endUserList: [DescribeDevicesResponseBody.Devices.EndUserList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.endUserList != nil {
                var tmp : [Any] = []
                for k in self.endUserList! {
                    tmp.append(k.toMap())
                }
                map["EndUserList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("EndUserList") {
                var tmp : [DescribeDevicesResponseBody.Devices.EndUserList] = []
                for v in dict["EndUserList"] as! [Any] {
                    var model = DescribeDevicesResponseBody.Devices.EndUserList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.endUserList = tmp
            }
        }
    }
    public var devices: [DescribeDevicesResponseBody.Devices]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.devices != nil {
            var tmp : [Any] = []
            for k in self.devices! {
                tmp.append(k.toMap())
            }
            map["Devices"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Devices") {
            var tmp : [DescribeDevicesResponseBody.Devices] = []
            for v in dict["Devices"] as! [Any] {
                var model = DescribeDevicesResponseBody.Devices()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.devices = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDirectoriesRequest : Tea.TeaModel {
    public var directoryId: [String]?

    public var directoryStatus: String?

    public var directoryType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.directoryStatus != nil {
            map["DirectoryStatus"] = self.directoryStatus!
        }
        if self.directoryType != nil {
            map["DirectoryType"] = self.directoryType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! [String]
        }
        if dict.keys.contains("DirectoryStatus") {
            self.directoryStatus = dict["DirectoryStatus"] as! String
        }
        if dict.keys.contains("DirectoryType") {
            self.directoryType = dict["DirectoryType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeDirectoriesResponseBody : Tea.TeaModel {
    public class Directories : Tea.TeaModel {
        public class ADConnectors : Tea.TeaModel {
            public var ADConnectorAddress: String?

            public var connectorStatus: String?

            public var networkInterfaceId: String?

            public var specification: String?

            public var trustKey: String?

            public var vSwitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ADConnectorAddress != nil {
                    map["ADConnectorAddress"] = self.ADConnectorAddress!
                }
                if self.connectorStatus != nil {
                    map["ConnectorStatus"] = self.connectorStatus!
                }
                if self.networkInterfaceId != nil {
                    map["NetworkInterfaceId"] = self.networkInterfaceId!
                }
                if self.specification != nil {
                    map["Specification"] = self.specification!
                }
                if self.trustKey != nil {
                    map["TrustKey"] = self.trustKey!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ADConnectorAddress") {
                    self.ADConnectorAddress = dict["ADConnectorAddress"] as! String
                }
                if dict.keys.contains("ConnectorStatus") {
                    self.connectorStatus = dict["ConnectorStatus"] as! String
                }
                if dict.keys.contains("NetworkInterfaceId") {
                    self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
                }
                if dict.keys.contains("Specification") {
                    self.specification = dict["Specification"] as! String
                }
                if dict.keys.contains("TrustKey") {
                    self.trustKey = dict["TrustKey"] as! String
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
            }
        }
        public class Logs : Tea.TeaModel {
            public var level: String?

            public var message: String?

            public var step: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.step != nil {
                    map["Step"] = self.step!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Level") {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Step") {
                    self.step = dict["Step"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var ADConnectors: [DescribeDirectoriesResponseBody.Directories.ADConnectors]?

        public var adHostname: String?

        public var backupDCHostname: String?

        public var backupDns: String?

        public var creationTime: String?

        public var customSecurityGroupId: String?

        public var desktopAccessType: String?

        public var desktopVpcEndpoint: String?

        public var directoryId: String?

        public var directoryType: String?

        public var dnsAddress: [String]?

        public var dnsUserName: String?

        public var domainName: String?

        public var domainPassword: String?

        public var domainUserName: String?

        public var enableAdminAccess: Bool?

        public var enableCrossDesktopAccess: Bool?

        public var enableInternetAccess: Bool?

        public var fileSystemIds: [String]?

        public var logs: [DescribeDirectoriesResponseBody.Directories.Logs]?

        public var mfaEnabled: Bool?

        public var name: String?

        public var needVerifyLoginRisk: Bool?

        public var ouName: String?

        public var ssoEnabled: Bool?

        public var status: String?

        public var subDnsAddress: [String]?

        public var subDomainName: String?

        public var trustPassword: String?

        public var vSwitchIds: [String]?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ADConnectors != nil {
                var tmp : [Any] = []
                for k in self.ADConnectors! {
                    tmp.append(k.toMap())
                }
                map["ADConnectors"] = tmp
            }
            if self.adHostname != nil {
                map["AdHostname"] = self.adHostname!
            }
            if self.backupDCHostname != nil {
                map["BackupDCHostname"] = self.backupDCHostname!
            }
            if self.backupDns != nil {
                map["BackupDns"] = self.backupDns!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.customSecurityGroupId != nil {
                map["CustomSecurityGroupId"] = self.customSecurityGroupId!
            }
            if self.desktopAccessType != nil {
                map["DesktopAccessType"] = self.desktopAccessType!
            }
            if self.desktopVpcEndpoint != nil {
                map["DesktopVpcEndpoint"] = self.desktopVpcEndpoint!
            }
            if self.directoryId != nil {
                map["DirectoryId"] = self.directoryId!
            }
            if self.directoryType != nil {
                map["DirectoryType"] = self.directoryType!
            }
            if self.dnsAddress != nil {
                map["DnsAddress"] = self.dnsAddress!
            }
            if self.dnsUserName != nil {
                map["DnsUserName"] = self.dnsUserName!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainPassword != nil {
                map["DomainPassword"] = self.domainPassword!
            }
            if self.domainUserName != nil {
                map["DomainUserName"] = self.domainUserName!
            }
            if self.enableAdminAccess != nil {
                map["EnableAdminAccess"] = self.enableAdminAccess!
            }
            if self.enableCrossDesktopAccess != nil {
                map["EnableCrossDesktopAccess"] = self.enableCrossDesktopAccess!
            }
            if self.enableInternetAccess != nil {
                map["EnableInternetAccess"] = self.enableInternetAccess!
            }
            if self.fileSystemIds != nil {
                map["FileSystemIds"] = self.fileSystemIds!
            }
            if self.logs != nil {
                var tmp : [Any] = []
                for k in self.logs! {
                    tmp.append(k.toMap())
                }
                map["Logs"] = tmp
            }
            if self.mfaEnabled != nil {
                map["MfaEnabled"] = self.mfaEnabled!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.needVerifyLoginRisk != nil {
                map["NeedVerifyLoginRisk"] = self.needVerifyLoginRisk!
            }
            if self.ouName != nil {
                map["OuName"] = self.ouName!
            }
            if self.ssoEnabled != nil {
                map["SsoEnabled"] = self.ssoEnabled!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subDnsAddress != nil {
                map["SubDnsAddress"] = self.subDnsAddress!
            }
            if self.subDomainName != nil {
                map["SubDomainName"] = self.subDomainName!
            }
            if self.trustPassword != nil {
                map["TrustPassword"] = self.trustPassword!
            }
            if self.vSwitchIds != nil {
                map["VSwitchIds"] = self.vSwitchIds!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ADConnectors") {
                var tmp : [DescribeDirectoriesResponseBody.Directories.ADConnectors] = []
                for v in dict["ADConnectors"] as! [Any] {
                    var model = DescribeDirectoriesResponseBody.Directories.ADConnectors()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ADConnectors = tmp
            }
            if dict.keys.contains("AdHostname") {
                self.adHostname = dict["AdHostname"] as! String
            }
            if dict.keys.contains("BackupDCHostname") {
                self.backupDCHostname = dict["BackupDCHostname"] as! String
            }
            if dict.keys.contains("BackupDns") {
                self.backupDns = dict["BackupDns"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("CustomSecurityGroupId") {
                self.customSecurityGroupId = dict["CustomSecurityGroupId"] as! String
            }
            if dict.keys.contains("DesktopAccessType") {
                self.desktopAccessType = dict["DesktopAccessType"] as! String
            }
            if dict.keys.contains("DesktopVpcEndpoint") {
                self.desktopVpcEndpoint = dict["DesktopVpcEndpoint"] as! String
            }
            if dict.keys.contains("DirectoryId") {
                self.directoryId = dict["DirectoryId"] as! String
            }
            if dict.keys.contains("DirectoryType") {
                self.directoryType = dict["DirectoryType"] as! String
            }
            if dict.keys.contains("DnsAddress") {
                self.dnsAddress = dict["DnsAddress"] as! [String]
            }
            if dict.keys.contains("DnsUserName") {
                self.dnsUserName = dict["DnsUserName"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("DomainPassword") {
                self.domainPassword = dict["DomainPassword"] as! String
            }
            if dict.keys.contains("DomainUserName") {
                self.domainUserName = dict["DomainUserName"] as! String
            }
            if dict.keys.contains("EnableAdminAccess") {
                self.enableAdminAccess = dict["EnableAdminAccess"] as! Bool
            }
            if dict.keys.contains("EnableCrossDesktopAccess") {
                self.enableCrossDesktopAccess = dict["EnableCrossDesktopAccess"] as! Bool
            }
            if dict.keys.contains("EnableInternetAccess") {
                self.enableInternetAccess = dict["EnableInternetAccess"] as! Bool
            }
            if dict.keys.contains("FileSystemIds") {
                self.fileSystemIds = dict["FileSystemIds"] as! [String]
            }
            if dict.keys.contains("Logs") {
                var tmp : [DescribeDirectoriesResponseBody.Directories.Logs] = []
                for v in dict["Logs"] as! [Any] {
                    var model = DescribeDirectoriesResponseBody.Directories.Logs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logs = tmp
            }
            if dict.keys.contains("MfaEnabled") {
                self.mfaEnabled = dict["MfaEnabled"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NeedVerifyLoginRisk") {
                self.needVerifyLoginRisk = dict["NeedVerifyLoginRisk"] as! Bool
            }
            if dict.keys.contains("OuName") {
                self.ouName = dict["OuName"] as! String
            }
            if dict.keys.contains("SsoEnabled") {
                self.ssoEnabled = dict["SsoEnabled"] as! Bool
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubDnsAddress") {
                self.subDnsAddress = dict["SubDnsAddress"] as! [String]
            }
            if dict.keys.contains("SubDomainName") {
                self.subDomainName = dict["SubDomainName"] as! String
            }
            if dict.keys.contains("TrustPassword") {
                self.trustPassword = dict["TrustPassword"] as! String
            }
            if dict.keys.contains("VSwitchIds") {
                self.vSwitchIds = dict["VSwitchIds"] as! [String]
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var adHostname: String?

    public var directories: [DescribeDirectoriesResponseBody.Directories]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adHostname != nil {
            map["AdHostname"] = self.adHostname!
        }
        if self.directories != nil {
            var tmp : [Any] = []
            for k in self.directories! {
                tmp.append(k.toMap())
            }
            map["Directories"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdHostname") {
            self.adHostname = dict["AdHostname"] as! String
        }
        if dict.keys.contains("Directories") {
            var tmp : [DescribeDirectoriesResponseBody.Directories] = []
            for v in dict["Directories"] as! [Any] {
                var model = DescribeDirectoriesResponseBody.Directories()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.directories = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDirectoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDirectoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDirectoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFlowMetricRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var instanceType: String?

    public var metricType: String?

    public var period: Int32?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeFlowMetricResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeFlowMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFlowMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFlowMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFlowStatisticRequest : Tea.TeaModel {
    public var desktopId: String?

    public var officeSiteId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var period: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeFlowStatisticResponseBody : Tea.TeaModel {
    public class DesktopFlowStatistic : Tea.TeaModel {
        public var desktopId: String?

        public var desktopName: String?

        public var flowIn: String?

        public var flowRank: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.desktopName != nil {
                map["DesktopName"] = self.desktopName!
            }
            if self.flowIn != nil {
                map["FlowIn"] = self.flowIn!
            }
            if self.flowRank != nil {
                map["FlowRank"] = self.flowRank!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("DesktopName") {
                self.desktopName = dict["DesktopName"] as! String
            }
            if dict.keys.contains("FlowIn") {
                self.flowIn = dict["FlowIn"] as! String
            }
            if dict.keys.contains("FlowRank") {
                self.flowRank = dict["FlowRank"] as! Int32
            }
        }
    }
    public var desktopCount: Int32?

    public var desktopFlowStatistic: [DescribeFlowStatisticResponseBody.DesktopFlowStatistic]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopCount != nil {
            map["DesktopCount"] = self.desktopCount!
        }
        if self.desktopFlowStatistic != nil {
            var tmp : [Any] = []
            for k in self.desktopFlowStatistic! {
                tmp.append(k.toMap())
            }
            map["DesktopFlowStatistic"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopCount") {
            self.desktopCount = dict["DesktopCount"] as! Int32
        }
        if dict.keys.contains("DesktopFlowStatistic") {
            var tmp : [DescribeFlowStatisticResponseBody.DesktopFlowStatistic] = []
            for v in dict["DesktopFlowStatistic"] as! [Any] {
                var model = DescribeFlowStatisticResponseBody.DesktopFlowStatistic()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.desktopFlowStatistic = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeFlowStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFlowStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFlowStatisticResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFotaPendingDesktopsRequest : Tea.TeaModel {
    public var desktopId: String?

    public var desktopName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var officeSiteId: String?

    public var regionId: String?

    public var taskUid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.desktopName != nil {
            map["DesktopName"] = self.desktopName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskUid != nil {
            map["TaskUid"] = self.taskUid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("DesktopName") {
            self.desktopName = dict["DesktopName"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskUid") {
            self.taskUid = dict["TaskUid"] as! String
        }
    }
}

public class DescribeFotaPendingDesktopsResponseBody : Tea.TeaModel {
    public class FotaPendingDesktops : Tea.TeaModel {
        public class Sessions : Tea.TeaModel {
            public var endUserId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endUserId != nil {
                    map["EndUserId"] = self.endUserId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndUserId") {
                    self.endUserId = dict["EndUserId"] as! String
                }
            }
        }
        public var currentAppVersion: String?

        public var desktopId: String?

        public var desktopName: String?

        public var fotaProject: String?

        public var officeSiteId: String?

        public var sessions: [DescribeFotaPendingDesktopsResponseBody.FotaPendingDesktops.Sessions]?

        public var status: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentAppVersion != nil {
                map["CurrentAppVersion"] = self.currentAppVersion!
            }
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.desktopName != nil {
                map["DesktopName"] = self.desktopName!
            }
            if self.fotaProject != nil {
                map["FotaProject"] = self.fotaProject!
            }
            if self.officeSiteId != nil {
                map["OfficeSiteId"] = self.officeSiteId!
            }
            if self.sessions != nil {
                var tmp : [Any] = []
                for k in self.sessions! {
                    tmp.append(k.toMap())
                }
                map["Sessions"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentAppVersion") {
                self.currentAppVersion = dict["CurrentAppVersion"] as! String
            }
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("DesktopName") {
                self.desktopName = dict["DesktopName"] as! String
            }
            if dict.keys.contains("FotaProject") {
                self.fotaProject = dict["FotaProject"] as! String
            }
            if dict.keys.contains("OfficeSiteId") {
                self.officeSiteId = dict["OfficeSiteId"] as! String
            }
            if dict.keys.contains("Sessions") {
                var tmp : [DescribeFotaPendingDesktopsResponseBody.FotaPendingDesktops.Sessions] = []
                for v in dict["Sessions"] as! [Any] {
                    var model = DescribeFotaPendingDesktopsResponseBody.FotaPendingDesktops.Sessions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sessions = tmp
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int64
            }
        }
    }
    public var code: String?

    public var fotaPendingDesktops: [DescribeFotaPendingDesktopsResponseBody.FotaPendingDesktops]?

    public var message: String?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.fotaPendingDesktops != nil {
            var tmp : [Any] = []
            for k in self.fotaPendingDesktops! {
                tmp.append(k.toMap())
            }
            map["FotaPendingDesktops"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("FotaPendingDesktops") {
            var tmp : [DescribeFotaPendingDesktopsResponseBody.FotaPendingDesktops] = []
            for v in dict["FotaPendingDesktops"] as! [Any] {
                var model = DescribeFotaPendingDesktopsResponseBody.FotaPendingDesktops()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fotaPendingDesktops = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeFotaPendingDesktopsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFotaPendingDesktopsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFotaPendingDesktopsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFotaTasksRequest : Tea.TeaModel {
    public var fotaStatus: String?

    public var lang: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public var taskUid: [String]?

    public var userStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fotaStatus != nil {
            map["FotaStatus"] = self.fotaStatus!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskUid != nil {
            map["TaskUid"] = self.taskUid!
        }
        if self.userStatus != nil {
            map["UserStatus"] = self.userStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FotaStatus") {
            self.fotaStatus = dict["FotaStatus"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskUid") {
            self.taskUid = dict["TaskUid"] as! [String]
        }
        if dict.keys.contains("UserStatus") {
            self.userStatus = dict["UserStatus"] as! String
        }
    }
}

public class DescribeFotaTasksResponseBody : Tea.TeaModel {
    public class FotaTasks : Tea.TeaModel {
        public var appVersion: String?

        public var fotaProject: String?

        public var pendingCustomImageCount: Int32?

        public var pendingDesktopCount: Int32?

        public var publishTime: String?

        public var releaseNote: String?

        public var size: Int32?

        public var status: String?

        public var taskUid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appVersion != nil {
                map["AppVersion"] = self.appVersion!
            }
            if self.fotaProject != nil {
                map["FotaProject"] = self.fotaProject!
            }
            if self.pendingCustomImageCount != nil {
                map["PendingCustomImageCount"] = self.pendingCustomImageCount!
            }
            if self.pendingDesktopCount != nil {
                map["PendingDesktopCount"] = self.pendingDesktopCount!
            }
            if self.publishTime != nil {
                map["PublishTime"] = self.publishTime!
            }
            if self.releaseNote != nil {
                map["ReleaseNote"] = self.releaseNote!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskUid != nil {
                map["TaskUid"] = self.taskUid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppVersion") {
                self.appVersion = dict["AppVersion"] as! String
            }
            if dict.keys.contains("FotaProject") {
                self.fotaProject = dict["FotaProject"] as! String
            }
            if dict.keys.contains("PendingCustomImageCount") {
                self.pendingCustomImageCount = dict["PendingCustomImageCount"] as! Int32
            }
            if dict.keys.contains("PendingDesktopCount") {
                self.pendingDesktopCount = dict["PendingDesktopCount"] as! Int32
            }
            if dict.keys.contains("PublishTime") {
                self.publishTime = dict["PublishTime"] as! String
            }
            if dict.keys.contains("ReleaseNote") {
                self.releaseNote = dict["ReleaseNote"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskUid") {
                self.taskUid = dict["TaskUid"] as! String
            }
        }
    }
    public var code: String?

    public var fotaTasks: [DescribeFotaTasksResponseBody.FotaTasks]?

    public var message: String?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.fotaTasks != nil {
            var tmp : [Any] = []
            for k in self.fotaTasks! {
                tmp.append(k.toMap())
            }
            map["FotaTasks"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("FotaTasks") {
            var tmp : [DescribeFotaTasksResponseBody.FotaTasks] = []
            for v in dict["FotaTasks"] as! [Any] {
                var model = DescribeFotaTasksResponseBody.FotaTasks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fotaTasks = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeFotaTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFotaTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFotaTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGuestApplicationsRequest : Tea.TeaModel {
    public var desktopId: String?

    public var endUserId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeGuestApplicationsResponseBody : Tea.TeaModel {
    public class Applications : Tea.TeaModel {
        public class ProcessData : Tea.TeaModel {
            public var applicationName: String?

            public var applicationVersion: String?

            public var cpuPercent: Double?

            public var gpuPercent: Double?

            public var iospeed: Double?

            public var memPercent: Double?

            public var pid: Int32?

            public var processPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applicationName != nil {
                    map["ApplicationName"] = self.applicationName!
                }
                if self.applicationVersion != nil {
                    map["ApplicationVersion"] = self.applicationVersion!
                }
                if self.cpuPercent != nil {
                    map["CpuPercent"] = self.cpuPercent!
                }
                if self.gpuPercent != nil {
                    map["GpuPercent"] = self.gpuPercent!
                }
                if self.iospeed != nil {
                    map["Iospeed"] = self.iospeed!
                }
                if self.memPercent != nil {
                    map["MemPercent"] = self.memPercent!
                }
                if self.pid != nil {
                    map["Pid"] = self.pid!
                }
                if self.processPath != nil {
                    map["ProcessPath"] = self.processPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApplicationName") {
                    self.applicationName = dict["ApplicationName"] as! String
                }
                if dict.keys.contains("ApplicationVersion") {
                    self.applicationVersion = dict["ApplicationVersion"] as! String
                }
                if dict.keys.contains("CpuPercent") {
                    self.cpuPercent = dict["CpuPercent"] as! Double
                }
                if dict.keys.contains("GpuPercent") {
                    self.gpuPercent = dict["GpuPercent"] as! Double
                }
                if dict.keys.contains("Iospeed") {
                    self.iospeed = dict["Iospeed"] as! Double
                }
                if dict.keys.contains("MemPercent") {
                    self.memPercent = dict["MemPercent"] as! Double
                }
                if dict.keys.contains("Pid") {
                    self.pid = dict["Pid"] as! Int32
                }
                if dict.keys.contains("ProcessPath") {
                    self.processPath = dict["ProcessPath"] as! String
                }
            }
        }
        public var applicationName: String?

        public var applicationVersion: String?

        public var cpuPercent: Double?

        public var gpuPercent: Double?

        public var iconUrl: String?

        public var ioSpeed: Double?

        public var memPercent: Double?

        public var pid: Int32?

        public var processData: [DescribeGuestApplicationsResponseBody.Applications.ProcessData]?

        public var processPath: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationName != nil {
                map["ApplicationName"] = self.applicationName!
            }
            if self.applicationVersion != nil {
                map["ApplicationVersion"] = self.applicationVersion!
            }
            if self.cpuPercent != nil {
                map["CpuPercent"] = self.cpuPercent!
            }
            if self.gpuPercent != nil {
                map["GpuPercent"] = self.gpuPercent!
            }
            if self.iconUrl != nil {
                map["IconUrl"] = self.iconUrl!
            }
            if self.ioSpeed != nil {
                map["IoSpeed"] = self.ioSpeed!
            }
            if self.memPercent != nil {
                map["MemPercent"] = self.memPercent!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.processData != nil {
                var tmp : [Any] = []
                for k in self.processData! {
                    tmp.append(k.toMap())
                }
                map["ProcessData"] = tmp
            }
            if self.processPath != nil {
                map["ProcessPath"] = self.processPath!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplicationName") {
                self.applicationName = dict["ApplicationName"] as! String
            }
            if dict.keys.contains("ApplicationVersion") {
                self.applicationVersion = dict["ApplicationVersion"] as! String
            }
            if dict.keys.contains("CpuPercent") {
                self.cpuPercent = dict["CpuPercent"] as! Double
            }
            if dict.keys.contains("GpuPercent") {
                self.gpuPercent = dict["GpuPercent"] as! Double
            }
            if dict.keys.contains("IconUrl") {
                self.iconUrl = dict["IconUrl"] as! String
            }
            if dict.keys.contains("IoSpeed") {
                self.ioSpeed = dict["IoSpeed"] as! Double
            }
            if dict.keys.contains("MemPercent") {
                self.memPercent = dict["MemPercent"] as! Double
            }
            if dict.keys.contains("Pid") {
                self.pid = dict["Pid"] as! Int32
            }
            if dict.keys.contains("ProcessData") {
                var tmp : [DescribeGuestApplicationsResponseBody.Applications.ProcessData] = []
                for v in dict["ProcessData"] as! [Any] {
                    var model = DescribeGuestApplicationsResponseBody.Applications.ProcessData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.processData = tmp
            }
            if dict.keys.contains("ProcessPath") {
                self.processPath = dict["ProcessPath"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var applications: [DescribeGuestApplicationsResponseBody.Applications]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applications != nil {
            var tmp : [Any] = []
            for k in self.applications! {
                tmp.append(k.toMap())
            }
            map["Applications"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Applications") {
            var tmp : [DescribeGuestApplicationsResponseBody.Applications] = []
            for v in dict["Applications"] as! [Any] {
                var model = DescribeGuestApplicationsResponseBody.Applications()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.applications = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeGuestApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGuestApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGuestApplicationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageModifiedRecordsRequest : Tea.TeaModel {
    public var desktopId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeImageModifiedRecordsResponseBody : Tea.TeaModel {
    public class ImageModifiedRecords : Tea.TeaModel {
        public var imageId: String?

        public var imageName: String?

        public var newImageId: String?

        public var newImageName: String?

        public var status: Int32?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.newImageId != nil {
                map["NewImageId"] = self.newImageId!
            }
            if self.newImageName != nil {
                map["NewImageName"] = self.newImageName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageName") {
                self.imageName = dict["ImageName"] as! String
            }
            if dict.keys.contains("NewImageId") {
                self.newImageId = dict["NewImageId"] as! String
            }
            if dict.keys.contains("NewImageName") {
                self.newImageName = dict["NewImageName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var imageModifiedRecords: [DescribeImageModifiedRecordsResponseBody.ImageModifiedRecords]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageModifiedRecords != nil {
            var tmp : [Any] = []
            for k in self.imageModifiedRecords! {
                tmp.append(k.toMap())
            }
            map["ImageModifiedRecords"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageModifiedRecords") {
            var tmp : [DescribeImageModifiedRecordsResponseBody.ImageModifiedRecords] = []
            for v in dict["ImageModifiedRecords"] as! [Any] {
                var model = DescribeImageModifiedRecordsResponseBody.ImageModifiedRecords()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.imageModifiedRecords = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeImageModifiedRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageModifiedRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImageModifiedRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImagePermissionRequest : Tea.TeaModel {
    public var imageId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeImagePermissionResponseBody : Tea.TeaModel {
    public var aliUids: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliUids != nil {
            map["AliUids"] = self.aliUids!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliUids") {
            self.aliUids = dict["AliUids"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImagePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImagePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImagePermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImagesRequest : Tea.TeaModel {
    public var desktopInstanceType: String?

    public var fotaVersion: String?

    public var gpuCategory: Bool?

    public var gpuDriverVersion: String?

    public var imageId: [String]?

    public var imageName: String?

    public var imageStatus: String?

    public var imageType: String?

    public var languageType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var osType: String?

    public var protocolType: String?

    public var regionId: String?

    public var sessionType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopInstanceType != nil {
            map["DesktopInstanceType"] = self.desktopInstanceType!
        }
        if self.fotaVersion != nil {
            map["FotaVersion"] = self.fotaVersion!
        }
        if self.gpuCategory != nil {
            map["GpuCategory"] = self.gpuCategory!
        }
        if self.gpuDriverVersion != nil {
            map["GpuDriverVersion"] = self.gpuDriverVersion!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.imageStatus != nil {
            map["ImageStatus"] = self.imageStatus!
        }
        if self.imageType != nil {
            map["ImageType"] = self.imageType!
        }
        if self.languageType != nil {
            map["LanguageType"] = self.languageType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.osType != nil {
            map["OsType"] = self.osType!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sessionType != nil {
            map["SessionType"] = self.sessionType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopInstanceType") {
            self.desktopInstanceType = dict["DesktopInstanceType"] as! String
        }
        if dict.keys.contains("FotaVersion") {
            self.fotaVersion = dict["FotaVersion"] as! String
        }
        if dict.keys.contains("GpuCategory") {
            self.gpuCategory = dict["GpuCategory"] as! Bool
        }
        if dict.keys.contains("GpuDriverVersion") {
            self.gpuDriverVersion = dict["GpuDriverVersion"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! [String]
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("ImageStatus") {
            self.imageStatus = dict["ImageStatus"] as! String
        }
        if dict.keys.contains("ImageType") {
            self.imageType = dict["ImageType"] as! String
        }
        if dict.keys.contains("LanguageType") {
            self.languageType = dict["LanguageType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OsType") {
            self.osType = dict["OsType"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SessionType") {
            self.sessionType = dict["SessionType"] as! String
        }
    }
}

public class DescribeImagesResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public var appVersion: String?

        public var creationTime: String?

        public var dataDiskSize: Int32?

        public var description_: String?

        public var gpuCategory: Bool?

        public var gpuDriverVersion: String?

        public var imageId: String?

        public var imageType: String?

        public var name: String?

        public var osType: String?

        public var platform: String?

        public var progress: String?

        public var protocolType: String?

        public var sessionType: String?

        public var sharedCount: Int32?

        public var size: Int32?

        public var status: String?

        public var supportedLanguages: [String]?

        public var updateTime: String?

        public var volumeEncryptionEnabled: Bool?

        public var volumeEncryptionKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appVersion != nil {
                map["AppVersion"] = self.appVersion!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.dataDiskSize != nil {
                map["DataDiskSize"] = self.dataDiskSize!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.gpuCategory != nil {
                map["GpuCategory"] = self.gpuCategory!
            }
            if self.gpuDriverVersion != nil {
                map["GpuDriverVersion"] = self.gpuDriverVersion!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageType != nil {
                map["ImageType"] = self.imageType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.osType != nil {
                map["OsType"] = self.osType!
            }
            if self.platform != nil {
                map["Platform"] = self.platform!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.sessionType != nil {
                map["SessionType"] = self.sessionType!
            }
            if self.sharedCount != nil {
                map["SharedCount"] = self.sharedCount!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.supportedLanguages != nil {
                map["SupportedLanguages"] = self.supportedLanguages!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.volumeEncryptionEnabled != nil {
                map["VolumeEncryptionEnabled"] = self.volumeEncryptionEnabled!
            }
            if self.volumeEncryptionKey != nil {
                map["VolumeEncryptionKey"] = self.volumeEncryptionKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppVersion") {
                self.appVersion = dict["AppVersion"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DataDiskSize") {
                self.dataDiskSize = dict["DataDiskSize"] as! Int32
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GpuCategory") {
                self.gpuCategory = dict["GpuCategory"] as! Bool
            }
            if dict.keys.contains("GpuDriverVersion") {
                self.gpuDriverVersion = dict["GpuDriverVersion"] as! String
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageType") {
                self.imageType = dict["ImageType"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OsType") {
                self.osType = dict["OsType"] as! String
            }
            if dict.keys.contains("Platform") {
                self.platform = dict["Platform"] as! String
            }
            if dict.keys.contains("Progress") {
                self.progress = dict["Progress"] as! String
            }
            if dict.keys.contains("ProtocolType") {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("SessionType") {
                self.sessionType = dict["SessionType"] as! String
            }
            if dict.keys.contains("SharedCount") {
                self.sharedCount = dict["SharedCount"] as! Int32
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SupportedLanguages") {
                self.supportedLanguages = dict["SupportedLanguages"] as! [String]
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
            if dict.keys.contains("VolumeEncryptionEnabled") {
                self.volumeEncryptionEnabled = dict["VolumeEncryptionEnabled"] as! Bool
            }
            if dict.keys.contains("VolumeEncryptionKey") {
                self.volumeEncryptionKey = dict["VolumeEncryptionKey"] as! String
            }
        }
    }
    public var images: [DescribeImagesResponseBody.Images]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.images != nil {
            var tmp : [Any] = []
            for k in self.images! {
                tmp.append(k.toMap())
            }
            map["Images"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Images") {
            var tmp : [DescribeImagesResponseBody.Images] = []
            for v in dict["Images"] as! [Any] {
                var model = DescribeImagesResponseBody.Images()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.images = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInvocationsRequest : Tea.TeaModel {
    public var commandType: String?

    public var contentEncoding: String?

    public var desktopId: String?

    public var desktopIds: [String]?

    public var endUserId: String?

    public var includeInvokeDesktops: Bool?

    public var includeOutput: Bool?

    public var invokeId: String?

    public var invokeStatus: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandType != nil {
            map["CommandType"] = self.commandType!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.desktopIds != nil {
            map["DesktopIds"] = self.desktopIds!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.includeInvokeDesktops != nil {
            map["IncludeInvokeDesktops"] = self.includeInvokeDesktops!
        }
        if self.includeOutput != nil {
            map["IncludeOutput"] = self.includeOutput!
        }
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.invokeStatus != nil {
            map["InvokeStatus"] = self.invokeStatus!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandType") {
            self.commandType = dict["CommandType"] as! String
        }
        if dict.keys.contains("ContentEncoding") {
            self.contentEncoding = dict["ContentEncoding"] as! String
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("DesktopIds") {
            self.desktopIds = dict["DesktopIds"] as! [String]
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("IncludeInvokeDesktops") {
            self.includeInvokeDesktops = dict["IncludeInvokeDesktops"] as! Bool
        }
        if dict.keys.contains("IncludeOutput") {
            self.includeOutput = dict["IncludeOutput"] as! Bool
        }
        if dict.keys.contains("InvokeId") {
            self.invokeId = dict["InvokeId"] as! String
        }
        if dict.keys.contains("InvokeStatus") {
            self.invokeStatus = dict["InvokeStatus"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeInvocationsResponseBody : Tea.TeaModel {
    public class Invocations : Tea.TeaModel {
        public class InvokeDesktops : Tea.TeaModel {
            public var creationTime: String?

            public var desktopId: String?

            public var desktopName: String?

            public var dropped: Int32?

            public var errorCode: String?

            public var errorInfo: String?

            public var exitCode: Int64?

            public var finishTime: String?

            public var invocationStatus: String?

            public var output: String?

            public var repeats: Int32?

            public var startTime: String?

            public var stopTime: String?

            public var updateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.desktopId != nil {
                    map["DesktopId"] = self.desktopId!
                }
                if self.desktopName != nil {
                    map["DesktopName"] = self.desktopName!
                }
                if self.dropped != nil {
                    map["Dropped"] = self.dropped!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorInfo != nil {
                    map["ErrorInfo"] = self.errorInfo!
                }
                if self.exitCode != nil {
                    map["ExitCode"] = self.exitCode!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.invocationStatus != nil {
                    map["InvocationStatus"] = self.invocationStatus!
                }
                if self.output != nil {
                    map["Output"] = self.output!
                }
                if self.repeats != nil {
                    map["Repeats"] = self.repeats!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.stopTime != nil {
                    map["StopTime"] = self.stopTime!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DesktopId") {
                    self.desktopId = dict["DesktopId"] as! String
                }
                if dict.keys.contains("DesktopName") {
                    self.desktopName = dict["DesktopName"] as! String
                }
                if dict.keys.contains("Dropped") {
                    self.dropped = dict["Dropped"] as! Int32
                }
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorInfo") {
                    self.errorInfo = dict["ErrorInfo"] as! String
                }
                if dict.keys.contains("ExitCode") {
                    self.exitCode = dict["ExitCode"] as! Int64
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("InvocationStatus") {
                    self.invocationStatus = dict["InvocationStatus"] as! String
                }
                if dict.keys.contains("Output") {
                    self.output = dict["Output"] as! String
                }
                if dict.keys.contains("Repeats") {
                    self.repeats = dict["Repeats"] as! Int32
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("StopTime") {
                    self.stopTime = dict["StopTime"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
            }
        }
        public var commandContent: String?

        public var commandType: String?

        public var creationTime: String?

        public var endUserId: String?

        public var invocationStatus: String?

        public var invokeDesktopCount: Int32?

        public var invokeDesktopSucceedCount: Int32?

        public var invokeDesktops: [DescribeInvocationsResponseBody.Invocations.InvokeDesktops]?

        public var invokeId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commandContent != nil {
                map["CommandContent"] = self.commandContent!
            }
            if self.commandType != nil {
                map["CommandType"] = self.commandType!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.endUserId != nil {
                map["EndUserId"] = self.endUserId!
            }
            if self.invocationStatus != nil {
                map["InvocationStatus"] = self.invocationStatus!
            }
            if self.invokeDesktopCount != nil {
                map["InvokeDesktopCount"] = self.invokeDesktopCount!
            }
            if self.invokeDesktopSucceedCount != nil {
                map["InvokeDesktopSucceedCount"] = self.invokeDesktopSucceedCount!
            }
            if self.invokeDesktops != nil {
                var tmp : [Any] = []
                for k in self.invokeDesktops! {
                    tmp.append(k.toMap())
                }
                map["InvokeDesktops"] = tmp
            }
            if self.invokeId != nil {
                map["InvokeId"] = self.invokeId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommandContent") {
                self.commandContent = dict["CommandContent"] as! String
            }
            if dict.keys.contains("CommandType") {
                self.commandType = dict["CommandType"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("EndUserId") {
                self.endUserId = dict["EndUserId"] as! String
            }
            if dict.keys.contains("InvocationStatus") {
                self.invocationStatus = dict["InvocationStatus"] as! String
            }
            if dict.keys.contains("InvokeDesktopCount") {
                self.invokeDesktopCount = dict["InvokeDesktopCount"] as! Int32
            }
            if dict.keys.contains("InvokeDesktopSucceedCount") {
                self.invokeDesktopSucceedCount = dict["InvokeDesktopSucceedCount"] as! Int32
            }
            if dict.keys.contains("InvokeDesktops") {
                var tmp : [DescribeInvocationsResponseBody.Invocations.InvokeDesktops] = []
                for v in dict["InvokeDesktops"] as! [Any] {
                    var model = DescribeInvocationsResponseBody.Invocations.InvokeDesktops()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.invokeDesktops = tmp
            }
            if dict.keys.contains("InvokeId") {
                self.invokeId = dict["InvokeId"] as! String
            }
        }
    }
    public var invocations: [DescribeInvocationsResponseBody.Invocations]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.invocations != nil {
            var tmp : [Any] = []
            for k in self.invocations! {
                tmp.append(k.toMap())
            }
            map["Invocations"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Invocations") {
            var tmp : [DescribeInvocationsResponseBody.Invocations] = []
            for v in dict["Invocations"] as! [Any] {
                var model = DescribeInvocationsResponseBody.Invocations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.invocations = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInvocationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInvocationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInvocationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeKmsKeysRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeKmsKeysResponseBody : Tea.TeaModel {
    public class Keys : Tea.TeaModel {
        public var alias: String?

        public var arn: String?

        public var keyId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.arn != nil {
                map["Arn"] = self.arn!
            }
            if self.keyId != nil {
                map["KeyId"] = self.keyId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alias") {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("Arn") {
                self.arn = dict["Arn"] as! String
            }
            if dict.keys.contains("KeyId") {
                self.keyId = dict["KeyId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var authorizeStatus: String?

    public var keys: [DescribeKmsKeysResponseBody.Keys]?

    public var kmsServiceStatus: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorizeStatus != nil {
            map["AuthorizeStatus"] = self.authorizeStatus!
        }
        if self.keys != nil {
            var tmp : [Any] = []
            for k in self.keys! {
                tmp.append(k.toMap())
            }
            map["Keys"] = tmp
        }
        if self.kmsServiceStatus != nil {
            map["KmsServiceStatus"] = self.kmsServiceStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorizeStatus") {
            self.authorizeStatus = dict["AuthorizeStatus"] as! String
        }
        if dict.keys.contains("Keys") {
            var tmp : [DescribeKmsKeysResponseBody.Keys] = []
            for v in dict["Keys"] as! [Any] {
                var model = DescribeKmsKeysResponseBody.Keys()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.keys = tmp
        }
        if dict.keys.contains("KmsServiceStatus") {
            self.kmsServiceStatus = dict["KmsServiceStatus"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeKmsKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeKmsKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeKmsKeysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeModificationPriceRequest : Tea.TeaModel {
    public var bandwidth: Int32?

    public var instanceId: String?

    public var instanceType: String?

    public var regionId: String?

    public var resourceType: String?

    public var rootDiskSizeGib: Int32?

    public var userDiskSizeGib: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.rootDiskSizeGib != nil {
            map["RootDiskSizeGib"] = self.rootDiskSizeGib!
        }
        if self.userDiskSizeGib != nil {
            map["UserDiskSizeGib"] = self.userDiskSizeGib!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("RootDiskSizeGib") {
            self.rootDiskSizeGib = dict["RootDiskSizeGib"] as! Int32
        }
        if dict.keys.contains("UserDiskSizeGib") {
            self.userDiskSizeGib = dict["UserDiskSizeGib"] as! Int32
        }
    }
}

public class DescribeModificationPriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Price : Tea.TeaModel {
            public class Promotions : Tea.TeaModel {
                public var optionCode: String?

                public var promotionDesc: String?

                public var promotionId: String?

                public var promotionName: String?

                public var selected: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.optionCode != nil {
                        map["OptionCode"] = self.optionCode!
                    }
                    if self.promotionDesc != nil {
                        map["PromotionDesc"] = self.promotionDesc!
                    }
                    if self.promotionId != nil {
                        map["PromotionId"] = self.promotionId!
                    }
                    if self.promotionName != nil {
                        map["PromotionName"] = self.promotionName!
                    }
                    if self.selected != nil {
                        map["Selected"] = self.selected!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OptionCode") {
                        self.optionCode = dict["OptionCode"] as! String
                    }
                    if dict.keys.contains("PromotionDesc") {
                        self.promotionDesc = dict["PromotionDesc"] as! String
                    }
                    if dict.keys.contains("PromotionId") {
                        self.promotionId = dict["PromotionId"] as! String
                    }
                    if dict.keys.contains("PromotionName") {
                        self.promotionName = dict["PromotionName"] as! String
                    }
                    if dict.keys.contains("Selected") {
                        self.selected = dict["Selected"] as! Bool
                    }
                }
            }
            public var currency: String?

            public var discountPrice: Double?

            public var orderLines: [String: String]?

            public var originalPrice: Double?

            public var promotions: [DescribeModificationPriceResponseBody.PriceInfo.Price.Promotions]?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.orderLines != nil {
                    map["OrderLines"] = self.orderLines!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.promotions != nil {
                    var tmp : [Any] = []
                    for k in self.promotions! {
                        tmp.append(k.toMap())
                    }
                    map["Promotions"] = tmp
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Currency") {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("DiscountPrice") {
                    self.discountPrice = dict["DiscountPrice"] as! Double
                }
                if dict.keys.contains("OrderLines") {
                    self.orderLines = dict["OrderLines"] as! [String: String]
                }
                if dict.keys.contains("OriginalPrice") {
                    self.originalPrice = dict["OriginalPrice"] as! Double
                }
                if dict.keys.contains("Promotions") {
                    var tmp : [DescribeModificationPriceResponseBody.PriceInfo.Price.Promotions] = []
                    for v in dict["Promotions"] as! [Any] {
                        var model = DescribeModificationPriceResponseBody.PriceInfo.Price.Promotions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.promotions = tmp
                }
                if dict.keys.contains("TradePrice") {
                    self.tradePrice = dict["TradePrice"] as! Double
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public var description_: String?

            public var ruleId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("RuleId") {
                    self.ruleId = dict["RuleId"] as! Int64
                }
            }
        }
        public var price: DescribeModificationPriceResponseBody.PriceInfo.Price?

        public var rules: [DescribeModificationPriceResponseBody.PriceInfo.Rules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.price?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.price != nil {
                map["Price"] = self.price?.toMap()
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Price") {
                var model = DescribeModificationPriceResponseBody.PriceInfo.Price()
                model.fromMap(dict["Price"] as! [String: Any])
                self.price = model
            }
            if dict.keys.contains("Rules") {
                var tmp : [DescribeModificationPriceResponseBody.PriceInfo.Rules] = []
                for v in dict["Rules"] as! [Any] {
                    var model = DescribeModificationPriceResponseBody.PriceInfo.Rules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.rules = tmp
            }
        }
    }
    public var priceInfo: DescribeModificationPriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PriceInfo") {
            var model = DescribeModificationPriceResponseBody.PriceInfo()
            model.fromMap(dict["PriceInfo"] as! [String: Any])
            self.priceInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeModificationPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeModificationPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeModificationPriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNASFileSystemsRequest : Tea.TeaModel {
    public var fileSystemId: [String]?

    public var matchCompatibleProfile: Bool?

    public var maxResults: Int32?

    public var nextToken: String?

    public var officeSiteId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        if self.matchCompatibleProfile != nil {
            map["MatchCompatibleProfile"] = self.matchCompatibleProfile!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileSystemId") {
            self.fileSystemId = dict["FileSystemId"] as! [String]
        }
        if dict.keys.contains("MatchCompatibleProfile") {
            self.matchCompatibleProfile = dict["MatchCompatibleProfile"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeNASFileSystemsResponseBody : Tea.TeaModel {
    public class FileSystems : Tea.TeaModel {
        public class AppInstanceGroups : Tea.TeaModel {
            public var appInstanceGroupId: String?

            public var appInstanceGroupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appInstanceGroupId != nil {
                    map["AppInstanceGroupId"] = self.appInstanceGroupId!
                }
                if self.appInstanceGroupName != nil {
                    map["AppInstanceGroupName"] = self.appInstanceGroupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppInstanceGroupId") {
                    self.appInstanceGroupId = dict["AppInstanceGroupId"] as! String
                }
                if dict.keys.contains("AppInstanceGroupName") {
                    self.appInstanceGroupName = dict["AppInstanceGroupName"] as! String
                }
            }
        }
        public class DesktopGroups : Tea.TeaModel {
            public var desktopGroupId: String?

            public var desktopGroupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.desktopGroupId != nil {
                    map["DesktopGroupId"] = self.desktopGroupId!
                }
                if self.desktopGroupName != nil {
                    map["DesktopGroupName"] = self.desktopGroupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DesktopGroupId") {
                    self.desktopGroupId = dict["DesktopGroupId"] as! String
                }
                if dict.keys.contains("DesktopGroupName") {
                    self.desktopGroupName = dict["DesktopGroupName"] as! String
                }
            }
        }
        public class OfficeSites : Tea.TeaModel {
            public var officeSiteId: String?

            public var officeSiteName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.officeSiteId != nil {
                    map["OfficeSiteId"] = self.officeSiteId!
                }
                if self.officeSiteName != nil {
                    map["OfficeSiteName"] = self.officeSiteName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OfficeSiteId") {
                    self.officeSiteId = dict["OfficeSiteId"] as! String
                }
                if dict.keys.contains("OfficeSiteName") {
                    self.officeSiteName = dict["OfficeSiteName"] as! String
                }
            }
        }
        public var allowOperateUserDrive: Bool?

        public var appInstanceGroups: [DescribeNASFileSystemsResponseBody.FileSystems.AppInstanceGroups]?

        public var capacity: Int64?

        public var createTime: String?

        public var description_: String?

        public var desktopGroups: [DescribeNASFileSystemsResponseBody.FileSystems.DesktopGroups]?

        public var encryptionEnabled: Bool?

        public var fileSystemId: String?

        public var fileSystemName: String?

        public var fileSystemStatus: String?

        public var fileSystemType: String?

        public var meteredSize: Int64?

        public var mountTargetDomain: String?

        public var mountTargetStatus: String?

        public var officeSiteId: String?

        public var officeSiteName: String?

        public var officeSites: [DescribeNASFileSystemsResponseBody.FileSystems.OfficeSites]?

        public var profileCompatible: Bool?

        public var regionId: String?

        public var scene: String?

        public var storageType: String?

        public var supportAcl: Bool?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowOperateUserDrive != nil {
                map["AllowOperateUserDrive"] = self.allowOperateUserDrive!
            }
            if self.appInstanceGroups != nil {
                var tmp : [Any] = []
                for k in self.appInstanceGroups! {
                    tmp.append(k.toMap())
                }
                map["AppInstanceGroups"] = tmp
            }
            if self.capacity != nil {
                map["Capacity"] = self.capacity!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.desktopGroups != nil {
                var tmp : [Any] = []
                for k in self.desktopGroups! {
                    tmp.append(k.toMap())
                }
                map["DesktopGroups"] = tmp
            }
            if self.encryptionEnabled != nil {
                map["EncryptionEnabled"] = self.encryptionEnabled!
            }
            if self.fileSystemId != nil {
                map["FileSystemId"] = self.fileSystemId!
            }
            if self.fileSystemName != nil {
                map["FileSystemName"] = self.fileSystemName!
            }
            if self.fileSystemStatus != nil {
                map["FileSystemStatus"] = self.fileSystemStatus!
            }
            if self.fileSystemType != nil {
                map["FileSystemType"] = self.fileSystemType!
            }
            if self.meteredSize != nil {
                map["MeteredSize"] = self.meteredSize!
            }
            if self.mountTargetDomain != nil {
                map["MountTargetDomain"] = self.mountTargetDomain!
            }
            if self.mountTargetStatus != nil {
                map["MountTargetStatus"] = self.mountTargetStatus!
            }
            if self.officeSiteId != nil {
                map["OfficeSiteId"] = self.officeSiteId!
            }
            if self.officeSiteName != nil {
                map["OfficeSiteName"] = self.officeSiteName!
            }
            if self.officeSites != nil {
                var tmp : [Any] = []
                for k in self.officeSites! {
                    tmp.append(k.toMap())
                }
                map["OfficeSites"] = tmp
            }
            if self.profileCompatible != nil {
                map["ProfileCompatible"] = self.profileCompatible!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.scene != nil {
                map["Scene"] = self.scene!
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            if self.supportAcl != nil {
                map["SupportAcl"] = self.supportAcl!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowOperateUserDrive") {
                self.allowOperateUserDrive = dict["AllowOperateUserDrive"] as! Bool
            }
            if dict.keys.contains("AppInstanceGroups") {
                var tmp : [DescribeNASFileSystemsResponseBody.FileSystems.AppInstanceGroups] = []
                for v in dict["AppInstanceGroups"] as! [Any] {
                    var model = DescribeNASFileSystemsResponseBody.FileSystems.AppInstanceGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.appInstanceGroups = tmp
            }
            if dict.keys.contains("Capacity") {
                self.capacity = dict["Capacity"] as! Int64
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DesktopGroups") {
                var tmp : [DescribeNASFileSystemsResponseBody.FileSystems.DesktopGroups] = []
                for v in dict["DesktopGroups"] as! [Any] {
                    var model = DescribeNASFileSystemsResponseBody.FileSystems.DesktopGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.desktopGroups = tmp
            }
            if dict.keys.contains("EncryptionEnabled") {
                self.encryptionEnabled = dict["EncryptionEnabled"] as! Bool
            }
            if dict.keys.contains("FileSystemId") {
                self.fileSystemId = dict["FileSystemId"] as! String
            }
            if dict.keys.contains("FileSystemName") {
                self.fileSystemName = dict["FileSystemName"] as! String
            }
            if dict.keys.contains("FileSystemStatus") {
                self.fileSystemStatus = dict["FileSystemStatus"] as! String
            }
            if dict.keys.contains("FileSystemType") {
                self.fileSystemType = dict["FileSystemType"] as! String
            }
            if dict.keys.contains("MeteredSize") {
                self.meteredSize = dict["MeteredSize"] as! Int64
            }
            if dict.keys.contains("MountTargetDomain") {
                self.mountTargetDomain = dict["MountTargetDomain"] as! String
            }
            if dict.keys.contains("MountTargetStatus") {
                self.mountTargetStatus = dict["MountTargetStatus"] as! String
            }
            if dict.keys.contains("OfficeSiteId") {
                self.officeSiteId = dict["OfficeSiteId"] as! String
            }
            if dict.keys.contains("OfficeSiteName") {
                self.officeSiteName = dict["OfficeSiteName"] as! String
            }
            if dict.keys.contains("OfficeSites") {
                var tmp : [DescribeNASFileSystemsResponseBody.FileSystems.OfficeSites] = []
                for v in dict["OfficeSites"] as! [Any] {
                    var model = DescribeNASFileSystemsResponseBody.FileSystems.OfficeSites()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.officeSites = tmp
            }
            if dict.keys.contains("ProfileCompatible") {
                self.profileCompatible = dict["ProfileCompatible"] as! Bool
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Scene") {
                self.scene = dict["Scene"] as! String
            }
            if dict.keys.contains("StorageType") {
                self.storageType = dict["StorageType"] as! String
            }
            if dict.keys.contains("SupportAcl") {
                self.supportAcl = dict["SupportAcl"] as! Bool
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var fileSystems: [DescribeNASFileSystemsResponseBody.FileSystems]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileSystems != nil {
            var tmp : [Any] = []
            for k in self.fileSystems! {
                tmp.append(k.toMap())
            }
            map["FileSystems"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileSystems") {
            var tmp : [DescribeNASFileSystemsResponseBody.FileSystems] = []
            for v in dict["FileSystems"] as! [Any] {
                var model = DescribeNASFileSystemsResponseBody.FileSystems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fileSystems = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeNASFileSystemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNASFileSystemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNASFileSystemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworkPackagesRequest : Tea.TeaModel {
    public var internetChargeType: String?

    public var maxResults: Int32?

    public var networkPackageId: [String]?

    public var nextToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.networkPackageId != nil {
            map["NetworkPackageId"] = self.networkPackageId!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NetworkPackageId") {
            self.networkPackageId = dict["NetworkPackageId"] as! [String]
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeNetworkPackagesResponseBody : Tea.TeaModel {
    public class NetworkPackages : Tea.TeaModel {
        public var bandwidth: Int32?

        public var businessStatus: String?

        public var createTime: String?

        public var eipAddresses: [String]?

        public var expiredTime: String?

        public var internetChargeType: String?

        public var networkPackageId: String?

        public var networkPackageStatus: String?

        public var officeSiteId: String?

        public var officeSiteName: String?

        public var officeSiteVpcType: String?

        public var payType: String?

        public var reservationActiveTime: String?

        public var reservationBandwidth: Int32?

        public var reservationInternetChargeType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.eipAddresses != nil {
                map["EipAddresses"] = self.eipAddresses!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.networkPackageId != nil {
                map["NetworkPackageId"] = self.networkPackageId!
            }
            if self.networkPackageStatus != nil {
                map["NetworkPackageStatus"] = self.networkPackageStatus!
            }
            if self.officeSiteId != nil {
                map["OfficeSiteId"] = self.officeSiteId!
            }
            if self.officeSiteName != nil {
                map["OfficeSiteName"] = self.officeSiteName!
            }
            if self.officeSiteVpcType != nil {
                map["OfficeSiteVpcType"] = self.officeSiteVpcType!
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.reservationActiveTime != nil {
                map["ReservationActiveTime"] = self.reservationActiveTime!
            }
            if self.reservationBandwidth != nil {
                map["ReservationBandwidth"] = self.reservationBandwidth!
            }
            if self.reservationInternetChargeType != nil {
                map["ReservationInternetChargeType"] = self.reservationInternetChargeType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bandwidth") {
                self.bandwidth = dict["Bandwidth"] as! Int32
            }
            if dict.keys.contains("BusinessStatus") {
                self.businessStatus = dict["BusinessStatus"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("EipAddresses") {
                self.eipAddresses = dict["EipAddresses"] as! [String]
            }
            if dict.keys.contains("ExpiredTime") {
                self.expiredTime = dict["ExpiredTime"] as! String
            }
            if dict.keys.contains("InternetChargeType") {
                self.internetChargeType = dict["InternetChargeType"] as! String
            }
            if dict.keys.contains("NetworkPackageId") {
                self.networkPackageId = dict["NetworkPackageId"] as! String
            }
            if dict.keys.contains("NetworkPackageStatus") {
                self.networkPackageStatus = dict["NetworkPackageStatus"] as! String
            }
            if dict.keys.contains("OfficeSiteId") {
                self.officeSiteId = dict["OfficeSiteId"] as! String
            }
            if dict.keys.contains("OfficeSiteName") {
                self.officeSiteName = dict["OfficeSiteName"] as! String
            }
            if dict.keys.contains("OfficeSiteVpcType") {
                self.officeSiteVpcType = dict["OfficeSiteVpcType"] as! String
            }
            if dict.keys.contains("PayType") {
                self.payType = dict["PayType"] as! String
            }
            if dict.keys.contains("ReservationActiveTime") {
                self.reservationActiveTime = dict["ReservationActiveTime"] as! String
            }
            if dict.keys.contains("ReservationBandwidth") {
                self.reservationBandwidth = dict["ReservationBandwidth"] as! Int32
            }
            if dict.keys.contains("ReservationInternetChargeType") {
                self.reservationInternetChargeType = dict["ReservationInternetChargeType"] as! String
            }
        }
    }
    public var networkPackages: [DescribeNetworkPackagesResponseBody.NetworkPackages]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkPackages != nil {
            var tmp : [Any] = []
            for k in self.networkPackages! {
                tmp.append(k.toMap())
            }
            map["NetworkPackages"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkPackages") {
            var tmp : [DescribeNetworkPackagesResponseBody.NetworkPackages] = []
            for v in dict["NetworkPackages"] as! [Any] {
                var model = DescribeNetworkPackagesResponseBody.NetworkPackages()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.networkPackages = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeNetworkPackagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkPackagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNetworkPackagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOfficeSitesRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var officeSiteId: [String]?

    public var officeSiteType: String?

    public var regionId: String?

    public var securityProtection: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.officeSiteType != nil {
            map["OfficeSiteType"] = self.officeSiteType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.securityProtection != nil {
            map["SecurityProtection"] = self.securityProtection!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! [String]
        }
        if dict.keys.contains("OfficeSiteType") {
            self.officeSiteType = dict["OfficeSiteType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SecurityProtection") {
            self.securityProtection = dict["SecurityProtection"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeOfficeSitesResponseBody : Tea.TeaModel {
    public class OfficeSites : Tea.TeaModel {
        public class ADConnectors : Tea.TeaModel {
            public var ADConnectorAddress: String?

            public var connectorStatus: String?

            public var networkInterfaceId: String?

            public var specification: String?

            public var trustKey: String?

            public var vSwitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ADConnectorAddress != nil {
                    map["ADConnectorAddress"] = self.ADConnectorAddress!
                }
                if self.connectorStatus != nil {
                    map["ConnectorStatus"] = self.connectorStatus!
                }
                if self.networkInterfaceId != nil {
                    map["NetworkInterfaceId"] = self.networkInterfaceId!
                }
                if self.specification != nil {
                    map["Specification"] = self.specification!
                }
                if self.trustKey != nil {
                    map["TrustKey"] = self.trustKey!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ADConnectorAddress") {
                    self.ADConnectorAddress = dict["ADConnectorAddress"] as! String
                }
                if dict.keys.contains("ConnectorStatus") {
                    self.connectorStatus = dict["ConnectorStatus"] as! String
                }
                if dict.keys.contains("NetworkInterfaceId") {
                    self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
                }
                if dict.keys.contains("Specification") {
                    self.specification = dict["Specification"] as! String
                }
                if dict.keys.contains("TrustKey") {
                    self.trustKey = dict["TrustKey"] as! String
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
            }
        }
        public class Logs : Tea.TeaModel {
            public var level: String?

            public var message: String?

            public var step: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.step != nil {
                    map["Step"] = self.step!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Level") {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Step") {
                    self.step = dict["Step"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public class ResourceAmounts : Tea.TeaModel {
            public var amount: Int64?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.resourceType != nil {
                    map["resourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amount") {
                    self.amount = dict["amount"] as! Int64
                }
                if dict.keys.contains("resourceType") {
                    self.resourceType = dict["resourceType"] as! String
                }
            }
        }
        public var ADConnectors: [DescribeOfficeSitesResponseBody.OfficeSites.ADConnectors]?

        public var acceleratorId: String?

        public var adHostname: String?

        public var backupDCHostname: String?

        public var backupDns: String?

        public var bandwidth: Int32?

        public var cenAttachStatus: String?

        public var cenId: String?

        public var cidrBlock: String?

        public var cloudBoxOfficeSite: Bool?

        public var creationTime: String?

        public var customAccessPoint: String?

        public var customDnsAddress: [String]?

        public var customSecurityGroupId: String?

        public var desktopAccessType: String?

        public var desktopCount: Int64?

        public var desktopVpcEndpoint: String?

        public var dnsAddress: [String]?

        public var dnsUserName: String?

        public var domainName: String?

        public var domainPassword: String?

        public var domainUserName: String?

        public var enableAdminAccess: Bool?

        public var enableCrossDesktopAccess: Bool?

        public var enableInternetAccess: Bool?

        public var enableServiceRoute: Bool?

        public var fileSystemIds: [String]?

        public var isLdap: Bool?

        public var ldapUrl: String?

        public var logs: [DescribeOfficeSitesResponseBody.OfficeSites.Logs]?

        public var mfaEnabled: Bool?

        public var name: String?

        public var needVerifyLoginRisk: Bool?

        public var needVerifyZeroDevice: Bool?

        public var networkPackageId: String?

        public var nmVersion: String?

        public var officeSiteId: String?

        public var officeSiteType: String?

        public var ouName: String?

        public var protocolType: String?

        public var rdsLicenseAddress: String?

        public var rdsLicenseDomainName: String?

        public var rdsLicenseStatus: String?

        public var resourceAmounts: [DescribeOfficeSitesResponseBody.OfficeSites.ResourceAmounts]?

        public var securityProtection: String?

        public var ssoEnabled: Bool?

        public var ssoType: String?

        public var status: String?

        public var subDnsAddress: [String]?

        public var subDomainName: String?

        public var subnetMode: String?

        public var totalEdsCount: Int64?

        public var totalEdsCountForGroup: Int64?

        public var totalResourceAmount: Int64?

        public var trustPassword: String?

        public var vSwitchIds: [String]?

        public var vpcId: String?

        public var vpcType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ADConnectors != nil {
                var tmp : [Any] = []
                for k in self.ADConnectors! {
                    tmp.append(k.toMap())
                }
                map["ADConnectors"] = tmp
            }
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.adHostname != nil {
                map["AdHostname"] = self.adHostname!
            }
            if self.backupDCHostname != nil {
                map["BackupDCHostname"] = self.backupDCHostname!
            }
            if self.backupDns != nil {
                map["BackupDns"] = self.backupDns!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.cenAttachStatus != nil {
                map["CenAttachStatus"] = self.cenAttachStatus!
            }
            if self.cenId != nil {
                map["CenId"] = self.cenId!
            }
            if self.cidrBlock != nil {
                map["CidrBlock"] = self.cidrBlock!
            }
            if self.cloudBoxOfficeSite != nil {
                map["CloudBoxOfficeSite"] = self.cloudBoxOfficeSite!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.customAccessPoint != nil {
                map["CustomAccessPoint"] = self.customAccessPoint!
            }
            if self.customDnsAddress != nil {
                map["CustomDnsAddress"] = self.customDnsAddress!
            }
            if self.customSecurityGroupId != nil {
                map["CustomSecurityGroupId"] = self.customSecurityGroupId!
            }
            if self.desktopAccessType != nil {
                map["DesktopAccessType"] = self.desktopAccessType!
            }
            if self.desktopCount != nil {
                map["DesktopCount"] = self.desktopCount!
            }
            if self.desktopVpcEndpoint != nil {
                map["DesktopVpcEndpoint"] = self.desktopVpcEndpoint!
            }
            if self.dnsAddress != nil {
                map["DnsAddress"] = self.dnsAddress!
            }
            if self.dnsUserName != nil {
                map["DnsUserName"] = self.dnsUserName!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainPassword != nil {
                map["DomainPassword"] = self.domainPassword!
            }
            if self.domainUserName != nil {
                map["DomainUserName"] = self.domainUserName!
            }
            if self.enableAdminAccess != nil {
                map["EnableAdminAccess"] = self.enableAdminAccess!
            }
            if self.enableCrossDesktopAccess != nil {
                map["EnableCrossDesktopAccess"] = self.enableCrossDesktopAccess!
            }
            if self.enableInternetAccess != nil {
                map["EnableInternetAccess"] = self.enableInternetAccess!
            }
            if self.enableServiceRoute != nil {
                map["EnableServiceRoute"] = self.enableServiceRoute!
            }
            if self.fileSystemIds != nil {
                map["FileSystemIds"] = self.fileSystemIds!
            }
            if self.isLdap != nil {
                map["IsLdap"] = self.isLdap!
            }
            if self.ldapUrl != nil {
                map["LdapUrl"] = self.ldapUrl!
            }
            if self.logs != nil {
                var tmp : [Any] = []
                for k in self.logs! {
                    tmp.append(k.toMap())
                }
                map["Logs"] = tmp
            }
            if self.mfaEnabled != nil {
                map["MfaEnabled"] = self.mfaEnabled!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.needVerifyLoginRisk != nil {
                map["NeedVerifyLoginRisk"] = self.needVerifyLoginRisk!
            }
            if self.needVerifyZeroDevice != nil {
                map["NeedVerifyZeroDevice"] = self.needVerifyZeroDevice!
            }
            if self.networkPackageId != nil {
                map["NetworkPackageId"] = self.networkPackageId!
            }
            if self.nmVersion != nil {
                map["NmVersion"] = self.nmVersion!
            }
            if self.officeSiteId != nil {
                map["OfficeSiteId"] = self.officeSiteId!
            }
            if self.officeSiteType != nil {
                map["OfficeSiteType"] = self.officeSiteType!
            }
            if self.ouName != nil {
                map["OuName"] = self.ouName!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.rdsLicenseAddress != nil {
                map["RdsLicenseAddress"] = self.rdsLicenseAddress!
            }
            if self.rdsLicenseDomainName != nil {
                map["RdsLicenseDomainName"] = self.rdsLicenseDomainName!
            }
            if self.rdsLicenseStatus != nil {
                map["RdsLicenseStatus"] = self.rdsLicenseStatus!
            }
            if self.resourceAmounts != nil {
                var tmp : [Any] = []
                for k in self.resourceAmounts! {
                    tmp.append(k.toMap())
                }
                map["ResourceAmounts"] = tmp
            }
            if self.securityProtection != nil {
                map["SecurityProtection"] = self.securityProtection!
            }
            if self.ssoEnabled != nil {
                map["SsoEnabled"] = self.ssoEnabled!
            }
            if self.ssoType != nil {
                map["SsoType"] = self.ssoType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subDnsAddress != nil {
                map["SubDnsAddress"] = self.subDnsAddress!
            }
            if self.subDomainName != nil {
                map["SubDomainName"] = self.subDomainName!
            }
            if self.subnetMode != nil {
                map["SubnetMode"] = self.subnetMode!
            }
            if self.totalEdsCount != nil {
                map["TotalEdsCount"] = self.totalEdsCount!
            }
            if self.totalEdsCountForGroup != nil {
                map["TotalEdsCountForGroup"] = self.totalEdsCountForGroup!
            }
            if self.totalResourceAmount != nil {
                map["TotalResourceAmount"] = self.totalResourceAmount!
            }
            if self.trustPassword != nil {
                map["TrustPassword"] = self.trustPassword!
            }
            if self.vSwitchIds != nil {
                map["VSwitchIds"] = self.vSwitchIds!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.vpcType != nil {
                map["VpcType"] = self.vpcType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ADConnectors") {
                var tmp : [DescribeOfficeSitesResponseBody.OfficeSites.ADConnectors] = []
                for v in dict["ADConnectors"] as! [Any] {
                    var model = DescribeOfficeSitesResponseBody.OfficeSites.ADConnectors()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ADConnectors = tmp
            }
            if dict.keys.contains("AcceleratorId") {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("AdHostname") {
                self.adHostname = dict["AdHostname"] as! String
            }
            if dict.keys.contains("BackupDCHostname") {
                self.backupDCHostname = dict["BackupDCHostname"] as! String
            }
            if dict.keys.contains("BackupDns") {
                self.backupDns = dict["BackupDns"] as! String
            }
            if dict.keys.contains("Bandwidth") {
                self.bandwidth = dict["Bandwidth"] as! Int32
            }
            if dict.keys.contains("CenAttachStatus") {
                self.cenAttachStatus = dict["CenAttachStatus"] as! String
            }
            if dict.keys.contains("CenId") {
                self.cenId = dict["CenId"] as! String
            }
            if dict.keys.contains("CidrBlock") {
                self.cidrBlock = dict["CidrBlock"] as! String
            }
            if dict.keys.contains("CloudBoxOfficeSite") {
                self.cloudBoxOfficeSite = dict["CloudBoxOfficeSite"] as! Bool
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("CustomAccessPoint") {
                self.customAccessPoint = dict["CustomAccessPoint"] as! String
            }
            if dict.keys.contains("CustomDnsAddress") {
                self.customDnsAddress = dict["CustomDnsAddress"] as! [String]
            }
            if dict.keys.contains("CustomSecurityGroupId") {
                self.customSecurityGroupId = dict["CustomSecurityGroupId"] as! String
            }
            if dict.keys.contains("DesktopAccessType") {
                self.desktopAccessType = dict["DesktopAccessType"] as! String
            }
            if dict.keys.contains("DesktopCount") {
                self.desktopCount = dict["DesktopCount"] as! Int64
            }
            if dict.keys.contains("DesktopVpcEndpoint") {
                self.desktopVpcEndpoint = dict["DesktopVpcEndpoint"] as! String
            }
            if dict.keys.contains("DnsAddress") {
                self.dnsAddress = dict["DnsAddress"] as! [String]
            }
            if dict.keys.contains("DnsUserName") {
                self.dnsUserName = dict["DnsUserName"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("DomainPassword") {
                self.domainPassword = dict["DomainPassword"] as! String
            }
            if dict.keys.contains("DomainUserName") {
                self.domainUserName = dict["DomainUserName"] as! String
            }
            if dict.keys.contains("EnableAdminAccess") {
                self.enableAdminAccess = dict["EnableAdminAccess"] as! Bool
            }
            if dict.keys.contains("EnableCrossDesktopAccess") {
                self.enableCrossDesktopAccess = dict["EnableCrossDesktopAccess"] as! Bool
            }
            if dict.keys.contains("EnableInternetAccess") {
                self.enableInternetAccess = dict["EnableInternetAccess"] as! Bool
            }
            if dict.keys.contains("EnableServiceRoute") {
                self.enableServiceRoute = dict["EnableServiceRoute"] as! Bool
            }
            if dict.keys.contains("FileSystemIds") {
                self.fileSystemIds = dict["FileSystemIds"] as! [String]
            }
            if dict.keys.contains("IsLdap") {
                self.isLdap = dict["IsLdap"] as! Bool
            }
            if dict.keys.contains("LdapUrl") {
                self.ldapUrl = dict["LdapUrl"] as! String
            }
            if dict.keys.contains("Logs") {
                var tmp : [DescribeOfficeSitesResponseBody.OfficeSites.Logs] = []
                for v in dict["Logs"] as! [Any] {
                    var model = DescribeOfficeSitesResponseBody.OfficeSites.Logs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logs = tmp
            }
            if dict.keys.contains("MfaEnabled") {
                self.mfaEnabled = dict["MfaEnabled"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NeedVerifyLoginRisk") {
                self.needVerifyLoginRisk = dict["NeedVerifyLoginRisk"] as! Bool
            }
            if dict.keys.contains("NeedVerifyZeroDevice") {
                self.needVerifyZeroDevice = dict["NeedVerifyZeroDevice"] as! Bool
            }
            if dict.keys.contains("NetworkPackageId") {
                self.networkPackageId = dict["NetworkPackageId"] as! String
            }
            if dict.keys.contains("NmVersion") {
                self.nmVersion = dict["NmVersion"] as! String
            }
            if dict.keys.contains("OfficeSiteId") {
                self.officeSiteId = dict["OfficeSiteId"] as! String
            }
            if dict.keys.contains("OfficeSiteType") {
                self.officeSiteType = dict["OfficeSiteType"] as! String
            }
            if dict.keys.contains("OuName") {
                self.ouName = dict["OuName"] as! String
            }
            if dict.keys.contains("ProtocolType") {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("RdsLicenseAddress") {
                self.rdsLicenseAddress = dict["RdsLicenseAddress"] as! String
            }
            if dict.keys.contains("RdsLicenseDomainName") {
                self.rdsLicenseDomainName = dict["RdsLicenseDomainName"] as! String
            }
            if dict.keys.contains("RdsLicenseStatus") {
                self.rdsLicenseStatus = dict["RdsLicenseStatus"] as! String
            }
            if dict.keys.contains("ResourceAmounts") {
                var tmp : [DescribeOfficeSitesResponseBody.OfficeSites.ResourceAmounts] = []
                for v in dict["ResourceAmounts"] as! [Any] {
                    var model = DescribeOfficeSitesResponseBody.OfficeSites.ResourceAmounts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resourceAmounts = tmp
            }
            if dict.keys.contains("SecurityProtection") {
                self.securityProtection = dict["SecurityProtection"] as! String
            }
            if dict.keys.contains("SsoEnabled") {
                self.ssoEnabled = dict["SsoEnabled"] as! Bool
            }
            if dict.keys.contains("SsoType") {
                self.ssoType = dict["SsoType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubDnsAddress") {
                self.subDnsAddress = dict["SubDnsAddress"] as! [String]
            }
            if dict.keys.contains("SubDomainName") {
                self.subDomainName = dict["SubDomainName"] as! String
            }
            if dict.keys.contains("SubnetMode") {
                self.subnetMode = dict["SubnetMode"] as! String
            }
            if dict.keys.contains("TotalEdsCount") {
                self.totalEdsCount = dict["TotalEdsCount"] as! Int64
            }
            if dict.keys.contains("TotalEdsCountForGroup") {
                self.totalEdsCountForGroup = dict["TotalEdsCountForGroup"] as! Int64
            }
            if dict.keys.contains("TotalResourceAmount") {
                self.totalResourceAmount = dict["TotalResourceAmount"] as! Int64
            }
            if dict.keys.contains("TrustPassword") {
                self.trustPassword = dict["TrustPassword"] as! String
            }
            if dict.keys.contains("VSwitchIds") {
                self.vSwitchIds = dict["VSwitchIds"] as! [String]
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("VpcType") {
                self.vpcType = dict["VpcType"] as! String
            }
        }
    }
    public var nextToken: String?

    public var officeSites: [DescribeOfficeSitesResponseBody.OfficeSites]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.officeSites != nil {
            var tmp : [Any] = []
            for k in self.officeSites! {
                tmp.append(k.toMap())
            }
            map["OfficeSites"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OfficeSites") {
            var tmp : [DescribeOfficeSitesResponseBody.OfficeSites] = []
            for v in dict["OfficeSites"] as! [Any] {
                var model = DescribeOfficeSitesResponseBody.OfficeSites()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.officeSites = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeOfficeSitesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOfficeSitesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOfficeSitesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePolicyGroupsRequest : Tea.TeaModel {
    public var externalPolicyGroupIds: [String]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var policyGroupId: [String]?

    public var regionId: String?

    public var scope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.externalPolicyGroupIds != nil {
            map["ExternalPolicyGroupIds"] = self.externalPolicyGroupIds!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExternalPolicyGroupIds") {
            self.externalPolicyGroupIds = dict["ExternalPolicyGroupIds"] as! [String]
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
    }
}

public class DescribePolicyGroupsResponseBody : Tea.TeaModel {
    public class DescribePolicyGroups : Tea.TeaModel {
        public class AuthorizeAccessPolicyRules : Tea.TeaModel {
            public var cidrIp: String?

            public var description_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidrIp != nil {
                    map["CidrIp"] = self.cidrIp!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CidrIp") {
                    self.cidrIp = dict["CidrIp"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
            }
        }
        public class AuthorizeSecurityPolicyRules : Tea.TeaModel {
            public var cidrIp: String?

            public var description_: String?

            public var ipProtocol: String?

            public var policy: String?

            public var portRange: String?

            public var priority: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidrIp != nil {
                    map["CidrIp"] = self.cidrIp!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ipProtocol != nil {
                    map["IpProtocol"] = self.ipProtocol!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                if self.portRange != nil {
                    map["PortRange"] = self.portRange!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CidrIp") {
                    self.cidrIp = dict["CidrIp"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("IpProtocol") {
                    self.ipProtocol = dict["IpProtocol"] as! String
                }
                if dict.keys.contains("Policy") {
                    self.policy = dict["Policy"] as! String
                }
                if dict.keys.contains("PortRange") {
                    self.portRange = dict["PortRange"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class ClientTypes : Tea.TeaModel {
            public var clientType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clientType != nil {
                    map["ClientType"] = self.clientType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClientType") {
                    self.clientType = dict["ClientType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DeviceRedirects : Tea.TeaModel {
            public var deviceType: String?

            public var redirectType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deviceType != nil {
                    map["DeviceType"] = self.deviceType!
                }
                if self.redirectType != nil {
                    map["RedirectType"] = self.redirectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeviceType") {
                    self.deviceType = dict["DeviceType"] as! String
                }
                if dict.keys.contains("RedirectType") {
                    self.redirectType = dict["RedirectType"] as! String
                }
            }
        }
        public class DeviceRules : Tea.TeaModel {
            public var deviceName: String?

            public var devicePid: String?

            public var deviceType: String?

            public var deviceVid: String?

            public var optCommand: String?

            public var redirectType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deviceName != nil {
                    map["DeviceName"] = self.deviceName!
                }
                if self.devicePid != nil {
                    map["DevicePid"] = self.devicePid!
                }
                if self.deviceType != nil {
                    map["DeviceType"] = self.deviceType!
                }
                if self.deviceVid != nil {
                    map["DeviceVid"] = self.deviceVid!
                }
                if self.optCommand != nil {
                    map["OptCommand"] = self.optCommand!
                }
                if self.redirectType != nil {
                    map["RedirectType"] = self.redirectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeviceName") {
                    self.deviceName = dict["DeviceName"] as! String
                }
                if dict.keys.contains("DevicePid") {
                    self.devicePid = dict["DevicePid"] as! String
                }
                if dict.keys.contains("DeviceType") {
                    self.deviceType = dict["DeviceType"] as! String
                }
                if dict.keys.contains("DeviceVid") {
                    self.deviceVid = dict["DeviceVid"] as! String
                }
                if dict.keys.contains("OptCommand") {
                    self.optCommand = dict["OptCommand"] as! String
                }
                if dict.keys.contains("RedirectType") {
                    self.redirectType = dict["RedirectType"] as! String
                }
            }
        }
        public class DomainResolveRule : Tea.TeaModel {
            public var description_: String?

            public var domain: String?

            public var policy: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("Policy") {
                    self.policy = dict["Policy"] as! String
                }
            }
        }
        public class NetRedirectRule : Tea.TeaModel {
            public var domain: String?

            public var policy: String?

            public var ruleType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                if self.ruleType != nil {
                    map["RuleType"] = self.ruleType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("Policy") {
                    self.policy = dict["Policy"] as! String
                }
                if dict.keys.contains("RuleType") {
                    self.ruleType = dict["RuleType"] as! String
                }
            }
        }
        public class UsbSupplyRedirectRule : Tea.TeaModel {
            public var description_: String?

            public var deviceClass: String?

            public var deviceSubclass: String?

            public var productId: String?

            public var usbRedirectType: Int64?

            public var usbRuleType: Int64?

            public var vendorId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.deviceClass != nil {
                    map["DeviceClass"] = self.deviceClass!
                }
                if self.deviceSubclass != nil {
                    map["DeviceSubclass"] = self.deviceSubclass!
                }
                if self.productId != nil {
                    map["ProductId"] = self.productId!
                }
                if self.usbRedirectType != nil {
                    map["UsbRedirectType"] = self.usbRedirectType!
                }
                if self.usbRuleType != nil {
                    map["UsbRuleType"] = self.usbRuleType!
                }
                if self.vendorId != nil {
                    map["VendorId"] = self.vendorId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DeviceClass") {
                    self.deviceClass = dict["DeviceClass"] as! String
                }
                if dict.keys.contains("DeviceSubclass") {
                    self.deviceSubclass = dict["DeviceSubclass"] as! String
                }
                if dict.keys.contains("ProductId") {
                    self.productId = dict["ProductId"] as! String
                }
                if dict.keys.contains("UsbRedirectType") {
                    self.usbRedirectType = dict["UsbRedirectType"] as! Int64
                }
                if dict.keys.contains("UsbRuleType") {
                    self.usbRuleType = dict["UsbRuleType"] as! Int64
                }
                if dict.keys.contains("VendorId") {
                    self.vendorId = dict["VendorId"] as! String
                }
            }
        }
        public var adminAccess: String?

        public var appContentProtection: String?

        public var authorizeAccessPolicyRules: [DescribePolicyGroupsResponseBody.DescribePolicyGroups.AuthorizeAccessPolicyRules]?

        public var authorizeSecurityPolicyRules: [DescribePolicyGroupsResponseBody.DescribePolicyGroups.AuthorizeSecurityPolicyRules]?

        public var cameraRedirect: String?

        public var clientTypes: [DescribePolicyGroupsResponseBody.DescribePolicyGroups.ClientTypes]?

        public var clipboard: String?

        public var colorEnhancement: String?

        public var cpuDownGradeDuration: Int32?

        public var cpuProcessors: [String]?

        public var cpuProtectedMode: String?

        public var cpuRateLimit: Int32?

        public var cpuSampleDuration: Int32?

        public var cpuSingleRateLimit: Int32?

        public var desktopCount: Int32?

        public var desktopGroupCount: Int32?

        public var deviceConnectHint: String?

        public var deviceRedirects: [DescribePolicyGroupsResponseBody.DescribePolicyGroups.DeviceRedirects]?

        public var deviceRules: [DescribePolicyGroupsResponseBody.DescribePolicyGroups.DeviceRules]?

        public var displayMode: String?

        public var domainList: String?

        public var domainResolveRule: [DescribePolicyGroupsResponseBody.DescribePolicyGroups.DomainResolveRule]?

        public var domainResolveRuleType: String?

        public var edsCount: Int32?

        public var endUserApplyAdminCoordinate: String?

        public var endUserGroupCoordinate: String?

        public var fileMigrate: String?

        public var fileTransfer: String?

        public var gpuAcceleration: String?

        public var html5Access: String?

        public var html5FileTransfer: String?

        public var internetCommunicationProtocol: String?

        public var localDrive: String?

        public var maxReconnectTime: Int32?

        public var memoryDownGradeDuration: Int32?

        public var memoryProcessors: [String]?

        public var memoryProtectedMode: String?

        public var memoryRateLimit: Int32?

        public var memorySampleDuration: Int32?

        public var memorySingleRateLimit: Int32?

        public var mobileRestart: String?

        public var mobileShutdown: String?

        public var name: String?

        public var netRedirect: String?

        public var netRedirectRule: [DescribePolicyGroupsResponseBody.DescribePolicyGroups.NetRedirectRule]?

        public var policyGroupId: String?

        public var policyGroupType: String?

        public var policyStatus: String?

        public var preemptLogin: String?

        public var preemptLoginUsers: [String]?

        public var printerRedirection: String?

        public var qualityEnhancement: String?

        public var recordContent: String?

        public var recordContentExpires: Int64?

        public var recordEventDuration: Int32?

        public var recordEventFilePaths: [String]?

        public var recordEventRegisters: [String]?

        public var recording: String?

        public var recordingAudio: String?

        public var recordingDuration: Int32?

        public var recordingEndTime: String?

        public var recordingExpires: Int64?

        public var recordingFps: Int64?

        public var recordingStartTime: String?

        public var recordingUserNotify: String?

        public var recordingUserNotifyMessage: String?

        public var remoteCoordinate: String?

        public var resetDesktop: String?

        public var resolutionHeight: Int32?

        public var resolutionModel: String?

        public var resolutionWidth: Int32?

        public var resourceGroupCount: Int32?

        public var resourceRegionId: String?

        public var scope: String?

        public var scopeValue: [String]?

        public var smoothEnhancement: String?

        public var statusMonitor: String?

        public var streamingMode: String?

        public var targetFps: Int32?

        public var usbRedirect: String?

        public var usbSupplyRedirectRule: [DescribePolicyGroupsResponseBody.DescribePolicyGroups.UsbSupplyRedirectRule]?

        public var videoEncAvgKbps: Int32?

        public var videoEncMaxQP: Int32?

        public var videoEncMinQP: Int32?

        public var videoEncPeakKbps: Int32?

        public var videoEncPolicy: String?

        public var videoRedirect: String?

        public var visualQuality: String?

        public var watermark: String?

        public var watermarkAntiCam: String?

        public var watermarkColor: Int32?

        public var watermarkCustomText: String?

        public var watermarkDegree: Double?

        public var watermarkFontSize: Int32?

        public var watermarkFontStyle: String?

        public var watermarkPower: String?

        public var watermarkRowAmount: Int32?

        public var watermarkSecurity: String?

        public var watermarkTransparency: String?

        public var watermarkTransparencyValue: Int32?

        public var watermarkType: String?

        public var wuyingKeeper: String?

        public var wyAssistant: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.adminAccess != nil {
                map["AdminAccess"] = self.adminAccess!
            }
            if self.appContentProtection != nil {
                map["AppContentProtection"] = self.appContentProtection!
            }
            if self.authorizeAccessPolicyRules != nil {
                var tmp : [Any] = []
                for k in self.authorizeAccessPolicyRules! {
                    tmp.append(k.toMap())
                }
                map["AuthorizeAccessPolicyRules"] = tmp
            }
            if self.authorizeSecurityPolicyRules != nil {
                var tmp : [Any] = []
                for k in self.authorizeSecurityPolicyRules! {
                    tmp.append(k.toMap())
                }
                map["AuthorizeSecurityPolicyRules"] = tmp
            }
            if self.cameraRedirect != nil {
                map["CameraRedirect"] = self.cameraRedirect!
            }
            if self.clientTypes != nil {
                var tmp : [Any] = []
                for k in self.clientTypes! {
                    tmp.append(k.toMap())
                }
                map["ClientTypes"] = tmp
            }
            if self.clipboard != nil {
                map["Clipboard"] = self.clipboard!
            }
            if self.colorEnhancement != nil {
                map["ColorEnhancement"] = self.colorEnhancement!
            }
            if self.cpuDownGradeDuration != nil {
                map["CpuDownGradeDuration"] = self.cpuDownGradeDuration!
            }
            if self.cpuProcessors != nil {
                map["CpuProcessors"] = self.cpuProcessors!
            }
            if self.cpuProtectedMode != nil {
                map["CpuProtectedMode"] = self.cpuProtectedMode!
            }
            if self.cpuRateLimit != nil {
                map["CpuRateLimit"] = self.cpuRateLimit!
            }
            if self.cpuSampleDuration != nil {
                map["CpuSampleDuration"] = self.cpuSampleDuration!
            }
            if self.cpuSingleRateLimit != nil {
                map["CpuSingleRateLimit"] = self.cpuSingleRateLimit!
            }
            if self.desktopCount != nil {
                map["DesktopCount"] = self.desktopCount!
            }
            if self.desktopGroupCount != nil {
                map["DesktopGroupCount"] = self.desktopGroupCount!
            }
            if self.deviceConnectHint != nil {
                map["DeviceConnectHint"] = self.deviceConnectHint!
            }
            if self.deviceRedirects != nil {
                var tmp : [Any] = []
                for k in self.deviceRedirects! {
                    tmp.append(k.toMap())
                }
                map["DeviceRedirects"] = tmp
            }
            if self.deviceRules != nil {
                var tmp : [Any] = []
                for k in self.deviceRules! {
                    tmp.append(k.toMap())
                }
                map["DeviceRules"] = tmp
            }
            if self.displayMode != nil {
                map["DisplayMode"] = self.displayMode!
            }
            if self.domainList != nil {
                map["DomainList"] = self.domainList!
            }
            if self.domainResolveRule != nil {
                var tmp : [Any] = []
                for k in self.domainResolveRule! {
                    tmp.append(k.toMap())
                }
                map["DomainResolveRule"] = tmp
            }
            if self.domainResolveRuleType != nil {
                map["DomainResolveRuleType"] = self.domainResolveRuleType!
            }
            if self.edsCount != nil {
                map["EdsCount"] = self.edsCount!
            }
            if self.endUserApplyAdminCoordinate != nil {
                map["EndUserApplyAdminCoordinate"] = self.endUserApplyAdminCoordinate!
            }
            if self.endUserGroupCoordinate != nil {
                map["EndUserGroupCoordinate"] = self.endUserGroupCoordinate!
            }
            if self.fileMigrate != nil {
                map["FileMigrate"] = self.fileMigrate!
            }
            if self.fileTransfer != nil {
                map["FileTransfer"] = self.fileTransfer!
            }
            if self.gpuAcceleration != nil {
                map["GpuAcceleration"] = self.gpuAcceleration!
            }
            if self.html5Access != nil {
                map["Html5Access"] = self.html5Access!
            }
            if self.html5FileTransfer != nil {
                map["Html5FileTransfer"] = self.html5FileTransfer!
            }
            if self.internetCommunicationProtocol != nil {
                map["InternetCommunicationProtocol"] = self.internetCommunicationProtocol!
            }
            if self.localDrive != nil {
                map["LocalDrive"] = self.localDrive!
            }
            if self.maxReconnectTime != nil {
                map["MaxReconnectTime"] = self.maxReconnectTime!
            }
            if self.memoryDownGradeDuration != nil {
                map["MemoryDownGradeDuration"] = self.memoryDownGradeDuration!
            }
            if self.memoryProcessors != nil {
                map["MemoryProcessors"] = self.memoryProcessors!
            }
            if self.memoryProtectedMode != nil {
                map["MemoryProtectedMode"] = self.memoryProtectedMode!
            }
            if self.memoryRateLimit != nil {
                map["MemoryRateLimit"] = self.memoryRateLimit!
            }
            if self.memorySampleDuration != nil {
                map["MemorySampleDuration"] = self.memorySampleDuration!
            }
            if self.memorySingleRateLimit != nil {
                map["MemorySingleRateLimit"] = self.memorySingleRateLimit!
            }
            if self.mobileRestart != nil {
                map["MobileRestart"] = self.mobileRestart!
            }
            if self.mobileShutdown != nil {
                map["MobileShutdown"] = self.mobileShutdown!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.netRedirect != nil {
                map["NetRedirect"] = self.netRedirect!
            }
            if self.netRedirectRule != nil {
                var tmp : [Any] = []
                for k in self.netRedirectRule! {
                    tmp.append(k.toMap())
                }
                map["NetRedirectRule"] = tmp
            }
            if self.policyGroupId != nil {
                map["PolicyGroupId"] = self.policyGroupId!
            }
            if self.policyGroupType != nil {
                map["PolicyGroupType"] = self.policyGroupType!
            }
            if self.policyStatus != nil {
                map["PolicyStatus"] = self.policyStatus!
            }
            if self.preemptLogin != nil {
                map["PreemptLogin"] = self.preemptLogin!
            }
            if self.preemptLoginUsers != nil {
                map["PreemptLoginUsers"] = self.preemptLoginUsers!
            }
            if self.printerRedirection != nil {
                map["PrinterRedirection"] = self.printerRedirection!
            }
            if self.qualityEnhancement != nil {
                map["QualityEnhancement"] = self.qualityEnhancement!
            }
            if self.recordContent != nil {
                map["RecordContent"] = self.recordContent!
            }
            if self.recordContentExpires != nil {
                map["RecordContentExpires"] = self.recordContentExpires!
            }
            if self.recordEventDuration != nil {
                map["RecordEventDuration"] = self.recordEventDuration!
            }
            if self.recordEventFilePaths != nil {
                map["RecordEventFilePaths"] = self.recordEventFilePaths!
            }
            if self.recordEventRegisters != nil {
                map["RecordEventRegisters"] = self.recordEventRegisters!
            }
            if self.recording != nil {
                map["Recording"] = self.recording!
            }
            if self.recordingAudio != nil {
                map["RecordingAudio"] = self.recordingAudio!
            }
            if self.recordingDuration != nil {
                map["RecordingDuration"] = self.recordingDuration!
            }
            if self.recordingEndTime != nil {
                map["RecordingEndTime"] = self.recordingEndTime!
            }
            if self.recordingExpires != nil {
                map["RecordingExpires"] = self.recordingExpires!
            }
            if self.recordingFps != nil {
                map["RecordingFps"] = self.recordingFps!
            }
            if self.recordingStartTime != nil {
                map["RecordingStartTime"] = self.recordingStartTime!
            }
            if self.recordingUserNotify != nil {
                map["RecordingUserNotify"] = self.recordingUserNotify!
            }
            if self.recordingUserNotifyMessage != nil {
                map["RecordingUserNotifyMessage"] = self.recordingUserNotifyMessage!
            }
            if self.remoteCoordinate != nil {
                map["RemoteCoordinate"] = self.remoteCoordinate!
            }
            if self.resetDesktop != nil {
                map["ResetDesktop"] = self.resetDesktop!
            }
            if self.resolutionHeight != nil {
                map["ResolutionHeight"] = self.resolutionHeight!
            }
            if self.resolutionModel != nil {
                map["ResolutionModel"] = self.resolutionModel!
            }
            if self.resolutionWidth != nil {
                map["ResolutionWidth"] = self.resolutionWidth!
            }
            if self.resourceGroupCount != nil {
                map["ResourceGroupCount"] = self.resourceGroupCount!
            }
            if self.resourceRegionId != nil {
                map["ResourceRegionId"] = self.resourceRegionId!
            }
            if self.scope != nil {
                map["Scope"] = self.scope!
            }
            if self.scopeValue != nil {
                map["ScopeValue"] = self.scopeValue!
            }
            if self.smoothEnhancement != nil {
                map["SmoothEnhancement"] = self.smoothEnhancement!
            }
            if self.statusMonitor != nil {
                map["StatusMonitor"] = self.statusMonitor!
            }
            if self.streamingMode != nil {
                map["StreamingMode"] = self.streamingMode!
            }
            if self.targetFps != nil {
                map["TargetFps"] = self.targetFps!
            }
            if self.usbRedirect != nil {
                map["UsbRedirect"] = self.usbRedirect!
            }
            if self.usbSupplyRedirectRule != nil {
                var tmp : [Any] = []
                for k in self.usbSupplyRedirectRule! {
                    tmp.append(k.toMap())
                }
                map["UsbSupplyRedirectRule"] = tmp
            }
            if self.videoEncAvgKbps != nil {
                map["VideoEncAvgKbps"] = self.videoEncAvgKbps!
            }
            if self.videoEncMaxQP != nil {
                map["VideoEncMaxQP"] = self.videoEncMaxQP!
            }
            if self.videoEncMinQP != nil {
                map["VideoEncMinQP"] = self.videoEncMinQP!
            }
            if self.videoEncPeakKbps != nil {
                map["VideoEncPeakKbps"] = self.videoEncPeakKbps!
            }
            if self.videoEncPolicy != nil {
                map["VideoEncPolicy"] = self.videoEncPolicy!
            }
            if self.videoRedirect != nil {
                map["VideoRedirect"] = self.videoRedirect!
            }
            if self.visualQuality != nil {
                map["VisualQuality"] = self.visualQuality!
            }
            if self.watermark != nil {
                map["Watermark"] = self.watermark!
            }
            if self.watermarkAntiCam != nil {
                map["WatermarkAntiCam"] = self.watermarkAntiCam!
            }
            if self.watermarkColor != nil {
                map["WatermarkColor"] = self.watermarkColor!
            }
            if self.watermarkCustomText != nil {
                map["WatermarkCustomText"] = self.watermarkCustomText!
            }
            if self.watermarkDegree != nil {
                map["WatermarkDegree"] = self.watermarkDegree!
            }
            if self.watermarkFontSize != nil {
                map["WatermarkFontSize"] = self.watermarkFontSize!
            }
            if self.watermarkFontStyle != nil {
                map["WatermarkFontStyle"] = self.watermarkFontStyle!
            }
            if self.watermarkPower != nil {
                map["WatermarkPower"] = self.watermarkPower!
            }
            if self.watermarkRowAmount != nil {
                map["WatermarkRowAmount"] = self.watermarkRowAmount!
            }
            if self.watermarkSecurity != nil {
                map["WatermarkSecurity"] = self.watermarkSecurity!
            }
            if self.watermarkTransparency != nil {
                map["WatermarkTransparency"] = self.watermarkTransparency!
            }
            if self.watermarkTransparencyValue != nil {
                map["WatermarkTransparencyValue"] = self.watermarkTransparencyValue!
            }
            if self.watermarkType != nil {
                map["WatermarkType"] = self.watermarkType!
            }
            if self.wuyingKeeper != nil {
                map["WuyingKeeper"] = self.wuyingKeeper!
            }
            if self.wyAssistant != nil {
                map["WyAssistant"] = self.wyAssistant!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AdminAccess") {
                self.adminAccess = dict["AdminAccess"] as! String
            }
            if dict.keys.contains("AppContentProtection") {
                self.appContentProtection = dict["AppContentProtection"] as! String
            }
            if dict.keys.contains("AuthorizeAccessPolicyRules") {
                var tmp : [DescribePolicyGroupsResponseBody.DescribePolicyGroups.AuthorizeAccessPolicyRules] = []
                for v in dict["AuthorizeAccessPolicyRules"] as! [Any] {
                    var model = DescribePolicyGroupsResponseBody.DescribePolicyGroups.AuthorizeAccessPolicyRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authorizeAccessPolicyRules = tmp
            }
            if dict.keys.contains("AuthorizeSecurityPolicyRules") {
                var tmp : [DescribePolicyGroupsResponseBody.DescribePolicyGroups.AuthorizeSecurityPolicyRules] = []
                for v in dict["AuthorizeSecurityPolicyRules"] as! [Any] {
                    var model = DescribePolicyGroupsResponseBody.DescribePolicyGroups.AuthorizeSecurityPolicyRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authorizeSecurityPolicyRules = tmp
            }
            if dict.keys.contains("CameraRedirect") {
                self.cameraRedirect = dict["CameraRedirect"] as! String
            }
            if dict.keys.contains("ClientTypes") {
                var tmp : [DescribePolicyGroupsResponseBody.DescribePolicyGroups.ClientTypes] = []
                for v in dict["ClientTypes"] as! [Any] {
                    var model = DescribePolicyGroupsResponseBody.DescribePolicyGroups.ClientTypes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clientTypes = tmp
            }
            if dict.keys.contains("Clipboard") {
                self.clipboard = dict["Clipboard"] as! String
            }
            if dict.keys.contains("ColorEnhancement") {
                self.colorEnhancement = dict["ColorEnhancement"] as! String
            }
            if dict.keys.contains("CpuDownGradeDuration") {
                self.cpuDownGradeDuration = dict["CpuDownGradeDuration"] as! Int32
            }
            if dict.keys.contains("CpuProcessors") {
                self.cpuProcessors = dict["CpuProcessors"] as! [String]
            }
            if dict.keys.contains("CpuProtectedMode") {
                self.cpuProtectedMode = dict["CpuProtectedMode"] as! String
            }
            if dict.keys.contains("CpuRateLimit") {
                self.cpuRateLimit = dict["CpuRateLimit"] as! Int32
            }
            if dict.keys.contains("CpuSampleDuration") {
                self.cpuSampleDuration = dict["CpuSampleDuration"] as! Int32
            }
            if dict.keys.contains("CpuSingleRateLimit") {
                self.cpuSingleRateLimit = dict["CpuSingleRateLimit"] as! Int32
            }
            if dict.keys.contains("DesktopCount") {
                self.desktopCount = dict["DesktopCount"] as! Int32
            }
            if dict.keys.contains("DesktopGroupCount") {
                self.desktopGroupCount = dict["DesktopGroupCount"] as! Int32
            }
            if dict.keys.contains("DeviceConnectHint") {
                self.deviceConnectHint = dict["DeviceConnectHint"] as! String
            }
            if dict.keys.contains("DeviceRedirects") {
                var tmp : [DescribePolicyGroupsResponseBody.DescribePolicyGroups.DeviceRedirects] = []
                for v in dict["DeviceRedirects"] as! [Any] {
                    var model = DescribePolicyGroupsResponseBody.DescribePolicyGroups.DeviceRedirects()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deviceRedirects = tmp
            }
            if dict.keys.contains("DeviceRules") {
                var tmp : [DescribePolicyGroupsResponseBody.DescribePolicyGroups.DeviceRules] = []
                for v in dict["DeviceRules"] as! [Any] {
                    var model = DescribePolicyGroupsResponseBody.DescribePolicyGroups.DeviceRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deviceRules = tmp
            }
            if dict.keys.contains("DisplayMode") {
                self.displayMode = dict["DisplayMode"] as! String
            }
            if dict.keys.contains("DomainList") {
                self.domainList = dict["DomainList"] as! String
            }
            if dict.keys.contains("DomainResolveRule") {
                var tmp : [DescribePolicyGroupsResponseBody.DescribePolicyGroups.DomainResolveRule] = []
                for v in dict["DomainResolveRule"] as! [Any] {
                    var model = DescribePolicyGroupsResponseBody.DescribePolicyGroups.DomainResolveRule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.domainResolveRule = tmp
            }
            if dict.keys.contains("DomainResolveRuleType") {
                self.domainResolveRuleType = dict["DomainResolveRuleType"] as! String
            }
            if dict.keys.contains("EdsCount") {
                self.edsCount = dict["EdsCount"] as! Int32
            }
            if dict.keys.contains("EndUserApplyAdminCoordinate") {
                self.endUserApplyAdminCoordinate = dict["EndUserApplyAdminCoordinate"] as! String
            }
            if dict.keys.contains("EndUserGroupCoordinate") {
                self.endUserGroupCoordinate = dict["EndUserGroupCoordinate"] as! String
            }
            if dict.keys.contains("FileMigrate") {
                self.fileMigrate = dict["FileMigrate"] as! String
            }
            if dict.keys.contains("FileTransfer") {
                self.fileTransfer = dict["FileTransfer"] as! String
            }
            if dict.keys.contains("GpuAcceleration") {
                self.gpuAcceleration = dict["GpuAcceleration"] as! String
            }
            if dict.keys.contains("Html5Access") {
                self.html5Access = dict["Html5Access"] as! String
            }
            if dict.keys.contains("Html5FileTransfer") {
                self.html5FileTransfer = dict["Html5FileTransfer"] as! String
            }
            if dict.keys.contains("InternetCommunicationProtocol") {
                self.internetCommunicationProtocol = dict["InternetCommunicationProtocol"] as! String
            }
            if dict.keys.contains("LocalDrive") {
                self.localDrive = dict["LocalDrive"] as! String
            }
            if dict.keys.contains("MaxReconnectTime") {
                self.maxReconnectTime = dict["MaxReconnectTime"] as! Int32
            }
            if dict.keys.contains("MemoryDownGradeDuration") {
                self.memoryDownGradeDuration = dict["MemoryDownGradeDuration"] as! Int32
            }
            if dict.keys.contains("MemoryProcessors") {
                self.memoryProcessors = dict["MemoryProcessors"] as! [String]
            }
            if dict.keys.contains("MemoryProtectedMode") {
                self.memoryProtectedMode = dict["MemoryProtectedMode"] as! String
            }
            if dict.keys.contains("MemoryRateLimit") {
                self.memoryRateLimit = dict["MemoryRateLimit"] as! Int32
            }
            if dict.keys.contains("MemorySampleDuration") {
                self.memorySampleDuration = dict["MemorySampleDuration"] as! Int32
            }
            if dict.keys.contains("MemorySingleRateLimit") {
                self.memorySingleRateLimit = dict["MemorySingleRateLimit"] as! Int32
            }
            if dict.keys.contains("MobileRestart") {
                self.mobileRestart = dict["MobileRestart"] as! String
            }
            if dict.keys.contains("MobileShutdown") {
                self.mobileShutdown = dict["MobileShutdown"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NetRedirect") {
                self.netRedirect = dict["NetRedirect"] as! String
            }
            if dict.keys.contains("NetRedirectRule") {
                var tmp : [DescribePolicyGroupsResponseBody.DescribePolicyGroups.NetRedirectRule] = []
                for v in dict["NetRedirectRule"] as! [Any] {
                    var model = DescribePolicyGroupsResponseBody.DescribePolicyGroups.NetRedirectRule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.netRedirectRule = tmp
            }
            if dict.keys.contains("PolicyGroupId") {
                self.policyGroupId = dict["PolicyGroupId"] as! String
            }
            if dict.keys.contains("PolicyGroupType") {
                self.policyGroupType = dict["PolicyGroupType"] as! String
            }
            if dict.keys.contains("PolicyStatus") {
                self.policyStatus = dict["PolicyStatus"] as! String
            }
            if dict.keys.contains("PreemptLogin") {
                self.preemptLogin = dict["PreemptLogin"] as! String
            }
            if dict.keys.contains("PreemptLoginUsers") {
                self.preemptLoginUsers = dict["PreemptLoginUsers"] as! [String]
            }
            if dict.keys.contains("PrinterRedirection") {
                self.printerRedirection = dict["PrinterRedirection"] as! String
            }
            if dict.keys.contains("QualityEnhancement") {
                self.qualityEnhancement = dict["QualityEnhancement"] as! String
            }
            if dict.keys.contains("RecordContent") {
                self.recordContent = dict["RecordContent"] as! String
            }
            if dict.keys.contains("RecordContentExpires") {
                self.recordContentExpires = dict["RecordContentExpires"] as! Int64
            }
            if dict.keys.contains("RecordEventDuration") {
                self.recordEventDuration = dict["RecordEventDuration"] as! Int32
            }
            if dict.keys.contains("RecordEventFilePaths") {
                self.recordEventFilePaths = dict["RecordEventFilePaths"] as! [String]
            }
            if dict.keys.contains("RecordEventRegisters") {
                self.recordEventRegisters = dict["RecordEventRegisters"] as! [String]
            }
            if dict.keys.contains("Recording") {
                self.recording = dict["Recording"] as! String
            }
            if dict.keys.contains("RecordingAudio") {
                self.recordingAudio = dict["RecordingAudio"] as! String
            }
            if dict.keys.contains("RecordingDuration") {
                self.recordingDuration = dict["RecordingDuration"] as! Int32
            }
            if dict.keys.contains("RecordingEndTime") {
                self.recordingEndTime = dict["RecordingEndTime"] as! String
            }
            if dict.keys.contains("RecordingExpires") {
                self.recordingExpires = dict["RecordingExpires"] as! Int64
            }
            if dict.keys.contains("RecordingFps") {
                self.recordingFps = dict["RecordingFps"] as! Int64
            }
            if dict.keys.contains("RecordingStartTime") {
                self.recordingStartTime = dict["RecordingStartTime"] as! String
            }
            if dict.keys.contains("RecordingUserNotify") {
                self.recordingUserNotify = dict["RecordingUserNotify"] as! String
            }
            if dict.keys.contains("RecordingUserNotifyMessage") {
                self.recordingUserNotifyMessage = dict["RecordingUserNotifyMessage"] as! String
            }
            if dict.keys.contains("RemoteCoordinate") {
                self.remoteCoordinate = dict["RemoteCoordinate"] as! String
            }
            if dict.keys.contains("ResetDesktop") {
                self.resetDesktop = dict["ResetDesktop"] as! String
            }
            if dict.keys.contains("ResolutionHeight") {
                self.resolutionHeight = dict["ResolutionHeight"] as! Int32
            }
            if dict.keys.contains("ResolutionModel") {
                self.resolutionModel = dict["ResolutionModel"] as! String
            }
            if dict.keys.contains("ResolutionWidth") {
                self.resolutionWidth = dict["ResolutionWidth"] as! Int32
            }
            if dict.keys.contains("ResourceGroupCount") {
                self.resourceGroupCount = dict["ResourceGroupCount"] as! Int32
            }
            if dict.keys.contains("ResourceRegionId") {
                self.resourceRegionId = dict["ResourceRegionId"] as! String
            }
            if dict.keys.contains("Scope") {
                self.scope = dict["Scope"] as! String
            }
            if dict.keys.contains("ScopeValue") {
                self.scopeValue = dict["ScopeValue"] as! [String]
            }
            if dict.keys.contains("SmoothEnhancement") {
                self.smoothEnhancement = dict["SmoothEnhancement"] as! String
            }
            if dict.keys.contains("StatusMonitor") {
                self.statusMonitor = dict["StatusMonitor"] as! String
            }
            if dict.keys.contains("StreamingMode") {
                self.streamingMode = dict["StreamingMode"] as! String
            }
            if dict.keys.contains("TargetFps") {
                self.targetFps = dict["TargetFps"] as! Int32
            }
            if dict.keys.contains("UsbRedirect") {
                self.usbRedirect = dict["UsbRedirect"] as! String
            }
            if dict.keys.contains("UsbSupplyRedirectRule") {
                var tmp : [DescribePolicyGroupsResponseBody.DescribePolicyGroups.UsbSupplyRedirectRule] = []
                for v in dict["UsbSupplyRedirectRule"] as! [Any] {
                    var model = DescribePolicyGroupsResponseBody.DescribePolicyGroups.UsbSupplyRedirectRule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.usbSupplyRedirectRule = tmp
            }
            if dict.keys.contains("VideoEncAvgKbps") {
                self.videoEncAvgKbps = dict["VideoEncAvgKbps"] as! Int32
            }
            if dict.keys.contains("VideoEncMaxQP") {
                self.videoEncMaxQP = dict["VideoEncMaxQP"] as! Int32
            }
            if dict.keys.contains("VideoEncMinQP") {
                self.videoEncMinQP = dict["VideoEncMinQP"] as! Int32
            }
            if dict.keys.contains("VideoEncPeakKbps") {
                self.videoEncPeakKbps = dict["VideoEncPeakKbps"] as! Int32
            }
            if dict.keys.contains("VideoEncPolicy") {
                self.videoEncPolicy = dict["VideoEncPolicy"] as! String
            }
            if dict.keys.contains("VideoRedirect") {
                self.videoRedirect = dict["VideoRedirect"] as! String
            }
            if dict.keys.contains("VisualQuality") {
                self.visualQuality = dict["VisualQuality"] as! String
            }
            if dict.keys.contains("Watermark") {
                self.watermark = dict["Watermark"] as! String
            }
            if dict.keys.contains("WatermarkAntiCam") {
                self.watermarkAntiCam = dict["WatermarkAntiCam"] as! String
            }
            if dict.keys.contains("WatermarkColor") {
                self.watermarkColor = dict["WatermarkColor"] as! Int32
            }
            if dict.keys.contains("WatermarkCustomText") {
                self.watermarkCustomText = dict["WatermarkCustomText"] as! String
            }
            if dict.keys.contains("WatermarkDegree") {
                self.watermarkDegree = dict["WatermarkDegree"] as! Double
            }
            if dict.keys.contains("WatermarkFontSize") {
                self.watermarkFontSize = dict["WatermarkFontSize"] as! Int32
            }
            if dict.keys.contains("WatermarkFontStyle") {
                self.watermarkFontStyle = dict["WatermarkFontStyle"] as! String
            }
            if dict.keys.contains("WatermarkPower") {
                self.watermarkPower = dict["WatermarkPower"] as! String
            }
            if dict.keys.contains("WatermarkRowAmount") {
                self.watermarkRowAmount = dict["WatermarkRowAmount"] as! Int32
            }
            if dict.keys.contains("WatermarkSecurity") {
                self.watermarkSecurity = dict["WatermarkSecurity"] as! String
            }
            if dict.keys.contains("WatermarkTransparency") {
                self.watermarkTransparency = dict["WatermarkTransparency"] as! String
            }
            if dict.keys.contains("WatermarkTransparencyValue") {
                self.watermarkTransparencyValue = dict["WatermarkTransparencyValue"] as! Int32
            }
            if dict.keys.contains("WatermarkType") {
                self.watermarkType = dict["WatermarkType"] as! String
            }
            if dict.keys.contains("WuyingKeeper") {
                self.wuyingKeeper = dict["WuyingKeeper"] as! String
            }
            if dict.keys.contains("WyAssistant") {
                self.wyAssistant = dict["WyAssistant"] as! String
            }
        }
    }
    public var count: Int32?

    public var describePolicyGroups: [DescribePolicyGroupsResponseBody.DescribePolicyGroups]?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.describePolicyGroups != nil {
            var tmp : [Any] = []
            for k in self.describePolicyGroups! {
                tmp.append(k.toMap())
            }
            map["DescribePolicyGroups"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("DescribePolicyGroups") {
            var tmp : [DescribePolicyGroupsResponseBody.DescribePolicyGroups] = []
            for v in dict["DescribePolicyGroups"] as! [Any] {
                var model = DescribePolicyGroupsResponseBody.DescribePolicyGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.describePolicyGroups = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePolicyGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePolicyGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePolicyGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePriceRequest : Tea.TeaModel {
    public var amount: Int32?

    public var bandwidth: Int32?

    public var duration: Int32?

    public var groupDesktopCount: Int32?

    public var instanceType: String?

    public var internetChargeType: String?

    public var osType: String?

    public var period: Int32?

    public var periodUnit: String?

    public var promotionId: String?

    public var regionId: String?

    public var resourceType: String?

    public var rootDiskCategory: String?

    public var rootDiskSizeGib: Int32?

    public var userDiskCategory: String?

    public var userDiskSizeGib: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.groupDesktopCount != nil {
            map["GroupDesktopCount"] = self.groupDesktopCount!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.osType != nil {
            map["OsType"] = self.osType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.promotionId != nil {
            map["PromotionId"] = self.promotionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.rootDiskCategory != nil {
            map["RootDiskCategory"] = self.rootDiskCategory!
        }
        if self.rootDiskSizeGib != nil {
            map["RootDiskSizeGib"] = self.rootDiskSizeGib!
        }
        if self.userDiskCategory != nil {
            map["UserDiskCategory"] = self.userDiskCategory!
        }
        if self.userDiskSizeGib != nil {
            map["UserDiskSizeGib"] = self.userDiskSizeGib!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! Int32
        }
        if dict.keys.contains("GroupDesktopCount") {
            self.groupDesktopCount = dict["GroupDesktopCount"] as! Int32
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("OsType") {
            self.osType = dict["OsType"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PromotionId") {
            self.promotionId = dict["PromotionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("RootDiskCategory") {
            self.rootDiskCategory = dict["RootDiskCategory"] as! String
        }
        if dict.keys.contains("RootDiskSizeGib") {
            self.rootDiskSizeGib = dict["RootDiskSizeGib"] as! Int32
        }
        if dict.keys.contains("UserDiskCategory") {
            self.userDiskCategory = dict["UserDiskCategory"] as! String
        }
        if dict.keys.contains("UserDiskSizeGib") {
            self.userDiskSizeGib = dict["UserDiskSizeGib"] as! Int32
        }
    }
}

public class DescribePriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Price : Tea.TeaModel {
            public class Promotions : Tea.TeaModel {
                public var optionCode: String?

                public var promotionDesc: String?

                public var promotionId: String?

                public var promotionName: String?

                public var selected: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.optionCode != nil {
                        map["OptionCode"] = self.optionCode!
                    }
                    if self.promotionDesc != nil {
                        map["PromotionDesc"] = self.promotionDesc!
                    }
                    if self.promotionId != nil {
                        map["PromotionId"] = self.promotionId!
                    }
                    if self.promotionName != nil {
                        map["PromotionName"] = self.promotionName!
                    }
                    if self.selected != nil {
                        map["Selected"] = self.selected!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OptionCode") {
                        self.optionCode = dict["OptionCode"] as! String
                    }
                    if dict.keys.contains("PromotionDesc") {
                        self.promotionDesc = dict["PromotionDesc"] as! String
                    }
                    if dict.keys.contains("PromotionId") {
                        self.promotionId = dict["PromotionId"] as! String
                    }
                    if dict.keys.contains("PromotionName") {
                        self.promotionName = dict["PromotionName"] as! String
                    }
                    if dict.keys.contains("Selected") {
                        self.selected = dict["Selected"] as! Bool
                    }
                }
            }
            public var currency: String?

            public var discountPrice: Double?

            public var orderLines: [String: String]?

            public var originalPrice: Double?

            public var promotions: [DescribePriceResponseBody.PriceInfo.Price.Promotions]?

            public var spPrice: Int64?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.orderLines != nil {
                    map["OrderLines"] = self.orderLines!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.promotions != nil {
                    var tmp : [Any] = []
                    for k in self.promotions! {
                        tmp.append(k.toMap())
                    }
                    map["Promotions"] = tmp
                }
                if self.spPrice != nil {
                    map["SpPrice"] = self.spPrice!
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Currency") {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("DiscountPrice") {
                    self.discountPrice = dict["DiscountPrice"] as! Double
                }
                if dict.keys.contains("OrderLines") {
                    self.orderLines = dict["OrderLines"] as! [String: String]
                }
                if dict.keys.contains("OriginalPrice") {
                    self.originalPrice = dict["OriginalPrice"] as! Double
                }
                if dict.keys.contains("Promotions") {
                    var tmp : [DescribePriceResponseBody.PriceInfo.Price.Promotions] = []
                    for v in dict["Promotions"] as! [Any] {
                        var model = DescribePriceResponseBody.PriceInfo.Price.Promotions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.promotions = tmp
                }
                if dict.keys.contains("SpPrice") {
                    self.spPrice = dict["SpPrice"] as! Int64
                }
                if dict.keys.contains("TradePrice") {
                    self.tradePrice = dict["TradePrice"] as! Double
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public var description_: String?

            public var ruleId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("RuleId") {
                    self.ruleId = dict["RuleId"] as! Int64
                }
            }
        }
        public var freeCdsQuota: Bool?

        public var freeCdsSize: Int64?

        public var price: DescribePriceResponseBody.PriceInfo.Price?

        public var rules: [DescribePriceResponseBody.PriceInfo.Rules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.price?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.freeCdsQuota != nil {
                map["FreeCdsQuota"] = self.freeCdsQuota!
            }
            if self.freeCdsSize != nil {
                map["FreeCdsSize"] = self.freeCdsSize!
            }
            if self.price != nil {
                map["Price"] = self.price?.toMap()
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FreeCdsQuota") {
                self.freeCdsQuota = dict["FreeCdsQuota"] as! Bool
            }
            if dict.keys.contains("FreeCdsSize") {
                self.freeCdsSize = dict["FreeCdsSize"] as! Int64
            }
            if dict.keys.contains("Price") {
                var model = DescribePriceResponseBody.PriceInfo.Price()
                model.fromMap(dict["Price"] as! [String: Any])
                self.price = model
            }
            if dict.keys.contains("Rules") {
                var tmp : [DescribePriceResponseBody.PriceInfo.Rules] = []
                for v in dict["Rules"] as! [Any] {
                    var model = DescribePriceResponseBody.PriceInfo.Rules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.rules = tmp
            }
        }
    }
    public var priceInfo: DescribePriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PriceInfo") {
            var model = DescribePriceResponseBody.PriceInfo()
            model.fromMap(dict["PriceInfo"] as! [String: Any])
            self.priceInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePriceForCreateDesktopOversoldGroupRequest : Tea.TeaModel {
    public var concurrenceCount: Int32?

    public var dataDiskSize: Int32?

    public var desktopType: String?

    public var oversoldUserCount: Int32?

    public var period: Int32?

    public var periodUnit: String?

    public var systemDiskSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.concurrenceCount != nil {
            map["ConcurrenceCount"] = self.concurrenceCount!
        }
        if self.dataDiskSize != nil {
            map["DataDiskSize"] = self.dataDiskSize!
        }
        if self.desktopType != nil {
            map["DesktopType"] = self.desktopType!
        }
        if self.oversoldUserCount != nil {
            map["OversoldUserCount"] = self.oversoldUserCount!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.systemDiskSize != nil {
            map["SystemDiskSize"] = self.systemDiskSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConcurrenceCount") {
            self.concurrenceCount = dict["ConcurrenceCount"] as! Int32
        }
        if dict.keys.contains("DataDiskSize") {
            self.dataDiskSize = dict["DataDiskSize"] as! Int32
        }
        if dict.keys.contains("DesktopType") {
            self.desktopType = dict["DesktopType"] as! String
        }
        if dict.keys.contains("OversoldUserCount") {
            self.oversoldUserCount = dict["OversoldUserCount"] as! Int32
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("SystemDiskSize") {
            self.systemDiskSize = dict["SystemDiskSize"] as! Int32
        }
    }
}

public class DescribePriceForCreateDesktopOversoldGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var price: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.price != nil {
                map["Price"] = self.price!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Price") {
                self.price = dict["Price"] as! String
            }
        }
    }
    public var data: DescribePriceForCreateDesktopOversoldGroupResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribePriceForCreateDesktopOversoldGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePriceForCreateDesktopOversoldGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePriceForCreateDesktopOversoldGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePriceForCreateDesktopOversoldGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePriceForModifyDesktopOversoldGroupSaleRequest : Tea.TeaModel {
    public var concurrenceCount: Int32?

    public var oversoldGroupId: String?

    public var oversoldUserCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.concurrenceCount != nil {
            map["ConcurrenceCount"] = self.concurrenceCount!
        }
        if self.oversoldGroupId != nil {
            map["OversoldGroupId"] = self.oversoldGroupId!
        }
        if self.oversoldUserCount != nil {
            map["OversoldUserCount"] = self.oversoldUserCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConcurrenceCount") {
            self.concurrenceCount = dict["ConcurrenceCount"] as! Int32
        }
        if dict.keys.contains("OversoldGroupId") {
            self.oversoldGroupId = dict["OversoldGroupId"] as! String
        }
        if dict.keys.contains("OversoldUserCount") {
            self.oversoldUserCount = dict["OversoldUserCount"] as! Int32
        }
    }
}

public class DescribePriceForModifyDesktopOversoldGroupSaleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var price: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.price != nil {
                map["Price"] = self.price!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Price") {
                self.price = dict["Price"] as! String
            }
        }
    }
    public var data: DescribePriceForModifyDesktopOversoldGroupSaleResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribePriceForModifyDesktopOversoldGroupSaleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePriceForModifyDesktopOversoldGroupSaleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePriceForModifyDesktopOversoldGroupSaleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePriceForModifyDesktopOversoldGroupSaleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePriceForRenewDesktopOversoldGroupRequest : Tea.TeaModel {
    public var oversoldGroupId: String?

    public var period: Int32?

    public var periodUnit: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.oversoldGroupId != nil {
            map["OversoldGroupId"] = self.oversoldGroupId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OversoldGroupId") {
            self.oversoldGroupId = dict["OversoldGroupId"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
    }
}

public class DescribePriceForRenewDesktopOversoldGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var price: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.price != nil {
                map["Price"] = self.price!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Price") {
                self.price = dict["Price"] as! String
            }
        }
    }
    public var data: DescribePriceForRenewDesktopOversoldGroupResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribePriceForRenewDesktopOversoldGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePriceForRenewDesktopOversoldGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePriceForRenewDesktopOversoldGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePriceForRenewDesktopOversoldGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRecordingsRequest : Tea.TeaModel {
    public var desktopId: String?

    public var endTime: String?

    public var maxResults: Int32?

    public var needSignedUrl: Bool?

    public var nextToken: String?

    public var policyGroupId: String?

    public var regionId: String?

    public var signedUrlExpireMinutes: Int32?

    public var standardEndTime: String?

    public var standardStartTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.needSignedUrl != nil {
            map["NeedSignedUrl"] = self.needSignedUrl!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.signedUrlExpireMinutes != nil {
            map["SignedUrlExpireMinutes"] = self.signedUrlExpireMinutes!
        }
        if self.standardEndTime != nil {
            map["StandardEndTime"] = self.standardEndTime!
        }
        if self.standardStartTime != nil {
            map["StandardStartTime"] = self.standardStartTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NeedSignedUrl") {
            self.needSignedUrl = dict["NeedSignedUrl"] as! Bool
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SignedUrlExpireMinutes") {
            self.signedUrlExpireMinutes = dict["SignedUrlExpireMinutes"] as! Int32
        }
        if dict.keys.contains("StandardEndTime") {
            self.standardEndTime = dict["StandardEndTime"] as! String
        }
        if dict.keys.contains("StandardStartTime") {
            self.standardStartTime = dict["StandardStartTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeRecordingsResponseBody : Tea.TeaModel {
    public class Recordings : Tea.TeaModel {
        public var desktopId: String?

        public var desktopName: String?

        public var endTime: String?

        public var endUserIds: [String]?

        public var filePath: String?

        public var policyGroupId: String?

        public var recordingSize: Int32?

        public var recordingType: String?

        public var signedUrl: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.desktopName != nil {
                map["DesktopName"] = self.desktopName!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.endUserIds != nil {
                map["EndUserIds"] = self.endUserIds!
            }
            if self.filePath != nil {
                map["FilePath"] = self.filePath!
            }
            if self.policyGroupId != nil {
                map["PolicyGroupId"] = self.policyGroupId!
            }
            if self.recordingSize != nil {
                map["RecordingSize"] = self.recordingSize!
            }
            if self.recordingType != nil {
                map["RecordingType"] = self.recordingType!
            }
            if self.signedUrl != nil {
                map["SignedUrl"] = self.signedUrl!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("DesktopName") {
                self.desktopName = dict["DesktopName"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("EndUserIds") {
                self.endUserIds = dict["EndUserIds"] as! [String]
            }
            if dict.keys.contains("FilePath") {
                self.filePath = dict["FilePath"] as! String
            }
            if dict.keys.contains("PolicyGroupId") {
                self.policyGroupId = dict["PolicyGroupId"] as! String
            }
            if dict.keys.contains("RecordingSize") {
                self.recordingSize = dict["RecordingSize"] as! Int32
            }
            if dict.keys.contains("RecordingType") {
                self.recordingType = dict["RecordingType"] as! String
            }
            if dict.keys.contains("SignedUrl") {
                self.signedUrl = dict["SignedUrl"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public var nextToken: String?

    public var recordings: [DescribeRecordingsResponseBody.Recordings]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.recordings != nil {
            var tmp : [Any] = []
            for k in self.recordings! {
                tmp.append(k.toMap())
            }
            map["Recordings"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Recordings") {
            var tmp : [DescribeRecordingsResponseBody.Recordings] = []
            for v in dict["Recordings"] as! [Any] {
                var model = DescribeRecordingsResponseBody.Recordings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.recordings = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRecordingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecordingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRecordingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRefundPriceRequest : Tea.TeaModel {
    public var desktopId: [String]?

    public var refundType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.refundType != nil {
            map["RefundType"] = self.refundType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("RefundType") {
            self.refundType = dict["RefundType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeRefundPriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public var currency: String?

        public var refundFee: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currency != nil {
                map["Currency"] = self.currency!
            }
            if self.refundFee != nil {
                map["RefundFee"] = self.refundFee!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Currency") {
                self.currency = dict["Currency"] as! String
            }
            if dict.keys.contains("RefundFee") {
                self.refundFee = dict["RefundFee"] as! Double
            }
        }
    }
    public var priceInfo: DescribeRefundPriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PriceInfo") {
            var model = DescribeRefundPriceResponseBody.PriceInfo()
            model.fromMap(dict["PriceInfo"] as! [String: Any])
            self.priceInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRefundPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRefundPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRefundPriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRegionsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public var localName: String?

        public var regionEndpoint: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.regionEndpoint != nil {
                map["RegionEndpoint"] = self.regionEndpoint!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LocalName") {
                self.localName = dict["LocalName"] as! String
            }
            if dict.keys.contains("RegionEndpoint") {
                self.regionEndpoint = dict["RegionEndpoint"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var regions: [DescribeRegionsResponseBody.Regions]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            var tmp : [Any] = []
            for k in self.regions! {
                tmp.append(k.toMap())
            }
            map["Regions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Regions") {
            var tmp : [DescribeRegionsResponseBody.Regions] = []
            for v in dict["Regions"] as! [Any] {
                var model = DescribeRegionsResponseBody.Regions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.regions = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRenewalPriceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceIds: [String]?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DescribeRenewalPriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Price : Tea.TeaModel {
            public class Promotions : Tea.TeaModel {
                public var optionCode: String?

                public var promotionDesc: String?

                public var promotionId: String?

                public var promotionName: String?

                public var selected: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.optionCode != nil {
                        map["OptionCode"] = self.optionCode!
                    }
                    if self.promotionDesc != nil {
                        map["PromotionDesc"] = self.promotionDesc!
                    }
                    if self.promotionId != nil {
                        map["PromotionId"] = self.promotionId!
                    }
                    if self.promotionName != nil {
                        map["PromotionName"] = self.promotionName!
                    }
                    if self.selected != nil {
                        map["Selected"] = self.selected!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OptionCode") {
                        self.optionCode = dict["OptionCode"] as! String
                    }
                    if dict.keys.contains("PromotionDesc") {
                        self.promotionDesc = dict["PromotionDesc"] as! String
                    }
                    if dict.keys.contains("PromotionId") {
                        self.promotionId = dict["PromotionId"] as! String
                    }
                    if dict.keys.contains("PromotionName") {
                        self.promotionName = dict["PromotionName"] as! String
                    }
                    if dict.keys.contains("Selected") {
                        self.selected = dict["Selected"] as! Bool
                    }
                }
            }
            public var currency: String?

            public var discountPrice: Double?

            public var orderLines: [String: String]?

            public var originalPrice: Double?

            public var promotions: [DescribeRenewalPriceResponseBody.PriceInfo.Price.Promotions]?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.orderLines != nil {
                    map["OrderLines"] = self.orderLines!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.promotions != nil {
                    var tmp : [Any] = []
                    for k in self.promotions! {
                        tmp.append(k.toMap())
                    }
                    map["Promotions"] = tmp
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Currency") {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("DiscountPrice") {
                    self.discountPrice = dict["DiscountPrice"] as! Double
                }
                if dict.keys.contains("OrderLines") {
                    self.orderLines = dict["OrderLines"] as! [String: String]
                }
                if dict.keys.contains("OriginalPrice") {
                    self.originalPrice = dict["OriginalPrice"] as! Double
                }
                if dict.keys.contains("Promotions") {
                    var tmp : [DescribeRenewalPriceResponseBody.PriceInfo.Price.Promotions] = []
                    for v in dict["Promotions"] as! [Any] {
                        var model = DescribeRenewalPriceResponseBody.PriceInfo.Price.Promotions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.promotions = tmp
                }
                if dict.keys.contains("TradePrice") {
                    self.tradePrice = dict["TradePrice"] as! Double
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public var description_: String?

            public var ruleId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("RuleId") {
                    self.ruleId = dict["RuleId"] as! Int64
                }
            }
        }
        public var price: DescribeRenewalPriceResponseBody.PriceInfo.Price?

        public var rules: [DescribeRenewalPriceResponseBody.PriceInfo.Rules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.price?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.price != nil {
                map["Price"] = self.price?.toMap()
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Price") {
                var model = DescribeRenewalPriceResponseBody.PriceInfo.Price()
                model.fromMap(dict["Price"] as! [String: Any])
                self.price = model
            }
            if dict.keys.contains("Rules") {
                var tmp : [DescribeRenewalPriceResponseBody.PriceInfo.Rules] = []
                for v in dict["Rules"] as! [Any] {
                    var model = DescribeRenewalPriceResponseBody.PriceInfo.Rules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.rules = tmp
            }
        }
    }
    public var priceInfo: DescribeRenewalPriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PriceInfo") {
            var model = DescribeRenewalPriceResponseBody.PriceInfo()
            model.fromMap(dict["PriceInfo"] as! [String: Any])
            self.priceInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRenewalPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRenewalPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRenewalPriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeResourceByCenterPolicyIdRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var policyGroupId: String?

    public var productType: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.productType != nil {
            map["ProductType"] = self.productType!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("ProductType") {
            self.productType = dict["ProductType"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
    }
}

public class DescribeResourceByCenterPolicyIdResponseBody : Tea.TeaModel {
    public class ResourceModelList : Tea.TeaModel {
        public class AppModelList : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
            }
        }
        public var appModelList: [DescribeResourceByCenterPolicyIdResponseBody.ResourceModelList.AppModelList]?

        public var cpu: Int32?

        public var desktopType: String?

        public var gpuCount: Double?

        public var gpuSpec: String?

        public var memory: Int64?

        public var osType: String?

        public var payType: String?

        public var productType: String?

        public var protocolType: String?

        public var resourceGroupId: String?

        public var resourceGroupName: String?

        public var resourceGroupRelCount: Int32?

        public var resourceId: String?

        public var resourceName: String?

        public var resourceRegionId: String?

        public var resourceType: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appModelList != nil {
                var tmp : [Any] = []
                for k in self.appModelList! {
                    tmp.append(k.toMap())
                }
                map["AppModelList"] = tmp
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.desktopType != nil {
                map["DesktopType"] = self.desktopType!
            }
            if self.gpuCount != nil {
                map["GpuCount"] = self.gpuCount!
            }
            if self.gpuSpec != nil {
                map["GpuSpec"] = self.gpuSpec!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.osType != nil {
                map["OsType"] = self.osType!
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.productType != nil {
                map["ProductType"] = self.productType!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.resourceGroupName != nil {
                map["ResourceGroupName"] = self.resourceGroupName!
            }
            if self.resourceGroupRelCount != nil {
                map["ResourceGroupRelCount"] = self.resourceGroupRelCount!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceName != nil {
                map["ResourceName"] = self.resourceName!
            }
            if self.resourceRegionId != nil {
                map["ResourceRegionId"] = self.resourceRegionId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppModelList") {
                var tmp : [DescribeResourceByCenterPolicyIdResponseBody.ResourceModelList.AppModelList] = []
                for v in dict["AppModelList"] as! [Any] {
                    var model = DescribeResourceByCenterPolicyIdResponseBody.ResourceModelList.AppModelList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.appModelList = tmp
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("DesktopType") {
                self.desktopType = dict["DesktopType"] as! String
            }
            if dict.keys.contains("GpuCount") {
                self.gpuCount = dict["GpuCount"] as! Double
            }
            if dict.keys.contains("GpuSpec") {
                self.gpuSpec = dict["GpuSpec"] as! String
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Int64
            }
            if dict.keys.contains("OsType") {
                self.osType = dict["OsType"] as! String
            }
            if dict.keys.contains("PayType") {
                self.payType = dict["PayType"] as! String
            }
            if dict.keys.contains("ProductType") {
                self.productType = dict["ProductType"] as! String
            }
            if dict.keys.contains("ProtocolType") {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ResourceGroupName") {
                self.resourceGroupName = dict["ResourceGroupName"] as! String
            }
            if dict.keys.contains("ResourceGroupRelCount") {
                self.resourceGroupRelCount = dict["ResourceGroupRelCount"] as! Int32
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceName") {
                self.resourceName = dict["ResourceName"] as! String
            }
            if dict.keys.contains("ResourceRegionId") {
                self.resourceRegionId = dict["ResourceRegionId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var count: String?

    public var nextToken: String?

    public var requestId: String?

    public var resourceModelList: [DescribeResourceByCenterPolicyIdResponseBody.ResourceModelList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceModelList != nil {
            var tmp : [Any] = []
            for k in self.resourceModelList! {
                tmp.append(k.toMap())
            }
            map["ResourceModelList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceModelList") {
            var tmp : [DescribeResourceByCenterPolicyIdResponseBody.ResourceModelList] = []
            for v in dict["ResourceModelList"] as! [Any] {
                var model = DescribeResourceByCenterPolicyIdResponseBody.ResourceModelList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceModelList = tmp
        }
    }
}

public class DescribeResourceByCenterPolicyIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourceByCenterPolicyIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeResourceByCenterPolicyIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSessionStatisticRequest : Tea.TeaModel {
    public var endTime: String?

    public var officeSiteId: String?

    public var period: Int32?

    public var regionId: String?

    public var searchRegionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.searchRegionId != nil {
            map["SearchRegionId"] = self.searchRegionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SearchRegionId") {
            self.searchRegionId = dict["SearchRegionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeSessionStatisticResponseBody : Tea.TeaModel {
    public class Statistic : Tea.TeaModel {
        public var count: Int64?

        public var timePoint: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.timePoint != nil {
                map["TimePoint"] = self.timePoint!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int64
            }
            if dict.keys.contains("TimePoint") {
                self.timePoint = dict["TimePoint"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var statistic: [DescribeSessionStatisticResponseBody.Statistic]?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistic != nil {
            var tmp : [Any] = []
            for k in self.statistic! {
                tmp.append(k.toMap())
            }
            map["Statistic"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistic") {
            var tmp : [DescribeSessionStatisticResponseBody.Statistic] = []
            for v in dict["Statistic"] as! [Any] {
                var model = DescribeSessionStatisticResponseBody.Statistic()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.statistic = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class DescribeSessionStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSessionStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSessionStatisticResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSnapshotsRequest : Tea.TeaModel {
    public var creator: String?

    public var desktopId: String?

    public var desktopName: String?

    public var endTime: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var osType: String?

    public var regionId: String?

    public var snapshotId: String?

    public var snapshotName: String?

    public var snapshotType: String?

    public var sourceDiskType: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.desktopName != nil {
            map["DesktopName"] = self.desktopName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.osType != nil {
            map["OsType"] = self.osType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.snapshotName != nil {
            map["SnapshotName"] = self.snapshotName!
        }
        if self.snapshotType != nil {
            map["SnapshotType"] = self.snapshotType!
        }
        if self.sourceDiskType != nil {
            map["SourceDiskType"] = self.sourceDiskType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Creator") {
            self.creator = dict["Creator"] as! String
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("DesktopName") {
            self.desktopName = dict["DesktopName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OsType") {
            self.osType = dict["OsType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("SnapshotName") {
            self.snapshotName = dict["SnapshotName"] as! String
        }
        if dict.keys.contains("SnapshotType") {
            self.snapshotType = dict["SnapshotType"] as! String
        }
        if dict.keys.contains("SourceDiskType") {
            self.sourceDiskType = dict["SourceDiskType"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeSnapshotsResponseBody : Tea.TeaModel {
    public class Snapshots : Tea.TeaModel {
        public var creationTime: String?

        public var creator: String?

        public var deletionTime: String?

        public var description_: String?

        public var desktopId: String?

        public var desktopName: String?

        public var desktopStatus: String?

        public var diskStatus: String?

        public var osType: String?

        public var progress: String?

        public var protocolType: String?

        public var remainTime: Int32?

        public var restorePointId: String?

        public var restorePointName: String?

        public var snapshotId: String?

        public var snapshotName: String?

        public var snapshotType: String?

        public var sourceDiskSize: String?

        public var sourceDiskType: String?

        public var status: String?

        public var volumeEncryptionEnabled: Bool?

        public var volumeEncryptionKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.deletionTime != nil {
                map["DeletionTime"] = self.deletionTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.desktopName != nil {
                map["DesktopName"] = self.desktopName!
            }
            if self.desktopStatus != nil {
                map["DesktopStatus"] = self.desktopStatus!
            }
            if self.diskStatus != nil {
                map["DiskStatus"] = self.diskStatus!
            }
            if self.osType != nil {
                map["OsType"] = self.osType!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.remainTime != nil {
                map["RemainTime"] = self.remainTime!
            }
            if self.restorePointId != nil {
                map["RestorePointId"] = self.restorePointId!
            }
            if self.restorePointName != nil {
                map["RestorePointName"] = self.restorePointName!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            if self.snapshotName != nil {
                map["SnapshotName"] = self.snapshotName!
            }
            if self.snapshotType != nil {
                map["SnapshotType"] = self.snapshotType!
            }
            if self.sourceDiskSize != nil {
                map["SourceDiskSize"] = self.sourceDiskSize!
            }
            if self.sourceDiskType != nil {
                map["SourceDiskType"] = self.sourceDiskType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.volumeEncryptionEnabled != nil {
                map["VolumeEncryptionEnabled"] = self.volumeEncryptionEnabled!
            }
            if self.volumeEncryptionKey != nil {
                map["VolumeEncryptionKey"] = self.volumeEncryptionKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("DeletionTime") {
                self.deletionTime = dict["DeletionTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("DesktopName") {
                self.desktopName = dict["DesktopName"] as! String
            }
            if dict.keys.contains("DesktopStatus") {
                self.desktopStatus = dict["DesktopStatus"] as! String
            }
            if dict.keys.contains("DiskStatus") {
                self.diskStatus = dict["DiskStatus"] as! String
            }
            if dict.keys.contains("OsType") {
                self.osType = dict["OsType"] as! String
            }
            if dict.keys.contains("Progress") {
                self.progress = dict["Progress"] as! String
            }
            if dict.keys.contains("ProtocolType") {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("RemainTime") {
                self.remainTime = dict["RemainTime"] as! Int32
            }
            if dict.keys.contains("RestorePointId") {
                self.restorePointId = dict["RestorePointId"] as! String
            }
            if dict.keys.contains("RestorePointName") {
                self.restorePointName = dict["RestorePointName"] as! String
            }
            if dict.keys.contains("SnapshotId") {
                self.snapshotId = dict["SnapshotId"] as! String
            }
            if dict.keys.contains("SnapshotName") {
                self.snapshotName = dict["SnapshotName"] as! String
            }
            if dict.keys.contains("SnapshotType") {
                self.snapshotType = dict["SnapshotType"] as! String
            }
            if dict.keys.contains("SourceDiskSize") {
                self.sourceDiskSize = dict["SourceDiskSize"] as! String
            }
            if dict.keys.contains("SourceDiskType") {
                self.sourceDiskType = dict["SourceDiskType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("VolumeEncryptionEnabled") {
                self.volumeEncryptionEnabled = dict["VolumeEncryptionEnabled"] as! Bool
            }
            if dict.keys.contains("VolumeEncryptionKey") {
                self.volumeEncryptionKey = dict["VolumeEncryptionKey"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var snapshots: [DescribeSnapshotsResponseBody.Snapshots]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshots != nil {
            var tmp : [Any] = []
            for k in self.snapshots! {
                tmp.append(k.toMap())
            }
            map["Snapshots"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Snapshots") {
            var tmp : [DescribeSnapshotsResponseBody.Snapshots] = []
            for v in dict["Snapshots"] as! [Any] {
                var model = DescribeSnapshotsResponseBody.Snapshots()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.snapshots = tmp
        }
    }
}

public class DescribeSnapshotsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSnapshotsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTimerGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeTimerGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ConfigTimers : Tea.TeaModel {
            public var allowClientSetting: Bool?

            public var cronExpression: String?

            public var enforce: Bool?

            public var interval: Int32?

            public var notificationTime: Int32?

            public var operationType: String?

            public var processWhitelist: [String]?

            public var resetType: String?

            public var timerType: String?

            public var triggerType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowClientSetting != nil {
                    map["AllowClientSetting"] = self.allowClientSetting!
                }
                if self.cronExpression != nil {
                    map["CronExpression"] = self.cronExpression!
                }
                if self.enforce != nil {
                    map["Enforce"] = self.enforce!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.notificationTime != nil {
                    map["NotificationTime"] = self.notificationTime!
                }
                if self.operationType != nil {
                    map["OperationType"] = self.operationType!
                }
                if self.processWhitelist != nil {
                    map["ProcessWhitelist"] = self.processWhitelist!
                }
                if self.resetType != nil {
                    map["ResetType"] = self.resetType!
                }
                if self.timerType != nil {
                    map["TimerType"] = self.timerType!
                }
                if self.triggerType != nil {
                    map["TriggerType"] = self.triggerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllowClientSetting") {
                    self.allowClientSetting = dict["AllowClientSetting"] as! Bool
                }
                if dict.keys.contains("CronExpression") {
                    self.cronExpression = dict["CronExpression"] as! String
                }
                if dict.keys.contains("Enforce") {
                    self.enforce = dict["Enforce"] as! Bool
                }
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int32
                }
                if dict.keys.contains("NotificationTime") {
                    self.notificationTime = dict["NotificationTime"] as! Int32
                }
                if dict.keys.contains("OperationType") {
                    self.operationType = dict["OperationType"] as! String
                }
                if dict.keys.contains("ProcessWhitelist") {
                    self.processWhitelist = dict["ProcessWhitelist"] as! [String]
                }
                if dict.keys.contains("ResetType") {
                    self.resetType = dict["ResetType"] as! String
                }
                if dict.keys.contains("TimerType") {
                    self.timerType = dict["TimerType"] as! String
                }
                if dict.keys.contains("TriggerType") {
                    self.triggerType = dict["TriggerType"] as! String
                }
            }
        }
        public var bindCount: Int32?

        public var bindCountMap: [String: Int32]?

        public var configTimers: [DescribeTimerGroupResponseBody.Data.ConfigTimers]?

        public var description_: String?

        public var groupId: String?

        public var name: String?

        public var productType: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bindCount != nil {
                map["BindCount"] = self.bindCount!
            }
            if self.bindCountMap != nil {
                map["BindCountMap"] = self.bindCountMap!
            }
            if self.configTimers != nil {
                var tmp : [Any] = []
                for k in self.configTimers! {
                    tmp.append(k.toMap())
                }
                map["ConfigTimers"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.productType != nil {
                map["ProductType"] = self.productType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BindCount") {
                self.bindCount = dict["BindCount"] as! Int32
            }
            if dict.keys.contains("BindCountMap") {
                self.bindCountMap = dict["BindCountMap"] as! [String: Int32]
            }
            if dict.keys.contains("ConfigTimers") {
                var tmp : [DescribeTimerGroupResponseBody.Data.ConfigTimers] = []
                for v in dict["ConfigTimers"] as! [Any] {
                    var model = DescribeTimerGroupResponseBody.Data.ConfigTimers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configTimers = tmp
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ProductType") {
                self.productType = dict["ProductType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var data: DescribeTimerGroupResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeTimerGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeTimerGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTimerGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTimerGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUserConnectTimeRequest : Tea.TeaModel {
    public var endTime: String?

    public var endUserId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var oversoldGroupId: String?

    public var startTime: String?

    public var userDesktopId: String?

    public var userGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.oversoldGroupId != nil {
            map["OversoldGroupId"] = self.oversoldGroupId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.userDesktopId != nil {
            map["UserDesktopId"] = self.userDesktopId!
        }
        if self.userGroupId != nil {
            map["UserGroupId"] = self.userGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OversoldGroupId") {
            self.oversoldGroupId = dict["OversoldGroupId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("UserDesktopId") {
            self.userDesktopId = dict["UserDesktopId"] as! String
        }
        if dict.keys.contains("UserGroupId") {
            self.userGroupId = dict["UserGroupId"] as! String
        }
    }
}

public class DescribeUserConnectTimeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var endConnectTime: String?

        public var endUserId: String?

        public var oversoldGroupId: String?

        public var startConnectTime: String?

        public var userDesktopId: String?

        public var userGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endConnectTime != nil {
                map["EndConnectTime"] = self.endConnectTime!
            }
            if self.endUserId != nil {
                map["EndUserId"] = self.endUserId!
            }
            if self.oversoldGroupId != nil {
                map["OversoldGroupId"] = self.oversoldGroupId!
            }
            if self.startConnectTime != nil {
                map["StartConnectTime"] = self.startConnectTime!
            }
            if self.userDesktopId != nil {
                map["UserDesktopId"] = self.userDesktopId!
            }
            if self.userGroupId != nil {
                map["UserGroupId"] = self.userGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndConnectTime") {
                self.endConnectTime = dict["EndConnectTime"] as! String
            }
            if dict.keys.contains("EndUserId") {
                self.endUserId = dict["EndUserId"] as! String
            }
            if dict.keys.contains("OversoldGroupId") {
                self.oversoldGroupId = dict["OversoldGroupId"] as! String
            }
            if dict.keys.contains("StartConnectTime") {
                self.startConnectTime = dict["StartConnectTime"] as! String
            }
            if dict.keys.contains("UserDesktopId") {
                self.userDesktopId = dict["UserDesktopId"] as! String
            }
            if dict.keys.contains("UserGroupId") {
                self.userGroupId = dict["UserGroupId"] as! String
            }
        }
    }
    public var count: Int32?

    public var data: [DescribeUserConnectTimeResponseBody.Data]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [DescribeUserConnectTimeResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeUserConnectTimeResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeUserConnectTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUserConnectTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUserConnectTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUserConnectionRecordsRequest : Tea.TeaModel {
    public var connectDurationFrom: Int64?

    public var connectDurationTo: Int64?

    public var connectEndTimeFrom: Int64?

    public var connectEndTimeTo: Int64?

    public var connectStartTimeFrom: Int64?

    public var connectStartTimeTo: Int64?

    public var desktopGroupId: String?

    public var desktopId: String?

    public var endUserId: String?

    public var endUserType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectDurationFrom != nil {
            map["ConnectDurationFrom"] = self.connectDurationFrom!
        }
        if self.connectDurationTo != nil {
            map["ConnectDurationTo"] = self.connectDurationTo!
        }
        if self.connectEndTimeFrom != nil {
            map["ConnectEndTimeFrom"] = self.connectEndTimeFrom!
        }
        if self.connectEndTimeTo != nil {
            map["ConnectEndTimeTo"] = self.connectEndTimeTo!
        }
        if self.connectStartTimeFrom != nil {
            map["ConnectStartTimeFrom"] = self.connectStartTimeFrom!
        }
        if self.connectStartTimeTo != nil {
            map["ConnectStartTimeTo"] = self.connectStartTimeTo!
        }
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.endUserType != nil {
            map["EndUserType"] = self.endUserType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConnectDurationFrom") {
            self.connectDurationFrom = dict["ConnectDurationFrom"] as! Int64
        }
        if dict.keys.contains("ConnectDurationTo") {
            self.connectDurationTo = dict["ConnectDurationTo"] as! Int64
        }
        if dict.keys.contains("ConnectEndTimeFrom") {
            self.connectEndTimeFrom = dict["ConnectEndTimeFrom"] as! Int64
        }
        if dict.keys.contains("ConnectEndTimeTo") {
            self.connectEndTimeTo = dict["ConnectEndTimeTo"] as! Int64
        }
        if dict.keys.contains("ConnectStartTimeFrom") {
            self.connectStartTimeFrom = dict["ConnectStartTimeFrom"] as! Int64
        }
        if dict.keys.contains("ConnectStartTimeTo") {
            self.connectStartTimeTo = dict["ConnectStartTimeTo"] as! Int64
        }
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("EndUserType") {
            self.endUserType = dict["EndUserType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeUserConnectionRecordsResponseBody : Tea.TeaModel {
    public class ConnectionRecords : Tea.TeaModel {
        public var connectDuration: String?

        public var connectEndTime: String?

        public var connectStartTime: String?

        public var connectionRecordId: String?

        public var desktopId: String?

        public var desktopName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectDuration != nil {
                map["ConnectDuration"] = self.connectDuration!
            }
            if self.connectEndTime != nil {
                map["ConnectEndTime"] = self.connectEndTime!
            }
            if self.connectStartTime != nil {
                map["ConnectStartTime"] = self.connectStartTime!
            }
            if self.connectionRecordId != nil {
                map["ConnectionRecordId"] = self.connectionRecordId!
            }
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.desktopName != nil {
                map["DesktopName"] = self.desktopName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConnectDuration") {
                self.connectDuration = dict["ConnectDuration"] as! String
            }
            if dict.keys.contains("ConnectEndTime") {
                self.connectEndTime = dict["ConnectEndTime"] as! String
            }
            if dict.keys.contains("ConnectStartTime") {
                self.connectStartTime = dict["ConnectStartTime"] as! String
            }
            if dict.keys.contains("ConnectionRecordId") {
                self.connectionRecordId = dict["ConnectionRecordId"] as! String
            }
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("DesktopName") {
                self.desktopName = dict["DesktopName"] as! String
            }
        }
    }
    public var connectionRecords: [DescribeUserConnectionRecordsResponseBody.ConnectionRecords]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionRecords != nil {
            var tmp : [Any] = []
            for k in self.connectionRecords! {
                tmp.append(k.toMap())
            }
            map["ConnectionRecords"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConnectionRecords") {
            var tmp : [DescribeUserConnectionRecordsResponseBody.ConnectionRecords] = []
            for v in dict["ConnectionRecords"] as! [Any] {
                var model = DescribeUserConnectionRecordsResponseBody.ConnectionRecords()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.connectionRecords = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeUserConnectionRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUserConnectionRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUserConnectionRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUserProfilePathRulesRequest : Tea.TeaModel {
    public var desktopGroupId: String?

    public var regionId: String?

    public var ruleType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleType") {
            self.ruleType = dict["RuleType"] as! String
        }
    }
}

public class DescribeUserProfilePathRulesResponseBody : Tea.TeaModel {
    public class UserProfilePathRule : Tea.TeaModel {
        public class Rules : Tea.TeaModel {
            public class BlackPath : Tea.TeaModel {
                public var path: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class WhitePaths : Tea.TeaModel {
                public var path: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var blackPath: DescribeUserProfilePathRulesResponseBody.UserProfilePathRule.Rules.BlackPath?

            public var whitePaths: [DescribeUserProfilePathRulesResponseBody.UserProfilePathRule.Rules.WhitePaths]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.blackPath?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blackPath != nil {
                    map["BlackPath"] = self.blackPath?.toMap()
                }
                if self.whitePaths != nil {
                    var tmp : [Any] = []
                    for k in self.whitePaths! {
                        tmp.append(k.toMap())
                    }
                    map["WhitePaths"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BlackPath") {
                    var model = DescribeUserProfilePathRulesResponseBody.UserProfilePathRule.Rules.BlackPath()
                    model.fromMap(dict["BlackPath"] as! [String: Any])
                    self.blackPath = model
                }
                if dict.keys.contains("WhitePaths") {
                    var tmp : [DescribeUserProfilePathRulesResponseBody.UserProfilePathRule.Rules.WhitePaths] = []
                    for v in dict["WhitePaths"] as! [Any] {
                        var model = DescribeUserProfilePathRulesResponseBody.UserProfilePathRule.Rules.WhitePaths()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.whitePaths = tmp
                }
            }
        }
        public var desktopGroupId: String?

        public var rules: [DescribeUserProfilePathRulesResponseBody.UserProfilePathRule.Rules]?

        public var userProfileRuleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desktopGroupId != nil {
                map["DesktopGroupId"] = self.desktopGroupId!
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            if self.userProfileRuleType != nil {
                map["UserProfileRuleType"] = self.userProfileRuleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DesktopGroupId") {
                self.desktopGroupId = dict["DesktopGroupId"] as! String
            }
            if dict.keys.contains("Rules") {
                var tmp : [DescribeUserProfilePathRulesResponseBody.UserProfilePathRule.Rules] = []
                for v in dict["Rules"] as! [Any] {
                    var model = DescribeUserProfilePathRulesResponseBody.UserProfilePathRule.Rules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.rules = tmp
            }
            if dict.keys.contains("UserProfileRuleType") {
                self.userProfileRuleType = dict["UserProfileRuleType"] as! String
            }
        }
    }
    public var requestId: String?

    public var userProfilePathRule: DescribeUserProfilePathRulesResponseBody.UserProfilePathRule?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userProfilePathRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userProfilePathRule != nil {
            map["UserProfilePathRule"] = self.userProfilePathRule?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserProfilePathRule") {
            var model = DescribeUserProfilePathRulesResponseBody.UserProfilePathRule()
            model.fromMap(dict["UserProfilePathRule"] as! [String: Any])
            self.userProfilePathRule = model
        }
    }
}

public class DescribeUserProfilePathRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUserProfilePathRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUserProfilePathRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUsersInGroupRequest : Tea.TeaModel {
    public var connectState: Int32?

    public var desktopGroupId: String?

    public var endUserId: String?

    public var endUserIds: [String]?

    public var filter: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orgId: String?

    public var queryUserDetail: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectState != nil {
            map["ConnectState"] = self.connectState!
        }
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.endUserIds != nil {
            map["EndUserIds"] = self.endUserIds!
        }
        if self.filter != nil {
            map["Filter"] = self.filter!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orgId != nil {
            map["OrgId"] = self.orgId!
        }
        if self.queryUserDetail != nil {
            map["QueryUserDetail"] = self.queryUserDetail!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConnectState") {
            self.connectState = dict["ConnectState"] as! Int32
        }
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("EndUserIds") {
            self.endUserIds = dict["EndUserIds"] as! [String]
        }
        if dict.keys.contains("Filter") {
            self.filter = dict["Filter"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrgId") {
            self.orgId = dict["OrgId"] as! String
        }
        if dict.keys.contains("QueryUserDetail") {
            self.queryUserDetail = dict["QueryUserDetail"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeUsersInGroupResponseBody : Tea.TeaModel {
    public class EndUsers : Tea.TeaModel {
        public class ExternalInfo : Tea.TeaModel {
            public var externalName: String?

            public var jobNumber: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.externalName != nil {
                    map["ExternalName"] = self.externalName!
                }
                if self.jobNumber != nil {
                    map["JobNumber"] = self.jobNumber!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ExternalName") {
                    self.externalName = dict["ExternalName"] as! String
                }
                if dict.keys.contains("JobNumber") {
                    self.jobNumber = dict["JobNumber"] as! String
                }
            }
        }
        public class UserSetPropertiesModels : Tea.TeaModel {
            public class PropertyValues : Tea.TeaModel {
                public var propertyValue: String?

                public var propertyValueId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.propertyValue != nil {
                        map["PropertyValue"] = self.propertyValue!
                    }
                    if self.propertyValueId != nil {
                        map["PropertyValueId"] = self.propertyValueId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PropertyValue") {
                        self.propertyValue = dict["PropertyValue"] as! String
                    }
                    if dict.keys.contains("PropertyValueId") {
                        self.propertyValueId = dict["PropertyValueId"] as! Int64
                    }
                }
            }
            public var propertyId: Int64?

            public var propertyKey: String?

            public var propertyType: Int32?

            public var propertyValues: [DescribeUsersInGroupResponseBody.EndUsers.UserSetPropertiesModels.PropertyValues]?

            public var userId: Int64?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.propertyId != nil {
                    map["PropertyId"] = self.propertyId!
                }
                if self.propertyKey != nil {
                    map["PropertyKey"] = self.propertyKey!
                }
                if self.propertyType != nil {
                    map["PropertyType"] = self.propertyType!
                }
                if self.propertyValues != nil {
                    var tmp : [Any] = []
                    for k in self.propertyValues! {
                        tmp.append(k.toMap())
                    }
                    map["PropertyValues"] = tmp
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PropertyId") {
                    self.propertyId = dict["PropertyId"] as! Int64
                }
                if dict.keys.contains("PropertyKey") {
                    self.propertyKey = dict["PropertyKey"] as! String
                }
                if dict.keys.contains("PropertyType") {
                    self.propertyType = dict["PropertyType"] as! Int32
                }
                if dict.keys.contains("PropertyValues") {
                    var tmp : [DescribeUsersInGroupResponseBody.EndUsers.UserSetPropertiesModels.PropertyValues] = []
                    for v in dict["PropertyValues"] as! [Any] {
                        var model = DescribeUsersInGroupResponseBody.EndUsers.UserSetPropertiesModels.PropertyValues()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.propertyValues = tmp
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! Int64
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public var connectionStatus: String?

        public var desktopId: String?

        public var desktopName: String?

        public var displayName: String?

        public var displayNameNew: String?

        public var endUserEmail: String?

        public var endUserId: String?

        public var endUserName: String?

        public var endUserPhone: String?

        public var endUserRemark: String?

        public var endUserType: String?

        public var externalInfo: DescribeUsersInGroupResponseBody.EndUsers.ExternalInfo?

        public var userDesktopId: String?

        public var userPrincipalName: String?

        public var userSetPropertiesModels: [DescribeUsersInGroupResponseBody.EndUsers.UserSetPropertiesModels]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.externalInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectionStatus != nil {
                map["ConnectionStatus"] = self.connectionStatus!
            }
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.desktopName != nil {
                map["DesktopName"] = self.desktopName!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.displayNameNew != nil {
                map["DisplayNameNew"] = self.displayNameNew!
            }
            if self.endUserEmail != nil {
                map["EndUserEmail"] = self.endUserEmail!
            }
            if self.endUserId != nil {
                map["EndUserId"] = self.endUserId!
            }
            if self.endUserName != nil {
                map["EndUserName"] = self.endUserName!
            }
            if self.endUserPhone != nil {
                map["EndUserPhone"] = self.endUserPhone!
            }
            if self.endUserRemark != nil {
                map["EndUserRemark"] = self.endUserRemark!
            }
            if self.endUserType != nil {
                map["EndUserType"] = self.endUserType!
            }
            if self.externalInfo != nil {
                map["ExternalInfo"] = self.externalInfo?.toMap()
            }
            if self.userDesktopId != nil {
                map["UserDesktopId"] = self.userDesktopId!
            }
            if self.userPrincipalName != nil {
                map["UserPrincipalName"] = self.userPrincipalName!
            }
            if self.userSetPropertiesModels != nil {
                var tmp : [Any] = []
                for k in self.userSetPropertiesModels! {
                    tmp.append(k.toMap())
                }
                map["UserSetPropertiesModels"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConnectionStatus") {
                self.connectionStatus = dict["ConnectionStatus"] as! String
            }
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("DesktopName") {
                self.desktopName = dict["DesktopName"] as! String
            }
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("DisplayNameNew") {
                self.displayNameNew = dict["DisplayNameNew"] as! String
            }
            if dict.keys.contains("EndUserEmail") {
                self.endUserEmail = dict["EndUserEmail"] as! String
            }
            if dict.keys.contains("EndUserId") {
                self.endUserId = dict["EndUserId"] as! String
            }
            if dict.keys.contains("EndUserName") {
                self.endUserName = dict["EndUserName"] as! String
            }
            if dict.keys.contains("EndUserPhone") {
                self.endUserPhone = dict["EndUserPhone"] as! String
            }
            if dict.keys.contains("EndUserRemark") {
                self.endUserRemark = dict["EndUserRemark"] as! String
            }
            if dict.keys.contains("EndUserType") {
                self.endUserType = dict["EndUserType"] as! String
            }
            if dict.keys.contains("ExternalInfo") {
                var model = DescribeUsersInGroupResponseBody.EndUsers.ExternalInfo()
                model.fromMap(dict["ExternalInfo"] as! [String: Any])
                self.externalInfo = model
            }
            if dict.keys.contains("UserDesktopId") {
                self.userDesktopId = dict["UserDesktopId"] as! String
            }
            if dict.keys.contains("UserPrincipalName") {
                self.userPrincipalName = dict["UserPrincipalName"] as! String
            }
            if dict.keys.contains("UserSetPropertiesModels") {
                var tmp : [DescribeUsersInGroupResponseBody.EndUsers.UserSetPropertiesModels] = []
                for v in dict["UserSetPropertiesModels"] as! [Any] {
                    var model = DescribeUsersInGroupResponseBody.EndUsers.UserSetPropertiesModels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.userSetPropertiesModels = tmp
            }
        }
    }
    public var endUsers: [DescribeUsersInGroupResponseBody.EndUsers]?

    public var nextToken: String?

    public var onlineUsersCount: Int32?

    public var requestId: String?

    public var userOuPath: String?

    public var usersCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endUsers != nil {
            var tmp : [Any] = []
            for k in self.endUsers! {
                tmp.append(k.toMap())
            }
            map["EndUsers"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.onlineUsersCount != nil {
            map["OnlineUsersCount"] = self.onlineUsersCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userOuPath != nil {
            map["UserOuPath"] = self.userOuPath!
        }
        if self.usersCount != nil {
            map["UsersCount"] = self.usersCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndUsers") {
            var tmp : [DescribeUsersInGroupResponseBody.EndUsers] = []
            for v in dict["EndUsers"] as! [Any] {
                var model = DescribeUsersInGroupResponseBody.EndUsers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endUsers = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OnlineUsersCount") {
            self.onlineUsersCount = dict["OnlineUsersCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserOuPath") {
            self.userOuPath = dict["UserOuPath"] as! String
        }
        if dict.keys.contains("UsersCount") {
            self.usersCount = dict["UsersCount"] as! Int32
        }
    }
}

public class DescribeUsersInGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUsersInGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUsersInGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUsersPasswordRequest : Tea.TeaModel {
    public var desktopId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeUsersPasswordResponseBody : Tea.TeaModel {
    public class DesktopUsers : Tea.TeaModel {
        public var displayName: String?

        public var endUserId: String?

        public var password: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.endUserId != nil {
                map["EndUserId"] = self.endUserId!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("EndUserId") {
                self.endUserId = dict["EndUserId"] as! String
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
        }
    }
    public var desktopUsers: [DescribeUsersPasswordResponseBody.DesktopUsers]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopUsers != nil {
            var tmp : [Any] = []
            for k in self.desktopUsers! {
                tmp.append(k.toMap())
            }
            map["DesktopUsers"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopUsers") {
            var tmp : [DescribeUsersPasswordResponseBody.DesktopUsers] = []
            for v in dict["DesktopUsers"] as! [Any] {
                var model = DescribeUsersPasswordResponseBody.DesktopUsers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.desktopUsers = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeUsersPasswordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUsersPasswordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUsersPasswordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVirtualMFADevicesRequest : Tea.TeaModel {
    public var endUserId: [String]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var officeSiteId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! [String]
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeVirtualMFADevicesResponseBody : Tea.TeaModel {
    public class VirtualMFADevices : Tea.TeaModel {
        public var consecutiveFails: Int32?

        public var directoryId: String?

        public var endUserId: String?

        public var gmtEnabled: String?

        public var gmtUnlock: String?

        public var officeSiteId: String?

        public var serialNumber: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consecutiveFails != nil {
                map["ConsecutiveFails"] = self.consecutiveFails!
            }
            if self.directoryId != nil {
                map["DirectoryId"] = self.directoryId!
            }
            if self.endUserId != nil {
                map["EndUserId"] = self.endUserId!
            }
            if self.gmtEnabled != nil {
                map["GmtEnabled"] = self.gmtEnabled!
            }
            if self.gmtUnlock != nil {
                map["GmtUnlock"] = self.gmtUnlock!
            }
            if self.officeSiteId != nil {
                map["OfficeSiteId"] = self.officeSiteId!
            }
            if self.serialNumber != nil {
                map["SerialNumber"] = self.serialNumber!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsecutiveFails") {
                self.consecutiveFails = dict["ConsecutiveFails"] as! Int32
            }
            if dict.keys.contains("DirectoryId") {
                self.directoryId = dict["DirectoryId"] as! String
            }
            if dict.keys.contains("EndUserId") {
                self.endUserId = dict["EndUserId"] as! String
            }
            if dict.keys.contains("GmtEnabled") {
                self.gmtEnabled = dict["GmtEnabled"] as! String
            }
            if dict.keys.contains("GmtUnlock") {
                self.gmtUnlock = dict["GmtUnlock"] as! String
            }
            if dict.keys.contains("OfficeSiteId") {
                self.officeSiteId = dict["OfficeSiteId"] as! String
            }
            if dict.keys.contains("SerialNumber") {
                self.serialNumber = dict["SerialNumber"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var virtualMFADevices: [DescribeVirtualMFADevicesResponseBody.VirtualMFADevices]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.virtualMFADevices != nil {
            var tmp : [Any] = []
            for k in self.virtualMFADevices! {
                tmp.append(k.toMap())
            }
            map["VirtualMFADevices"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VirtualMFADevices") {
            var tmp : [DescribeVirtualMFADevicesResponseBody.VirtualMFADevices] = []
            for v in dict["VirtualMFADevices"] as! [Any] {
                var model = DescribeVirtualMFADevicesResponseBody.VirtualMFADevices()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.virtualMFADevices = tmp
        }
    }
}

public class DescribeVirtualMFADevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVirtualMFADevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVirtualMFADevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeZonesRequest : Tea.TeaModel {
    public var regionId: String?

    public var zoneType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.zoneType != nil {
            map["ZoneType"] = self.zoneType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ZoneType") {
            self.zoneType = dict["ZoneType"] as! String
        }
    }
}

public class DescribeZonesResponseBody : Tea.TeaModel {
    public class Zones : Tea.TeaModel {
        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var requestId: String?

    public var zones: [DescribeZonesResponseBody.Zones]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.zones != nil {
            var tmp : [Any] = []
            for k in self.zones! {
                tmp.append(k.toMap())
            }
            map["Zones"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Zones") {
            var tmp : [DescribeZonesResponseBody.Zones] = []
            for v in dict["Zones"] as! [Any] {
                var model = DescribeZonesResponseBody.Zones()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.zones = tmp
        }
    }
}

public class DescribeZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeZonesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachCenRequest : Tea.TeaModel {
    public var officeSiteId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DetachCenResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachCenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachCenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachCenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachEndUserRequest : Tea.TeaModel {
    public var adDomain: String?

    public var clientType: String?

    public var deviceId: String?

    public var directoryId: String?

    public var endUserId: String?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adDomain != nil {
            map["AdDomain"] = self.adDomain!
        }
        if self.clientType != nil {
            map["ClientType"] = self.clientType!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdDomain") {
            self.adDomain = dict["AdDomain"] as! String
        }
        if dict.keys.contains("ClientType") {
            self.clientType = dict["ClientType"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
    }
}

public class DetachEndUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachEndUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachEndUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachEndUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableDesktopsInGroupRequest : Tea.TeaModel {
    public var desktopGroupId: String?

    public var desktopIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.desktopIds != nil {
            map["DesktopIds"] = self.desktopIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("DesktopIds") {
            self.desktopIds = dict["DesktopIds"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DisableDesktopsInGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableDesktopsInGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableDesktopsInGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableDesktopsInGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisconnectDesktopSessionsRequest : Tea.TeaModel {
    public class Sessions : Tea.TeaModel {
        public var desktopId: String?

        public var endUserId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.endUserId != nil {
                map["EndUserId"] = self.endUserId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("EndUserId") {
                self.endUserId = dict["EndUserId"] as! String
            }
        }
    }
    public var preCheck: Bool?

    public var regionId: String?

    public var sessions: [DisconnectDesktopSessionsRequest.Sessions]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.preCheck != nil {
            map["PreCheck"] = self.preCheck!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sessions != nil {
            var tmp : [Any] = []
            for k in self.sessions! {
                tmp.append(k.toMap())
            }
            map["Sessions"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PreCheck") {
            self.preCheck = dict["PreCheck"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Sessions") {
            var tmp : [DisconnectDesktopSessionsRequest.Sessions] = []
            for v in dict["Sessions"] as! [Any] {
                var model = DisconnectDesktopSessionsRequest.Sessions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sessions = tmp
        }
    }
}

public class DisconnectDesktopSessionsResponseBody : Tea.TeaModel {
    public class InvalidSessions : Tea.TeaModel {
        public var desktopId: String?

        public var endUserId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.endUserId != nil {
                map["EndUserId"] = self.endUserId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("EndUserId") {
                self.endUserId = dict["EndUserId"] as! String
            }
        }
    }
    public var invalidSessions: [DisconnectDesktopSessionsResponseBody.InvalidSessions]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.invalidSessions != nil {
            var tmp : [Any] = []
            for k in self.invalidSessions! {
                tmp.append(k.toMap())
            }
            map["InvalidSessions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InvalidSessions") {
            var tmp : [DisconnectDesktopSessionsResponseBody.InvalidSessions] = []
            for v in dict["InvalidSessions"] as! [Any] {
                var model = DisconnectDesktopSessionsResponseBody.InvalidSessions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.invalidSessions = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisconnectDesktopSessionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisconnectDesktopSessionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisconnectDesktopSessionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DissociateNetworkPackageRequest : Tea.TeaModel {
    public var networkPackageId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkPackageId != nil {
            map["NetworkPackageId"] = self.networkPackageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkPackageId") {
            self.networkPackageId = dict["NetworkPackageId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DissociateNetworkPackageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DissociateNetworkPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DissociateNetworkPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DissociateNetworkPackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DownloadCdsFileRequest : Tea.TeaModel {
    public var cdsId: String?

    public var endUserId: String?

    public var fileId: String?

    public var groupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DownloadCdsFileResponseBody : Tea.TeaModel {
    public class DownloadFileModel : Tea.TeaModel {
        public var downloadType: String?

        public var downloadUrl: String?

        public var expirationSecond: String?

        public var expirationTime: String?

        public var fileId: String?

        public var size: Int64?

        public var streamUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadType != nil {
                map["DownloadType"] = self.downloadType!
            }
            if self.downloadUrl != nil {
                map["DownloadUrl"] = self.downloadUrl!
            }
            if self.expirationSecond != nil {
                map["ExpirationSecond"] = self.expirationSecond!
            }
            if self.expirationTime != nil {
                map["ExpirationTime"] = self.expirationTime!
            }
            if self.fileId != nil {
                map["FileId"] = self.fileId!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.streamUrl != nil {
                map["StreamUrl"] = self.streamUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DownloadType") {
                self.downloadType = dict["DownloadType"] as! String
            }
            if dict.keys.contains("DownloadUrl") {
                self.downloadUrl = dict["DownloadUrl"] as! String
            }
            if dict.keys.contains("ExpirationSecond") {
                self.expirationSecond = dict["ExpirationSecond"] as! String
            }
            if dict.keys.contains("ExpirationTime") {
                self.expirationTime = dict["ExpirationTime"] as! String
            }
            if dict.keys.contains("FileId") {
                self.fileId = dict["FileId"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("StreamUrl") {
                self.streamUrl = dict["StreamUrl"] as! String
            }
        }
    }
    public var downloadFileModel: DownloadCdsFileResponseBody.DownloadFileModel?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.downloadFileModel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadFileModel != nil {
            map["DownloadFileModel"] = self.downloadFileModel?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadFileModel") {
            var model = DownloadCdsFileResponseBody.DownloadFileModel()
            model.fromMap(dict["DownloadFileModel"] as! [String: Any])
            self.downloadFileModel = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DownloadCdsFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadCdsFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DownloadCdsFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportClientEventsRequest : Tea.TeaModel {
    public var desktopId: String?

    public var desktopName: String?

    public var endTime: String?

    public var endUserId: String?

    public var eventType: String?

    public var eventTypes: [String]?

    public var langType: String?

    public var maxResults: Int32?

    public var officeSiteId: String?

    public var officeSiteName: String?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.desktopName != nil {
            map["DesktopName"] = self.desktopName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.eventTypes != nil {
            map["EventTypes"] = self.eventTypes!
        }
        if self.langType != nil {
            map["LangType"] = self.langType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.officeSiteName != nil {
            map["OfficeSiteName"] = self.officeSiteName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("DesktopName") {
            self.desktopName = dict["DesktopName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("EventType") {
            self.eventType = dict["EventType"] as! String
        }
        if dict.keys.contains("EventTypes") {
            self.eventTypes = dict["EventTypes"] as! [String]
        }
        if dict.keys.contains("LangType") {
            self.langType = dict["LangType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("OfficeSiteName") {
            self.officeSiteName = dict["OfficeSiteName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ExportClientEventsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class ExportClientEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportClientEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportClientEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportDesktopGroupInfoRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var chargeType: String?

    public var desktopGroupId: [String]?

    public var desktopGroupName: String?

    public var endUserId: [String]?

    public var expiredTime: String?

    public var langType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var officeSiteId: String?

    public var policyGroupId: String?

    public var regionId: String?

    public var tag: [ExportDesktopGroupInfoRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.desktopGroupName != nil {
            map["DesktopGroupName"] = self.desktopGroupName!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.langType != nil {
            map["LangType"] = self.langType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! [String]
        }
        if dict.keys.contains("DesktopGroupName") {
            self.desktopGroupName = dict["DesktopGroupName"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! [String]
        }
        if dict.keys.contains("ExpiredTime") {
            self.expiredTime = dict["ExpiredTime"] as! String
        }
        if dict.keys.contains("LangType") {
            self.langType = dict["LangType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [ExportDesktopGroupInfoRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ExportDesktopGroupInfoRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ExportDesktopGroupInfoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class ExportDesktopGroupInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportDesktopGroupInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportDesktopGroupInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportDesktopListInfoRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var chargeType: String?

    public var desktopId: [String]?

    public var desktopName: String?

    public var desktopStatus: String?

    public var endUserId: [String]?

    public var expiredTime: String?

    public var groupId: String?

    public var langType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var officeSiteId: String?

    public var policyGroupId: String?

    public var regionId: String?

    public var tag: [ExportDesktopListInfoRequest.Tag]?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.desktopName != nil {
            map["DesktopName"] = self.desktopName!
        }
        if self.desktopStatus != nil {
            map["DesktopStatus"] = self.desktopStatus!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.langType != nil {
            map["LangType"] = self.langType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("DesktopName") {
            self.desktopName = dict["DesktopName"] as! String
        }
        if dict.keys.contains("DesktopStatus") {
            self.desktopStatus = dict["DesktopStatus"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! [String]
        }
        if dict.keys.contains("ExpiredTime") {
            self.expiredTime = dict["ExpiredTime"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("LangType") {
            self.langType = dict["LangType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [ExportDesktopListInfoRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ExportDesktopListInfoRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class ExportDesktopListInfoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class ExportDesktopListInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportDesktopListInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportDesktopListInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAsyncTaskRequest : Tea.TeaModel {
    public var asyncTaskId: String?

    public var cdsId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asyncTaskId != nil {
            map["AsyncTaskId"] = self.asyncTaskId!
        }
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AsyncTaskId") {
            self.asyncTaskId = dict["AsyncTaskId"] as! String
        }
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
    }
}

public class GetAsyncTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var asyncTaskId: String?

        public var consumedProcess: String?

        public var errCode: Int64?

        public var message: String?

        public var status: String?

        public var totalProcess: Int64?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.asyncTaskId != nil {
                map["AsyncTaskId"] = self.asyncTaskId!
            }
            if self.consumedProcess != nil {
                map["ConsumedProcess"] = self.consumedProcess!
            }
            if self.errCode != nil {
                map["ErrCode"] = self.errCode!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.totalProcess != nil {
                map["TotalProcess"] = self.totalProcess!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AsyncTaskId") {
                self.asyncTaskId = dict["AsyncTaskId"] as! String
            }
            if dict.keys.contains("ConsumedProcess") {
                self.consumedProcess = dict["ConsumedProcess"] as! String
            }
            if dict.keys.contains("ErrCode") {
                self.errCode = dict["ErrCode"] as! Int64
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TotalProcess") {
                self.totalProcess = dict["TotalProcess"] as! Int64
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetAsyncTaskResponseBody.Data?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetAsyncTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetAsyncTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAsyncTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAsyncTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetConnectionTicketRequest : Tea.TeaModel {
    public var commandContent: String?

    public var desktopId: String?

    public var endUserId: String?

    public var ownerId: Int64?

    public var password: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var taskId: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandContent != nil {
            map["CommandContent"] = self.commandContent!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandContent") {
            self.commandContent = dict["CommandContent"] as! String
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("Uuid") {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class GetConnectionTicketResponseBody : Tea.TeaModel {
    public var desktopId: String?

    public var requestId: String?

    public var taskCode: String?

    public var taskId: String?

    public var taskMessage: String?

    public var taskStatus: String?

    public var ticket: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskCode != nil {
            map["TaskCode"] = self.taskCode!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskMessage != nil {
            map["TaskMessage"] = self.taskMessage!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        if self.ticket != nil {
            map["Ticket"] = self.ticket!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskCode") {
            self.taskCode = dict["TaskCode"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskMessage") {
            self.taskMessage = dict["TaskMessage"] as! String
        }
        if dict.keys.contains("TaskStatus") {
            self.taskStatus = dict["TaskStatus"] as! String
        }
        if dict.keys.contains("Ticket") {
            self.ticket = dict["Ticket"] as! String
        }
    }
}

public class GetConnectionTicketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetConnectionTicketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetConnectionTicketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCoordinateTicketRequest : Tea.TeaModel {
    public var coId: String?

    public var endUserId: String?

    public var regionId: String?

    public var taskId: String?

    public var userType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coId != nil {
            map["CoId"] = self.coId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.userType != nil {
            map["UserType"] = self.userType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoId") {
            self.coId = dict["CoId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("UserType") {
            self.userType = dict["UserType"] as! String
        }
    }
}

public class GetCoordinateTicketResponseBody : Tea.TeaModel {
    public var coId: String?

    public var requestId: String?

    public var taskId: String?

    public var taskStatus: String?

    public var ticket: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coId != nil {
            map["CoId"] = self.coId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        if self.ticket != nil {
            map["Ticket"] = self.ticket!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoId") {
            self.coId = dict["CoId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskStatus") {
            self.taskStatus = dict["TaskStatus"] as! String
        }
        if dict.keys.contains("Ticket") {
            self.ticket = dict["Ticket"] as! String
        }
    }
}

public class GetCoordinateTicketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCoordinateTicketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCoordinateTicketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDesktopGroupDetailRequest : Tea.TeaModel {
    public var desktopGroupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetDesktopGroupDetailResponseBody : Tea.TeaModel {
    public class Desktops : Tea.TeaModel {
        public class ScaleTimerInfos : Tea.TeaModel {
            public var buyResAmount: Int32?

            public var cron: String?

            public var keepDuration: Int64?

            public var loadPolicy: Int32?

            public var maxResAmount: Int32?

            public var minResAmount: Int32?

            public var ratioThreshold: Double?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.buyResAmount != nil {
                    map["BuyResAmount"] = self.buyResAmount!
                }
                if self.cron != nil {
                    map["Cron"] = self.cron!
                }
                if self.keepDuration != nil {
                    map["KeepDuration"] = self.keepDuration!
                }
                if self.loadPolicy != nil {
                    map["LoadPolicy"] = self.loadPolicy!
                }
                if self.maxResAmount != nil {
                    map["MaxResAmount"] = self.maxResAmount!
                }
                if self.minResAmount != nil {
                    map["MinResAmount"] = self.minResAmount!
                }
                if self.ratioThreshold != nil {
                    map["RatioThreshold"] = self.ratioThreshold!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BuyResAmount") {
                    self.buyResAmount = dict["BuyResAmount"] as! Int32
                }
                if dict.keys.contains("Cron") {
                    self.cron = dict["Cron"] as! String
                }
                if dict.keys.contains("KeepDuration") {
                    self.keepDuration = dict["KeepDuration"] as! Int64
                }
                if dict.keys.contains("LoadPolicy") {
                    self.loadPolicy = dict["LoadPolicy"] as! Int32
                }
                if dict.keys.contains("MaxResAmount") {
                    self.maxResAmount = dict["MaxResAmount"] as! Int32
                }
                if dict.keys.contains("MinResAmount") {
                    self.minResAmount = dict["MinResAmount"] as! Int32
                }
                if dict.keys.contains("RatioThreshold") {
                    self.ratioThreshold = dict["RatioThreshold"] as! Double
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class TimerInfos : Tea.TeaModel {
            public var cronExpression: String?

            public var forced: Bool?

            public var status: Int32?

            public var timerType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cronExpression != nil {
                    map["CronExpression"] = self.cronExpression!
                }
                if self.forced != nil {
                    map["Forced"] = self.forced!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timerType != nil {
                    map["TimerType"] = self.timerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CronExpression") {
                    self.cronExpression = dict["CronExpression"] as! String
                }
                if dict.keys.contains("Forced") {
                    self.forced = dict["Forced"] as! Bool
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("TimerType") {
                    self.timerType = dict["TimerType"] as! Int32
                }
            }
        }
        public var allowAutoSetup: Int32?

        public var allowBufferCount: Int32?

        public var bindAmount: Int32?

        public var buyDesktopsCount: Int32?

        public var comments: String?

        public var connectDuration: Int64?

        public var cpu: Int32?

        public var creationTime: String?

        public var creator: String?

        public var dataDiskCategory: String?

        public var dataDiskSize: String?

        public var desktopGroupId: String?

        public var desktopGroupName: String?

        public var directoryId: String?

        public var directoryType: String?

        public var expiredTime: String?

        public var gpuCount: Double?

        public var gpuSpec: String?

        public var idleDisconnectDuration: Int64?

        public var imageId: String?

        public var keepDuration: Int64?

        public var loadPolicy: Int32?

        public var maxDesktopsCount: Int32?

        public var memory: Int64?

        public var minDesktopsCount: Int32?

        public var nasFileSystemID: String?

        public var nasFileSystemName: String?

        public var officeSiteId: String?

        public var officeSiteName: String?

        public var officeSiteType: String?

        public var ownBundleId: String?

        public var ownBundleName: String?

        public var ownType: Int32?

        public var payType: String?

        public var policyGroupId: String?

        public var policyGroupIds: [String]?

        public var policyGroupName: String?

        public var policyGroupNames: [String]?

        public var profileFollowSwitch: Bool?

        public var ratioThreshold: Double?

        public var resType: Int32?

        public var resetType: Int32?

        public var scaleTimerInfos: [GetDesktopGroupDetailResponseBody.Desktops.ScaleTimerInfos]?

        public var status: Int32?

        public var stopDuration: Int64?

        public var systemDiskCategory: String?

        public var systemDiskSize: Int32?

        public var timerInfos: [GetDesktopGroupDetailResponseBody.Desktops.TimerInfos]?

        public var timingStrategyInfo: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowAutoSetup != nil {
                map["AllowAutoSetup"] = self.allowAutoSetup!
            }
            if self.allowBufferCount != nil {
                map["AllowBufferCount"] = self.allowBufferCount!
            }
            if self.bindAmount != nil {
                map["BindAmount"] = self.bindAmount!
            }
            if self.buyDesktopsCount != nil {
                map["BuyDesktopsCount"] = self.buyDesktopsCount!
            }
            if self.comments != nil {
                map["Comments"] = self.comments!
            }
            if self.connectDuration != nil {
                map["ConnectDuration"] = self.connectDuration!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.dataDiskCategory != nil {
                map["DataDiskCategory"] = self.dataDiskCategory!
            }
            if self.dataDiskSize != nil {
                map["DataDiskSize"] = self.dataDiskSize!
            }
            if self.desktopGroupId != nil {
                map["DesktopGroupId"] = self.desktopGroupId!
            }
            if self.desktopGroupName != nil {
                map["DesktopGroupName"] = self.desktopGroupName!
            }
            if self.directoryId != nil {
                map["DirectoryId"] = self.directoryId!
            }
            if self.directoryType != nil {
                map["DirectoryType"] = self.directoryType!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.gpuCount != nil {
                map["GpuCount"] = self.gpuCount!
            }
            if self.gpuSpec != nil {
                map["GpuSpec"] = self.gpuSpec!
            }
            if self.idleDisconnectDuration != nil {
                map["IdleDisconnectDuration"] = self.idleDisconnectDuration!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.keepDuration != nil {
                map["KeepDuration"] = self.keepDuration!
            }
            if self.loadPolicy != nil {
                map["LoadPolicy"] = self.loadPolicy!
            }
            if self.maxDesktopsCount != nil {
                map["MaxDesktopsCount"] = self.maxDesktopsCount!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.minDesktopsCount != nil {
                map["MinDesktopsCount"] = self.minDesktopsCount!
            }
            if self.nasFileSystemID != nil {
                map["NasFileSystemID"] = self.nasFileSystemID!
            }
            if self.nasFileSystemName != nil {
                map["NasFileSystemName"] = self.nasFileSystemName!
            }
            if self.officeSiteId != nil {
                map["OfficeSiteId"] = self.officeSiteId!
            }
            if self.officeSiteName != nil {
                map["OfficeSiteName"] = self.officeSiteName!
            }
            if self.officeSiteType != nil {
                map["OfficeSiteType"] = self.officeSiteType!
            }
            if self.ownBundleId != nil {
                map["OwnBundleId"] = self.ownBundleId!
            }
            if self.ownBundleName != nil {
                map["OwnBundleName"] = self.ownBundleName!
            }
            if self.ownType != nil {
                map["OwnType"] = self.ownType!
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.policyGroupId != nil {
                map["PolicyGroupId"] = self.policyGroupId!
            }
            if self.policyGroupIds != nil {
                map["PolicyGroupIds"] = self.policyGroupIds!
            }
            if self.policyGroupName != nil {
                map["PolicyGroupName"] = self.policyGroupName!
            }
            if self.policyGroupNames != nil {
                map["PolicyGroupNames"] = self.policyGroupNames!
            }
            if self.profileFollowSwitch != nil {
                map["ProfileFollowSwitch"] = self.profileFollowSwitch!
            }
            if self.ratioThreshold != nil {
                map["RatioThreshold"] = self.ratioThreshold!
            }
            if self.resType != nil {
                map["ResType"] = self.resType!
            }
            if self.resetType != nil {
                map["ResetType"] = self.resetType!
            }
            if self.scaleTimerInfos != nil {
                var tmp : [Any] = []
                for k in self.scaleTimerInfos! {
                    tmp.append(k.toMap())
                }
                map["ScaleTimerInfos"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.stopDuration != nil {
                map["StopDuration"] = self.stopDuration!
            }
            if self.systemDiskCategory != nil {
                map["SystemDiskCategory"] = self.systemDiskCategory!
            }
            if self.systemDiskSize != nil {
                map["SystemDiskSize"] = self.systemDiskSize!
            }
            if self.timerInfos != nil {
                var tmp : [Any] = []
                for k in self.timerInfos! {
                    tmp.append(k.toMap())
                }
                map["TimerInfos"] = tmp
            }
            if self.timingStrategyInfo != nil {
                map["TimingStrategyInfo"] = self.timingStrategyInfo!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowAutoSetup") {
                self.allowAutoSetup = dict["AllowAutoSetup"] as! Int32
            }
            if dict.keys.contains("AllowBufferCount") {
                self.allowBufferCount = dict["AllowBufferCount"] as! Int32
            }
            if dict.keys.contains("BindAmount") {
                self.bindAmount = dict["BindAmount"] as! Int32
            }
            if dict.keys.contains("BuyDesktopsCount") {
                self.buyDesktopsCount = dict["BuyDesktopsCount"] as! Int32
            }
            if dict.keys.contains("Comments") {
                self.comments = dict["Comments"] as! String
            }
            if dict.keys.contains("ConnectDuration") {
                self.connectDuration = dict["ConnectDuration"] as! Int64
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("DataDiskCategory") {
                self.dataDiskCategory = dict["DataDiskCategory"] as! String
            }
            if dict.keys.contains("DataDiskSize") {
                self.dataDiskSize = dict["DataDiskSize"] as! String
            }
            if dict.keys.contains("DesktopGroupId") {
                self.desktopGroupId = dict["DesktopGroupId"] as! String
            }
            if dict.keys.contains("DesktopGroupName") {
                self.desktopGroupName = dict["DesktopGroupName"] as! String
            }
            if dict.keys.contains("DirectoryId") {
                self.directoryId = dict["DirectoryId"] as! String
            }
            if dict.keys.contains("DirectoryType") {
                self.directoryType = dict["DirectoryType"] as! String
            }
            if dict.keys.contains("ExpiredTime") {
                self.expiredTime = dict["ExpiredTime"] as! String
            }
            if dict.keys.contains("GpuCount") {
                self.gpuCount = dict["GpuCount"] as! Double
            }
            if dict.keys.contains("GpuSpec") {
                self.gpuSpec = dict["GpuSpec"] as! String
            }
            if dict.keys.contains("IdleDisconnectDuration") {
                self.idleDisconnectDuration = dict["IdleDisconnectDuration"] as! Int64
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("KeepDuration") {
                self.keepDuration = dict["KeepDuration"] as! Int64
            }
            if dict.keys.contains("LoadPolicy") {
                self.loadPolicy = dict["LoadPolicy"] as! Int32
            }
            if dict.keys.contains("MaxDesktopsCount") {
                self.maxDesktopsCount = dict["MaxDesktopsCount"] as! Int32
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Int64
            }
            if dict.keys.contains("MinDesktopsCount") {
                self.minDesktopsCount = dict["MinDesktopsCount"] as! Int32
            }
            if dict.keys.contains("NasFileSystemID") {
                self.nasFileSystemID = dict["NasFileSystemID"] as! String
            }
            if dict.keys.contains("NasFileSystemName") {
                self.nasFileSystemName = dict["NasFileSystemName"] as! String
            }
            if dict.keys.contains("OfficeSiteId") {
                self.officeSiteId = dict["OfficeSiteId"] as! String
            }
            if dict.keys.contains("OfficeSiteName") {
                self.officeSiteName = dict["OfficeSiteName"] as! String
            }
            if dict.keys.contains("OfficeSiteType") {
                self.officeSiteType = dict["OfficeSiteType"] as! String
            }
            if dict.keys.contains("OwnBundleId") {
                self.ownBundleId = dict["OwnBundleId"] as! String
            }
            if dict.keys.contains("OwnBundleName") {
                self.ownBundleName = dict["OwnBundleName"] as! String
            }
            if dict.keys.contains("OwnType") {
                self.ownType = dict["OwnType"] as! Int32
            }
            if dict.keys.contains("PayType") {
                self.payType = dict["PayType"] as! String
            }
            if dict.keys.contains("PolicyGroupId") {
                self.policyGroupId = dict["PolicyGroupId"] as! String
            }
            if dict.keys.contains("PolicyGroupIds") {
                self.policyGroupIds = dict["PolicyGroupIds"] as! [String]
            }
            if dict.keys.contains("PolicyGroupName") {
                self.policyGroupName = dict["PolicyGroupName"] as! String
            }
            if dict.keys.contains("PolicyGroupNames") {
                self.policyGroupNames = dict["PolicyGroupNames"] as! [String]
            }
            if dict.keys.contains("ProfileFollowSwitch") {
                self.profileFollowSwitch = dict["ProfileFollowSwitch"] as! Bool
            }
            if dict.keys.contains("RatioThreshold") {
                self.ratioThreshold = dict["RatioThreshold"] as! Double
            }
            if dict.keys.contains("ResType") {
                self.resType = dict["ResType"] as! Int32
            }
            if dict.keys.contains("ResetType") {
                self.resetType = dict["ResetType"] as! Int32
            }
            if dict.keys.contains("ScaleTimerInfos") {
                var tmp : [GetDesktopGroupDetailResponseBody.Desktops.ScaleTimerInfos] = []
                for v in dict["ScaleTimerInfos"] as! [Any] {
                    var model = GetDesktopGroupDetailResponseBody.Desktops.ScaleTimerInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.scaleTimerInfos = tmp
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("StopDuration") {
                self.stopDuration = dict["StopDuration"] as! Int64
            }
            if dict.keys.contains("SystemDiskCategory") {
                self.systemDiskCategory = dict["SystemDiskCategory"] as! String
            }
            if dict.keys.contains("SystemDiskSize") {
                self.systemDiskSize = dict["SystemDiskSize"] as! Int32
            }
            if dict.keys.contains("TimerInfos") {
                var tmp : [GetDesktopGroupDetailResponseBody.Desktops.TimerInfos] = []
                for v in dict["TimerInfos"] as! [Any] {
                    var model = GetDesktopGroupDetailResponseBody.Desktops.TimerInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.timerInfos = tmp
            }
            if dict.keys.contains("TimingStrategyInfo") {
                self.timingStrategyInfo = dict["TimingStrategyInfo"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var desktops: GetDesktopGroupDetailResponseBody.Desktops?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.desktops?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktops != nil {
            map["Desktops"] = self.desktops?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Desktops") {
            var model = GetDesktopGroupDetailResponseBody.Desktops()
            model.fromMap(dict["Desktops"] as! [String: Any])
            self.desktops = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDesktopGroupDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDesktopGroupDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDesktopGroupDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOfficeSiteSsoStatusRequest : Tea.TeaModel {
    public var officeSiteId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetOfficeSiteSsoStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var ssoStatus: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ssoStatus != nil {
            map["SsoStatus"] = self.ssoStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SsoStatus") {
            self.ssoStatus = dict["SsoStatus"] as! Bool
        }
    }
}

public class GetOfficeSiteSsoStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOfficeSiteSsoStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOfficeSiteSsoStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSpMetadataRequest : Tea.TeaModel {
    public var directoryId: String?

    public var officeSiteId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetSpMetadataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var spMetadata: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.spMetadata != nil {
            map["SpMetadata"] = self.spMetadata!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SpMetadata") {
            self.spMetadata = dict["SpMetadata"] as! String
        }
    }
}

public class GetSpMetadataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSpMetadataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSpMetadataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class HibernateDesktopsRequest : Tea.TeaModel {
    public var desktopId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class HibernateDesktopsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class HibernateDesktopsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: HibernateDesktopsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = HibernateDesktopsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCdsFilesRequest : Tea.TeaModel {
    public var cdsId: String?

    public var endUserId: String?

    public var fileIds: [String]?

    public var groupId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orderType: String?

    public var parentFileId: String?

    public var regionId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.fileIds != nil {
            map["FileIds"] = self.fileIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.parentFileId != nil {
            map["ParentFileId"] = self.parentFileId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("FileIds") {
            self.fileIds = dict["FileIds"] as! [String]
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("ParentFileId") {
            self.parentFileId = dict["ParentFileId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListCdsFilesShrinkRequest : Tea.TeaModel {
    public var cdsId: String?

    public var endUserId: String?

    public var fileIdsShrink: String?

    public var groupId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orderType: String?

    public var parentFileId: String?

    public var regionId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.fileIdsShrink != nil {
            map["FileIds"] = self.fileIdsShrink!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.parentFileId != nil {
            map["ParentFileId"] = self.parentFileId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("FileIds") {
            self.fileIdsShrink = dict["FileIds"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("ParentFileId") {
            self.parentFileId = dict["ParentFileId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListCdsFilesResponseBody : Tea.TeaModel {
    public class FileModels : Tea.TeaModel {
        public var category: String?

        public var contentType: String?

        public var createTime: String?

        public var creator: String?

        public var description_: String?

        public var downloadUrl: String?

        public var fileExtension: String?

        public var fileId: String?

        public var filePath: String?

        public var fileType: String?

        public var md5: String?

        public var modifiedTime: String?

        public var modifier: String?

        public var name: String?

        public var openTime: String?

        public var openTimeStamp: Int64?

        public var parentId: String?

        public var regionId: String?

        public var sha1: String?

        public var size: Int64?

        public var thumbnail: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.contentType != nil {
                map["ContentType"] = self.contentType!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.downloadUrl != nil {
                map["DownloadUrl"] = self.downloadUrl!
            }
            if self.fileExtension != nil {
                map["FileExtension"] = self.fileExtension!
            }
            if self.fileId != nil {
                map["FileId"] = self.fileId!
            }
            if self.filePath != nil {
                map["FilePath"] = self.filePath!
            }
            if self.fileType != nil {
                map["FileType"] = self.fileType!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifier != nil {
                map["Modifier"] = self.modifier!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.openTime != nil {
                map["OpenTime"] = self.openTime!
            }
            if self.openTimeStamp != nil {
                map["OpenTimeStamp"] = self.openTimeStamp!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.sha1 != nil {
                map["Sha1"] = self.sha1!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.thumbnail != nil {
                map["Thumbnail"] = self.thumbnail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("ContentType") {
                self.contentType = dict["ContentType"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DownloadUrl") {
                self.downloadUrl = dict["DownloadUrl"] as! String
            }
            if dict.keys.contains("FileExtension") {
                self.fileExtension = dict["FileExtension"] as! String
            }
            if dict.keys.contains("FileId") {
                self.fileId = dict["FileId"] as! String
            }
            if dict.keys.contains("FilePath") {
                self.filePath = dict["FilePath"] as! String
            }
            if dict.keys.contains("FileType") {
                self.fileType = dict["FileType"] as! String
            }
            if dict.keys.contains("Md5") {
                self.md5 = dict["Md5"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Modifier") {
                self.modifier = dict["Modifier"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OpenTime") {
                self.openTime = dict["OpenTime"] as! String
            }
            if dict.keys.contains("OpenTimeStamp") {
                self.openTimeStamp = dict["OpenTimeStamp"] as! Int64
            }
            if dict.keys.contains("ParentId") {
                self.parentId = dict["ParentId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Sha1") {
                self.sha1 = dict["Sha1"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Thumbnail") {
                self.thumbnail = dict["Thumbnail"] as! String
            }
        }
    }
    public var code: String?

    public var count: String?

    public var fileModels: [ListCdsFilesResponseBody.FileModels]?

    public var message: String?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.fileModels != nil {
            var tmp : [Any] = []
            for k in self.fileModels! {
                tmp.append(k.toMap())
            }
            map["FileModels"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! String
        }
        if dict.keys.contains("FileModels") {
            var tmp : [ListCdsFilesResponseBody.FileModels] = []
            for v in dict["FileModels"] as! [Any] {
                var model = ListCdsFilesResponseBody.FileModels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fileModels = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListCdsFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCdsFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCdsFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDirectoryUsersRequest : Tea.TeaModel {
    public var assignedInfo: String?

    public var directoryId: String?

    public var filter: String?

    public var includeAssignedUser: Bool?

    public var maxResults: Int32?

    public var nextToken: String?

    public var OUPath: String?

    public var regionId: String?

    public var sortType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignedInfo != nil {
            map["AssignedInfo"] = self.assignedInfo!
        }
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.filter != nil {
            map["Filter"] = self.filter!
        }
        if self.includeAssignedUser != nil {
            map["IncludeAssignedUser"] = self.includeAssignedUser!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.OUPath != nil {
            map["OUPath"] = self.OUPath!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssignedInfo") {
            self.assignedInfo = dict["AssignedInfo"] as! String
        }
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("Filter") {
            self.filter = dict["Filter"] as! String
        }
        if dict.keys.contains("IncludeAssignedUser") {
            self.includeAssignedUser = dict["IncludeAssignedUser"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OUPath") {
            self.OUPath = dict["OUPath"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SortType") {
            self.sortType = dict["SortType"] as! String
        }
    }
}

public class ListDirectoryUsersResponseBody : Tea.TeaModel {
    public class Users : Tea.TeaModel {
        public var assignedDesktopNumber: Int32?

        public var displayName: String?

        public var displayNameNew: String?

        public var email: String?

        public var endUser: String?

        public var phone: String?

        public var userPrincipalName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedDesktopNumber != nil {
                map["AssignedDesktopNumber"] = self.assignedDesktopNumber!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.displayNameNew != nil {
                map["DisplayNameNew"] = self.displayNameNew!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.endUser != nil {
                map["EndUser"] = self.endUser!
            }
            if self.phone != nil {
                map["Phone"] = self.phone!
            }
            if self.userPrincipalName != nil {
                map["UserPrincipalName"] = self.userPrincipalName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssignedDesktopNumber") {
                self.assignedDesktopNumber = dict["AssignedDesktopNumber"] as! Int32
            }
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("DisplayNameNew") {
                self.displayNameNew = dict["DisplayNameNew"] as! String
            }
            if dict.keys.contains("Email") {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("EndUser") {
                self.endUser = dict["EndUser"] as! String
            }
            if dict.keys.contains("Phone") {
                self.phone = dict["Phone"] as! String
            }
            if dict.keys.contains("UserPrincipalName") {
                self.userPrincipalName = dict["UserPrincipalName"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var users: [ListDirectoryUsersResponseBody.Users]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.users != nil {
            var tmp : [Any] = []
            for k in self.users! {
                tmp.append(k.toMap())
            }
            map["Users"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Users") {
            var tmp : [ListDirectoryUsersResponseBody.Users] = []
            for v in dict["Users"] as! [Any] {
                var model = ListDirectoryUsersResponseBody.Users()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.users = tmp
        }
    }
}

public class ListDirectoryUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDirectoryUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDirectoryUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFilePermissionRequest : Tea.TeaModel {
    public var cdsId: String?

    public var endUserId: String?

    public var fileId: String?

    public var groupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListFilePermissionResponseBody : Tea.TeaModel {
    public var filePermissions: [FilePermissionMember]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filePermissions != nil {
            var tmp : [Any] = []
            for k in self.filePermissions! {
                tmp.append(k.toMap())
            }
            map["FilePermissions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilePermissions") {
            var tmp : [FilePermissionMember] = []
            for v in dict["FilePermissions"] as! [Any] {
                var model = FilePermissionMember()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filePermissions = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListFilePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFilePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListFilePermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListOfficeSiteOverviewRequest : Tea.TeaModel {
    public var forceRefresh: Bool?

    public var maxResults: Int32?

    public var nextToken: String?

    public var officeSiteId: [String]?

    public var queryRange: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forceRefresh != nil {
            map["ForceRefresh"] = self.forceRefresh!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.queryRange != nil {
            map["QueryRange"] = self.queryRange!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForceRefresh") {
            self.forceRefresh = dict["ForceRefresh"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! [String]
        }
        if dict.keys.contains("QueryRange") {
            self.queryRange = dict["QueryRange"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListOfficeSiteOverviewResponseBody : Tea.TeaModel {
    public class OfficeSiteOverviewResults : Tea.TeaModel {
        public var hasExpiredEdsCount: Int32?

        public var hasExpiredEdsCountForGroup: Int32?

        public var officeSiteId: String?

        public var officeSiteName: String?

        public var officeSiteStatus: String?

        public var regionId: String?

        public var runningEdsCount: Int32?

        public var runningEdsCountForGroup: Int32?

        public var totalEdsCount: Int32?

        public var totalEdsCountForGroup: Int32?

        public var vpcType: String?

        public var willExpiredEdsCount: Int32?

        public var willExpiredEdsCountForGroup: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hasExpiredEdsCount != nil {
                map["HasExpiredEdsCount"] = self.hasExpiredEdsCount!
            }
            if self.hasExpiredEdsCountForGroup != nil {
                map["HasExpiredEdsCountForGroup"] = self.hasExpiredEdsCountForGroup!
            }
            if self.officeSiteId != nil {
                map["OfficeSiteId"] = self.officeSiteId!
            }
            if self.officeSiteName != nil {
                map["OfficeSiteName"] = self.officeSiteName!
            }
            if self.officeSiteStatus != nil {
                map["OfficeSiteStatus"] = self.officeSiteStatus!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.runningEdsCount != nil {
                map["RunningEdsCount"] = self.runningEdsCount!
            }
            if self.runningEdsCountForGroup != nil {
                map["RunningEdsCountForGroup"] = self.runningEdsCountForGroup!
            }
            if self.totalEdsCount != nil {
                map["TotalEdsCount"] = self.totalEdsCount!
            }
            if self.totalEdsCountForGroup != nil {
                map["TotalEdsCountForGroup"] = self.totalEdsCountForGroup!
            }
            if self.vpcType != nil {
                map["VpcType"] = self.vpcType!
            }
            if self.willExpiredEdsCount != nil {
                map["WillExpiredEdsCount"] = self.willExpiredEdsCount!
            }
            if self.willExpiredEdsCountForGroup != nil {
                map["WillExpiredEdsCountForGroup"] = self.willExpiredEdsCountForGroup!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HasExpiredEdsCount") {
                self.hasExpiredEdsCount = dict["HasExpiredEdsCount"] as! Int32
            }
            if dict.keys.contains("HasExpiredEdsCountForGroup") {
                self.hasExpiredEdsCountForGroup = dict["HasExpiredEdsCountForGroup"] as! Int32
            }
            if dict.keys.contains("OfficeSiteId") {
                self.officeSiteId = dict["OfficeSiteId"] as! String
            }
            if dict.keys.contains("OfficeSiteName") {
                self.officeSiteName = dict["OfficeSiteName"] as! String
            }
            if dict.keys.contains("OfficeSiteStatus") {
                self.officeSiteStatus = dict["OfficeSiteStatus"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RunningEdsCount") {
                self.runningEdsCount = dict["RunningEdsCount"] as! Int32
            }
            if dict.keys.contains("RunningEdsCountForGroup") {
                self.runningEdsCountForGroup = dict["RunningEdsCountForGroup"] as! Int32
            }
            if dict.keys.contains("TotalEdsCount") {
                self.totalEdsCount = dict["TotalEdsCount"] as! Int32
            }
            if dict.keys.contains("TotalEdsCountForGroup") {
                self.totalEdsCountForGroup = dict["TotalEdsCountForGroup"] as! Int32
            }
            if dict.keys.contains("VpcType") {
                self.vpcType = dict["VpcType"] as! String
            }
            if dict.keys.contains("WillExpiredEdsCount") {
                self.willExpiredEdsCount = dict["WillExpiredEdsCount"] as! Int32
            }
            if dict.keys.contains("WillExpiredEdsCountForGroup") {
                self.willExpiredEdsCountForGroup = dict["WillExpiredEdsCountForGroup"] as! Int32
            }
        }
    }
    public var nextToken: String?

    public var officeSiteOverviewResults: [ListOfficeSiteOverviewResponseBody.OfficeSiteOverviewResults]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.officeSiteOverviewResults != nil {
            var tmp : [Any] = []
            for k in self.officeSiteOverviewResults! {
                tmp.append(k.toMap())
            }
            map["OfficeSiteOverviewResults"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OfficeSiteOverviewResults") {
            var tmp : [ListOfficeSiteOverviewResponseBody.OfficeSiteOverviewResults] = []
            for v in dict["OfficeSiteOverviewResults"] as! [Any] {
                var model = ListOfficeSiteOverviewResponseBody.OfficeSiteOverviewResults()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.officeSiteOverviewResults = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListOfficeSiteOverviewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListOfficeSiteOverviewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListOfficeSiteOverviewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListOfficeSiteUsersRequest : Tea.TeaModel {
    public var assignedInfo: String?

    public var filter: String?

    public var includeAssignedUser: Bool?

    public var maxResults: Int32?

    public var nextToken: String?

    public var OUPath: String?

    public var officeSiteId: String?

    public var regionId: String?

    public var sortType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignedInfo != nil {
            map["AssignedInfo"] = self.assignedInfo!
        }
        if self.filter != nil {
            map["Filter"] = self.filter!
        }
        if self.includeAssignedUser != nil {
            map["IncludeAssignedUser"] = self.includeAssignedUser!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.OUPath != nil {
            map["OUPath"] = self.OUPath!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssignedInfo") {
            self.assignedInfo = dict["AssignedInfo"] as! String
        }
        if dict.keys.contains("Filter") {
            self.filter = dict["Filter"] as! String
        }
        if dict.keys.contains("IncludeAssignedUser") {
            self.includeAssignedUser = dict["IncludeAssignedUser"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OUPath") {
            self.OUPath = dict["OUPath"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SortType") {
            self.sortType = dict["SortType"] as! String
        }
    }
}

public class ListOfficeSiteUsersResponseBody : Tea.TeaModel {
    public class Users : Tea.TeaModel {
        public var assignedDesktopNumber: Int32?

        public var displayName: String?

        public var displayNameNew: String?

        public var email: String?

        public var endUser: String?

        public var phone: String?

        public var userPrincipalName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedDesktopNumber != nil {
                map["AssignedDesktopNumber"] = self.assignedDesktopNumber!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.displayNameNew != nil {
                map["DisplayNameNew"] = self.displayNameNew!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.endUser != nil {
                map["EndUser"] = self.endUser!
            }
            if self.phone != nil {
                map["Phone"] = self.phone!
            }
            if self.userPrincipalName != nil {
                map["UserPrincipalName"] = self.userPrincipalName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssignedDesktopNumber") {
                self.assignedDesktopNumber = dict["AssignedDesktopNumber"] as! Int32
            }
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("DisplayNameNew") {
                self.displayNameNew = dict["DisplayNameNew"] as! String
            }
            if dict.keys.contains("Email") {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("EndUser") {
                self.endUser = dict["EndUser"] as! String
            }
            if dict.keys.contains("Phone") {
                self.phone = dict["Phone"] as! String
            }
            if dict.keys.contains("UserPrincipalName") {
                self.userPrincipalName = dict["UserPrincipalName"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var users: [ListOfficeSiteUsersResponseBody.Users]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.users != nil {
            var tmp : [Any] = []
            for k in self.users! {
                tmp.append(k.toMap())
            }
            map["Users"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Users") {
            var tmp : [ListOfficeSiteUsersResponseBody.Users] = []
            for v in dict["Users"] as! [Any] {
                var model = ListOfficeSiteUsersResponseBody.Users()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.users = tmp
        }
    }
}

public class ListOfficeSiteUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListOfficeSiteUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListOfficeSiteUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListTagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("TagKey") {
                self.tagKey = dict["TagKey"] as! String
            }
            if dict.keys.contains("TagValue") {
                self.tagValue = dict["TagValue"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: [ListTagResourcesResponseBody.TagResources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            var tmp : [Any] = []
            for k in self.tagResources! {
                tmp.append(k.toMap())
            }
            map["TagResources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") {
            var tmp : [ListTagResourcesResponseBody.TagResources] = []
            for v in dict["TagResources"] as! [Any] {
                var model = ListTagResourcesResponseBody.TagResources()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tagResources = tmp
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserAdOrganizationUnitsRequest : Tea.TeaModel {
    public var filter: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var officeSiteId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            map["Filter"] = self.filter!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            self.filter = dict["Filter"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListUserAdOrganizationUnitsResponseBody : Tea.TeaModel {
    public class OUNames : Tea.TeaModel {
        public var displayOUName: String?

        public var OUName: String?

        public var officeSiteId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayOUName != nil {
                map["DisplayOUName"] = self.displayOUName!
            }
            if self.OUName != nil {
                map["OUName"] = self.OUName!
            }
            if self.officeSiteId != nil {
                map["OfficeSiteId"] = self.officeSiteId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayOUName") {
                self.displayOUName = dict["DisplayOUName"] as! String
            }
            if dict.keys.contains("OUName") {
                self.OUName = dict["OUName"] as! String
            }
            if dict.keys.contains("OfficeSiteId") {
                self.officeSiteId = dict["OfficeSiteId"] as! String
            }
        }
    }
    public var nextToken: String?

    public var OUNames: [ListUserAdOrganizationUnitsResponseBody.OUNames]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.OUNames != nil {
            var tmp : [Any] = []
            for k in self.OUNames! {
                tmp.append(k.toMap())
            }
            map["OUNames"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OUNames") {
            var tmp : [ListUserAdOrganizationUnitsResponseBody.OUNames] = []
            for v in dict["OUNames"] as! [Any] {
                var model = ListUserAdOrganizationUnitsResponseBody.OUNames()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.OUNames = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListUserAdOrganizationUnitsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserAdOrganizationUnitsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListUserAdOrganizationUnitsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class LockVirtualMFADeviceRequest : Tea.TeaModel {
    public var regionId: String?

    public var serialNumber: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.serialNumber != nil {
            map["SerialNumber"] = self.serialNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SerialNumber") {
            self.serialNumber = dict["SerialNumber"] as! String
        }
    }
}

public class LockVirtualMFADeviceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class LockVirtualMFADeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LockVirtualMFADeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = LockVirtualMFADeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MigrateDesktopsRequest : Tea.TeaModel {
    public var desktopId: [String]?

    public var regionId: String?

    public var targetOfficeSiteId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.targetOfficeSiteId != nil {
            map["TargetOfficeSiteId"] = self.targetOfficeSiteId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TargetOfficeSiteId") {
            self.targetOfficeSiteId = dict["TargetOfficeSiteId"] as! String
        }
    }
}

public class MigrateDesktopsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MigrateDesktopsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MigrateDesktopsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MigrateDesktopsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MigrateImageProtocolRequest : Tea.TeaModel {
    public var imageId: [String]?

    public var regionId: String?

    public var targetProtocolType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.targetProtocolType != nil {
            map["TargetProtocolType"] = self.targetProtocolType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TargetProtocolType") {
            self.targetProtocolType = dict["TargetProtocolType"] as! String
        }
    }
}

public class MigrateImageProtocolResponseBody : Tea.TeaModel {
    public var failedIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedIds != nil {
            map["FailedIds"] = self.failedIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailedIds") {
            self.failedIds = dict["FailedIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MigrateImageProtocolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MigrateImageProtocolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MigrateImageProtocolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyADConnectorDirectoryRequest : Tea.TeaModel {
    public var adHostname: String?

    public var directoryId: String?

    public var directoryName: String?

    public var dnsAddress: [String]?

    public var domainName: String?

    public var domainPassword: String?

    public var domainUserName: String?

    public var mfaEnabled: Bool?

    public var OUName: String?

    public var regionId: String?

    public var subDomainDnsAddress: [String]?

    public var subDomainName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adHostname != nil {
            map["AdHostname"] = self.adHostname!
        }
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.directoryName != nil {
            map["DirectoryName"] = self.directoryName!
        }
        if self.dnsAddress != nil {
            map["DnsAddress"] = self.dnsAddress!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainPassword != nil {
            map["DomainPassword"] = self.domainPassword!
        }
        if self.domainUserName != nil {
            map["DomainUserName"] = self.domainUserName!
        }
        if self.mfaEnabled != nil {
            map["MfaEnabled"] = self.mfaEnabled!
        }
        if self.OUName != nil {
            map["OUName"] = self.OUName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.subDomainDnsAddress != nil {
            map["SubDomainDnsAddress"] = self.subDomainDnsAddress!
        }
        if self.subDomainName != nil {
            map["SubDomainName"] = self.subDomainName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdHostname") {
            self.adHostname = dict["AdHostname"] as! String
        }
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("DirectoryName") {
            self.directoryName = dict["DirectoryName"] as! String
        }
        if dict.keys.contains("DnsAddress") {
            self.dnsAddress = dict["DnsAddress"] as! [String]
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainPassword") {
            self.domainPassword = dict["DomainPassword"] as! String
        }
        if dict.keys.contains("DomainUserName") {
            self.domainUserName = dict["DomainUserName"] as! String
        }
        if dict.keys.contains("MfaEnabled") {
            self.mfaEnabled = dict["MfaEnabled"] as! Bool
        }
        if dict.keys.contains("OUName") {
            self.OUName = dict["OUName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SubDomainDnsAddress") {
            self.subDomainDnsAddress = dict["SubDomainDnsAddress"] as! [String]
        }
        if dict.keys.contains("SubDomainName") {
            self.subDomainName = dict["SubDomainName"] as! String
        }
    }
}

public class ModifyADConnectorDirectoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyADConnectorDirectoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyADConnectorDirectoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyADConnectorDirectoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyADConnectorOfficeSiteRequest : Tea.TeaModel {
    public var adHostname: String?

    public var backupDCHostname: String?

    public var backupDns: String?

    public var dnsAddress: [String]?

    public var domainName: String?

    public var domainPassword: String?

    public var domainUserName: String?

    public var mfaEnabled: Bool?

    public var OUName: String?

    public var officeSiteId: String?

    public var officeSiteName: String?

    public var regionId: String?

    public var subDomainDnsAddress: [String]?

    public var subDomainName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adHostname != nil {
            map["AdHostname"] = self.adHostname!
        }
        if self.backupDCHostname != nil {
            map["BackupDCHostname"] = self.backupDCHostname!
        }
        if self.backupDns != nil {
            map["BackupDns"] = self.backupDns!
        }
        if self.dnsAddress != nil {
            map["DnsAddress"] = self.dnsAddress!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainPassword != nil {
            map["DomainPassword"] = self.domainPassword!
        }
        if self.domainUserName != nil {
            map["DomainUserName"] = self.domainUserName!
        }
        if self.mfaEnabled != nil {
            map["MfaEnabled"] = self.mfaEnabled!
        }
        if self.OUName != nil {
            map["OUName"] = self.OUName!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.officeSiteName != nil {
            map["OfficeSiteName"] = self.officeSiteName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.subDomainDnsAddress != nil {
            map["SubDomainDnsAddress"] = self.subDomainDnsAddress!
        }
        if self.subDomainName != nil {
            map["SubDomainName"] = self.subDomainName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdHostname") {
            self.adHostname = dict["AdHostname"] as! String
        }
        if dict.keys.contains("BackupDCHostname") {
            self.backupDCHostname = dict["BackupDCHostname"] as! String
        }
        if dict.keys.contains("BackupDns") {
            self.backupDns = dict["BackupDns"] as! String
        }
        if dict.keys.contains("DnsAddress") {
            self.dnsAddress = dict["DnsAddress"] as! [String]
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainPassword") {
            self.domainPassword = dict["DomainPassword"] as! String
        }
        if dict.keys.contains("DomainUserName") {
            self.domainUserName = dict["DomainUserName"] as! String
        }
        if dict.keys.contains("MfaEnabled") {
            self.mfaEnabled = dict["MfaEnabled"] as! Bool
        }
        if dict.keys.contains("OUName") {
            self.OUName = dict["OUName"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("OfficeSiteName") {
            self.officeSiteName = dict["OfficeSiteName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SubDomainDnsAddress") {
            self.subDomainDnsAddress = dict["SubDomainDnsAddress"] as! [String]
        }
        if dict.keys.contains("SubDomainName") {
            self.subDomainName = dict["SubDomainName"] as! String
        }
    }
}

public class ModifyADConnectorOfficeSiteResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyADConnectorOfficeSiteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyADConnectorOfficeSiteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyADConnectorOfficeSiteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAclEntriesRequest : Tea.TeaModel {
    public var policy: String?

    public var regionId: String?

    public var sourceId: [String]?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sourceId != nil {
            map["SourceId"] = self.sourceId!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SourceId") {
            self.sourceId = dict["SourceId"] as! [String]
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class ModifyAclEntriesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAclEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAclEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyAclEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAutoSnapshotPolicyRequest : Tea.TeaModel {
    public var cronExpression: String?

    public var policyId: String?

    public var policyName: String?

    public var regionId: String?

    public var retentionDays: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cronExpression != nil {
            map["CronExpression"] = self.cronExpression!
        }
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        if self.policyName != nil {
            map["PolicyName"] = self.policyName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.retentionDays != nil {
            map["RetentionDays"] = self.retentionDays!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CronExpression") {
            self.cronExpression = dict["CronExpression"] as! String
        }
        if dict.keys.contains("PolicyId") {
            self.policyId = dict["PolicyId"] as! String
        }
        if dict.keys.contains("PolicyName") {
            self.policyName = dict["PolicyName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RetentionDays") {
            self.retentionDays = dict["RetentionDays"] as! Int32
        }
    }
}

public class ModifyAutoSnapshotPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAutoSnapshotPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAutoSnapshotPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyAutoSnapshotPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyBundleRequest : Tea.TeaModel {
    public var bundleId: String?

    public var bundleName: String?

    public var description_: String?

    public var imageId: String?

    public var language: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bundleId != nil {
            map["BundleId"] = self.bundleId!
        }
        if self.bundleName != nil {
            map["BundleName"] = self.bundleName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BundleId") {
            self.bundleId = dict["BundleId"] as! String
        }
        if dict.keys.contains("BundleName") {
            self.bundleName = dict["BundleName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyBundleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyBundleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBundleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyBundleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCdsFileRequest : Tea.TeaModel {
    public var cdsId: String?

    public var conflictPolicy: String?

    public var endUserId: String?

    public var fileId: String?

    public var fileName: String?

    public var groupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.conflictPolicy != nil {
            map["ConflictPolicy"] = self.conflictPolicy!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("ConflictPolicy") {
            self.conflictPolicy = dict["ConflictPolicy"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! String
        }
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyCdsFileResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyCdsFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCdsFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCdsFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCdsFileShareLinkRequest : Tea.TeaModel {
    public var cdsId: String?

    public var description_: String?

    public var disableDownload: Bool?

    public var disablePreview: Bool?

    public var disableSave: Bool?

    public var downloadCount: Int64?

    public var downloadLimit: Int64?

    public var expiration: String?

    public var previewCount: Int64?

    public var previewLimit: Int64?

    public var reportCount: Int64?

    public var saveCount: Int64?

    public var saveLimit: Int64?

    public var shareId: String?

    public var shareName: String?

    public var sharePwd: String?

    public var status: String?

    public var videoPreviewCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableDownload != nil {
            map["DisableDownload"] = self.disableDownload!
        }
        if self.disablePreview != nil {
            map["DisablePreview"] = self.disablePreview!
        }
        if self.disableSave != nil {
            map["DisableSave"] = self.disableSave!
        }
        if self.downloadCount != nil {
            map["DownloadCount"] = self.downloadCount!
        }
        if self.downloadLimit != nil {
            map["DownloadLimit"] = self.downloadLimit!
        }
        if self.expiration != nil {
            map["Expiration"] = self.expiration!
        }
        if self.previewCount != nil {
            map["PreviewCount"] = self.previewCount!
        }
        if self.previewLimit != nil {
            map["PreviewLimit"] = self.previewLimit!
        }
        if self.reportCount != nil {
            map["ReportCount"] = self.reportCount!
        }
        if self.saveCount != nil {
            map["SaveCount"] = self.saveCount!
        }
        if self.saveLimit != nil {
            map["SaveLimit"] = self.saveLimit!
        }
        if self.shareId != nil {
            map["ShareId"] = self.shareId!
        }
        if self.shareName != nil {
            map["ShareName"] = self.shareName!
        }
        if self.sharePwd != nil {
            map["SharePwd"] = self.sharePwd!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.videoPreviewCount != nil {
            map["VideoPreviewCount"] = self.videoPreviewCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableDownload") {
            self.disableDownload = dict["DisableDownload"] as! Bool
        }
        if dict.keys.contains("DisablePreview") {
            self.disablePreview = dict["DisablePreview"] as! Bool
        }
        if dict.keys.contains("DisableSave") {
            self.disableSave = dict["DisableSave"] as! Bool
        }
        if dict.keys.contains("DownloadCount") {
            self.downloadCount = dict["DownloadCount"] as! Int64
        }
        if dict.keys.contains("DownloadLimit") {
            self.downloadLimit = dict["DownloadLimit"] as! Int64
        }
        if dict.keys.contains("Expiration") {
            self.expiration = dict["Expiration"] as! String
        }
        if dict.keys.contains("PreviewCount") {
            self.previewCount = dict["PreviewCount"] as! Int64
        }
        if dict.keys.contains("PreviewLimit") {
            self.previewLimit = dict["PreviewLimit"] as! Int64
        }
        if dict.keys.contains("ReportCount") {
            self.reportCount = dict["ReportCount"] as! Int64
        }
        if dict.keys.contains("SaveCount") {
            self.saveCount = dict["SaveCount"] as! Int64
        }
        if dict.keys.contains("SaveLimit") {
            self.saveLimit = dict["SaveLimit"] as! Int64
        }
        if dict.keys.contains("ShareId") {
            self.shareId = dict["ShareId"] as! String
        }
        if dict.keys.contains("ShareName") {
            self.shareName = dict["ShareName"] as! String
        }
        if dict.keys.contains("SharePwd") {
            self.sharePwd = dict["SharePwd"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("VideoPreviewCount") {
            self.videoPreviewCount = dict["VideoPreviewCount"] as! Int64
        }
    }
}

public class ModifyCdsFileShareLinkResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: CdsFileShareLinkModel?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CdsFileShareLinkModel()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyCdsFileShareLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCdsFileShareLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCdsFileShareLinkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCenterPolicyRequest : Tea.TeaModel {
    public class AuthorizeAccessPolicyRule : Tea.TeaModel {
        public var cidrIp: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrIp != nil {
                map["CidrIp"] = self.cidrIp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrIp") {
                self.cidrIp = dict["CidrIp"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
        }
    }
    public class AuthorizeSecurityPolicyRule : Tea.TeaModel {
        public var cidrIp: String?

        public var description_: String?

        public var ipProtocol: String?

        public var policy: String?

        public var portRange: String?

        public var priority: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrIp != nil {
                map["CidrIp"] = self.cidrIp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrIp") {
                self.cidrIp = dict["CidrIp"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ClientType : Tea.TeaModel {
        public var clientType: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientType != nil {
                map["ClientType"] = self.clientType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientType") {
                self.clientType = dict["ClientType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class DeviceRedirects : Tea.TeaModel {
        public var deviceType: String?

        public var redirectType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceType != nil {
                map["DeviceType"] = self.deviceType!
            }
            if self.redirectType != nil {
                map["RedirectType"] = self.redirectType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceType") {
                self.deviceType = dict["DeviceType"] as! String
            }
            if dict.keys.contains("RedirectType") {
                self.redirectType = dict["RedirectType"] as! String
            }
        }
    }
    public class DeviceRules : Tea.TeaModel {
        public var deviceName: String?

        public var devicePid: String?

        public var deviceType: String?

        public var deviceVid: String?

        public var optCommand: String?

        public var redirectType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceName != nil {
                map["DeviceName"] = self.deviceName!
            }
            if self.devicePid != nil {
                map["DevicePid"] = self.devicePid!
            }
            if self.deviceType != nil {
                map["DeviceType"] = self.deviceType!
            }
            if self.deviceVid != nil {
                map["DeviceVid"] = self.deviceVid!
            }
            if self.optCommand != nil {
                map["OptCommand"] = self.optCommand!
            }
            if self.redirectType != nil {
                map["RedirectType"] = self.redirectType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceName") {
                self.deviceName = dict["DeviceName"] as! String
            }
            if dict.keys.contains("DevicePid") {
                self.devicePid = dict["DevicePid"] as! String
            }
            if dict.keys.contains("DeviceType") {
                self.deviceType = dict["DeviceType"] as! String
            }
            if dict.keys.contains("DeviceVid") {
                self.deviceVid = dict["DeviceVid"] as! String
            }
            if dict.keys.contains("OptCommand") {
                self.optCommand = dict["OptCommand"] as! String
            }
            if dict.keys.contains("RedirectType") {
                self.redirectType = dict["RedirectType"] as! String
            }
        }
    }
    public class DomainResolveRule : Tea.TeaModel {
        public var description_: String?

        public var domain: String?

        public var policy: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
        }
    }
    public class NetRedirectRule : Tea.TeaModel {
        public var domain: String?

        public var policy: String?

        public var ruleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.ruleType != nil {
                map["RuleType"] = self.ruleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("RuleType") {
                self.ruleType = dict["RuleType"] as! String
            }
        }
    }
    public class RevokeAccessPolicyRule : Tea.TeaModel {
        public var cidrIp: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrIp != nil {
                map["CidrIp"] = self.cidrIp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrIp") {
                self.cidrIp = dict["CidrIp"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
        }
    }
    public class RevokeSecurityPolicyRule : Tea.TeaModel {
        public var cidrIp: String?

        public var description_: String?

        public var ipProtocol: String?

        public var policy: String?

        public var portRange: String?

        public var priority: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrIp != nil {
                map["CidrIp"] = self.cidrIp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrIp") {
                self.cidrIp = dict["CidrIp"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class UsbSupplyRedirectRule : Tea.TeaModel {
        public var description_: String?

        public var productId: String?

        public var usbRedirectType: String?

        public var usbRuleType: String?

        public var vendorId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.productId != nil {
                map["ProductId"] = self.productId!
            }
            if self.usbRedirectType != nil {
                map["UsbRedirectType"] = self.usbRedirectType!
            }
            if self.usbRuleType != nil {
                map["UsbRuleType"] = self.usbRuleType!
            }
            if self.vendorId != nil {
                map["VendorId"] = self.vendorId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ProductId") {
                self.productId = dict["ProductId"] as! String
            }
            if dict.keys.contains("UsbRedirectType") {
                self.usbRedirectType = dict["UsbRedirectType"] as! String
            }
            if dict.keys.contains("UsbRuleType") {
                self.usbRuleType = dict["UsbRuleType"] as! String
            }
            if dict.keys.contains("VendorId") {
                self.vendorId = dict["VendorId"] as! String
            }
        }
    }
    public var adminAccess: String?

    public var appContentProtection: String?

    public var authorizeAccessPolicyRule: [ModifyCenterPolicyRequest.AuthorizeAccessPolicyRule]?

    public var authorizeSecurityPolicyRule: [ModifyCenterPolicyRequest.AuthorizeSecurityPolicyRule]?

    public var businessType: Int32?

    public var cameraRedirect: String?

    public var clientType: [ModifyCenterPolicyRequest.ClientType]?

    public var clipboard: String?

    public var colorEnhancement: String?

    public var cpuDownGradeDuration: Int32?

    public var cpuProcessors: [String]?

    public var cpuProtectedMode: String?

    public var cpuRateLimit: Int32?

    public var cpuSampleDuration: Int32?

    public var cpuSingleRateLimit: Int32?

    public var deviceConnectHint: String?

    public var deviceRedirects: [ModifyCenterPolicyRequest.DeviceRedirects]?

    public var deviceRules: [ModifyCenterPolicyRequest.DeviceRules]?

    public var disconnectKeepSession: String?

    public var disconnectKeepSessionTime: Int32?

    public var displayMode: String?

    public var domainResolveRule: [ModifyCenterPolicyRequest.DomainResolveRule]?

    public var domainResolveRuleType: String?

    public var enableSessionRateLimiting: String?

    public var endUserApplyAdminCoordinate: String?

    public var endUserGroupCoordinate: String?

    public var fileMigrate: String?

    public var gpuAcceleration: String?

    public var html5FileTransfer: String?

    public var internetCommunicationProtocol: String?

    public var localDrive: String?

    public var maxReconnectTime: Int32?

    public var memoryDownGradeDuration: Int32?

    public var memoryProcessors: [String]?

    public var memoryProtectedMode: String?

    public var memoryRateLimit: Int32?

    public var memorySampleDuration: Int32?

    public var memorySingleRateLimit: Int32?

    public var mobileRestart: String?

    public var mobileShutdown: String?

    public var name: String?

    public var netRedirect: String?

    public var netRedirectRule: [ModifyCenterPolicyRequest.NetRedirectRule]?

    public var noOperationDisconnect: String?

    public var noOperationDisconnectTime: Int32?

    public var policyGroupId: String?

    public var printerRedirect: String?

    public var qualityEnhancement: String?

    public var recordEventDuration: Int32?

    public var recordEventFilePaths: [String]?

    public var recordEventRegisters: [String]?

    public var recordEvents: [String]?

    public var recording: String?

    public var recordingAudio: String?

    public var recordingDuration: Int32?

    public var recordingEndTime: String?

    public var recordingExpires: Int32?

    public var recordingFps: String?

    public var recordingStartTime: String?

    public var recordingUserNotify: String?

    public var recordingUserNotifyMessage: String?

    public var regionId: String?

    public var remoteCoordinate: String?

    public var resetDesktop: String?

    public var resolutionHeight: Int32?

    public var resolutionModel: String?

    public var resolutionWidth: Int32?

    public var resourceType: String?

    public var revokeAccessPolicyRule: [ModifyCenterPolicyRequest.RevokeAccessPolicyRule]?

    public var revokeSecurityPolicyRule: [ModifyCenterPolicyRequest.RevokeSecurityPolicyRule]?

    public var scope: String?

    public var scopeValue: [String]?

    public var sessionMaxRateKbps: Int32?

    public var smoothEnhancement: String?

    public var statusMonitor: String?

    public var streamingMode: String?

    public var targetFps: Int32?

    public var taskbar: String?

    public var usbRedirect: String?

    public var usbSupplyRedirectRule: [ModifyCenterPolicyRequest.UsbSupplyRedirectRule]?

    public var videoEncAvgKbps: Int32?

    public var videoEncMaxQP: Int32?

    public var videoEncMinQP: Int32?

    public var videoEncPeakKbps: Int32?

    public var videoEncPolicy: String?

    public var videoRedirect: String?

    public var visualQuality: String?

    public var watermark: String?

    public var watermarkAntiCam: String?

    public var watermarkColor: Int32?

    public var watermarkColumnAmount: Int32?

    public var watermarkCustomText: String?

    public var watermarkDegree: Double?

    public var watermarkFontSize: Int32?

    public var watermarkFontStyle: String?

    public var watermarkPower: String?

    public var watermarkRowAmount: Int32?

    public var watermarkSecurity: String?

    public var watermarkTransparencyValue: Int32?

    public var watermarkType: String?

    public var wuyingKeeper: String?

    public var wyAssistant: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adminAccess != nil {
            map["AdminAccess"] = self.adminAccess!
        }
        if self.appContentProtection != nil {
            map["AppContentProtection"] = self.appContentProtection!
        }
        if self.authorizeAccessPolicyRule != nil {
            var tmp : [Any] = []
            for k in self.authorizeAccessPolicyRule! {
                tmp.append(k.toMap())
            }
            map["AuthorizeAccessPolicyRule"] = tmp
        }
        if self.authorizeSecurityPolicyRule != nil {
            var tmp : [Any] = []
            for k in self.authorizeSecurityPolicyRule! {
                tmp.append(k.toMap())
            }
            map["AuthorizeSecurityPolicyRule"] = tmp
        }
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.cameraRedirect != nil {
            map["CameraRedirect"] = self.cameraRedirect!
        }
        if self.clientType != nil {
            var tmp : [Any] = []
            for k in self.clientType! {
                tmp.append(k.toMap())
            }
            map["ClientType"] = tmp
        }
        if self.clipboard != nil {
            map["Clipboard"] = self.clipboard!
        }
        if self.colorEnhancement != nil {
            map["ColorEnhancement"] = self.colorEnhancement!
        }
        if self.cpuDownGradeDuration != nil {
            map["CpuDownGradeDuration"] = self.cpuDownGradeDuration!
        }
        if self.cpuProcessors != nil {
            map["CpuProcessors"] = self.cpuProcessors!
        }
        if self.cpuProtectedMode != nil {
            map["CpuProtectedMode"] = self.cpuProtectedMode!
        }
        if self.cpuRateLimit != nil {
            map["CpuRateLimit"] = self.cpuRateLimit!
        }
        if self.cpuSampleDuration != nil {
            map["CpuSampleDuration"] = self.cpuSampleDuration!
        }
        if self.cpuSingleRateLimit != nil {
            map["CpuSingleRateLimit"] = self.cpuSingleRateLimit!
        }
        if self.deviceConnectHint != nil {
            map["DeviceConnectHint"] = self.deviceConnectHint!
        }
        if self.deviceRedirects != nil {
            var tmp : [Any] = []
            for k in self.deviceRedirects! {
                tmp.append(k.toMap())
            }
            map["DeviceRedirects"] = tmp
        }
        if self.deviceRules != nil {
            var tmp : [Any] = []
            for k in self.deviceRules! {
                tmp.append(k.toMap())
            }
            map["DeviceRules"] = tmp
        }
        if self.disconnectKeepSession != nil {
            map["DisconnectKeepSession"] = self.disconnectKeepSession!
        }
        if self.disconnectKeepSessionTime != nil {
            map["DisconnectKeepSessionTime"] = self.disconnectKeepSessionTime!
        }
        if self.displayMode != nil {
            map["DisplayMode"] = self.displayMode!
        }
        if self.domainResolveRule != nil {
            var tmp : [Any] = []
            for k in self.domainResolveRule! {
                tmp.append(k.toMap())
            }
            map["DomainResolveRule"] = tmp
        }
        if self.domainResolveRuleType != nil {
            map["DomainResolveRuleType"] = self.domainResolveRuleType!
        }
        if self.enableSessionRateLimiting != nil {
            map["EnableSessionRateLimiting"] = self.enableSessionRateLimiting!
        }
        if self.endUserApplyAdminCoordinate != nil {
            map["EndUserApplyAdminCoordinate"] = self.endUserApplyAdminCoordinate!
        }
        if self.endUserGroupCoordinate != nil {
            map["EndUserGroupCoordinate"] = self.endUserGroupCoordinate!
        }
        if self.fileMigrate != nil {
            map["FileMigrate"] = self.fileMigrate!
        }
        if self.gpuAcceleration != nil {
            map["GpuAcceleration"] = self.gpuAcceleration!
        }
        if self.html5FileTransfer != nil {
            map["Html5FileTransfer"] = self.html5FileTransfer!
        }
        if self.internetCommunicationProtocol != nil {
            map["InternetCommunicationProtocol"] = self.internetCommunicationProtocol!
        }
        if self.localDrive != nil {
            map["LocalDrive"] = self.localDrive!
        }
        if self.maxReconnectTime != nil {
            map["MaxReconnectTime"] = self.maxReconnectTime!
        }
        if self.memoryDownGradeDuration != nil {
            map["MemoryDownGradeDuration"] = self.memoryDownGradeDuration!
        }
        if self.memoryProcessors != nil {
            map["MemoryProcessors"] = self.memoryProcessors!
        }
        if self.memoryProtectedMode != nil {
            map["MemoryProtectedMode"] = self.memoryProtectedMode!
        }
        if self.memoryRateLimit != nil {
            map["MemoryRateLimit"] = self.memoryRateLimit!
        }
        if self.memorySampleDuration != nil {
            map["MemorySampleDuration"] = self.memorySampleDuration!
        }
        if self.memorySingleRateLimit != nil {
            map["MemorySingleRateLimit"] = self.memorySingleRateLimit!
        }
        if self.mobileRestart != nil {
            map["MobileRestart"] = self.mobileRestart!
        }
        if self.mobileShutdown != nil {
            map["MobileShutdown"] = self.mobileShutdown!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.netRedirect != nil {
            map["NetRedirect"] = self.netRedirect!
        }
        if self.netRedirectRule != nil {
            var tmp : [Any] = []
            for k in self.netRedirectRule! {
                tmp.append(k.toMap())
            }
            map["NetRedirectRule"] = tmp
        }
        if self.noOperationDisconnect != nil {
            map["NoOperationDisconnect"] = self.noOperationDisconnect!
        }
        if self.noOperationDisconnectTime != nil {
            map["NoOperationDisconnectTime"] = self.noOperationDisconnectTime!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.printerRedirect != nil {
            map["PrinterRedirect"] = self.printerRedirect!
        }
        if self.qualityEnhancement != nil {
            map["QualityEnhancement"] = self.qualityEnhancement!
        }
        if self.recordEventDuration != nil {
            map["RecordEventDuration"] = self.recordEventDuration!
        }
        if self.recordEventFilePaths != nil {
            map["RecordEventFilePaths"] = self.recordEventFilePaths!
        }
        if self.recordEventRegisters != nil {
            map["RecordEventRegisters"] = self.recordEventRegisters!
        }
        if self.recordEvents != nil {
            map["RecordEvents"] = self.recordEvents!
        }
        if self.recording != nil {
            map["Recording"] = self.recording!
        }
        if self.recordingAudio != nil {
            map["RecordingAudio"] = self.recordingAudio!
        }
        if self.recordingDuration != nil {
            map["RecordingDuration"] = self.recordingDuration!
        }
        if self.recordingEndTime != nil {
            map["RecordingEndTime"] = self.recordingEndTime!
        }
        if self.recordingExpires != nil {
            map["RecordingExpires"] = self.recordingExpires!
        }
        if self.recordingFps != nil {
            map["RecordingFps"] = self.recordingFps!
        }
        if self.recordingStartTime != nil {
            map["RecordingStartTime"] = self.recordingStartTime!
        }
        if self.recordingUserNotify != nil {
            map["RecordingUserNotify"] = self.recordingUserNotify!
        }
        if self.recordingUserNotifyMessage != nil {
            map["RecordingUserNotifyMessage"] = self.recordingUserNotifyMessage!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteCoordinate != nil {
            map["RemoteCoordinate"] = self.remoteCoordinate!
        }
        if self.resetDesktop != nil {
            map["ResetDesktop"] = self.resetDesktop!
        }
        if self.resolutionHeight != nil {
            map["ResolutionHeight"] = self.resolutionHeight!
        }
        if self.resolutionModel != nil {
            map["ResolutionModel"] = self.resolutionModel!
        }
        if self.resolutionWidth != nil {
            map["ResolutionWidth"] = self.resolutionWidth!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.revokeAccessPolicyRule != nil {
            var tmp : [Any] = []
            for k in self.revokeAccessPolicyRule! {
                tmp.append(k.toMap())
            }
            map["RevokeAccessPolicyRule"] = tmp
        }
        if self.revokeSecurityPolicyRule != nil {
            var tmp : [Any] = []
            for k in self.revokeSecurityPolicyRule! {
                tmp.append(k.toMap())
            }
            map["RevokeSecurityPolicyRule"] = tmp
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.scopeValue != nil {
            map["ScopeValue"] = self.scopeValue!
        }
        if self.sessionMaxRateKbps != nil {
            map["SessionMaxRateKbps"] = self.sessionMaxRateKbps!
        }
        if self.smoothEnhancement != nil {
            map["SmoothEnhancement"] = self.smoothEnhancement!
        }
        if self.statusMonitor != nil {
            map["StatusMonitor"] = self.statusMonitor!
        }
        if self.streamingMode != nil {
            map["StreamingMode"] = self.streamingMode!
        }
        if self.targetFps != nil {
            map["TargetFps"] = self.targetFps!
        }
        if self.taskbar != nil {
            map["Taskbar"] = self.taskbar!
        }
        if self.usbRedirect != nil {
            map["UsbRedirect"] = self.usbRedirect!
        }
        if self.usbSupplyRedirectRule != nil {
            var tmp : [Any] = []
            for k in self.usbSupplyRedirectRule! {
                tmp.append(k.toMap())
            }
            map["UsbSupplyRedirectRule"] = tmp
        }
        if self.videoEncAvgKbps != nil {
            map["VideoEncAvgKbps"] = self.videoEncAvgKbps!
        }
        if self.videoEncMaxQP != nil {
            map["VideoEncMaxQP"] = self.videoEncMaxQP!
        }
        if self.videoEncMinQP != nil {
            map["VideoEncMinQP"] = self.videoEncMinQP!
        }
        if self.videoEncPeakKbps != nil {
            map["VideoEncPeakKbps"] = self.videoEncPeakKbps!
        }
        if self.videoEncPolicy != nil {
            map["VideoEncPolicy"] = self.videoEncPolicy!
        }
        if self.videoRedirect != nil {
            map["VideoRedirect"] = self.videoRedirect!
        }
        if self.visualQuality != nil {
            map["VisualQuality"] = self.visualQuality!
        }
        if self.watermark != nil {
            map["Watermark"] = self.watermark!
        }
        if self.watermarkAntiCam != nil {
            map["WatermarkAntiCam"] = self.watermarkAntiCam!
        }
        if self.watermarkColor != nil {
            map["WatermarkColor"] = self.watermarkColor!
        }
        if self.watermarkColumnAmount != nil {
            map["WatermarkColumnAmount"] = self.watermarkColumnAmount!
        }
        if self.watermarkCustomText != nil {
            map["WatermarkCustomText"] = self.watermarkCustomText!
        }
        if self.watermarkDegree != nil {
            map["WatermarkDegree"] = self.watermarkDegree!
        }
        if self.watermarkFontSize != nil {
            map["WatermarkFontSize"] = self.watermarkFontSize!
        }
        if self.watermarkFontStyle != nil {
            map["WatermarkFontStyle"] = self.watermarkFontStyle!
        }
        if self.watermarkPower != nil {
            map["WatermarkPower"] = self.watermarkPower!
        }
        if self.watermarkRowAmount != nil {
            map["WatermarkRowAmount"] = self.watermarkRowAmount!
        }
        if self.watermarkSecurity != nil {
            map["WatermarkSecurity"] = self.watermarkSecurity!
        }
        if self.watermarkTransparencyValue != nil {
            map["WatermarkTransparencyValue"] = self.watermarkTransparencyValue!
        }
        if self.watermarkType != nil {
            map["WatermarkType"] = self.watermarkType!
        }
        if self.wuyingKeeper != nil {
            map["WuyingKeeper"] = self.wuyingKeeper!
        }
        if self.wyAssistant != nil {
            map["WyAssistant"] = self.wyAssistant!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdminAccess") {
            self.adminAccess = dict["AdminAccess"] as! String
        }
        if dict.keys.contains("AppContentProtection") {
            self.appContentProtection = dict["AppContentProtection"] as! String
        }
        if dict.keys.contains("AuthorizeAccessPolicyRule") {
            var tmp : [ModifyCenterPolicyRequest.AuthorizeAccessPolicyRule] = []
            for v in dict["AuthorizeAccessPolicyRule"] as! [Any] {
                var model = ModifyCenterPolicyRequest.AuthorizeAccessPolicyRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.authorizeAccessPolicyRule = tmp
        }
        if dict.keys.contains("AuthorizeSecurityPolicyRule") {
            var tmp : [ModifyCenterPolicyRequest.AuthorizeSecurityPolicyRule] = []
            for v in dict["AuthorizeSecurityPolicyRule"] as! [Any] {
                var model = ModifyCenterPolicyRequest.AuthorizeSecurityPolicyRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.authorizeSecurityPolicyRule = tmp
        }
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! Int32
        }
        if dict.keys.contains("CameraRedirect") {
            self.cameraRedirect = dict["CameraRedirect"] as! String
        }
        if dict.keys.contains("ClientType") {
            var tmp : [ModifyCenterPolicyRequest.ClientType] = []
            for v in dict["ClientType"] as! [Any] {
                var model = ModifyCenterPolicyRequest.ClientType()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.clientType = tmp
        }
        if dict.keys.contains("Clipboard") {
            self.clipboard = dict["Clipboard"] as! String
        }
        if dict.keys.contains("ColorEnhancement") {
            self.colorEnhancement = dict["ColorEnhancement"] as! String
        }
        if dict.keys.contains("CpuDownGradeDuration") {
            self.cpuDownGradeDuration = dict["CpuDownGradeDuration"] as! Int32
        }
        if dict.keys.contains("CpuProcessors") {
            self.cpuProcessors = dict["CpuProcessors"] as! [String]
        }
        if dict.keys.contains("CpuProtectedMode") {
            self.cpuProtectedMode = dict["CpuProtectedMode"] as! String
        }
        if dict.keys.contains("CpuRateLimit") {
            self.cpuRateLimit = dict["CpuRateLimit"] as! Int32
        }
        if dict.keys.contains("CpuSampleDuration") {
            self.cpuSampleDuration = dict["CpuSampleDuration"] as! Int32
        }
        if dict.keys.contains("CpuSingleRateLimit") {
            self.cpuSingleRateLimit = dict["CpuSingleRateLimit"] as! Int32
        }
        if dict.keys.contains("DeviceConnectHint") {
            self.deviceConnectHint = dict["DeviceConnectHint"] as! String
        }
        if dict.keys.contains("DeviceRedirects") {
            var tmp : [ModifyCenterPolicyRequest.DeviceRedirects] = []
            for v in dict["DeviceRedirects"] as! [Any] {
                var model = ModifyCenterPolicyRequest.DeviceRedirects()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deviceRedirects = tmp
        }
        if dict.keys.contains("DeviceRules") {
            var tmp : [ModifyCenterPolicyRequest.DeviceRules] = []
            for v in dict["DeviceRules"] as! [Any] {
                var model = ModifyCenterPolicyRequest.DeviceRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deviceRules = tmp
        }
        if dict.keys.contains("DisconnectKeepSession") {
            self.disconnectKeepSession = dict["DisconnectKeepSession"] as! String
        }
        if dict.keys.contains("DisconnectKeepSessionTime") {
            self.disconnectKeepSessionTime = dict["DisconnectKeepSessionTime"] as! Int32
        }
        if dict.keys.contains("DisplayMode") {
            self.displayMode = dict["DisplayMode"] as! String
        }
        if dict.keys.contains("DomainResolveRule") {
            var tmp : [ModifyCenterPolicyRequest.DomainResolveRule] = []
            for v in dict["DomainResolveRule"] as! [Any] {
                var model = ModifyCenterPolicyRequest.DomainResolveRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.domainResolveRule = tmp
        }
        if dict.keys.contains("DomainResolveRuleType") {
            self.domainResolveRuleType = dict["DomainResolveRuleType"] as! String
        }
        if dict.keys.contains("EnableSessionRateLimiting") {
            self.enableSessionRateLimiting = dict["EnableSessionRateLimiting"] as! String
        }
        if dict.keys.contains("EndUserApplyAdminCoordinate") {
            self.endUserApplyAdminCoordinate = dict["EndUserApplyAdminCoordinate"] as! String
        }
        if dict.keys.contains("EndUserGroupCoordinate") {
            self.endUserGroupCoordinate = dict["EndUserGroupCoordinate"] as! String
        }
        if dict.keys.contains("FileMigrate") {
            self.fileMigrate = dict["FileMigrate"] as! String
        }
        if dict.keys.contains("GpuAcceleration") {
            self.gpuAcceleration = dict["GpuAcceleration"] as! String
        }
        if dict.keys.contains("Html5FileTransfer") {
            self.html5FileTransfer = dict["Html5FileTransfer"] as! String
        }
        if dict.keys.contains("InternetCommunicationProtocol") {
            self.internetCommunicationProtocol = dict["InternetCommunicationProtocol"] as! String
        }
        if dict.keys.contains("LocalDrive") {
            self.localDrive = dict["LocalDrive"] as! String
        }
        if dict.keys.contains("MaxReconnectTime") {
            self.maxReconnectTime = dict["MaxReconnectTime"] as! Int32
        }
        if dict.keys.contains("MemoryDownGradeDuration") {
            self.memoryDownGradeDuration = dict["MemoryDownGradeDuration"] as! Int32
        }
        if dict.keys.contains("MemoryProcessors") {
            self.memoryProcessors = dict["MemoryProcessors"] as! [String]
        }
        if dict.keys.contains("MemoryProtectedMode") {
            self.memoryProtectedMode = dict["MemoryProtectedMode"] as! String
        }
        if dict.keys.contains("MemoryRateLimit") {
            self.memoryRateLimit = dict["MemoryRateLimit"] as! Int32
        }
        if dict.keys.contains("MemorySampleDuration") {
            self.memorySampleDuration = dict["MemorySampleDuration"] as! Int32
        }
        if dict.keys.contains("MemorySingleRateLimit") {
            self.memorySingleRateLimit = dict["MemorySingleRateLimit"] as! Int32
        }
        if dict.keys.contains("MobileRestart") {
            self.mobileRestart = dict["MobileRestart"] as! String
        }
        if dict.keys.contains("MobileShutdown") {
            self.mobileShutdown = dict["MobileShutdown"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NetRedirect") {
            self.netRedirect = dict["NetRedirect"] as! String
        }
        if dict.keys.contains("NetRedirectRule") {
            var tmp : [ModifyCenterPolicyRequest.NetRedirectRule] = []
            for v in dict["NetRedirectRule"] as! [Any] {
                var model = ModifyCenterPolicyRequest.NetRedirectRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.netRedirectRule = tmp
        }
        if dict.keys.contains("NoOperationDisconnect") {
            self.noOperationDisconnect = dict["NoOperationDisconnect"] as! String
        }
        if dict.keys.contains("NoOperationDisconnectTime") {
            self.noOperationDisconnectTime = dict["NoOperationDisconnectTime"] as! Int32
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("PrinterRedirect") {
            self.printerRedirect = dict["PrinterRedirect"] as! String
        }
        if dict.keys.contains("QualityEnhancement") {
            self.qualityEnhancement = dict["QualityEnhancement"] as! String
        }
        if dict.keys.contains("RecordEventDuration") {
            self.recordEventDuration = dict["RecordEventDuration"] as! Int32
        }
        if dict.keys.contains("RecordEventFilePaths") {
            self.recordEventFilePaths = dict["RecordEventFilePaths"] as! [String]
        }
        if dict.keys.contains("RecordEventRegisters") {
            self.recordEventRegisters = dict["RecordEventRegisters"] as! [String]
        }
        if dict.keys.contains("RecordEvents") {
            self.recordEvents = dict["RecordEvents"] as! [String]
        }
        if dict.keys.contains("Recording") {
            self.recording = dict["Recording"] as! String
        }
        if dict.keys.contains("RecordingAudio") {
            self.recordingAudio = dict["RecordingAudio"] as! String
        }
        if dict.keys.contains("RecordingDuration") {
            self.recordingDuration = dict["RecordingDuration"] as! Int32
        }
        if dict.keys.contains("RecordingEndTime") {
            self.recordingEndTime = dict["RecordingEndTime"] as! String
        }
        if dict.keys.contains("RecordingExpires") {
            self.recordingExpires = dict["RecordingExpires"] as! Int32
        }
        if dict.keys.contains("RecordingFps") {
            self.recordingFps = dict["RecordingFps"] as! String
        }
        if dict.keys.contains("RecordingStartTime") {
            self.recordingStartTime = dict["RecordingStartTime"] as! String
        }
        if dict.keys.contains("RecordingUserNotify") {
            self.recordingUserNotify = dict["RecordingUserNotify"] as! String
        }
        if dict.keys.contains("RecordingUserNotifyMessage") {
            self.recordingUserNotifyMessage = dict["RecordingUserNotifyMessage"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoteCoordinate") {
            self.remoteCoordinate = dict["RemoteCoordinate"] as! String
        }
        if dict.keys.contains("ResetDesktop") {
            self.resetDesktop = dict["ResetDesktop"] as! String
        }
        if dict.keys.contains("ResolutionHeight") {
            self.resolutionHeight = dict["ResolutionHeight"] as! Int32
        }
        if dict.keys.contains("ResolutionModel") {
            self.resolutionModel = dict["ResolutionModel"] as! String
        }
        if dict.keys.contains("ResolutionWidth") {
            self.resolutionWidth = dict["ResolutionWidth"] as! Int32
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("RevokeAccessPolicyRule") {
            var tmp : [ModifyCenterPolicyRequest.RevokeAccessPolicyRule] = []
            for v in dict["RevokeAccessPolicyRule"] as! [Any] {
                var model = ModifyCenterPolicyRequest.RevokeAccessPolicyRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.revokeAccessPolicyRule = tmp
        }
        if dict.keys.contains("RevokeSecurityPolicyRule") {
            var tmp : [ModifyCenterPolicyRequest.RevokeSecurityPolicyRule] = []
            for v in dict["RevokeSecurityPolicyRule"] as! [Any] {
                var model = ModifyCenterPolicyRequest.RevokeSecurityPolicyRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.revokeSecurityPolicyRule = tmp
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("ScopeValue") {
            self.scopeValue = dict["ScopeValue"] as! [String]
        }
        if dict.keys.contains("SessionMaxRateKbps") {
            self.sessionMaxRateKbps = dict["SessionMaxRateKbps"] as! Int32
        }
        if dict.keys.contains("SmoothEnhancement") {
            self.smoothEnhancement = dict["SmoothEnhancement"] as! String
        }
        if dict.keys.contains("StatusMonitor") {
            self.statusMonitor = dict["StatusMonitor"] as! String
        }
        if dict.keys.contains("StreamingMode") {
            self.streamingMode = dict["StreamingMode"] as! String
        }
        if dict.keys.contains("TargetFps") {
            self.targetFps = dict["TargetFps"] as! Int32
        }
        if dict.keys.contains("Taskbar") {
            self.taskbar = dict["Taskbar"] as! String
        }
        if dict.keys.contains("UsbRedirect") {
            self.usbRedirect = dict["UsbRedirect"] as! String
        }
        if dict.keys.contains("UsbSupplyRedirectRule") {
            var tmp : [ModifyCenterPolicyRequest.UsbSupplyRedirectRule] = []
            for v in dict["UsbSupplyRedirectRule"] as! [Any] {
                var model = ModifyCenterPolicyRequest.UsbSupplyRedirectRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.usbSupplyRedirectRule = tmp
        }
        if dict.keys.contains("VideoEncAvgKbps") {
            self.videoEncAvgKbps = dict["VideoEncAvgKbps"] as! Int32
        }
        if dict.keys.contains("VideoEncMaxQP") {
            self.videoEncMaxQP = dict["VideoEncMaxQP"] as! Int32
        }
        if dict.keys.contains("VideoEncMinQP") {
            self.videoEncMinQP = dict["VideoEncMinQP"] as! Int32
        }
        if dict.keys.contains("VideoEncPeakKbps") {
            self.videoEncPeakKbps = dict["VideoEncPeakKbps"] as! Int32
        }
        if dict.keys.contains("VideoEncPolicy") {
            self.videoEncPolicy = dict["VideoEncPolicy"] as! String
        }
        if dict.keys.contains("VideoRedirect") {
            self.videoRedirect = dict["VideoRedirect"] as! String
        }
        if dict.keys.contains("VisualQuality") {
            self.visualQuality = dict["VisualQuality"] as! String
        }
        if dict.keys.contains("Watermark") {
            self.watermark = dict["Watermark"] as! String
        }
        if dict.keys.contains("WatermarkAntiCam") {
            self.watermarkAntiCam = dict["WatermarkAntiCam"] as! String
        }
        if dict.keys.contains("WatermarkColor") {
            self.watermarkColor = dict["WatermarkColor"] as! Int32
        }
        if dict.keys.contains("WatermarkColumnAmount") {
            self.watermarkColumnAmount = dict["WatermarkColumnAmount"] as! Int32
        }
        if dict.keys.contains("WatermarkCustomText") {
            self.watermarkCustomText = dict["WatermarkCustomText"] as! String
        }
        if dict.keys.contains("WatermarkDegree") {
            self.watermarkDegree = dict["WatermarkDegree"] as! Double
        }
        if dict.keys.contains("WatermarkFontSize") {
            self.watermarkFontSize = dict["WatermarkFontSize"] as! Int32
        }
        if dict.keys.contains("WatermarkFontStyle") {
            self.watermarkFontStyle = dict["WatermarkFontStyle"] as! String
        }
        if dict.keys.contains("WatermarkPower") {
            self.watermarkPower = dict["WatermarkPower"] as! String
        }
        if dict.keys.contains("WatermarkRowAmount") {
            self.watermarkRowAmount = dict["WatermarkRowAmount"] as! Int32
        }
        if dict.keys.contains("WatermarkSecurity") {
            self.watermarkSecurity = dict["WatermarkSecurity"] as! String
        }
        if dict.keys.contains("WatermarkTransparencyValue") {
            self.watermarkTransparencyValue = dict["WatermarkTransparencyValue"] as! Int32
        }
        if dict.keys.contains("WatermarkType") {
            self.watermarkType = dict["WatermarkType"] as! String
        }
        if dict.keys.contains("WuyingKeeper") {
            self.wuyingKeeper = dict["WuyingKeeper"] as! String
        }
        if dict.keys.contains("WyAssistant") {
            self.wyAssistant = dict["WyAssistant"] as! String
        }
    }
}

public class ModifyCenterPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCenterPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCenterPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCenterPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCloudDriveGroupsRequest : Tea.TeaModel {
    public var cdsId: String?

    public var groupId: [String]?

    public var regionId: String?

    public var status: String?

    public var totalSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.totalSize != nil {
            map["TotalSize"] = self.totalSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TotalSize") {
            self.totalSize = dict["TotalSize"] as! Int64
        }
    }
}

public class ModifyCloudDriveGroupsResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyCloudDriveGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCloudDriveGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCloudDriveGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCloudDrivePermissionRequest : Tea.TeaModel {
    public var cdsId: String?

    public var downloadEndUserIds: [String]?

    public var downloadUploadEndUserIds: [String]?

    public var noDownloadNoUploadEndUserIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.downloadEndUserIds != nil {
            map["DownloadEndUserIds"] = self.downloadEndUserIds!
        }
        if self.downloadUploadEndUserIds != nil {
            map["DownloadUploadEndUserIds"] = self.downloadUploadEndUserIds!
        }
        if self.noDownloadNoUploadEndUserIds != nil {
            map["NoDownloadNoUploadEndUserIds"] = self.noDownloadNoUploadEndUserIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("DownloadEndUserIds") {
            self.downloadEndUserIds = dict["DownloadEndUserIds"] as! [String]
        }
        if dict.keys.contains("DownloadUploadEndUserIds") {
            self.downloadUploadEndUserIds = dict["DownloadUploadEndUserIds"] as! [String]
        }
        if dict.keys.contains("NoDownloadNoUploadEndUserIds") {
            self.noDownloadNoUploadEndUserIds = dict["NoDownloadNoUploadEndUserIds"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyCloudDrivePermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCloudDrivePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCloudDrivePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCloudDrivePermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCloudDriveUsersRequest : Tea.TeaModel {
    public var cdsId: String?

    public var endUserId: [String]?

    public var regionId: String?

    public var status: String?

    public var userMaxSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.userMaxSize != nil {
            map["UserMaxSize"] = self.userMaxSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UserMaxSize") {
            self.userMaxSize = dict["UserMaxSize"] as! Int64
        }
    }
}

public class ModifyCloudDriveUsersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCloudDriveUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCloudDriveUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCloudDriveUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyConfigGroupRequest : Tea.TeaModel {
    public var description_: String?

    public var groupId: String?

    public var name: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyConfigGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyConfigGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyConfigGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyConfigGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCustomizedListHeadersRequest : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var displayType: String?

        public var headerKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayType != nil {
                map["DisplayType"] = self.displayType!
            }
            if self.headerKey != nil {
                map["HeaderKey"] = self.headerKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayType") {
                self.displayType = dict["DisplayType"] as! String
            }
            if dict.keys.contains("HeaderKey") {
                self.headerKey = dict["HeaderKey"] as! String
            }
        }
    }
    public var headers: [ModifyCustomizedListHeadersRequest.Headers]?

    public var listType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            var tmp : [Any] = []
            for k in self.headers! {
                tmp.append(k.toMap())
            }
            map["Headers"] = tmp
        }
        if self.listType != nil {
            map["ListType"] = self.listType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var tmp : [ModifyCustomizedListHeadersRequest.Headers] = []
            for v in dict["Headers"] as! [Any] {
                var model = ModifyCustomizedListHeadersRequest.Headers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.headers = tmp
        }
        if dict.keys.contains("ListType") {
            self.listType = dict["ListType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyCustomizedListHeadersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCustomizedListHeadersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCustomizedListHeadersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCustomizedListHeadersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDesktopChargeTypeRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var chargeType: String?

    public var desktopId: [String]?

    public var period: Int32?

    public var periodUnit: String?

    public var promotionId: String?

    public var regionId: String?

    public var useDuration: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.promotionId != nil {
            map["PromotionId"] = self.promotionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.useDuration != nil {
            map["UseDuration"] = self.useDuration!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PromotionId") {
            self.promotionId = dict["PromotionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("UseDuration") {
            self.useDuration = dict["UseDuration"] as! Int32
        }
    }
}

public class ModifyDesktopChargeTypeResponseBody : Tea.TeaModel {
    public var desktopId: [String]?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDesktopChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDesktopChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDesktopChargeTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDesktopGroupRequest : Tea.TeaModel {
    public var allowAutoSetup: Int32?

    public var allowBufferCount: Int32?

    public var bindAmount: Int64?

    public var buyDesktopsCount: Int32?

    public var classify: String?

    public var comments: String?

    public var connectDuration: Int64?

    public var desktopGroupId: String?

    public var desktopGroupName: String?

    public var disableSessionConfig: Bool?

    public var fileSystemId: String?

    public var idleDisconnectDuration: Int64?

    public var imageId: String?

    public var keepDuration: Int64?

    public var loadPolicy: Int64?

    public var maxDesktopsCount: Int32?

    public var minDesktopsCount: Int32?

    public var ownBundleId: String?

    public var policyGroupId: String?

    public var policyGroupIds: [String]?

    public var profileFollowSwitch: Bool?

    public var ratioThreshold: Double?

    public var regionId: String?

    public var resetType: Int64?

    public var scaleStrategyId: String?

    public var stopDuration: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowAutoSetup != nil {
            map["AllowAutoSetup"] = self.allowAutoSetup!
        }
        if self.allowBufferCount != nil {
            map["AllowBufferCount"] = self.allowBufferCount!
        }
        if self.bindAmount != nil {
            map["BindAmount"] = self.bindAmount!
        }
        if self.buyDesktopsCount != nil {
            map["BuyDesktopsCount"] = self.buyDesktopsCount!
        }
        if self.classify != nil {
            map["Classify"] = self.classify!
        }
        if self.comments != nil {
            map["Comments"] = self.comments!
        }
        if self.connectDuration != nil {
            map["ConnectDuration"] = self.connectDuration!
        }
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.desktopGroupName != nil {
            map["DesktopGroupName"] = self.desktopGroupName!
        }
        if self.disableSessionConfig != nil {
            map["DisableSessionConfig"] = self.disableSessionConfig!
        }
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        if self.idleDisconnectDuration != nil {
            map["IdleDisconnectDuration"] = self.idleDisconnectDuration!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.keepDuration != nil {
            map["KeepDuration"] = self.keepDuration!
        }
        if self.loadPolicy != nil {
            map["LoadPolicy"] = self.loadPolicy!
        }
        if self.maxDesktopsCount != nil {
            map["MaxDesktopsCount"] = self.maxDesktopsCount!
        }
        if self.minDesktopsCount != nil {
            map["MinDesktopsCount"] = self.minDesktopsCount!
        }
        if self.ownBundleId != nil {
            map["OwnBundleId"] = self.ownBundleId!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.policyGroupIds != nil {
            map["PolicyGroupIds"] = self.policyGroupIds!
        }
        if self.profileFollowSwitch != nil {
            map["ProfileFollowSwitch"] = self.profileFollowSwitch!
        }
        if self.ratioThreshold != nil {
            map["RatioThreshold"] = self.ratioThreshold!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resetType != nil {
            map["ResetType"] = self.resetType!
        }
        if self.scaleStrategyId != nil {
            map["ScaleStrategyId"] = self.scaleStrategyId!
        }
        if self.stopDuration != nil {
            map["StopDuration"] = self.stopDuration!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowAutoSetup") {
            self.allowAutoSetup = dict["AllowAutoSetup"] as! Int32
        }
        if dict.keys.contains("AllowBufferCount") {
            self.allowBufferCount = dict["AllowBufferCount"] as! Int32
        }
        if dict.keys.contains("BindAmount") {
            self.bindAmount = dict["BindAmount"] as! Int64
        }
        if dict.keys.contains("BuyDesktopsCount") {
            self.buyDesktopsCount = dict["BuyDesktopsCount"] as! Int32
        }
        if dict.keys.contains("Classify") {
            self.classify = dict["Classify"] as! String
        }
        if dict.keys.contains("Comments") {
            self.comments = dict["Comments"] as! String
        }
        if dict.keys.contains("ConnectDuration") {
            self.connectDuration = dict["ConnectDuration"] as! Int64
        }
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("DesktopGroupName") {
            self.desktopGroupName = dict["DesktopGroupName"] as! String
        }
        if dict.keys.contains("DisableSessionConfig") {
            self.disableSessionConfig = dict["DisableSessionConfig"] as! Bool
        }
        if dict.keys.contains("FileSystemId") {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
        if dict.keys.contains("IdleDisconnectDuration") {
            self.idleDisconnectDuration = dict["IdleDisconnectDuration"] as! Int64
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("KeepDuration") {
            self.keepDuration = dict["KeepDuration"] as! Int64
        }
        if dict.keys.contains("LoadPolicy") {
            self.loadPolicy = dict["LoadPolicy"] as! Int64
        }
        if dict.keys.contains("MaxDesktopsCount") {
            self.maxDesktopsCount = dict["MaxDesktopsCount"] as! Int32
        }
        if dict.keys.contains("MinDesktopsCount") {
            self.minDesktopsCount = dict["MinDesktopsCount"] as! Int32
        }
        if dict.keys.contains("OwnBundleId") {
            self.ownBundleId = dict["OwnBundleId"] as! String
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("PolicyGroupIds") {
            self.policyGroupIds = dict["PolicyGroupIds"] as! [String]
        }
        if dict.keys.contains("ProfileFollowSwitch") {
            self.profileFollowSwitch = dict["ProfileFollowSwitch"] as! Bool
        }
        if dict.keys.contains("RatioThreshold") {
            self.ratioThreshold = dict["RatioThreshold"] as! Double
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResetType") {
            self.resetType = dict["ResetType"] as! Int64
        }
        if dict.keys.contains("ScaleStrategyId") {
            self.scaleStrategyId = dict["ScaleStrategyId"] as! String
        }
        if dict.keys.contains("StopDuration") {
            self.stopDuration = dict["StopDuration"] as! Int64
        }
    }
}

public class ModifyDesktopGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDesktopGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDesktopGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDesktopGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDesktopHostNameRequest : Tea.TeaModel {
    public var desktopId: String?

    public var newHostName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.newHostName != nil {
            map["NewHostName"] = self.newHostName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("NewHostName") {
            self.newHostName = dict["NewHostName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyDesktopHostNameResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDesktopHostNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDesktopHostNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDesktopHostNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDesktopNameRequest : Tea.TeaModel {
    public var desktopId: String?

    public var newDesktopName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.newDesktopName != nil {
            map["NewDesktopName"] = self.newDesktopName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("NewDesktopName") {
            self.newDesktopName = dict["NewDesktopName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyDesktopNameResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDesktopNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDesktopNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDesktopNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDesktopOversoldGroupRequest : Tea.TeaModel {
    public var concurrenceCount: Int32?

    public var description_: String?

    public var idleDisconnectDuration: Int64?

    public var imageId: String?

    public var keepDuration: Int32?

    public var name: String?

    public var oversoldGroupId: String?

    public var oversoldUserCount: Int32?

    public var oversoldWarn: Int32?

    public var policyGroupId: String?

    public var stopDuration: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.concurrenceCount != nil {
            map["ConcurrenceCount"] = self.concurrenceCount!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.idleDisconnectDuration != nil {
            map["IdleDisconnectDuration"] = self.idleDisconnectDuration!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.keepDuration != nil {
            map["KeepDuration"] = self.keepDuration!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.oversoldGroupId != nil {
            map["OversoldGroupId"] = self.oversoldGroupId!
        }
        if self.oversoldUserCount != nil {
            map["OversoldUserCount"] = self.oversoldUserCount!
        }
        if self.oversoldWarn != nil {
            map["OversoldWarn"] = self.oversoldWarn!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.stopDuration != nil {
            map["StopDuration"] = self.stopDuration!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConcurrenceCount") {
            self.concurrenceCount = dict["ConcurrenceCount"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IdleDisconnectDuration") {
            self.idleDisconnectDuration = dict["IdleDisconnectDuration"] as! Int64
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("KeepDuration") {
            self.keepDuration = dict["KeepDuration"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OversoldGroupId") {
            self.oversoldGroupId = dict["OversoldGroupId"] as! String
        }
        if dict.keys.contains("OversoldUserCount") {
            self.oversoldUserCount = dict["OversoldUserCount"] as! Int32
        }
        if dict.keys.contains("OversoldWarn") {
            self.oversoldWarn = dict["OversoldWarn"] as! Int32
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("StopDuration") {
            self.stopDuration = dict["StopDuration"] as! Int32
        }
    }
}

public class ModifyDesktopOversoldGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var oversoldGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.oversoldGroupId != nil {
                map["OversoldGroupId"] = self.oversoldGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OversoldGroupId") {
                self.oversoldGroupId = dict["OversoldGroupId"] as! String
            }
        }
    }
    public var data: ModifyDesktopOversoldGroupResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ModifyDesktopOversoldGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDesktopOversoldGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDesktopOversoldGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDesktopOversoldGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDesktopOversoldGroupSaleRequest : Tea.TeaModel {
    public var concurrenceCount: Int32?

    public var oversoldGroupId: String?

    public var oversoldUserCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.concurrenceCount != nil {
            map["ConcurrenceCount"] = self.concurrenceCount!
        }
        if self.oversoldGroupId != nil {
            map["OversoldGroupId"] = self.oversoldGroupId!
        }
        if self.oversoldUserCount != nil {
            map["OversoldUserCount"] = self.oversoldUserCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConcurrenceCount") {
            self.concurrenceCount = dict["ConcurrenceCount"] as! Int32
        }
        if dict.keys.contains("OversoldGroupId") {
            self.oversoldGroupId = dict["OversoldGroupId"] as! String
        }
        if dict.keys.contains("OversoldUserCount") {
            self.oversoldUserCount = dict["OversoldUserCount"] as! Int32
        }
    }
}

public class ModifyDesktopOversoldGroupSaleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var orderId: Int64?

        public var oversoldGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.oversoldGroupId != nil {
                map["OversoldGroupId"] = self.oversoldGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OrderId") {
                self.orderId = dict["OrderId"] as! Int64
            }
            if dict.keys.contains("OversoldGroupId") {
                self.oversoldGroupId = dict["OversoldGroupId"] as! String
            }
        }
    }
    public var data: ModifyDesktopOversoldGroupSaleResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ModifyDesktopOversoldGroupSaleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDesktopOversoldGroupSaleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDesktopOversoldGroupSaleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDesktopOversoldGroupSaleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDesktopOversoldUserGroupRequest : Tea.TeaModel {
    public var imageId: String?

    public var name: String?

    public var oversoldGroupId: String?

    public var policyGroupId: String?

    public var userGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.oversoldGroupId != nil {
            map["OversoldGroupId"] = self.oversoldGroupId!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.userGroupId != nil {
            map["UserGroupId"] = self.userGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OversoldGroupId") {
            self.oversoldGroupId = dict["OversoldGroupId"] as! String
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("UserGroupId") {
            self.userGroupId = dict["UserGroupId"] as! String
        }
    }
}

public class ModifyDesktopOversoldUserGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var userGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userGroupId != nil {
                map["UserGroupId"] = self.userGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserGroupId") {
                self.userGroupId = dict["UserGroupId"] as! String
            }
        }
    }
    public var data: ModifyDesktopOversoldUserGroupResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ModifyDesktopOversoldUserGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDesktopOversoldUserGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDesktopOversoldUserGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDesktopOversoldUserGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDesktopSpecRequest : Tea.TeaModel {
    public class ResourceSpecs : Tea.TeaModel {
        public var desktopId: String?

        public var rootDiskSizeGib: Int32?

        public var userDiskSizeGib: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.rootDiskSizeGib != nil {
                map["RootDiskSizeGib"] = self.rootDiskSizeGib!
            }
            if self.userDiskSizeGib != nil {
                map["UserDiskSizeGib"] = self.userDiskSizeGib!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("RootDiskSizeGib") {
                self.rootDiskSizeGib = dict["RootDiskSizeGib"] as! Int32
            }
            if dict.keys.contains("UserDiskSizeGib") {
                self.userDiskSizeGib = dict["UserDiskSizeGib"] as! Int32
            }
        }
    }
    public var autoPay: Bool?

    public var desktopId: String?

    public var desktopType: String?

    public var promotionId: String?

    public var regionId: String?

    public var resourceSpecs: [ModifyDesktopSpecRequest.ResourceSpecs]?

    public var resourceType: String?

    public var rootDiskSizeGib: Int32?

    public var userDiskPerformanceLevel: String?

    public var userDiskSizeGib: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.desktopType != nil {
            map["DesktopType"] = self.desktopType!
        }
        if self.promotionId != nil {
            map["PromotionId"] = self.promotionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceSpecs != nil {
            var tmp : [Any] = []
            for k in self.resourceSpecs! {
                tmp.append(k.toMap())
            }
            map["ResourceSpecs"] = tmp
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.rootDiskSizeGib != nil {
            map["RootDiskSizeGib"] = self.rootDiskSizeGib!
        }
        if self.userDiskPerformanceLevel != nil {
            map["UserDiskPerformanceLevel"] = self.userDiskPerformanceLevel!
        }
        if self.userDiskSizeGib != nil {
            map["UserDiskSizeGib"] = self.userDiskSizeGib!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("DesktopType") {
            self.desktopType = dict["DesktopType"] as! String
        }
        if dict.keys.contains("PromotionId") {
            self.promotionId = dict["PromotionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceSpecs") {
            var tmp : [ModifyDesktopSpecRequest.ResourceSpecs] = []
            for v in dict["ResourceSpecs"] as! [Any] {
                var model = ModifyDesktopSpecRequest.ResourceSpecs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceSpecs = tmp
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("RootDiskSizeGib") {
            self.rootDiskSizeGib = dict["RootDiskSizeGib"] as! Int32
        }
        if dict.keys.contains("UserDiskPerformanceLevel") {
            self.userDiskPerformanceLevel = dict["UserDiskPerformanceLevel"] as! String
        }
        if dict.keys.contains("UserDiskSizeGib") {
            self.userDiskSizeGib = dict["UserDiskSizeGib"] as! Int32
        }
    }
}

public class ModifyDesktopSpecResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var orderIds: [Int64]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.orderIds != nil {
            map["OrderIds"] = self.orderIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("OrderIds") {
            self.orderIds = dict["OrderIds"] as! [Int64]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDesktopSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDesktopSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDesktopSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDesktopTimerRequest : Tea.TeaModel {
    public class DesktopTimers : Tea.TeaModel {
        public var allowClientSetting: Bool?

        public var cronExpression: String?

        public var enforce: Bool?

        public var interval: Int32?

        public var operationType: String?

        public var resetType: String?

        public var timerType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowClientSetting != nil {
                map["AllowClientSetting"] = self.allowClientSetting!
            }
            if self.cronExpression != nil {
                map["CronExpression"] = self.cronExpression!
            }
            if self.enforce != nil {
                map["Enforce"] = self.enforce!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.operationType != nil {
                map["OperationType"] = self.operationType!
            }
            if self.resetType != nil {
                map["ResetType"] = self.resetType!
            }
            if self.timerType != nil {
                map["TimerType"] = self.timerType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowClientSetting") {
                self.allowClientSetting = dict["AllowClientSetting"] as! Bool
            }
            if dict.keys.contains("CronExpression") {
                self.cronExpression = dict["CronExpression"] as! String
            }
            if dict.keys.contains("Enforce") {
                self.enforce = dict["Enforce"] as! Bool
            }
            if dict.keys.contains("Interval") {
                self.interval = dict["Interval"] as! Int32
            }
            if dict.keys.contains("OperationType") {
                self.operationType = dict["OperationType"] as! String
            }
            if dict.keys.contains("ResetType") {
                self.resetType = dict["ResetType"] as! String
            }
            if dict.keys.contains("TimerType") {
                self.timerType = dict["TimerType"] as! String
            }
        }
    }
    public var desktopId: [String]?

    public var desktopTimers: [ModifyDesktopTimerRequest.DesktopTimers]?

    public var regionId: String?

    public var useDesktopTimers: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.desktopTimers != nil {
            var tmp : [Any] = []
            for k in self.desktopTimers! {
                tmp.append(k.toMap())
            }
            map["DesktopTimers"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.useDesktopTimers != nil {
            map["UseDesktopTimers"] = self.useDesktopTimers!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("DesktopTimers") {
            var tmp : [ModifyDesktopTimerRequest.DesktopTimers] = []
            for v in dict["DesktopTimers"] as! [Any] {
                var model = ModifyDesktopTimerRequest.DesktopTimers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.desktopTimers = tmp
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("UseDesktopTimers") {
            self.useDesktopTimers = dict["UseDesktopTimers"] as! Bool
        }
    }
}

public class ModifyDesktopTimerResponseBody : Tea.TeaModel {
    public var desktopIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopIds != nil {
            map["DesktopIds"] = self.desktopIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopIds") {
            self.desktopIds = dict["DesktopIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDesktopTimerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDesktopTimerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDesktopTimerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDesktopsPolicyGroupRequest : Tea.TeaModel {
    public var desktopId: [String]?

    public var policyGroupId: String?

    public var policyGroupIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.policyGroupIds != nil {
            map["PolicyGroupIds"] = self.policyGroupIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("PolicyGroupIds") {
            self.policyGroupIds = dict["PolicyGroupIds"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyDesktopsPolicyGroupResponseBody : Tea.TeaModel {
    public class ModifyResults : Tea.TeaModel {
        public var code: String?

        public var desktopId: String?

        public var message: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
        }
    }
    public var modifyResults: [ModifyDesktopsPolicyGroupResponseBody.ModifyResults]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.modifyResults != nil {
            var tmp : [Any] = []
            for k in self.modifyResults! {
                tmp.append(k.toMap())
            }
            map["ModifyResults"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ModifyResults") {
            var tmp : [ModifyDesktopsPolicyGroupResponseBody.ModifyResults] = []
            for v in dict["ModifyResults"] as! [Any] {
                var model = ModifyDesktopsPolicyGroupResponseBody.ModifyResults()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.modifyResults = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDesktopsPolicyGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDesktopsPolicyGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDesktopsPolicyGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDiskSpecRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var desktopId: String?

    public var promotionId: String?

    public var regionId: String?

    public var resellerOwnerUid: Int64?

    public var rootDiskPerformanceLevel: String?

    public var userDiskPerformanceLevel: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.promotionId != nil {
            map["PromotionId"] = self.promotionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resellerOwnerUid != nil {
            map["ResellerOwnerUid"] = self.resellerOwnerUid!
        }
        if self.rootDiskPerformanceLevel != nil {
            map["RootDiskPerformanceLevel"] = self.rootDiskPerformanceLevel!
        }
        if self.userDiskPerformanceLevel != nil {
            map["UserDiskPerformanceLevel"] = self.userDiskPerformanceLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("PromotionId") {
            self.promotionId = dict["PromotionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResellerOwnerUid") {
            self.resellerOwnerUid = dict["ResellerOwnerUid"] as! Int64
        }
        if dict.keys.contains("RootDiskPerformanceLevel") {
            self.rootDiskPerformanceLevel = dict["RootDiskPerformanceLevel"] as! String
        }
        if dict.keys.contains("UserDiskPerformanceLevel") {
            self.userDiskPerformanceLevel = dict["UserDiskPerformanceLevel"] as! String
        }
    }
}

public class ModifyDiskSpecResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDiskSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDiskSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDiskSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyEntitlementRequest : Tea.TeaModel {
    public var desktopId: String?

    public var endUserId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyEntitlementResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyEntitlementResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEntitlementResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyEntitlementResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyImageAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var imageId: String?

    public var name: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyImageAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyImageAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyImageAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyImageAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyImagePermissionRequest : Tea.TeaModel {
    public var addAccount: [Int64]?

    public var imageId: String?

    public var regionId: String?

    public var removeAccount: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addAccount != nil {
            map["AddAccount"] = self.addAccount!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removeAccount != nil {
            map["RemoveAccount"] = self.removeAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddAccount") {
            self.addAccount = dict["AddAccount"] as! [Int64]
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoveAccount") {
            self.removeAccount = dict["RemoveAccount"] as! [Int64]
        }
    }
}

public class ModifyImagePermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyImagePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyImagePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyImagePermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyNASDefaultMountTargetRequest : Tea.TeaModel {
    public var fileSystemId: String?

    public var mountTargetDomain: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        if self.mountTargetDomain != nil {
            map["MountTargetDomain"] = self.mountTargetDomain!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileSystemId") {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
        if dict.keys.contains("MountTargetDomain") {
            self.mountTargetDomain = dict["MountTargetDomain"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyNASDefaultMountTargetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyNASDefaultMountTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNASDefaultMountTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyNASDefaultMountTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyNetworkPackageBandwidthRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var bandwidth: Int32?

    public var networkPackageId: String?

    public var promotionId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.networkPackageId != nil {
            map["NetworkPackageId"] = self.networkPackageId!
        }
        if self.promotionId != nil {
            map["PromotionId"] = self.promotionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("NetworkPackageId") {
            self.networkPackageId = dict["NetworkPackageId"] as! String
        }
        if dict.keys.contains("PromotionId") {
            self.promotionId = dict["PromotionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyNetworkPackageBandwidthResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyNetworkPackageBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNetworkPackageBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyNetworkPackageBandwidthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyNetworkPackageEnabledRequest : Tea.TeaModel {
    public var enabled: Bool?

    public var networkPackageId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.networkPackageId != nil {
            map["NetworkPackageId"] = self.networkPackageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("NetworkPackageId") {
            self.networkPackageId = dict["NetworkPackageId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyNetworkPackageEnabledResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyNetworkPackageEnabledResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNetworkPackageEnabledResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyNetworkPackageEnabledResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyOfficeSiteAttributeRequest : Tea.TeaModel {
    public var desktopAccessType: String?

    public var enableAdminAccess: Bool?

    public var needVerifyLoginRisk: Bool?

    public var needVerifyZeroDevice: Bool?

    public var officeSiteId: String?

    public var officeSiteName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopAccessType != nil {
            map["DesktopAccessType"] = self.desktopAccessType!
        }
        if self.enableAdminAccess != nil {
            map["EnableAdminAccess"] = self.enableAdminAccess!
        }
        if self.needVerifyLoginRisk != nil {
            map["NeedVerifyLoginRisk"] = self.needVerifyLoginRisk!
        }
        if self.needVerifyZeroDevice != nil {
            map["NeedVerifyZeroDevice"] = self.needVerifyZeroDevice!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.officeSiteName != nil {
            map["OfficeSiteName"] = self.officeSiteName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopAccessType") {
            self.desktopAccessType = dict["DesktopAccessType"] as! String
        }
        if dict.keys.contains("EnableAdminAccess") {
            self.enableAdminAccess = dict["EnableAdminAccess"] as! Bool
        }
        if dict.keys.contains("NeedVerifyLoginRisk") {
            self.needVerifyLoginRisk = dict["NeedVerifyLoginRisk"] as! Bool
        }
        if dict.keys.contains("NeedVerifyZeroDevice") {
            self.needVerifyZeroDevice = dict["NeedVerifyZeroDevice"] as! Bool
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("OfficeSiteName") {
            self.officeSiteName = dict["OfficeSiteName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyOfficeSiteAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyOfficeSiteAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyOfficeSiteAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyOfficeSiteAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyOfficeSiteCrossDesktopAccessRequest : Tea.TeaModel {
    public var enableCrossDesktopAccess: Bool?

    public var officeSiteId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableCrossDesktopAccess != nil {
            map["EnableCrossDesktopAccess"] = self.enableCrossDesktopAccess!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableCrossDesktopAccess") {
            self.enableCrossDesktopAccess = dict["EnableCrossDesktopAccess"] as! Bool
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyOfficeSiteCrossDesktopAccessResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyOfficeSiteCrossDesktopAccessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyOfficeSiteCrossDesktopAccessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyOfficeSiteCrossDesktopAccessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyOfficeSiteDnsInfoRequest : Tea.TeaModel {
    public var dnsAddress: [String]?

    public var officeSiteId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dnsAddress != nil {
            map["DnsAddress"] = self.dnsAddress!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DnsAddress") {
            self.dnsAddress = dict["DnsAddress"] as! [String]
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyOfficeSiteDnsInfoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyOfficeSiteDnsInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyOfficeSiteDnsInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyOfficeSiteDnsInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyOfficeSiteMfaEnabledRequest : Tea.TeaModel {
    public var mfaEnabled: Bool?

    public var officeSiteId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mfaEnabled != nil {
            map["MfaEnabled"] = self.mfaEnabled!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MfaEnabled") {
            self.mfaEnabled = dict["MfaEnabled"] as! Bool
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyOfficeSiteMfaEnabledResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyOfficeSiteMfaEnabledResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyOfficeSiteMfaEnabledResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyOfficeSiteMfaEnabledResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyPolicyGroupRequest : Tea.TeaModel {
    public class AuthorizeAccessPolicyRule : Tea.TeaModel {
        public var cidrIp: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrIp != nil {
                map["CidrIp"] = self.cidrIp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrIp") {
                self.cidrIp = dict["CidrIp"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
        }
    }
    public class AuthorizeSecurityPolicyRule : Tea.TeaModel {
        public var cidrIp: String?

        public var description_: String?

        public var ipProtocol: String?

        public var policy: String?

        public var portRange: String?

        public var priority: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrIp != nil {
                map["CidrIp"] = self.cidrIp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrIp") {
                self.cidrIp = dict["CidrIp"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ClientType : Tea.TeaModel {
        public var clientType: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientType != nil {
                map["ClientType"] = self.clientType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientType") {
                self.clientType = dict["ClientType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class DeviceRedirects : Tea.TeaModel {
        public var deviceType: String?

        public var redirectType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceType != nil {
                map["DeviceType"] = self.deviceType!
            }
            if self.redirectType != nil {
                map["RedirectType"] = self.redirectType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceType") {
                self.deviceType = dict["DeviceType"] as! String
            }
            if dict.keys.contains("RedirectType") {
                self.redirectType = dict["RedirectType"] as! String
            }
        }
    }
    public class DeviceRules : Tea.TeaModel {
        public var deviceName: String?

        public var devicePid: String?

        public var deviceType: String?

        public var deviceVid: String?

        public var optCommand: String?

        public var redirectType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceName != nil {
                map["DeviceName"] = self.deviceName!
            }
            if self.devicePid != nil {
                map["DevicePid"] = self.devicePid!
            }
            if self.deviceType != nil {
                map["DeviceType"] = self.deviceType!
            }
            if self.deviceVid != nil {
                map["DeviceVid"] = self.deviceVid!
            }
            if self.optCommand != nil {
                map["OptCommand"] = self.optCommand!
            }
            if self.redirectType != nil {
                map["RedirectType"] = self.redirectType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceName") {
                self.deviceName = dict["DeviceName"] as! String
            }
            if dict.keys.contains("DevicePid") {
                self.devicePid = dict["DevicePid"] as! String
            }
            if dict.keys.contains("DeviceType") {
                self.deviceType = dict["DeviceType"] as! String
            }
            if dict.keys.contains("DeviceVid") {
                self.deviceVid = dict["DeviceVid"] as! String
            }
            if dict.keys.contains("OptCommand") {
                self.optCommand = dict["OptCommand"] as! String
            }
            if dict.keys.contains("RedirectType") {
                self.redirectType = dict["RedirectType"] as! String
            }
        }
    }
    public class DomainResolveRule : Tea.TeaModel {
        public var description_: String?

        public var domain: String?

        public var policy: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
        }
    }
    public class RevokeAccessPolicyRule : Tea.TeaModel {
        public var cidrIp: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrIp != nil {
                map["CidrIp"] = self.cidrIp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrIp") {
                self.cidrIp = dict["CidrIp"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
        }
    }
    public class RevokeSecurityPolicyRule : Tea.TeaModel {
        public var cidrIp: String?

        public var description_: String?

        public var ipProtocol: String?

        public var policy: String?

        public var portRange: String?

        public var priority: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrIp != nil {
                map["CidrIp"] = self.cidrIp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrIp") {
                self.cidrIp = dict["CidrIp"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class UsbSupplyRedirectRule : Tea.TeaModel {
        public var description_: String?

        public var deviceClass: String?

        public var deviceSubclass: String?

        public var productId: String?

        public var usbRedirectType: Int64?

        public var usbRuleType: Int64?

        public var vendorId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.deviceClass != nil {
                map["DeviceClass"] = self.deviceClass!
            }
            if self.deviceSubclass != nil {
                map["DeviceSubclass"] = self.deviceSubclass!
            }
            if self.productId != nil {
                map["ProductId"] = self.productId!
            }
            if self.usbRedirectType != nil {
                map["UsbRedirectType"] = self.usbRedirectType!
            }
            if self.usbRuleType != nil {
                map["UsbRuleType"] = self.usbRuleType!
            }
            if self.vendorId != nil {
                map["VendorId"] = self.vendorId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DeviceClass") {
                self.deviceClass = dict["DeviceClass"] as! String
            }
            if dict.keys.contains("DeviceSubclass") {
                self.deviceSubclass = dict["DeviceSubclass"] as! String
            }
            if dict.keys.contains("ProductId") {
                self.productId = dict["ProductId"] as! String
            }
            if dict.keys.contains("UsbRedirectType") {
                self.usbRedirectType = dict["UsbRedirectType"] as! Int64
            }
            if dict.keys.contains("UsbRuleType") {
                self.usbRuleType = dict["UsbRuleType"] as! Int64
            }
            if dict.keys.contains("VendorId") {
                self.vendorId = dict["VendorId"] as! String
            }
        }
    }
    public var adminAccess: String?

    public var appContentProtection: String?

    public var authorizeAccessPolicyRule: [ModifyPolicyGroupRequest.AuthorizeAccessPolicyRule]?

    public var authorizeSecurityPolicyRule: [ModifyPolicyGroupRequest.AuthorizeSecurityPolicyRule]?

    public var cameraRedirect: String?

    public var clientType: [ModifyPolicyGroupRequest.ClientType]?

    public var clipboard: String?

    public var deviceRedirects: [ModifyPolicyGroupRequest.DeviceRedirects]?

    public var deviceRules: [ModifyPolicyGroupRequest.DeviceRules]?

    public var domainList: String?

    public var domainResolveRule: [ModifyPolicyGroupRequest.DomainResolveRule]?

    public var domainResolveRuleType: String?

    public var endUserApplyAdminCoordinate: String?

    public var endUserGroupCoordinate: String?

    public var gpuAcceleration: String?

    public var html5Access: String?

    public var html5FileTransfer: String?

    public var internetCommunicationProtocol: String?

    public var localDrive: String?

    public var maxReconnectTime: Int32?

    public var name: String?

    public var netRedirect: String?

    public var policyGroupId: String?

    public var preemptLogin: String?

    public var preemptLoginUser: [String]?

    public var printerRedirection: String?

    public var recordContent: String?

    public var recordContentExpires: Int64?

    public var recording: String?

    public var recordingAudio: String?

    public var recordingDuration: Int32?

    public var recordingEndTime: String?

    public var recordingExpires: Int64?

    public var recordingFps: Int64?

    public var recordingStartTime: String?

    public var recordingUserNotify: String?

    public var recordingUserNotifyMessage: String?

    public var regionId: String?

    public var remoteCoordinate: String?

    public var revokeAccessPolicyRule: [ModifyPolicyGroupRequest.RevokeAccessPolicyRule]?

    public var revokeSecurityPolicyRule: [ModifyPolicyGroupRequest.RevokeSecurityPolicyRule]?

    public var scope: String?

    public var scopeValue: [String]?

    public var usbRedirect: String?

    public var usbSupplyRedirectRule: [ModifyPolicyGroupRequest.UsbSupplyRedirectRule]?

    public var videoRedirect: String?

    public var visualQuality: String?

    public var watermark: String?

    public var watermarkAntiCam: String?

    public var watermarkColor: Int32?

    public var watermarkDegree: Double?

    public var watermarkFontSize: Int32?

    public var watermarkFontStyle: String?

    public var watermarkPower: String?

    public var watermarkRowAmount: Int32?

    public var watermarkSecurity: String?

    public var watermarkTransparency: String?

    public var watermarkTransparencyValue: Int32?

    public var watermarkType: String?

    public var wyAssistant: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adminAccess != nil {
            map["AdminAccess"] = self.adminAccess!
        }
        if self.appContentProtection != nil {
            map["AppContentProtection"] = self.appContentProtection!
        }
        if self.authorizeAccessPolicyRule != nil {
            var tmp : [Any] = []
            for k in self.authorizeAccessPolicyRule! {
                tmp.append(k.toMap())
            }
            map["AuthorizeAccessPolicyRule"] = tmp
        }
        if self.authorizeSecurityPolicyRule != nil {
            var tmp : [Any] = []
            for k in self.authorizeSecurityPolicyRule! {
                tmp.append(k.toMap())
            }
            map["AuthorizeSecurityPolicyRule"] = tmp
        }
        if self.cameraRedirect != nil {
            map["CameraRedirect"] = self.cameraRedirect!
        }
        if self.clientType != nil {
            var tmp : [Any] = []
            for k in self.clientType! {
                tmp.append(k.toMap())
            }
            map["ClientType"] = tmp
        }
        if self.clipboard != nil {
            map["Clipboard"] = self.clipboard!
        }
        if self.deviceRedirects != nil {
            var tmp : [Any] = []
            for k in self.deviceRedirects! {
                tmp.append(k.toMap())
            }
            map["DeviceRedirects"] = tmp
        }
        if self.deviceRules != nil {
            var tmp : [Any] = []
            for k in self.deviceRules! {
                tmp.append(k.toMap())
            }
            map["DeviceRules"] = tmp
        }
        if self.domainList != nil {
            map["DomainList"] = self.domainList!
        }
        if self.domainResolveRule != nil {
            var tmp : [Any] = []
            for k in self.domainResolveRule! {
                tmp.append(k.toMap())
            }
            map["DomainResolveRule"] = tmp
        }
        if self.domainResolveRuleType != nil {
            map["DomainResolveRuleType"] = self.domainResolveRuleType!
        }
        if self.endUserApplyAdminCoordinate != nil {
            map["EndUserApplyAdminCoordinate"] = self.endUserApplyAdminCoordinate!
        }
        if self.endUserGroupCoordinate != nil {
            map["EndUserGroupCoordinate"] = self.endUserGroupCoordinate!
        }
        if self.gpuAcceleration != nil {
            map["GpuAcceleration"] = self.gpuAcceleration!
        }
        if self.html5Access != nil {
            map["Html5Access"] = self.html5Access!
        }
        if self.html5FileTransfer != nil {
            map["Html5FileTransfer"] = self.html5FileTransfer!
        }
        if self.internetCommunicationProtocol != nil {
            map["InternetCommunicationProtocol"] = self.internetCommunicationProtocol!
        }
        if self.localDrive != nil {
            map["LocalDrive"] = self.localDrive!
        }
        if self.maxReconnectTime != nil {
            map["MaxReconnectTime"] = self.maxReconnectTime!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.netRedirect != nil {
            map["NetRedirect"] = self.netRedirect!
        }
        if self.policyGroupId != nil {
            map["PolicyGroupId"] = self.policyGroupId!
        }
        if self.preemptLogin != nil {
            map["PreemptLogin"] = self.preemptLogin!
        }
        if self.preemptLoginUser != nil {
            map["PreemptLoginUser"] = self.preemptLoginUser!
        }
        if self.printerRedirection != nil {
            map["PrinterRedirection"] = self.printerRedirection!
        }
        if self.recordContent != nil {
            map["RecordContent"] = self.recordContent!
        }
        if self.recordContentExpires != nil {
            map["RecordContentExpires"] = self.recordContentExpires!
        }
        if self.recording != nil {
            map["Recording"] = self.recording!
        }
        if self.recordingAudio != nil {
            map["RecordingAudio"] = self.recordingAudio!
        }
        if self.recordingDuration != nil {
            map["RecordingDuration"] = self.recordingDuration!
        }
        if self.recordingEndTime != nil {
            map["RecordingEndTime"] = self.recordingEndTime!
        }
        if self.recordingExpires != nil {
            map["RecordingExpires"] = self.recordingExpires!
        }
        if self.recordingFps != nil {
            map["RecordingFps"] = self.recordingFps!
        }
        if self.recordingStartTime != nil {
            map["RecordingStartTime"] = self.recordingStartTime!
        }
        if self.recordingUserNotify != nil {
            map["RecordingUserNotify"] = self.recordingUserNotify!
        }
        if self.recordingUserNotifyMessage != nil {
            map["RecordingUserNotifyMessage"] = self.recordingUserNotifyMessage!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteCoordinate != nil {
            map["RemoteCoordinate"] = self.remoteCoordinate!
        }
        if self.revokeAccessPolicyRule != nil {
            var tmp : [Any] = []
            for k in self.revokeAccessPolicyRule! {
                tmp.append(k.toMap())
            }
            map["RevokeAccessPolicyRule"] = tmp
        }
        if self.revokeSecurityPolicyRule != nil {
            var tmp : [Any] = []
            for k in self.revokeSecurityPolicyRule! {
                tmp.append(k.toMap())
            }
            map["RevokeSecurityPolicyRule"] = tmp
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.scopeValue != nil {
            map["ScopeValue"] = self.scopeValue!
        }
        if self.usbRedirect != nil {
            map["UsbRedirect"] = self.usbRedirect!
        }
        if self.usbSupplyRedirectRule != nil {
            var tmp : [Any] = []
            for k in self.usbSupplyRedirectRule! {
                tmp.append(k.toMap())
            }
            map["UsbSupplyRedirectRule"] = tmp
        }
        if self.videoRedirect != nil {
            map["VideoRedirect"] = self.videoRedirect!
        }
        if self.visualQuality != nil {
            map["VisualQuality"] = self.visualQuality!
        }
        if self.watermark != nil {
            map["Watermark"] = self.watermark!
        }
        if self.watermarkAntiCam != nil {
            map["WatermarkAntiCam"] = self.watermarkAntiCam!
        }
        if self.watermarkColor != nil {
            map["WatermarkColor"] = self.watermarkColor!
        }
        if self.watermarkDegree != nil {
            map["WatermarkDegree"] = self.watermarkDegree!
        }
        if self.watermarkFontSize != nil {
            map["WatermarkFontSize"] = self.watermarkFontSize!
        }
        if self.watermarkFontStyle != nil {
            map["WatermarkFontStyle"] = self.watermarkFontStyle!
        }
        if self.watermarkPower != nil {
            map["WatermarkPower"] = self.watermarkPower!
        }
        if self.watermarkRowAmount != nil {
            map["WatermarkRowAmount"] = self.watermarkRowAmount!
        }
        if self.watermarkSecurity != nil {
            map["WatermarkSecurity"] = self.watermarkSecurity!
        }
        if self.watermarkTransparency != nil {
            map["WatermarkTransparency"] = self.watermarkTransparency!
        }
        if self.watermarkTransparencyValue != nil {
            map["WatermarkTransparencyValue"] = self.watermarkTransparencyValue!
        }
        if self.watermarkType != nil {
            map["WatermarkType"] = self.watermarkType!
        }
        if self.wyAssistant != nil {
            map["WyAssistant"] = self.wyAssistant!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdminAccess") {
            self.adminAccess = dict["AdminAccess"] as! String
        }
        if dict.keys.contains("AppContentProtection") {
            self.appContentProtection = dict["AppContentProtection"] as! String
        }
        if dict.keys.contains("AuthorizeAccessPolicyRule") {
            var tmp : [ModifyPolicyGroupRequest.AuthorizeAccessPolicyRule] = []
            for v in dict["AuthorizeAccessPolicyRule"] as! [Any] {
                var model = ModifyPolicyGroupRequest.AuthorizeAccessPolicyRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.authorizeAccessPolicyRule = tmp
        }
        if dict.keys.contains("AuthorizeSecurityPolicyRule") {
            var tmp : [ModifyPolicyGroupRequest.AuthorizeSecurityPolicyRule] = []
            for v in dict["AuthorizeSecurityPolicyRule"] as! [Any] {
                var model = ModifyPolicyGroupRequest.AuthorizeSecurityPolicyRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.authorizeSecurityPolicyRule = tmp
        }
        if dict.keys.contains("CameraRedirect") {
            self.cameraRedirect = dict["CameraRedirect"] as! String
        }
        if dict.keys.contains("ClientType") {
            var tmp : [ModifyPolicyGroupRequest.ClientType] = []
            for v in dict["ClientType"] as! [Any] {
                var model = ModifyPolicyGroupRequest.ClientType()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.clientType = tmp
        }
        if dict.keys.contains("Clipboard") {
            self.clipboard = dict["Clipboard"] as! String
        }
        if dict.keys.contains("DeviceRedirects") {
            var tmp : [ModifyPolicyGroupRequest.DeviceRedirects] = []
            for v in dict["DeviceRedirects"] as! [Any] {
                var model = ModifyPolicyGroupRequest.DeviceRedirects()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deviceRedirects = tmp
        }
        if dict.keys.contains("DeviceRules") {
            var tmp : [ModifyPolicyGroupRequest.DeviceRules] = []
            for v in dict["DeviceRules"] as! [Any] {
                var model = ModifyPolicyGroupRequest.DeviceRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deviceRules = tmp
        }
        if dict.keys.contains("DomainList") {
            self.domainList = dict["DomainList"] as! String
        }
        if dict.keys.contains("DomainResolveRule") {
            var tmp : [ModifyPolicyGroupRequest.DomainResolveRule] = []
            for v in dict["DomainResolveRule"] as! [Any] {
                var model = ModifyPolicyGroupRequest.DomainResolveRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.domainResolveRule = tmp
        }
        if dict.keys.contains("DomainResolveRuleType") {
            self.domainResolveRuleType = dict["DomainResolveRuleType"] as! String
        }
        if dict.keys.contains("EndUserApplyAdminCoordinate") {
            self.endUserApplyAdminCoordinate = dict["EndUserApplyAdminCoordinate"] as! String
        }
        if dict.keys.contains("EndUserGroupCoordinate") {
            self.endUserGroupCoordinate = dict["EndUserGroupCoordinate"] as! String
        }
        if dict.keys.contains("GpuAcceleration") {
            self.gpuAcceleration = dict["GpuAcceleration"] as! String
        }
        if dict.keys.contains("Html5Access") {
            self.html5Access = dict["Html5Access"] as! String
        }
        if dict.keys.contains("Html5FileTransfer") {
            self.html5FileTransfer = dict["Html5FileTransfer"] as! String
        }
        if dict.keys.contains("InternetCommunicationProtocol") {
            self.internetCommunicationProtocol = dict["InternetCommunicationProtocol"] as! String
        }
        if dict.keys.contains("LocalDrive") {
            self.localDrive = dict["LocalDrive"] as! String
        }
        if dict.keys.contains("MaxReconnectTime") {
            self.maxReconnectTime = dict["MaxReconnectTime"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NetRedirect") {
            self.netRedirect = dict["NetRedirect"] as! String
        }
        if dict.keys.contains("PolicyGroupId") {
            self.policyGroupId = dict["PolicyGroupId"] as! String
        }
        if dict.keys.contains("PreemptLogin") {
            self.preemptLogin = dict["PreemptLogin"] as! String
        }
        if dict.keys.contains("PreemptLoginUser") {
            self.preemptLoginUser = dict["PreemptLoginUser"] as! [String]
        }
        if dict.keys.contains("PrinterRedirection") {
            self.printerRedirection = dict["PrinterRedirection"] as! String
        }
        if dict.keys.contains("RecordContent") {
            self.recordContent = dict["RecordContent"] as! String
        }
        if dict.keys.contains("RecordContentExpires") {
            self.recordContentExpires = dict["RecordContentExpires"] as! Int64
        }
        if dict.keys.contains("Recording") {
            self.recording = dict["Recording"] as! String
        }
        if dict.keys.contains("RecordingAudio") {
            self.recordingAudio = dict["RecordingAudio"] as! String
        }
        if dict.keys.contains("RecordingDuration") {
            self.recordingDuration = dict["RecordingDuration"] as! Int32
        }
        if dict.keys.contains("RecordingEndTime") {
            self.recordingEndTime = dict["RecordingEndTime"] as! String
        }
        if dict.keys.contains("RecordingExpires") {
            self.recordingExpires = dict["RecordingExpires"] as! Int64
        }
        if dict.keys.contains("RecordingFps") {
            self.recordingFps = dict["RecordingFps"] as! Int64
        }
        if dict.keys.contains("RecordingStartTime") {
            self.recordingStartTime = dict["RecordingStartTime"] as! String
        }
        if dict.keys.contains("RecordingUserNotify") {
            self.recordingUserNotify = dict["RecordingUserNotify"] as! String
        }
        if dict.keys.contains("RecordingUserNotifyMessage") {
            self.recordingUserNotifyMessage = dict["RecordingUserNotifyMessage"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoteCoordinate") {
            self.remoteCoordinate = dict["RemoteCoordinate"] as! String
        }
        if dict.keys.contains("RevokeAccessPolicyRule") {
            var tmp : [ModifyPolicyGroupRequest.RevokeAccessPolicyRule] = []
            for v in dict["RevokeAccessPolicyRule"] as! [Any] {
                var model = ModifyPolicyGroupRequest.RevokeAccessPolicyRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.revokeAccessPolicyRule = tmp
        }
        if dict.keys.contains("RevokeSecurityPolicyRule") {
            var tmp : [ModifyPolicyGroupRequest.RevokeSecurityPolicyRule] = []
            for v in dict["RevokeSecurityPolicyRule"] as! [Any] {
                var model = ModifyPolicyGroupRequest.RevokeSecurityPolicyRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.revokeSecurityPolicyRule = tmp
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("ScopeValue") {
            self.scopeValue = dict["ScopeValue"] as! [String]
        }
        if dict.keys.contains("UsbRedirect") {
            self.usbRedirect = dict["UsbRedirect"] as! String
        }
        if dict.keys.contains("UsbSupplyRedirectRule") {
            var tmp : [ModifyPolicyGroupRequest.UsbSupplyRedirectRule] = []
            for v in dict["UsbSupplyRedirectRule"] as! [Any] {
                var model = ModifyPolicyGroupRequest.UsbSupplyRedirectRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.usbSupplyRedirectRule = tmp
        }
        if dict.keys.contains("VideoRedirect") {
            self.videoRedirect = dict["VideoRedirect"] as! String
        }
        if dict.keys.contains("VisualQuality") {
            self.visualQuality = dict["VisualQuality"] as! String
        }
        if dict.keys.contains("Watermark") {
            self.watermark = dict["Watermark"] as! String
        }
        if dict.keys.contains("WatermarkAntiCam") {
            self.watermarkAntiCam = dict["WatermarkAntiCam"] as! String
        }
        if dict.keys.contains("WatermarkColor") {
            self.watermarkColor = dict["WatermarkColor"] as! Int32
        }
        if dict.keys.contains("WatermarkDegree") {
            self.watermarkDegree = dict["WatermarkDegree"] as! Double
        }
        if dict.keys.contains("WatermarkFontSize") {
            self.watermarkFontSize = dict["WatermarkFontSize"] as! Int32
        }
        if dict.keys.contains("WatermarkFontStyle") {
            self.watermarkFontStyle = dict["WatermarkFontStyle"] as! String
        }
        if dict.keys.contains("WatermarkPower") {
            self.watermarkPower = dict["WatermarkPower"] as! String
        }
        if dict.keys.contains("WatermarkRowAmount") {
            self.watermarkRowAmount = dict["WatermarkRowAmount"] as! Int32
        }
        if dict.keys.contains("WatermarkSecurity") {
            self.watermarkSecurity = dict["WatermarkSecurity"] as! String
        }
        if dict.keys.contains("WatermarkTransparency") {
            self.watermarkTransparency = dict["WatermarkTransparency"] as! String
        }
        if dict.keys.contains("WatermarkTransparencyValue") {
            self.watermarkTransparencyValue = dict["WatermarkTransparencyValue"] as! Int32
        }
        if dict.keys.contains("WatermarkType") {
            self.watermarkType = dict["WatermarkType"] as! String
        }
        if dict.keys.contains("WyAssistant") {
            self.wyAssistant = dict["WyAssistant"] as! String
        }
    }
}

public class ModifyPolicyGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyPolicyGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPolicyGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyPolicyGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyResourceCenterPolicyRequest : Tea.TeaModel {
    public var policyGroupIds: [String]?

    public var policyGroupType: String?

    public var productType: String?

    public var resourceIds: [String]?

    public var resourceRegionId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyGroupIds != nil {
            map["PolicyGroupIds"] = self.policyGroupIds!
        }
        if self.policyGroupType != nil {
            map["PolicyGroupType"] = self.policyGroupType!
        }
        if self.productType != nil {
            map["ProductType"] = self.productType!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceRegionId != nil {
            map["ResourceRegionId"] = self.resourceRegionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyGroupIds") {
            self.policyGroupIds = dict["PolicyGroupIds"] as! [String]
        }
        if dict.keys.contains("PolicyGroupType") {
            self.policyGroupType = dict["PolicyGroupType"] as! String
        }
        if dict.keys.contains("ProductType") {
            self.productType = dict["ProductType"] as! String
        }
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! [String]
        }
        if dict.keys.contains("ResourceRegionId") {
            self.resourceRegionId = dict["ResourceRegionId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ModifyResourceCenterPolicyResponseBody : Tea.TeaModel {
    public class ModifyResults : Tea.TeaModel {
        public var checkResult: Bool?

        public var resourceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkResult != nil {
                map["CheckResult"] = self.checkResult!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckResult") {
                self.checkResult = dict["CheckResult"] as! Bool
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
        }
    }
    public var modifyResults: [ModifyResourceCenterPolicyResponseBody.ModifyResults]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.modifyResults != nil {
            var tmp : [Any] = []
            for k in self.modifyResults! {
                tmp.append(k.toMap())
            }
            map["ModifyResults"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ModifyResults") {
            var tmp : [ModifyResourceCenterPolicyResponseBody.ModifyResults] = []
            for v in dict["ModifyResults"] as! [Any] {
                var model = ModifyResourceCenterPolicyResponseBody.ModifyResults()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.modifyResults = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyResourceCenterPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyResourceCenterPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyResourceCenterPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTimerGroupRequest : Tea.TeaModel {
    public class ConfigTimers : Tea.TeaModel {
        public var allowClientSetting: Bool?

        public var cronExpression: String?

        public var enforce: Bool?

        public var interval: Int32?

        public var notificationTime: Int32?

        public var operationType: String?

        public var processWhitelist: [String]?

        public var resetType: String?

        public var timerType: String?

        public var triggerType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowClientSetting != nil {
                map["AllowClientSetting"] = self.allowClientSetting!
            }
            if self.cronExpression != nil {
                map["CronExpression"] = self.cronExpression!
            }
            if self.enforce != nil {
                map["Enforce"] = self.enforce!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.notificationTime != nil {
                map["NotificationTime"] = self.notificationTime!
            }
            if self.operationType != nil {
                map["OperationType"] = self.operationType!
            }
            if self.processWhitelist != nil {
                map["ProcessWhitelist"] = self.processWhitelist!
            }
            if self.resetType != nil {
                map["ResetType"] = self.resetType!
            }
            if self.timerType != nil {
                map["TimerType"] = self.timerType!
            }
            if self.triggerType != nil {
                map["TriggerType"] = self.triggerType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowClientSetting") {
                self.allowClientSetting = dict["AllowClientSetting"] as! Bool
            }
            if dict.keys.contains("CronExpression") {
                self.cronExpression = dict["CronExpression"] as! String
            }
            if dict.keys.contains("Enforce") {
                self.enforce = dict["Enforce"] as! Bool
            }
            if dict.keys.contains("Interval") {
                self.interval = dict["Interval"] as! Int32
            }
            if dict.keys.contains("NotificationTime") {
                self.notificationTime = dict["NotificationTime"] as! Int32
            }
            if dict.keys.contains("OperationType") {
                self.operationType = dict["OperationType"] as! String
            }
            if dict.keys.contains("ProcessWhitelist") {
                self.processWhitelist = dict["ProcessWhitelist"] as! [String]
            }
            if dict.keys.contains("ResetType") {
                self.resetType = dict["ResetType"] as! String
            }
            if dict.keys.contains("TimerType") {
                self.timerType = dict["TimerType"] as! String
            }
            if dict.keys.contains("TriggerType") {
                self.triggerType = dict["TriggerType"] as! String
            }
        }
    }
    public var configTimers: [ModifyTimerGroupRequest.ConfigTimers]?

    public var description_: String?

    public var groupId: String?

    public var name: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configTimers != nil {
            var tmp : [Any] = []
            for k in self.configTimers! {
                tmp.append(k.toMap())
            }
            map["ConfigTimers"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigTimers") {
            var tmp : [ModifyTimerGroupRequest.ConfigTimers] = []
            for v in dict["ConfigTimers"] as! [Any] {
                var model = ModifyTimerGroupRequest.ConfigTimers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.configTimers = tmp
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyTimerGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyTimerGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTimerGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTimerGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyUserEntitlementRequest : Tea.TeaModel {
    public var authorizeDesktopId: [String]?

    public var endUserId: [String]?

    public var regionId: String?

    public var revokeDesktopId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorizeDesktopId != nil {
            map["AuthorizeDesktopId"] = self.authorizeDesktopId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.revokeDesktopId != nil {
            map["RevokeDesktopId"] = self.revokeDesktopId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorizeDesktopId") {
            self.authorizeDesktopId = dict["AuthorizeDesktopId"] as! [String]
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RevokeDesktopId") {
            self.revokeDesktopId = dict["RevokeDesktopId"] as! [String]
        }
    }
}

public class ModifyUserEntitlementResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyUserEntitlementResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyUserEntitlementResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyUserEntitlementResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyUserToDesktopGroupRequest : Tea.TeaModel {
    public var desktopGroupId: String?

    public var newEndUserIds: [String]?

    public var oldEndUserIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.newEndUserIds != nil {
            map["NewEndUserIds"] = self.newEndUserIds!
        }
        if self.oldEndUserIds != nil {
            map["OldEndUserIds"] = self.oldEndUserIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("NewEndUserIds") {
            self.newEndUserIds = dict["NewEndUserIds"] as! [String]
        }
        if dict.keys.contains("OldEndUserIds") {
            self.oldEndUserIds = dict["OldEndUserIds"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyUserToDesktopGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyUserToDesktopGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyUserToDesktopGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyUserToDesktopGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MoveCdsFileRequest : Tea.TeaModel {
    public var cdsId: String?

    public var conflictPolicy: String?

    public var endUserId: String?

    public var fileId: String?

    public var groupId: String?

    public var parentFolderId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.conflictPolicy != nil {
            map["ConflictPolicy"] = self.conflictPolicy!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.parentFolderId != nil {
            map["ParentFolderId"] = self.parentFolderId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("ConflictPolicy") {
            self.conflictPolicy = dict["ConflictPolicy"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ParentFolderId") {
            self.parentFolderId = dict["ParentFolderId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class MoveCdsFileResponseBody : Tea.TeaModel {
    public class MoveCdsFileModel : Tea.TeaModel {
        public var asyncTaskId: String?

        public var exist: Bool?

        public var fileId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.asyncTaskId != nil {
                map["AsyncTaskId"] = self.asyncTaskId!
            }
            if self.exist != nil {
                map["Exist"] = self.exist!
            }
            if self.fileId != nil {
                map["FileId"] = self.fileId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AsyncTaskId") {
                self.asyncTaskId = dict["AsyncTaskId"] as! String
            }
            if dict.keys.contains("Exist") {
                self.exist = dict["Exist"] as! Bool
            }
            if dict.keys.contains("FileId") {
                self.fileId = dict["FileId"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var moveCdsFileModel: MoveCdsFileResponseBody.MoveCdsFileModel?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.moveCdsFileModel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.moveCdsFileModel != nil {
            map["MoveCdsFileModel"] = self.moveCdsFileModel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("MoveCdsFileModel") {
            var model = MoveCdsFileResponseBody.MoveCdsFileModel()
            model.fromMap(dict["MoveCdsFileModel"] as! [String: Any])
            self.moveCdsFileModel = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class MoveCdsFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveCdsFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MoveCdsFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RebootDesktopsRequest : Tea.TeaModel {
    public var desktopId: [String]?

    public var osUpdate: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.osUpdate != nil {
            map["OsUpdate"] = self.osUpdate!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("OsUpdate") {
            self.osUpdate = dict["OsUpdate"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class RebootDesktopsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RebootDesktopsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebootDesktopsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RebootDesktopsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RebuildDesktopsRequest : Tea.TeaModel {
    public var afterStatus: String?

    public var desktopId: [String]?

    public var imageId: String?

    public var language: String?

    public var operateType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.afterStatus != nil {
            map["AfterStatus"] = self.afterStatus!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.operateType != nil {
            map["OperateType"] = self.operateType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AfterStatus") {
            self.afterStatus = dict["AfterStatus"] as! String
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("OperateType") {
            self.operateType = dict["OperateType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class RebuildDesktopsResponseBody : Tea.TeaModel {
    public class RebuildResults : Tea.TeaModel {
        public var code: String?

        public var desktopId: String?

        public var message: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.desktopId != nil {
                map["DesktopId"] = self.desktopId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("DesktopId") {
                self.desktopId = dict["DesktopId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
        }
    }
    public var rebuildResults: [RebuildDesktopsResponseBody.RebuildResults]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rebuildResults != nil {
            var tmp : [Any] = []
            for k in self.rebuildResults! {
                tmp.append(k.toMap())
            }
            map["RebuildResults"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RebuildResults") {
            var tmp : [RebuildDesktopsResponseBody.RebuildResults] = []
            for v in dict["RebuildResults"] as! [Any] {
                var model = RebuildDesktopsResponseBody.RebuildResults()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.rebuildResults = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RebuildDesktopsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebuildDesktopsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RebuildDesktopsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveFilePermissionRequest : Tea.TeaModel {
    public class MemberList : Tea.TeaModel {
        public class CdsIdentity : Tea.TeaModel {
            public var id: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var cdsIdentity: RemoveFilePermissionRequest.MemberList.CdsIdentity?

        public var roleId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cdsIdentity?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cdsIdentity != nil {
                map["CdsIdentity"] = self.cdsIdentity?.toMap()
            }
            if self.roleId != nil {
                map["RoleId"] = self.roleId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CdsIdentity") {
                var model = RemoveFilePermissionRequest.MemberList.CdsIdentity()
                model.fromMap(dict["CdsIdentity"] as! [String: Any])
                self.cdsIdentity = model
            }
            if dict.keys.contains("RoleId") {
                self.roleId = dict["RoleId"] as! String
            }
        }
    }
    public var cdsId: String?

    public var endUserId: String?

    public var fileId: String?

    public var groupId: String?

    public var memberList: [RemoveFilePermissionRequest.MemberList]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.memberList != nil {
            var tmp : [Any] = []
            for k in self.memberList! {
                tmp.append(k.toMap())
            }
            map["MemberList"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("MemberList") {
            var tmp : [RemoveFilePermissionRequest.MemberList] = []
            for v in dict["MemberList"] as! [Any] {
                var model = RemoveFilePermissionRequest.MemberList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.memberList = tmp
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class RemoveFilePermissionShrinkRequest : Tea.TeaModel {
    public var cdsId: String?

    public var endUserId: String?

    public var fileId: String?

    public var groupId: String?

    public var memberListShrink: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdsId != nil {
            map["CdsId"] = self.cdsId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.memberListShrink != nil {
            map["MemberList"] = self.memberListShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CdsId") {
            self.cdsId = dict["CdsId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("MemberList") {
            self.memberListShrink = dict["MemberList"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class RemoveFilePermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveFilePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveFilePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveFilePermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveUserFromDesktopGroupRequest : Tea.TeaModel {
    public var desktopGroupId: String?

    public var desktopGroupIds: [String]?

    public var endUserIds: [String]?

    public var regionId: String?

    public var userOuPath: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.desktopGroupIds != nil {
            map["DesktopGroupIds"] = self.desktopGroupIds!
        }
        if self.endUserIds != nil {
            map["EndUserIds"] = self.endUserIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.userOuPath != nil {
            map["UserOuPath"] = self.userOuPath!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("DesktopGroupIds") {
            self.desktopGroupIds = dict["DesktopGroupIds"] as! [String]
        }
        if dict.keys.contains("EndUserIds") {
            self.endUserIds = dict["EndUserIds"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("UserOuPath") {
            self.userOuPath = dict["UserOuPath"] as! String
        }
    }
}

public class RemoveUserFromDesktopGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveUserFromDesktopGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveUserFromDesktopGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveUserFromDesktopGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveUserFromDesktopOversoldUserGroupRequest : Tea.TeaModel {
    public var endUserId: String?

    public var oversoldGroupId: String?

    public var userDesktopId: String?

    public var userGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.oversoldGroupId != nil {
            map["OversoldGroupId"] = self.oversoldGroupId!
        }
        if self.userDesktopId != nil {
            map["UserDesktopId"] = self.userDesktopId!
        }
        if self.userGroupId != nil {
            map["UserGroupId"] = self.userGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("OversoldGroupId") {
            self.oversoldGroupId = dict["OversoldGroupId"] as! String
        }
        if dict.keys.contains("UserDesktopId") {
            self.userDesktopId = dict["UserDesktopId"] as! String
        }
        if dict.keys.contains("UserGroupId") {
            self.userGroupId = dict["UserGroupId"] as! String
        }
    }
}

public class RemoveUserFromDesktopOversoldUserGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveUserFromDesktopOversoldUserGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveUserFromDesktopOversoldUserGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveUserFromDesktopOversoldUserGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenewDesktopGroupRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var desktopGroupId: String?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class RenewDesktopGroupResponseBody : Tea.TeaModel {
    public var orderId: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RenewDesktopGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewDesktopGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenewDesktopGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenewDesktopOversoldGroupRequest : Tea.TeaModel {
    public var oversoldGroupId: String?

    public var period: Int32?

    public var periodUnit: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.oversoldGroupId != nil {
            map["OversoldGroupId"] = self.oversoldGroupId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OversoldGroupId") {
            self.oversoldGroupId = dict["OversoldGroupId"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
    }
}

public class RenewDesktopOversoldGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var orderId: Int64?

        public var oversoldGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.oversoldGroupId != nil {
                map["OversoldGroupId"] = self.oversoldGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OrderId") {
                self.orderId = dict["OrderId"] as! Int64
            }
            if dict.keys.contains("OversoldGroupId") {
                self.oversoldGroupId = dict["OversoldGroupId"] as! String
            }
        }
    }
    public var data: RenewDesktopOversoldGroupResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = RenewDesktopOversoldGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RenewDesktopOversoldGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewDesktopOversoldGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenewDesktopOversoldGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenewDesktopsRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var desktopId: [String]?

    public var period: Int32?

    public var periodUnit: String?

    public var promotionId: String?

    public var regionId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.promotionId != nil {
            map["PromotionId"] = self.promotionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PromotionId") {
            self.promotionId = dict["PromotionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class RenewDesktopsResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RenewDesktopsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewDesktopsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenewDesktopsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenewNetworkPackagesRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var networkPackageId: [String]?

    public var period: Int32?

    public var periodUnit: String?

    public var promotionId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.networkPackageId != nil {
            map["NetworkPackageId"] = self.networkPackageId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.promotionId != nil {
            map["PromotionId"] = self.promotionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("NetworkPackageId") {
            self.networkPackageId = dict["NetworkPackageId"] as! [String]
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PromotionId") {
            self.promotionId = dict["PromotionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class RenewNetworkPackagesResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RenewNetworkPackagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewNetworkPackagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenewNetworkPackagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetDesktopsRequest : Tea.TeaModel {
    public var desktopGroupId: String?

    public var desktopGroupIds: [String]?

    public var desktopId: [String]?

    public var imageId: String?

    public var payType: String?

    public var regionId: String?

    public var resetScope: String?

    public var resetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.desktopGroupIds != nil {
            map["DesktopGroupIds"] = self.desktopGroupIds!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resetScope != nil {
            map["ResetScope"] = self.resetScope!
        }
        if self.resetType != nil {
            map["ResetType"] = self.resetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("DesktopGroupIds") {
            self.desktopGroupIds = dict["DesktopGroupIds"] as! [String]
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResetScope") {
            self.resetScope = dict["ResetScope"] as! String
        }
        if dict.keys.contains("ResetType") {
            self.resetType = dict["ResetType"] as! String
        }
    }
}

public class ResetDesktopsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetDesktopsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetDesktopsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetDesktopsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetNASDefaultMountTargetRequest : Tea.TeaModel {
    public var fileSystemId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileSystemId") {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ResetNASDefaultMountTargetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetNASDefaultMountTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetNASDefaultMountTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetNASDefaultMountTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetSnapshotRequest : Tea.TeaModel {
    public var regionId: String?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
    }
}

public class ResetSnapshotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetSnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetSnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetSnapshotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokeCoordinatePrivilegeRequest : Tea.TeaModel {
    public var coId: String?

    public var endUserId: String?

    public var regionId: String?

    public var userType: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coId != nil {
            map["CoId"] = self.coId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.userType != nil {
            map["UserType"] = self.userType!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoId") {
            self.coId = dict["CoId"] as! String
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("UserType") {
            self.userType = dict["UserType"] as! String
        }
        if dict.keys.contains("Uuid") {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class RevokeCoordinatePrivilegeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RevokeCoordinatePrivilegeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeCoordinatePrivilegeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RevokeCoordinatePrivilegeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunCommandRequest : Tea.TeaModel {
    public var commandContent: String?

    public var contentEncoding: String?

    public var desktopId: [String]?

    public var endUserId: String?

    public var regionId: String?

    public var timeout: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandContent != nil {
            map["CommandContent"] = self.commandContent!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.endUserId != nil {
            map["EndUserId"] = self.endUserId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandContent") {
            self.commandContent = dict["CommandContent"] as! String
        }
        if dict.keys.contains("ContentEncoding") {
            self.contentEncoding = dict["ContentEncoding"] as! String
        }
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("EndUserId") {
            self.endUserId = dict["EndUserId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class RunCommandResponseBody : Tea.TeaModel {
    public var invokeId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InvokeId") {
            self.invokeId = dict["InvokeId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RunCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RunCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendVerifyCodeRequest : Tea.TeaModel {
    public var extraInfo: String?

    public var regionId: String?

    public var verifyCodeAction: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extraInfo != nil {
            map["ExtraInfo"] = self.extraInfo!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.verifyCodeAction != nil {
            map["VerifyCodeAction"] = self.verifyCodeAction!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExtraInfo") {
            self.extraInfo = dict["ExtraInfo"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("VerifyCodeAction") {
            self.verifyCodeAction = dict["VerifyCodeAction"] as! String
        }
    }
}

public class SendVerifyCodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendVerifyCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendVerifyCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendVerifyCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDesktopGroupScaleTimerRequest : Tea.TeaModel {
    public class ScaleTimerInfos : Tea.TeaModel {
        public var buyResAmount: Int32?

        public var cron: String?

        public var keepDuration: Int64?

        public var loadPolicy: Int32?

        public var maxResAmount: Int32?

        public var minResAmount: Int32?

        public var ratioThreshold: Double?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.buyResAmount != nil {
                map["BuyResAmount"] = self.buyResAmount!
            }
            if self.cron != nil {
                map["Cron"] = self.cron!
            }
            if self.keepDuration != nil {
                map["KeepDuration"] = self.keepDuration!
            }
            if self.loadPolicy != nil {
                map["LoadPolicy"] = self.loadPolicy!
            }
            if self.maxResAmount != nil {
                map["MaxResAmount"] = self.maxResAmount!
            }
            if self.minResAmount != nil {
                map["MinResAmount"] = self.minResAmount!
            }
            if self.ratioThreshold != nil {
                map["RatioThreshold"] = self.ratioThreshold!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BuyResAmount") {
                self.buyResAmount = dict["BuyResAmount"] as! Int32
            }
            if dict.keys.contains("Cron") {
                self.cron = dict["Cron"] as! String
            }
            if dict.keys.contains("KeepDuration") {
                self.keepDuration = dict["KeepDuration"] as! Int64
            }
            if dict.keys.contains("LoadPolicy") {
                self.loadPolicy = dict["LoadPolicy"] as! Int32
            }
            if dict.keys.contains("MaxResAmount") {
                self.maxResAmount = dict["MaxResAmount"] as! Int32
            }
            if dict.keys.contains("MinResAmount") {
                self.minResAmount = dict["MinResAmount"] as! Int32
            }
            if dict.keys.contains("RatioThreshold") {
                self.ratioThreshold = dict["RatioThreshold"] as! Double
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var desktopGroupId: String?

    public var regionId: String?

    public var scaleTimerInfos: [SetDesktopGroupScaleTimerRequest.ScaleTimerInfos]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scaleTimerInfos != nil {
            var tmp : [Any] = []
            for k in self.scaleTimerInfos! {
                tmp.append(k.toMap())
            }
            map["ScaleTimerInfos"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScaleTimerInfos") {
            var tmp : [SetDesktopGroupScaleTimerRequest.ScaleTimerInfos] = []
            for v in dict["ScaleTimerInfos"] as! [Any] {
                var model = SetDesktopGroupScaleTimerRequest.ScaleTimerInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scaleTimerInfos = tmp
        }
    }
}

public class SetDesktopGroupScaleTimerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDesktopGroupScaleTimerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDesktopGroupScaleTimerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDesktopGroupScaleTimerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDesktopGroupTimerRequest : Tea.TeaModel {
    public var cronExpression: String?

    public var desktopGroupId: String?

    public var force: Bool?

    public var regionId: String?

    public var resetType: Int32?

    public var timerType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cronExpression != nil {
            map["CronExpression"] = self.cronExpression!
        }
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resetType != nil {
            map["ResetType"] = self.resetType!
        }
        if self.timerType != nil {
            map["TimerType"] = self.timerType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CronExpression") {
            self.cronExpression = dict["CronExpression"] as! String
        }
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResetType") {
            self.resetType = dict["ResetType"] as! Int32
        }
        if dict.keys.contains("TimerType") {
            self.timerType = dict["TimerType"] as! Int32
        }
    }
}

public class SetDesktopGroupTimerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDesktopGroupTimerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDesktopGroupTimerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDesktopGroupTimerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDesktopGroupTimerStatusRequest : Tea.TeaModel {
    public var desktopGroupId: String?

    public var regionId: String?

    public var status: Int32?

    public var timerType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.timerType != nil {
            map["TimerType"] = self.timerType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("TimerType") {
            self.timerType = dict["TimerType"] as! Int32
        }
    }
}

public class SetDesktopGroupTimerStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDesktopGroupTimerStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDesktopGroupTimerStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDesktopGroupTimerStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDesktopMaintenanceRequest : Tea.TeaModel {
    public var desktopIds: [String]?

    public var mode: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopIds != nil {
            map["DesktopIds"] = self.desktopIds!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopIds") {
            self.desktopIds = dict["DesktopIds"] as! [String]
        }
        if dict.keys.contains("Mode") {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class SetDesktopMaintenanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDesktopMaintenanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDesktopMaintenanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDesktopMaintenanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDirectorySsoStatusRequest : Tea.TeaModel {
    public var directoryId: String?

    public var enableSso: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.enableSso != nil {
            map["EnableSso"] = self.enableSso!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("EnableSso") {
            self.enableSso = dict["EnableSso"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class SetDirectorySsoStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDirectorySsoStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDirectorySsoStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDirectorySsoStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetIdpMetadataRequest : Tea.TeaModel {
    public var directoryId: String?

    public var idpMetadata: String?

    public var officeSiteId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.directoryId != nil {
            map["DirectoryId"] = self.directoryId!
        }
        if self.idpMetadata != nil {
            map["IdpMetadata"] = self.idpMetadata!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DirectoryId") {
            self.directoryId = dict["DirectoryId"] as! String
        }
        if dict.keys.contains("IdpMetadata") {
            self.idpMetadata = dict["IdpMetadata"] as! String
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class SetIdpMetadataResponseBody : Tea.TeaModel {
    public var idpEntityId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.idpEntityId != nil {
            map["IdpEntityId"] = self.idpEntityId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IdpEntityId") {
            self.idpEntityId = dict["IdpEntityId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetIdpMetadataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetIdpMetadataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetIdpMetadataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetOfficeSiteSsoStatusRequest : Tea.TeaModel {
    public var enableSso: Bool?

    public var officeSiteId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableSso != nil {
            map["EnableSso"] = self.enableSso!
        }
        if self.officeSiteId != nil {
            map["OfficeSiteId"] = self.officeSiteId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableSso") {
            self.enableSso = dict["EnableSso"] as! Bool
        }
        if dict.keys.contains("OfficeSiteId") {
            self.officeSiteId = dict["OfficeSiteId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class SetOfficeSiteSsoStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetOfficeSiteSsoStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetOfficeSiteSsoStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetOfficeSiteSsoStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetUserProfilePathRulesRequest : Tea.TeaModel {
    public class UserProfilePathRule : Tea.TeaModel {
        public class BlackPath : Tea.TeaModel {
            public var path: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class WhitePaths : Tea.TeaModel {
            public var path: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var blackPath: SetUserProfilePathRulesRequest.UserProfilePathRule.BlackPath?

        public var whitePaths: [SetUserProfilePathRulesRequest.UserProfilePathRule.WhitePaths]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.blackPath?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.blackPath != nil {
                map["BlackPath"] = self.blackPath?.toMap()
            }
            if self.whitePaths != nil {
                var tmp : [Any] = []
                for k in self.whitePaths! {
                    tmp.append(k.toMap())
                }
                map["WhitePaths"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BlackPath") {
                var model = SetUserProfilePathRulesRequest.UserProfilePathRule.BlackPath()
                model.fromMap(dict["BlackPath"] as! [String: Any])
                self.blackPath = model
            }
            if dict.keys.contains("WhitePaths") {
                var tmp : [SetUserProfilePathRulesRequest.UserProfilePathRule.WhitePaths] = []
                for v in dict["WhitePaths"] as! [Any] {
                    var model = SetUserProfilePathRulesRequest.UserProfilePathRule.WhitePaths()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.whitePaths = tmp
            }
        }
    }
    public var desktopGroupId: String?

    public var regionId: String?

    public var userProfilePathRule: [SetUserProfilePathRulesRequest.UserProfilePathRule]?

    public var userProfileRuleType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.userProfilePathRule != nil {
            var tmp : [Any] = []
            for k in self.userProfilePathRule! {
                tmp.append(k.toMap())
            }
            map["UserProfilePathRule"] = tmp
        }
        if self.userProfileRuleType != nil {
            map["UserProfileRuleType"] = self.userProfileRuleType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("UserProfilePathRule") {
            var tmp : [SetUserProfilePathRulesRequest.UserProfilePathRule] = []
            for v in dict["UserProfilePathRule"] as! [Any] {
                var model = SetUserProfilePathRulesRequest.UserProfilePathRule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.userProfilePathRule = tmp
        }
        if dict.keys.contains("UserProfileRuleType") {
            self.userProfileRuleType = dict["UserProfileRuleType"] as! String
        }
    }
}

public class SetUserProfilePathRulesShrinkRequest : Tea.TeaModel {
    public var desktopGroupId: String?

    public var regionId: String?

    public var userProfilePathRuleShrink: String?

    public var userProfileRuleType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.userProfilePathRuleShrink != nil {
            map["UserProfilePathRule"] = self.userProfilePathRuleShrink!
        }
        if self.userProfileRuleType != nil {
            map["UserProfileRuleType"] = self.userProfileRuleType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("UserProfilePathRule") {
            self.userProfilePathRuleShrink = dict["UserProfilePathRule"] as! String
        }
        if dict.keys.contains("UserProfileRuleType") {
            self.userProfileRuleType = dict["UserProfileRuleType"] as! String
        }
    }
}

public class SetUserProfilePathRulesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetUserProfilePathRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetUserProfilePathRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetUserProfilePathRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartDesktopsRequest : Tea.TeaModel {
    public var desktopId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class StartDesktopsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartDesktopsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartDesktopsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartDesktopsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopDesktopsRequest : Tea.TeaModel {
    public var desktopId: [String]?

    public var osUpdate: Bool?

    public var regionId: String?

    public var stoppedMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.osUpdate != nil {
            map["OsUpdate"] = self.osUpdate!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.stoppedMode != nil {
            map["StoppedMode"] = self.stoppedMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("OsUpdate") {
            self.osUpdate = dict["OsUpdate"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StoppedMode") {
            self.stoppedMode = dict["StoppedMode"] as! String
        }
    }
}

public class StopDesktopsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopDesktopsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopDesktopsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopDesktopsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopInvocationRequest : Tea.TeaModel {
    public var desktopId: [String]?

    public var invokeId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("InvokeId") {
            self.invokeId = dict["InvokeId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class StopInvocationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopInvocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopInvocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopInvocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = TagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindConfigGroupRequest : Tea.TeaModel {
    public class ResourceInfos : Tea.TeaModel {
        public var productType: String?

        public var resourceId: String?

        public var resourceRegionId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.productType != nil {
                map["ProductType"] = self.productType!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceRegionId != nil {
                map["ResourceRegionId"] = self.resourceRegionId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ProductType") {
                self.productType = dict["ProductType"] as! String
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceRegionId") {
                self.resourceRegionId = dict["ResourceRegionId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
        }
    }
    public var regionId: String?

    public var resourceInfos: [UnbindConfigGroupRequest.ResourceInfos]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceInfos != nil {
            var tmp : [Any] = []
            for k in self.resourceInfos! {
                tmp.append(k.toMap())
            }
            map["ResourceInfos"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceInfos") {
            var tmp : [UnbindConfigGroupRequest.ResourceInfos] = []
            for v in dict["ResourceInfos"] as! [Any] {
                var model = UnbindConfigGroupRequest.ResourceInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceInfos = tmp
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class UnbindConfigGroupResponseBody : Tea.TeaModel {
    public var groupIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupIds != nil {
            map["GroupIds"] = self.groupIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupIds") {
            self.groupIds = dict["GroupIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnbindConfigGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindConfigGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnbindConfigGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindUserDesktopRequest : Tea.TeaModel {
    public var desktopAgentIds: [String]?

    public var desktopGroupId: String?

    public var desktopIds: [String]?

    public var force: Bool?

    public var reason: String?

    public var userDesktopIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopAgentIds != nil {
            map["DesktopAgentIds"] = self.desktopAgentIds!
        }
        if self.desktopGroupId != nil {
            map["DesktopGroupId"] = self.desktopGroupId!
        }
        if self.desktopIds != nil {
            map["DesktopIds"] = self.desktopIds!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.userDesktopIds != nil {
            map["UserDesktopIds"] = self.userDesktopIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopAgentIds") {
            self.desktopAgentIds = dict["DesktopAgentIds"] as! [String]
        }
        if dict.keys.contains("DesktopGroupId") {
            self.desktopGroupId = dict["DesktopGroupId"] as! String
        }
        if dict.keys.contains("DesktopIds") {
            self.desktopIds = dict["DesktopIds"] as! [String]
        }
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("Reason") {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("UserDesktopIds") {
            self.userDesktopIds = dict["UserDesktopIds"] as! [String]
        }
    }
}

public class UnbindUserDesktopResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnbindUserDesktopResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindUserDesktopResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnbindUserDesktopResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnlockVirtualMFADeviceRequest : Tea.TeaModel {
    public var regionId: String?

    public var serialNumber: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.serialNumber != nil {
            map["SerialNumber"] = self.serialNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SerialNumber") {
            self.serialNumber = dict["SerialNumber"] as! String
        }
    }
}

public class UnlockVirtualMFADeviceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnlockVirtualMFADeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnlockVirtualMFADeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnlockVirtualMFADeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateFotaTaskRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskUid: String?

    public var userStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskUid != nil {
            map["TaskUid"] = self.taskUid!
        }
        if self.userStatus != nil {
            map["UserStatus"] = self.userStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskUid") {
            self.taskUid = dict["TaskUid"] as! String
        }
        if dict.keys.contains("UserStatus") {
            self.userStatus = dict["UserStatus"] as! String
        }
    }
}

public class UpdateFotaTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateFotaTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFotaTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateFotaTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadImageRequest : Tea.TeaModel {
    public var dataDiskSize: Int32?

    public var description_: String?

    public var enableSecurityCheck: Bool?

    public var gpuCategory: Bool?

    public var gpuDriverType: String?

    public var imageName: String?

    public var licenseType: String?

    public var osType: String?

    public var ossObjectPath: String?

    public var protocolType: String?

    public var regionId: String?

    public var systemDiskSize: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataDiskSize != nil {
            map["DataDiskSize"] = self.dataDiskSize!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableSecurityCheck != nil {
            map["EnableSecurityCheck"] = self.enableSecurityCheck!
        }
        if self.gpuCategory != nil {
            map["GpuCategory"] = self.gpuCategory!
        }
        if self.gpuDriverType != nil {
            map["GpuDriverType"] = self.gpuDriverType!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.licenseType != nil {
            map["LicenseType"] = self.licenseType!
        }
        if self.osType != nil {
            map["OsType"] = self.osType!
        }
        if self.ossObjectPath != nil {
            map["OssObjectPath"] = self.ossObjectPath!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.systemDiskSize != nil {
            map["SystemDiskSize"] = self.systemDiskSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataDiskSize") {
            self.dataDiskSize = dict["DataDiskSize"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnableSecurityCheck") {
            self.enableSecurityCheck = dict["EnableSecurityCheck"] as! Bool
        }
        if dict.keys.contains("GpuCategory") {
            self.gpuCategory = dict["GpuCategory"] as! Bool
        }
        if dict.keys.contains("GpuDriverType") {
            self.gpuDriverType = dict["GpuDriverType"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("LicenseType") {
            self.licenseType = dict["LicenseType"] as! String
        }
        if dict.keys.contains("OsType") {
            self.osType = dict["OsType"] as! String
        }
        if dict.keys.contains("OssObjectPath") {
            self.ossObjectPath = dict["OssObjectPath"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SystemDiskSize") {
            self.systemDiskSize = dict["SystemDiskSize"] as! String
        }
    }
}

public class UploadImageResponseBody : Tea.TeaModel {
    public var imageId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UploadImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UploadImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class VerifyCenRequest : Tea.TeaModel {
    public var cenId: String?

    public var cenOwnerId: Int64?

    public var cidrBlock: String?

    public var regionId: String?

    public var verifyCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cenId != nil {
            map["CenId"] = self.cenId!
        }
        if self.cenOwnerId != nil {
            map["CenOwnerId"] = self.cenOwnerId!
        }
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.verifyCode != nil {
            map["VerifyCode"] = self.verifyCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CenId") {
            self.cenId = dict["CenId"] as! String
        }
        if dict.keys.contains("CenOwnerId") {
            self.cenOwnerId = dict["CenOwnerId"] as! Int64
        }
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("VerifyCode") {
            self.verifyCode = dict["VerifyCode"] as! String
        }
    }
}

public class VerifyCenResponseBody : Tea.TeaModel {
    public class RouteEntries : Tea.TeaModel {
        public var destinationCidrBlock: String?

        public var nextHopInstanceId: String?

        public var regionId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.nextHopInstanceId != nil {
                map["NextHopInstanceId"] = self.nextHopInstanceId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DestinationCidrBlock") {
                self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
            }
            if dict.keys.contains("NextHopInstanceId") {
                self.nextHopInstanceId = dict["NextHopInstanceId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var cidrBlocks: [String]?

    public var requestId: String?

    public var routeEntries: [VerifyCenResponseBody.RouteEntries]?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlocks != nil {
            map["CidrBlocks"] = self.cidrBlocks!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeEntries != nil {
            var tmp : [Any] = []
            for k in self.routeEntries! {
                tmp.append(k.toMap())
            }
            map["RouteEntries"] = tmp
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlocks") {
            self.cidrBlocks = dict["CidrBlocks"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteEntries") {
            var tmp : [VerifyCenResponseBody.RouteEntries] = []
            for v in dict["RouteEntries"] as! [Any] {
                var model = VerifyCenResponseBody.RouteEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.routeEntries = tmp
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class VerifyCenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VerifyCenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = VerifyCenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class WakeupDesktopsRequest : Tea.TeaModel {
    public var desktopId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desktopId != nil {
            map["DesktopId"] = self.desktopId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesktopId") {
            self.desktopId = dict["DesktopId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class WakeupDesktopsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class WakeupDesktopsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WakeupDesktopsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = WakeupDesktopsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
